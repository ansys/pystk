################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AgECrdnAngleType", "AgECrdnAxesType", "AgECrdnCalcScalarType", "AgECrdnConditionCombinedOperationType", "AgECrdnConditionSetType", 
"AgECrdnConditionThresholdOption", "AgECrdnConditionType", "AgECrdnDimensionInheritance", "AgECrdnDirectionType", "AgECrdnDisplayAxisSelector", 
"AgECrdnEventArrayFilterType", "AgECrdnEventArrayType", "AgECrdnEventIntervalCollectionType", "AgECrdnEventIntervalListType", 
"AgECrdnEventIntervalType", "AgECrdnEventListMergeOperation", "AgECrdnEventType", "AgECrdnExtremumConstants", "AgECrdnFileInterpolatorType", 
"AgECrdnIntegralType", "AgECrdnIntegrationWindowType", "AgECrdnInterpolatorType", "AgECrdnIntersectionSurface", "AgECrdnIntervalDurationKind", 
"AgECrdnIntervalSelection", "AgECrdnKind", "AgECrdnLagrangeLibrationPointType", "AgECrdnMeanElementTheory", "AgECrdnParameterSetType", 
"AgECrdnPlaneType", "AgECrdnPointBPlaneType", "AgECrdnPointType", "AgECrdnPruneFilter", "AgECrdnQuadrantType", "AgECrdnReferenceShapeType", 
"AgECrdnSampledReferenceTime", "AgECrdnSamplingMethod", "AgECrdnSatisfactionCrossing", "AgECrdnSaveDataOption", "AgECrdnSignalPathReferenceSystem", 
"AgECrdnSignalSense", "AgECrdnSignedAngleType", "AgECrdnSmartEpochState", "AgECrdnSmartIntervalState", "AgECrdnSpeedOptions", 
"AgECrdnStartStopOption", "AgECrdnSurfaceType", "AgECrdnSweepMode", "AgECrdnSystemType", "AgECrdnThreshConvergeSense", "AgECrdnTrajectoryAxesType", 
"AgECrdnVectorComponentType", "AgECrdnVectorScaledDimensionInheritance", "AgECrdnVectorType", "AgECrdnVolumeAberrationType", 
"AgECrdnVolumeCalcAltitudeReferenceType", "AgECrdnVolumeCalcAngleOffVectorType", "AgECrdnVolumeCalcRangeDistanceType", "AgECrdnVolumeCalcRangeSpeedType", 
"AgECrdnVolumeCalcType", "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType", "AgECrdnVolumeCalcVolumeSatisfactionDurationType", 
"AgECrdnVolumeCalcVolumeSatisfactionFilterType", "AgECrdnVolumeCalcVolumeSatisfactionMetricType", "AgECrdnVolumeClockHostType", 
"AgECrdnVolumeCombinedOperationType", "AgECrdnVolumeFromGridEdgeType", "AgECrdnVolumeGridType", "AgECrdnVolumeLightingConditionsType", 
"AgECrdnVolumeOverTimeDurationType", "AgECrdnVolumeResultVectorRequest", "AgECrdnVolumeTimeSenseType", "AgECrdnVolumeType", 
"AgECrdnVolumetricGridValuesMethodType", "AnalysisWorkbenchCentralBody", "AnalysisWorkbenchCentralBodyCollection", "AnalysisWorkbenchCentralBodyRefTo", 
"AnalysisWorkbenchCollection", "AnalysisWorkbenchConverge", "AnalysisWorkbenchDerivative", "AnalysisWorkbenchGeneric", "AnalysisWorkbenchInstance", 
"AnalysisWorkbenchIntegral", "AnalysisWorkbenchInterp", "AnalysisWorkbenchLLAPosition", "AnalysisWorkbenchMethodCallResult", 
"AnalysisWorkbenchProvider", "AnalysisWorkbenchRoot", "AnalysisWorkbenchSampling", "AnalysisWorkbenchSignalDelay", "AnalysisWorkbenchTemplate", 
"AnalysisWorkbenchTypeInfo", "CalculationToolCondition", "CalculationToolConditionCombined", "CalculationToolConditionFactory", 
"CalculationToolConditionGroup", "CalculationToolConditionPointInVolume", "CalculationToolConditionScalarBounds", "CalculationToolConditionSet", 
"CalculationToolConditionSetEvaluateResult", "CalculationToolConditionSetEvaluateWithRateResult", "CalculationToolConditionSetFactory", 
"CalculationToolConditionSetGroup", "CalculationToolConditionSetScalarThresholds", "CalculationToolConvergeBasic", "CalculationToolDerivativeBasic", 
"CalculationToolEvaluateResult", "CalculationToolEvaluateWithRateResult", "CalculationToolIntegralBasic", "CalculationToolInterpBasic", 
"CalculationToolParameterSet", "CalculationToolParameterSetAttitude", "CalculationToolParameterSetFactory", "CalculationToolParameterSetGroundTrajectory", 
"CalculationToolParameterSetGroup", "CalculationToolParameterSetOrbit", "CalculationToolParameterSetTrajectory", "CalculationToolParameterSetVector", 
"CalculationToolSamplingBasic", "CalculationToolSamplingCurvatureTolerance", "CalculationToolSamplingFixedStep", "CalculationToolSamplingMethod", 
"CalculationToolSamplingMethodFactory", "CalculationToolSamplingRelativeTolerance", "CalculationToolScalar", "CalculationToolScalarAngle", 
"CalculationToolScalarConstant", "CalculationToolScalarCustom", "CalculationToolScalarDataElement", "CalculationToolScalarDerivative", 
"CalculationToolScalarDotProduct", "CalculationToolScalarElapsedTime", "CalculationToolScalarFactory", "CalculationToolScalarFile", 
"CalculationToolScalarFixedAtTimeInstant", "CalculationToolScalarFunction", "CalculationToolScalarFunction2Var", "CalculationToolScalarGroup", 
"CalculationToolScalarIntegral", "CalculationToolScalarPlugin", "CalculationToolScalarSurfaceDistanceBetweenPoints", "CalculationToolScalarVectorComponent", 
"CalculationToolScalarVectorMagnitude", "IAnalysisWorkbenchCentralBody", "IAnalysisWorkbenchCentralBodyCollection", "IAnalysisWorkbenchCentralBodyRefTo", 
"IAnalysisWorkbenchCollection", "IAnalysisWorkbenchComponent", "IAnalysisWorkbenchContext", "IAnalysisWorkbenchConverge", 
"IAnalysisWorkbenchDerivative", "IAnalysisWorkbenchInstance", "IAnalysisWorkbenchIntegral", "IAnalysisWorkbenchInterp", 
"IAnalysisWorkbenchLLAPosition", "IAnalysisWorkbenchMethodCallResult", "IAnalysisWorkbenchProvider", "IAnalysisWorkbenchRefTo", 
"IAnalysisWorkbenchRoot", "IAnalysisWorkbenchSampling", "IAnalysisWorkbenchSignalDelay", "IAnalysisWorkbenchTemplate", "IAnalysisWorkbenchTypeInfo", 
"ICalculationToolCondition", "ICalculationToolConditionCombined", "ICalculationToolConditionFactory", "ICalculationToolConditionGroup", 
"ICalculationToolConditionPointInVolume", "ICalculationToolConditionScalarBounds", "ICalculationToolConditionSet", "ICalculationToolConditionSetEvaluateResult", 
"ICalculationToolConditionSetEvaluateWithRateResult", "ICalculationToolConditionSetFactory", "ICalculationToolConditionSetGroup", 
"ICalculationToolConditionSetScalarThresholds", "ICalculationToolConvergeBasic", "ICalculationToolDerivativeBasic", "ICalculationToolEvaluateResult", 
"ICalculationToolEvaluateWithRateResult", "ICalculationToolIntegralBasic", "ICalculationToolInterpBasic", "ICalculationToolParameterSet", 
"ICalculationToolParameterSetAttitude", "ICalculationToolParameterSetFactory", "ICalculationToolParameterSetGroundTrajectory", 
"ICalculationToolParameterSetGroup", "ICalculationToolParameterSetOrbit", "ICalculationToolParameterSetTrajectory", "ICalculationToolParameterSetVector", 
"ICalculationToolSamplingBasic", "ICalculationToolSamplingCurvatureTolerance", "ICalculationToolSamplingFixedStep", "ICalculationToolSamplingMethod", 
"ICalculationToolSamplingMethodFactory", "ICalculationToolSamplingRelativeTolerance", "ICalculationToolScalar", "ICalculationToolScalarAngle", 
"ICalculationToolScalarConstant", "ICalculationToolScalarCustom", "ICalculationToolScalarDataElement", "ICalculationToolScalarDerivative", 
"ICalculationToolScalarDotProduct", "ICalculationToolScalarElapsedTime", "ICalculationToolScalarFactory", "ICalculationToolScalarFile", 
"ICalculationToolScalarFixedAtTimeInstant", "ICalculationToolScalarFunction", "ICalculationToolScalarFunction2Var", "ICalculationToolScalarGroup", 
"ICalculationToolScalarIntegral", "ICalculationToolScalarPlugin", "ICalculationToolScalarSurfaceDistanceBetweenPoints", 
"ICalculationToolScalarVectorComponent", "ICalculationToolScalarVectorMagnitude", "ISpatialAnalysisToolGridCoordinateDefinition", 
"ISpatialAnalysisToolGridValuesCustom", "ISpatialAnalysisToolGridValuesFixedNumberOfSteps", "ISpatialAnalysisToolGridValuesFixedStep", 
"ISpatialAnalysisToolGridValuesMethod", "ISpatialAnalysisToolVolume", "ISpatialAnalysisToolVolumeCalc", "ISpatialAnalysisToolVolumeCalcAltitude", 
"ISpatialAnalysisToolVolumeCalcAngleOffVector", "ISpatialAnalysisToolVolumeCalcConditionSatMetric", "ISpatialAnalysisToolVolumeCalcDelayRange", 
"ISpatialAnalysisToolVolumeCalcFactory", "ISpatialAnalysisToolVolumeCalcFile", "ISpatialAnalysisToolVolumeCalcFromScalar", 
"ISpatialAnalysisToolVolumeCalcGroup", "ISpatialAnalysisToolVolumeCalcRange", "ISpatialAnalysisToolVolumeCalcSolarIntensity", 
"ISpatialAnalysisToolVolumeCombined", "ISpatialAnalysisToolVolumeFactory", "ISpatialAnalysisToolVolumeFromCalc", "ISpatialAnalysisToolVolumeFromCondition", 
"ISpatialAnalysisToolVolumeFromGrid", "ISpatialAnalysisToolVolumeFromTimeSatisfaction", "ISpatialAnalysisToolVolumeGrid", 
"ISpatialAnalysisToolVolumeGridBearingAlt", "ISpatialAnalysisToolVolumeGridCartesian", "ISpatialAnalysisToolVolumeGridConstrained", 
"ISpatialAnalysisToolVolumeGridCylindrical", "ISpatialAnalysisToolVolumeGridFactory", "ISpatialAnalysisToolVolumeGridGroup", 
"ISpatialAnalysisToolVolumeGridLatLonAlt", "ISpatialAnalysisToolVolumeGridResult", "ISpatialAnalysisToolVolumeGridSpherical", 
"ISpatialAnalysisToolVolumeGroup", "ISpatialAnalysisToolVolumeInview", "ISpatialAnalysisToolVolumeLighting", "ISpatialAnalysisToolVolumeOverTime", 
"ITimeToolAxesSamplingInterval", "ITimeToolAxesSamplingIntervalCollection", "ITimeToolAxesSamplingResult", "ITimeToolEvent", 
"ITimeToolEventArray", "ITimeToolEventArrayConditionCrossings", "ITimeToolEventArrayExtrema", "ITimeToolEventArrayFactory", 
"ITimeToolEventArrayFiltered", "ITimeToolEventArrayFixedStep", "ITimeToolEventArrayFixedTimes", "ITimeToolEventArrayGroup", 
"ITimeToolEventArrayMerged", "ITimeToolEventArraySignaled", "ITimeToolEventArrayStartStopTimes", "ITimeToolEventEpoch", 
"ITimeToolEventExtremum", "ITimeToolEventFactory", "ITimeToolEventFindOccurrenceResult", "ITimeToolEventGroup", "ITimeToolEventInterval", 
"ITimeToolEventIntervalBetweenTimeInstants", "ITimeToolEventIntervalCollection", "ITimeToolEventIntervalCollectionCondition", 
"ITimeToolEventIntervalCollectionFactory", "ITimeToolEventIntervalCollectionGroup", "ITimeToolEventIntervalCollectionLighting", 
"ITimeToolEventIntervalCollectionOccurredResult", "ITimeToolEventIntervalCollectionSignaled", "ITimeToolEventIntervalFactory", 
"ITimeToolEventIntervalFixed", "ITimeToolEventIntervalFixedDuration", "ITimeToolEventIntervalFromIntervalList", "ITimeToolEventIntervalGroup", 
"ITimeToolEventIntervalList", "ITimeToolEventIntervalListCondition", "ITimeToolEventIntervalListFactory", "ITimeToolEventIntervalListFile", 
"ITimeToolEventIntervalListFiltered", "ITimeToolEventIntervalListFixed", "ITimeToolEventIntervalListGroup", "ITimeToolEventIntervalListMerged", 
"ITimeToolEventIntervalListScaled", "ITimeToolEventIntervalListSignaled", "ITimeToolEventIntervalListTimeOffset", "ITimeToolEventIntervalResult", 
"ITimeToolEventIntervalScaled", "ITimeToolEventIntervalSignaled", "ITimeToolEventIntervalSmartInterval", "ITimeToolEventIntervalTimeOffset", 
"ITimeToolEventSignaled", "ITimeToolEventSmartEpoch", "ITimeToolEventStartStopTime", "ITimeToolEventTimeOffset", "ITimeToolFindTimesResult", 
"ITimeToolFirstIntervalsFilter", "ITimeToolGapsFilter", "ITimeToolInterval", "ITimeToolIntervalCollection", "ITimeToolIntervalListResult", 
"ITimeToolIntervalVectorCollection", "ITimeToolIntervalsFilter", "ITimeToolIntervalsVectorResult", "ITimeToolLastIntervalsFilter", 
"ITimeToolLightTimeDelay", "ITimeToolPointSamplingInterval", "ITimeToolPointSamplingIntervalCollection", "ITimeToolPointSamplingResult", 
"ITimeToolPruneFilter", "ITimeToolPruneFilterFactory", "ITimeToolRelativeSatisfactionConditionFilter", "ITimeToolSatisfactionConditionFilter", 
"ITimeToolSignalDelayBasic", "ITimeToolTimeProperties", "IVectorGeometryToolAngle", "IVectorGeometryToolAngleBetweenPlanes", 
"IVectorGeometryToolAngleBetweenVectors", "IVectorGeometryToolAngleDihedral", "IVectorGeometryToolAngleFactory", "IVectorGeometryToolAngleFindAngleResult", 
"IVectorGeometryToolAngleFindAngleWithRateResult", "IVectorGeometryToolAngleFindResult", "IVectorGeometryToolAngleFindWithRateResult", 
"IVectorGeometryToolAngleGroup", "IVectorGeometryToolAngleRefTo", "IVectorGeometryToolAngleRotation", "IVectorGeometryToolAngleToPlane", 
"IVectorGeometryToolAxes", "IVectorGeometryToolAxesAlignedAndConstrained", "IVectorGeometryToolAxesAngularOffset", "IVectorGeometryToolAxesAtTimeInstant", 
"IVectorGeometryToolAxesAttitudeFile", "IVectorGeometryToolAxesBPlane", "IVectorGeometryToolAxesCommonTasks", "IVectorGeometryToolAxesCustomScript", 
"IVectorGeometryToolAxesFactory", "IVectorGeometryToolAxesFindInAxesResult", "IVectorGeometryToolAxesFindInAxesWithRateResult", 
"IVectorGeometryToolAxesFixed", "IVectorGeometryToolAxesFixedAtEpoch", "IVectorGeometryToolAxesGroup", "IVectorGeometryToolAxesLabels", 
"IVectorGeometryToolAxesLagrangeLibration", "IVectorGeometryToolAxesModelAttach", "IVectorGeometryToolAxesOnSurface", "IVectorGeometryToolAxesPlugin", 
"IVectorGeometryToolAxesRefTo", "IVectorGeometryToolAxesSpinning", "IVectorGeometryToolAxesTrajectory", "IVectorGeometryToolAxesTransformResult", 
"IVectorGeometryToolAxesTransformWithRateResult", "IVectorGeometryToolPlane", "IVectorGeometryToolPlaneFactory", "IVectorGeometryToolPlaneFindInAxesResult", 
"IVectorGeometryToolPlaneFindInAxesWithRateResult", "IVectorGeometryToolPlaneFindInSystemResult", "IVectorGeometryToolPlaneFindInSystemWithRateResult", 
"IVectorGeometryToolPlaneGroup", "IVectorGeometryToolPlaneLabels", "IVectorGeometryToolPlaneNormal", "IVectorGeometryToolPlaneQuadrant", 
"IVectorGeometryToolPlaneRefTo", "IVectorGeometryToolPlaneTrajectory", "IVectorGeometryToolPlaneTriad", "IVectorGeometryToolPlaneTwoVector", 
"IVectorGeometryToolPoint", "IVectorGeometryToolPointAtTimeInstant", "IVectorGeometryToolPointBPlane", "IVectorGeometryToolPointCBFixedOffset", 
"IVectorGeometryToolPointCentBodyIntersect", "IVectorGeometryToolPointCommonTasks", "IVectorGeometryToolPointCovarianceGrazing", 
"IVectorGeometryToolPointFactory", "IVectorGeometryToolPointFile", "IVectorGeometryToolPointFixedInSystem", "IVectorGeometryToolPointGlint", 
"IVectorGeometryToolPointGrazing", "IVectorGeometryToolPointGroup", "IVectorGeometryToolPointLagrangeLibration", "IVectorGeometryToolPointLocateInSystemResult", 
"IVectorGeometryToolPointLocateInSystemWithRateResult", "IVectorGeometryToolPointModelAttach", "IVectorGeometryToolPointOnSurface", 
"IVectorGeometryToolPointPlaneIntersection", "IVectorGeometryToolPointPlaneProjection", "IVectorGeometryToolPointPlugin", 
"IVectorGeometryToolPointRefTo", "IVectorGeometryToolPointSatelliteCollectionEntry", "IVectorGeometryToolSystem", "IVectorGeometryToolSystemAssembled", 
"IVectorGeometryToolSystemCommonTasks", "IVectorGeometryToolSystemFactory", "IVectorGeometryToolSystemFindInSystemResult", 
"IVectorGeometryToolSystemGroup", "IVectorGeometryToolSystemOnSurface", "IVectorGeometryToolSystemRefTo", "IVectorGeometryToolSystemTransformResult", 
"IVectorGeometryToolSystemTransformWithRateResult", "IVectorGeometryToolVector", "IVectorGeometryToolVectorAngleRate", "IVectorGeometryToolVectorAngularVelocity", 
"IVectorGeometryToolVectorApoapsis", "IVectorGeometryToolVectorConing", "IVectorGeometryToolVectorCross", "IVectorGeometryToolVectorCustomScript", 
"IVectorGeometryToolVectorDerivative", "IVectorGeometryToolVectorDirectionToStar", "IVectorGeometryToolVectorDispSurface", 
"IVectorGeometryToolVectorDisplacement", "IVectorGeometryToolVectorEccentricity", "IVectorGeometryToolVectorFactory", "IVectorGeometryToolVectorFindInAxesResult", 
"IVectorGeometryToolVectorFindInAxesWithRateResult", "IVectorGeometryToolVectorFixedAtEpoch", "IVectorGeometryToolVectorFixedAtTimeInstant", 
"IVectorGeometryToolVectorFixedInAxes", "IVectorGeometryToolVectorGroup", "IVectorGeometryToolVectorLineOfNodes", "IVectorGeometryToolVectorLinearCombination", 
"IVectorGeometryToolVectorModelAttach", "IVectorGeometryToolVectorOrbitAngularMomentum", "IVectorGeometryToolVectorOrbitNormal", 
"IVectorGeometryToolVectorPeriapsis", "IVectorGeometryToolVectorPlugin", "IVectorGeometryToolVectorProjectAlongVector", 
"IVectorGeometryToolVectorProjection", "IVectorGeometryToolVectorRefTo", "IVectorGeometryToolVectorReflection", "IVectorGeometryToolVectorRotationVector", 
"IVectorGeometryToolVectorScalarLinearCombination", "IVectorGeometryToolVectorScalarScaled", "IVectorGeometryToolVectorScaled", 
"IVectorGeometryToolVectorTwoPlanesIntersection", "IVectorGeometryToolVectorVelocityAcceleration", "IVectorGeometryToolWellKnownAxes", 
"IVectorGeometryToolWellKnownEarthAxes", "IVectorGeometryToolWellKnownEarthSystems", "IVectorGeometryToolWellKnownSunAxes", 
"IVectorGeometryToolWellKnownSunSystems", "IVectorGeometryToolWellKnownSystems", "SpatialAnalysisToolGridCoordinateDefinition", 
"SpatialAnalysisToolGridValuesCustom", "SpatialAnalysisToolGridValuesFixedNumberOfSteps", "SpatialAnalysisToolGridValuesFixedStep", 
"SpatialAnalysisToolGridValuesMethod", "SpatialAnalysisToolVolume", "SpatialAnalysisToolVolumeCalc", "SpatialAnalysisToolVolumeCalcAltitude", 
"SpatialAnalysisToolVolumeCalcAngleOffVector", "SpatialAnalysisToolVolumeCalcConditionSatMetric", "SpatialAnalysisToolVolumeCalcDelayRange", 
"SpatialAnalysisToolVolumeCalcFactory", "SpatialAnalysisToolVolumeCalcFile", "SpatialAnalysisToolVolumeCalcFromScalar", 
"SpatialAnalysisToolVolumeCalcGroup", "SpatialAnalysisToolVolumeCalcRange", "SpatialAnalysisToolVolumeCalcSolarIntensity", 
"SpatialAnalysisToolVolumeCombined", "SpatialAnalysisToolVolumeFactory", "SpatialAnalysisToolVolumeFromCalc", "SpatialAnalysisToolVolumeFromCondition", 
"SpatialAnalysisToolVolumeFromGrid", "SpatialAnalysisToolVolumeFromTimeSatisfaction", "SpatialAnalysisToolVolumeGrid", "SpatialAnalysisToolVolumeGridBearingAlt", 
"SpatialAnalysisToolVolumeGridCartesian", "SpatialAnalysisToolVolumeGridConstrained", "SpatialAnalysisToolVolumeGridCylindrical", 
"SpatialAnalysisToolVolumeGridFactory", "SpatialAnalysisToolVolumeGridGroup", "SpatialAnalysisToolVolumeGridLatLonAlt", 
"SpatialAnalysisToolVolumeGridResult", "SpatialAnalysisToolVolumeGridSpherical", "SpatialAnalysisToolVolumeGroup", "SpatialAnalysisToolVolumeInview", 
"SpatialAnalysisToolVolumeLighting", "SpatialAnalysisToolVolumeOverTime", "TimeToolAxesSamplingInterval", "TimeToolAxesSamplingIntervalCollection", 
"TimeToolAxesSamplingResult", "TimeToolEvent", "TimeToolEventArray", "TimeToolEventArrayConditionCrossings", "TimeToolEventArrayExtrema", 
"TimeToolEventArrayFactory", "TimeToolEventArrayFiltered", "TimeToolEventArrayFixedStep", "TimeToolEventArrayFixedTimes", 
"TimeToolEventArrayGroup", "TimeToolEventArrayMerged", "TimeToolEventArraySignaled", "TimeToolEventArrayStartStopTimes", 
"TimeToolEventEpoch", "TimeToolEventExtremum", "TimeToolEventFactory", "TimeToolEventFindOccurrenceResult", "TimeToolEventGroup", 
"TimeToolEventInterval", "TimeToolEventIntervalBetweenTimeInstants", "TimeToolEventIntervalCollection", "TimeToolEventIntervalCollectionCondition", 
"TimeToolEventIntervalCollectionFactory", "TimeToolEventIntervalCollectionGroup", "TimeToolEventIntervalCollectionLighting", 
"TimeToolEventIntervalCollectionOccurredResult", "TimeToolEventIntervalCollectionSignaled", "TimeToolEventIntervalFactory", 
"TimeToolEventIntervalFixed", "TimeToolEventIntervalFixedDuration", "TimeToolEventIntervalFromIntervalList", "TimeToolEventIntervalGroup", 
"TimeToolEventIntervalList", "TimeToolEventIntervalListCondition", "TimeToolEventIntervalListFactory", "TimeToolEventIntervalListFile", 
"TimeToolEventIntervalListFiltered", "TimeToolEventIntervalListFixed", "TimeToolEventIntervalListGroup", "TimeToolEventIntervalListMerged", 
"TimeToolEventIntervalListScaled", "TimeToolEventIntervalListSignaled", "TimeToolEventIntervalListTimeOffset", "TimeToolEventIntervalResult", 
"TimeToolEventIntervalScaled", "TimeToolEventIntervalSignaled", "TimeToolEventIntervalSmartInterval", "TimeToolEventIntervalTimeOffset", 
"TimeToolEventSignaled", "TimeToolEventSmartEpoch", "TimeToolEventStartStopTime", "TimeToolEventTimeOffset", "TimeToolFindTimesResult", 
"TimeToolFirstIntervalsFilter", "TimeToolGapsFilter", "TimeToolInterval", "TimeToolIntervalCollection", "TimeToolIntervalListResult", 
"TimeToolIntervalVectorCollection", "TimeToolIntervalsFilter", "TimeToolIntervalsVectorResult", "TimeToolLastIntervalsFilter", 
"TimeToolLightTimeDelay", "TimeToolPointSamplingInterval", "TimeToolPointSamplingIntervalCollection", "TimeToolPointSamplingResult", 
"TimeToolPruneFilter", "TimeToolPruneFilterFactory", "TimeToolRelativeSatisfactionConditionFilter", "TimeToolSatisfactionConditionFilter", 
"TimeToolSignalDelayBasic", "VectorGeometryToolAngle", "VectorGeometryToolAngleBetweenPlanes", "VectorGeometryToolAngleBetweenVectors", 
"VectorGeometryToolAngleDihedral", "VectorGeometryToolAngleFactory", "VectorGeometryToolAngleGroup", "VectorGeometryToolAngleRefTo", 
"VectorGeometryToolAngleRotation", "VectorGeometryToolAngleToPlane", "VectorGeometryToolAxes", "VectorGeometryToolAxesAlignedAndConstrained", 
"VectorGeometryToolAxesAngularOffset", "VectorGeometryToolAxesAtTimeInstant", "VectorGeometryToolAxesAttitudeFile", "VectorGeometryToolAxesBPlane", 
"VectorGeometryToolAxesCommonTasks", "VectorGeometryToolAxesCustomScript", "VectorGeometryToolAxesFactory", "VectorGeometryToolAxesFixed", 
"VectorGeometryToolAxesFixedAtEpoch", "VectorGeometryToolAxesGroup", "VectorGeometryToolAxesLabels", "VectorGeometryToolAxesLagrangeLibration", 
"VectorGeometryToolAxesModelAttach", "VectorGeometryToolAxesOnSurface", "VectorGeometryToolAxesPlugin", "VectorGeometryToolAxesRefTo", 
"VectorGeometryToolAxesSpinning", "VectorGeometryToolAxesTrajectory", "VectorGeometryToolPlane", "VectorGeometryToolPlaneFactory", 
"VectorGeometryToolPlaneGroup", "VectorGeometryToolPlaneLabels", "VectorGeometryToolPlaneNormal", "VectorGeometryToolPlaneQuadrant", 
"VectorGeometryToolPlaneRefTo", "VectorGeometryToolPlaneTrajectory", "VectorGeometryToolPlaneTriad", "VectorGeometryToolPlaneTwoVector", 
"VectorGeometryToolPoint", "VectorGeometryToolPointAtTimeInstant", "VectorGeometryToolPointBPlane", "VectorGeometryToolPointCBFixedOffset", 
"VectorGeometryToolPointCentBodyIntersect", "VectorGeometryToolPointCommonTasks", "VectorGeometryToolPointCovarianceGrazing", 
"VectorGeometryToolPointFactory", "VectorGeometryToolPointFile", "VectorGeometryToolPointFixedInSystem", "VectorGeometryToolPointGlint", 
"VectorGeometryToolPointGrazing", "VectorGeometryToolPointGroup", "VectorGeometryToolPointLagrangeLibration", "VectorGeometryToolPointModelAttach", 
"VectorGeometryToolPointOnSurface", "VectorGeometryToolPointPlaneIntersection", "VectorGeometryToolPointPlaneProjection", 
"VectorGeometryToolPointPlugin", "VectorGeometryToolPointRefTo", "VectorGeometryToolPointSatelliteCollectionEntry", "VectorGeometryToolSystem", 
"VectorGeometryToolSystemAssembled", "VectorGeometryToolSystemCommonTasks", "VectorGeometryToolSystemFactory", "VectorGeometryToolSystemGroup", 
"VectorGeometryToolSystemOnSurface", "VectorGeometryToolSystemRefTo", "VectorGeometryToolVector", "VectorGeometryToolVectorAngleRate", 
"VectorGeometryToolVectorAngularVelocity", "VectorGeometryToolVectorApoapsis", "VectorGeometryToolVectorConing", "VectorGeometryToolVectorCross", 
"VectorGeometryToolVectorCustomScript", "VectorGeometryToolVectorDerivative", "VectorGeometryToolVectorDirectionToStar", 
"VectorGeometryToolVectorDispSurface", "VectorGeometryToolVectorDisplacement", "VectorGeometryToolVectorEccentricity", "VectorGeometryToolVectorFactory", 
"VectorGeometryToolVectorFixedAtEpoch", "VectorGeometryToolVectorFixedAtTimeInstant", "VectorGeometryToolVectorFixedInAxes", 
"VectorGeometryToolVectorGroup", "VectorGeometryToolVectorLineOfNodes", "VectorGeometryToolVectorLinearCombination", "VectorGeometryToolVectorModelAttach", 
"VectorGeometryToolVectorOrbitAngularMomentum", "VectorGeometryToolVectorOrbitNormal", "VectorGeometryToolVectorPeriapsis", 
"VectorGeometryToolVectorPlugin", "VectorGeometryToolVectorProjectAlongVector", "VectorGeometryToolVectorProjection", "VectorGeometryToolVectorRefTo", 
"VectorGeometryToolVectorReflection", "VectorGeometryToolVectorRotationVector", "VectorGeometryToolVectorScalarLinearCombination", 
"VectorGeometryToolVectorScalarScaled", "VectorGeometryToolVectorScaled", "VectorGeometryToolVectorTwoPlanesIntersection", 
"VectorGeometryToolVectorVelocityAcceleration", "VectorGeometryToolWellKnownAxes", "VectorGeometryToolWellKnownEarthAxes", 
"VectorGeometryToolWellKnownEarthSystems", "VectorGeometryToolWellKnownSunAxes", "VectorGeometryToolWellKnownSunSystems", 
"VectorGeometryToolWellKnownSystems"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame
except ModuleNotFoundError:
    pass

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal  import dataanalysisutil as agdata
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IDispatch, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgECrdnCalcScalarType(IntEnum):
    """Defines available calculation scalar types."""
    # Unknown or unsupported calculation scalar types
    eCrdnCalcScalarTypeUnknown = -1
    # Scalar equal to angular displacement obtained from any angle in VGT.
    eCrdnCalcScalarTypeAngle = 0
    # Constant scalar created by evaluating input scalar calculation at specified reference time instant.
    eCrdnCalcScalarTypeFixedAtTimeInstant = 1
    # Constant scalar value of specified dimension.
    eCrdnCalcScalarTypeConstant = 2
    # Any time-dependent data element from STK data providers available for parent STK object.
    eCrdnCalcScalarTypeDataElement = 3
    # Derivative of input scalar calculation.
    eCrdnCalcScalarTypeDerivative = 4
    # Time elapsed since reference time instant.
    eCrdnCalcScalarTypeElapsedTime = 5
    # Tabulated scalar calculation data loaded from specified file.
    eCrdnCalcScalarTypeFile = 6
    # Defined by performing one of specified functions on input scalar.
    eCrdnCalcScalarTypeFunction = 7
    # Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types.
    eCrdnCalcScalarTypeIntegral = 8
    # Defined by performing one of specified binary operations on two scalar arguments.
    eCrdnCalcScalarTypeFunction2Var = 9
    # Scalar equal to magnitude of specified vector.
    eCrdnCalcScalarTypeVectorMagnitude = 10
    # A calc scalar plugin based on a COM object.
    eCrdnCalcScalarTypePlugin = 11
    # A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate.
    eCrdnCalcScalarTypeCustomScript = 12
    # Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude).
    eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints = 13
    # Scalar equal to the dot product between two vectors.
    eCrdnCalcScalarTypeDotProduct = 14
    # Scalar equal to the specified component of a vector when resolved in the specified axes.
    eCrdnCalcScalarTypeVectorComponent = 15

AgECrdnCalcScalarType.eCrdnCalcScalarTypeUnknown.__doc__ = "Unknown or unsupported calculation scalar types"
AgECrdnCalcScalarType.eCrdnCalcScalarTypeAngle.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFixedAtTimeInstant.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeConstant.__doc__ = "Constant scalar value of specified dimension."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDataElement.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDerivative.__doc__ = "Derivative of input scalar calculation."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeElapsedTime.__doc__ = "Time elapsed since reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFile.__doc__ = "Tabulated scalar calculation data loaded from specified file."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction.__doc__ = "Defined by performing one of specified functions on input scalar."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeIntegral.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction2Var.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorMagnitude.__doc__ = "Scalar equal to magnitude of specified vector."
AgECrdnCalcScalarType.eCrdnCalcScalarTypePlugin.__doc__ = "A calc scalar plugin based on a COM object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeCustomScript.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDotProduct.__doc__ = "Scalar equal to the dot product between two vectors."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorComponent.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."

agcls.AgTypeNameMap["AgECrdnCalcScalarType"] = AgECrdnCalcScalarType

class AgECrdnConditionCombinedOperationType(IntEnum):
    """Defines scalar condition combined operation types."""
    # Scalar condition combined AND operation.
    eCrdnConditionCombinedOperationTypeAND = 1
    # Scalar condition combined OR operation.
    eCrdnConditionCombinedOperationTypeOR = 2
    # Scalar condition combined XOR operation.
    eCrdnConditionCombinedOperationTypeXOR = 3
    # Scalar condition combined MINUS operation.
    eCrdnConditionCombinedOperationTypeMINUS = 4

AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeAND.__doc__ = "Scalar condition combined AND operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeOR.__doc__ = "Scalar condition combined OR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeXOR.__doc__ = "Scalar condition combined XOR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeMINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnConditionCombinedOperationType"] = AgECrdnConditionCombinedOperationType

class AgECrdnConditionSetType(IntEnum):
    """Defines available condition set types."""
    # Unknown or unsupported condition set types.
    eCrdnConditionSetTypeUnknown = -1
    # Condition set placing multiple thresholds on specified scalar.
    eCrdnConditionSetTypeScalarThresholds = 0

AgECrdnConditionSetType.eCrdnConditionSetTypeUnknown.__doc__ = "Unknown or unsupported condition set types."
AgECrdnConditionSetType.eCrdnConditionSetTypeScalarThresholds.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["AgECrdnConditionSetType"] = AgECrdnConditionSetType

class AgECrdnConditionThresholdOption(IntEnum):
    """Operations for Scalar Bounds Condition"""
    # Bound is above a minimum value
    eCrdnConditionThresholdOptionAboveMin = 1
    # Bound is below a maximum value
    eCrdnConditionThresholdOptionBelowMax = 2
    # Bound is between a minimum and maximum value
    eCrdnConditionThresholdOptionInsideMinMax = 3
    # Bound is outside a minimum and maximum value
    eCrdnConditionThresholdOptionOutsideMinMax = 4

AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionAboveMin.__doc__ = "Bound is above a minimum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionBelowMax.__doc__ = "Bound is below a maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionInsideMinMax.__doc__ = "Bound is between a minimum and maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionOutsideMinMax.__doc__ = "Bound is outside a minimum and maximum value"

agcls.AgTypeNameMap["AgECrdnConditionThresholdOption"] = AgECrdnConditionThresholdOption

class AgECrdnConditionType(IntEnum):
    """Defines available condition types."""
    # Unknown or unsupported condition type
    eCrdnConditionTypeUnknown = -1
    # Condition placing bounds on specified scalar.
    eCrdnConditionTypeScalarBounds = 0
    # Multiple conditiones on specified scalar.
    eCrdnConditionTypeCombined = 1
    # Condition placing point in volume.
    eCrdnConditionTypePointInVolume = 2

AgECrdnConditionType.eCrdnConditionTypeUnknown.__doc__ = "Unknown or unsupported condition type"
AgECrdnConditionType.eCrdnConditionTypeScalarBounds.__doc__ = "Condition placing bounds on specified scalar."
AgECrdnConditionType.eCrdnConditionTypeCombined.__doc__ = "Multiple conditiones on specified scalar."
AgECrdnConditionType.eCrdnConditionTypePointInVolume.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["AgECrdnConditionType"] = AgECrdnConditionType

class AgECrdnDimensionInheritance(IntEnum):
    """Defines how dimension is inherited"""
    # Do not inherit dimension.
    eCrdnDimensionInheritanceNone = 0
    # Inherit dimension from X scalar.
    eCrdnDimensionInheritanceFromX = 1
    # Inherit dimension from Y scalar.
    eCrdnDimensionInheritanceFromY = 2

AgECrdnDimensionInheritance.eCrdnDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromX.__doc__ = "Inherit dimension from X scalar."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromY.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["AgECrdnDimensionInheritance"] = AgECrdnDimensionInheritance

class AgECrdnEventArrayFilterType(IntEnum):
    """Event array filter types."""
    # Skip time step
    eCrdnEventArrayFilterTypeSkipTimeStep = 0
    # Skip count
    eCrdnEventArrayFilterTypeSkipCount = 1
    # Intervals
    eCrdnEventArrayFilterTypeIntervals = 2

AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipTimeStep.__doc__ = "Skip time step"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipCount.__doc__ = "Skip count"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeIntervals.__doc__ = "Intervals"

agcls.AgTypeNameMap["AgECrdnEventArrayFilterType"] = AgECrdnEventArrayFilterType

class AgECrdnEventArrayType(IntEnum):
    """Defines available time array types."""
    # Unknown or unsupported time array types
    eCrdnEventArrayTypeUnknown = -1
    # Determines time of local minimum and/or maximum of specified scalar calculation.
    eCrdnEventArrayTypeExtrema = 0
    # Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array.
    eCrdnEventArrayTypeStartStopTimes = 1
    # Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays.
    eCrdnEventArrayTypeMerged = 2
    # Defined by filtering times from original time array according to specified filtering method.
    eCrdnEventArrayTypeFiltered = 3
    # Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list.
    eCrdnEventArrayTypeFixedStep = 4
    # Time array containing times at which specified condition changes its satisfaction status.
    eCrdnEventArrayTypeConditionCrossings = 5
    # Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations.
    eCrdnEventArrayTypeSignaled = 6
    # Time array containing specific times.
    eCrdnEventArrayTypeFixedTimes = 7

AgECrdnEventArrayType.eCrdnEventArrayTypeUnknown.__doc__ = "Unknown or unsupported time array types"
AgECrdnEventArrayType.eCrdnEventArrayTypeExtrema.__doc__ = "Determines time of local minimum and/or maximum of specified scalar calculation."
AgECrdnEventArrayType.eCrdnEventArrayTypeStartStopTimes.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
AgECrdnEventArrayType.eCrdnEventArrayTypeMerged.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
AgECrdnEventArrayType.eCrdnEventArrayTypeFiltered.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedStep.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
AgECrdnEventArrayType.eCrdnEventArrayTypeConditionCrossings.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
AgECrdnEventArrayType.eCrdnEventArrayTypeSignaled.__doc__ = "Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedTimes.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["AgECrdnEventArrayType"] = AgECrdnEventArrayType

class AgECrdnEventIntervalCollectionType(IntEnum):
    """Defines available interval collection types."""
    # Unknown or unsupported interval collection types
    eCrdnEventIntervalCollectionTypeUnknown = -1
    # Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies.
    eCrdnEventIntervalCollectionTypeLighting = 0
    # Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations.
    eCrdnEventIntervalCollectionTypeSignaled = 1
    # Interval collection containing intervals during which condition set is satisfied.
    eCrdnEventIntervalCollectionTypeCondition = 2

AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeUnknown.__doc__ = "Unknown or unsupported interval collection types"
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeLighting.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeSignaled.__doc__ = "Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeCondition.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["AgECrdnEventIntervalCollectionType"] = AgECrdnEventIntervalCollectionType

class AgECrdnEventIntervalListType(IntEnum):
    """Defines available interval list types."""
    # Unknown or unsupported interval list types
    eCrdnEventIntervalListTypeUnknown = -1
    # Interval list created by merging two constituent interval lists using specified logical operation.
    eCrdnEventIntervalListTypeMerged = 1
    # Defined by filtering intervals from original interval list using specified filtering method.
    eCrdnEventIntervalListTypeFiltered = 2
    # Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction).
    eCrdnEventIntervalListTypeCondition = 3
    # Interval List defined by scaling every interval in original interval list using either absolute or relative scale.
    eCrdnEventIntervalListTypeScaled = 4
    # Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations.
    eCrdnEventIntervalListTypeSignaled = 5
    # Interval List defined by shifting specified reference interval list by fixed time offset.
    eCrdnEventIntervalListTypeTimeOffset = 6
    # Interval list loaded from specified interval file
    eCrdnEventIntervalListTypeFile = 0
    # Interval list with individual intervals defined between explicitly specified start and stop times.
    eCrdnEventIntervalListTypeFixed = 7

AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeUnknown.__doc__ = "Unknown or unsupported interval list types"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeMerged.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFiltered.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeCondition.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeScaled.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeSignaled.__doc__ = "Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeTimeOffset.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFile.__doc__ = "Interval list loaded from specified interval file"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFixed.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["AgECrdnEventIntervalListType"] = AgECrdnEventIntervalListType

class AgECrdnEventIntervalType(IntEnum):
    """Defines available interval types."""
    # Unknown or unsupported interval types
    eCrdnEventIntervalTypeUnknown = -1
    # Interval defined between two explicitly specified start and stop times.
    eCrdnEventIntervalTypeFixed = 0
    # Interval of fixed duration specified using start and stop offsets relative to specified reference time instant.
    eCrdnEventIntervalTypeFixedDuration = 1
    # Interval between specified start and stop time instants.
    eCrdnEventIntervalTypeBetweenTimeInstants = 2
    # Interval created from specified interval list by using one of several selection methods.
    eCrdnEventIntervalTypeFromIntervalList = 3
    # Interval defined by scaling original interval using either absolute or relative scale.
    eCrdnEventIntervalTypeScaled = 4
    # Determines an interval recorded at a target clock location by performing signal transmission.
    eCrdnEventIntervalTypeSignaled = 5
    # Interval defined by shifting specified reference interval by fixed time offset.
    eCrdnEventIntervalTypeTimeOffset = 6
    # A smart interval.
    eCrdnEventIntervalTypeSmartInterval = 7

AgECrdnEventIntervalType.eCrdnEventIntervalTypeUnknown.__doc__ = "Unknown or unsupported interval types"
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixed.__doc__ = "Interval defined between two explicitly specified start and stop times."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixedDuration.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeBetweenTimeInstants.__doc__ = "Interval between specified start and stop time instants."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFromIntervalList.__doc__ = "Interval created from specified interval list by using one of several selection methods."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeScaled.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSignaled.__doc__ = "Determines an interval recorded at a target clock location by performing signal transmission."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeTimeOffset.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSmartInterval.__doc__ = "A smart interval."

agcls.AgTypeNameMap["AgECrdnEventIntervalType"] = AgECrdnEventIntervalType

class AgECrdnEventListMergeOperation(IntEnum):
    """Defines merge operations for interval lists."""
    # Intervals both in A and B
    eCrdnEventListMergeOperationAND = 0
    # Intervals in A or B
    eCrdnEventListMergeOperationOR = 1
    # Intervals in A or B but not in both
    eCrdnEventListMergeOperationXOR = 2
    # Intervals in A and not in B
    eCrdnEventListMergeOperationMINUS = 3

AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationAND.__doc__ = "Intervals both in A and B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationOR.__doc__ = "Intervals in A or B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationXOR.__doc__ = "Intervals in A or B but not in both"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationMINUS.__doc__ = "Intervals in A and not in B"

agcls.AgTypeNameMap["AgECrdnEventListMergeOperation"] = AgECrdnEventListMergeOperation

class AgECrdnEventType(IntEnum):
    """Defines available time instant types."""
    # Unknown or unsupported time instant types
    eCrdnEventTypeUnknown = -1
    # Time instant set at specified date/time
    eCrdnEventTypeEpoch = 0
    # Determines time of global minimum or maximum of specified scalar calculation.
    eCrdnEventTypeExtremum = 1
    # Start or stop time of selected reference interval
    eCrdnEventTypeFromInterval = 2
    # Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations.
    eCrdnEventTypeSignaled = 3
    # Time instant at fixed offset from specified reference time instant
    eCrdnEventTypeTimeOffset = 4
    # A smart epoch.
    eCrdnEventTypeSmartEpoch = 5

AgECrdnEventType.eCrdnEventTypeUnknown.__doc__ = "Unknown or unsupported time instant types"
AgECrdnEventType.eCrdnEventTypeEpoch.__doc__ = "Time instant set at specified date/time"
AgECrdnEventType.eCrdnEventTypeExtremum.__doc__ = "Determines time of global minimum or maximum of specified scalar calculation."
AgECrdnEventType.eCrdnEventTypeFromInterval.__doc__ = "Start or stop time of selected reference interval"
AgECrdnEventType.eCrdnEventTypeSignaled.__doc__ = "Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
AgECrdnEventType.eCrdnEventTypeTimeOffset.__doc__ = "Time instant at fixed offset from specified reference time instant"
AgECrdnEventType.eCrdnEventTypeSmartEpoch.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["AgECrdnEventType"] = AgECrdnEventType

class AgECrdnExtremumConstants(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
    # Find the minimum value
    eCrdnExtremumMinimum = 1
    # Find the maximum value
    eCrdnExtremumMaximum = 2

AgECrdnExtremumConstants.eCrdnExtremumMinimum.__doc__ = "Find the minimum value"
AgECrdnExtremumConstants.eCrdnExtremumMaximum.__doc__ = "Find the maximum value"

agcls.AgTypeNameMap["AgECrdnExtremumConstants"] = AgECrdnExtremumConstants

class AgECrdnFileInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnFileInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnFileInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnFileInterpolatorTypeHermite = 2
    # Holds the value at the closest previous sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldPrevious = 3
    # Holds the value at the closest next sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldNext = 4
    # Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time.
    eCrdnFileInterpolatorTypeHoldNearest = 5

AgECrdnFileInterpolatorType.eCrdnFileInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHermite.__doc__ = "Hermite interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldPrevious.__doc__ = "Holds the value at the closest previous sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNext.__doc__ = "Holds the value at the closest next sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNearest.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["AgECrdnFileInterpolatorType"] = AgECrdnFileInterpolatorType

class AgECrdnIntegralType(IntEnum):
    """Integral types."""
    # Simpson integral method
    eCrdnIntegralTypeFixedStepSimpson = 2
    # Trapezoidal integral method
    eCrdnIntegralTypeFixedStepTrapz = 1
    # Adaptive Lobatto integral method
    eCrdnIntegralTypeAdaptiveStep = 3

AgECrdnIntegralType.eCrdnIntegralTypeFixedStepSimpson.__doc__ = "Simpson integral method"
AgECrdnIntegralType.eCrdnIntegralTypeFixedStepTrapz.__doc__ = "Trapezoidal integral method"
AgECrdnIntegralType.eCrdnIntegralTypeAdaptiveStep.__doc__ = "Adaptive Lobatto integral method"

agcls.AgTypeNameMap["AgECrdnIntegralType"] = AgECrdnIntegralType

class AgECrdnIntegrationWindowType(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
    # Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant.
    eCrdnIntegrationWindowTypeTotal = 0
    # Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time.
    eCrdnIntegrationWindowTypeCumulativeToCurrent = 1
    # Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time.
    eCrdnIntegrationWindowTypeCumulativeFromCurrent = 2
    # Defines the integral's window as the interval of times centered around the current time with the specified front and back durations.
    eCrdnIntegrationWindowTypeSlidingWindow = 3

AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeTotal.__doc__ = "Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeToCurrent.__doc__ = "Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeFromCurrent.__doc__ = "Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeSlidingWindow.__doc__ = "Defines the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["AgECrdnIntegrationWindowType"] = AgECrdnIntegrationWindowType

class AgECrdnInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnInterpolatorTypeHermite = 2

AgECrdnInterpolatorType.eCrdnInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeHermite.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["AgECrdnInterpolatorType"] = AgECrdnInterpolatorType

class AgECrdnIntervalDurationKind(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays"""
    # Filter by at least a specified number of seconds
    eCrdnIntervalDurationKindAtLeast = 0
    # Filter by at most a specified number of seconds
    eCrdnIntervalDurationKindAtMost = 1

AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtLeast.__doc__ = "Filter by at least a specified number of seconds"
AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtMost.__doc__ = "Filter by at most a specified number of seconds"

agcls.AgTypeNameMap["AgECrdnIntervalDurationKind"] = AgECrdnIntervalDurationKind

class AgECrdnIntervalSelection(IntEnum):
    """Select the method to choose an interval from an interval list"""
    # Select an interval by counting a specified number from the first interval
    eCrdnIntervalSelectionFromStart = 1
    # Select an interval by counting a specified number back from the last interval
    eCrdnIntervalSelectionFromEnd = 2
    # Select the interval with the largest duration
    eCrdnIntervalSelectionMaxDuration = 4
    # Select the interval with the smallest duration
    eCrdnIntervalSelectionMinDuration = 5
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMaxGap = 9
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMinGap = 10
    # Select the interval that is the span of the interval list
    eCrdnIntervalSelectionSpan = 100

AgECrdnIntervalSelection.eCrdnIntervalSelectionFromStart.__doc__ = "Select an interval by counting a specified number from the first interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionFromEnd.__doc__ = "Select an interval by counting a specified number back from the last interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxDuration.__doc__ = "Select the interval with the largest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinDuration.__doc__ = "Select the interval with the smallest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionSpan.__doc__ = "Select the interval that is the span of the interval list"

agcls.AgTypeNameMap["AgECrdnIntervalSelection"] = AgECrdnIntervalSelection

class AgECrdnParameterSetType(IntEnum):
    """Defines parameter set types."""
    # Unknown or unsupported parameter set
    eCrdnParameterSetTypeUnknown = -1
    # A parameter set type is defined by identifying one set of axes in reference to another.
    eCrdnParameterSetTypeAttitude = 0
    # A parameter set type is defined by identifying location in reference central body.
    eCrdnParameterSetTypeGroundTrajectory = 1
    # A parameter set type is defined by identifying location in reference coordinate system.
    eCrdnParameterSetTypeTrajectory = 2
    # A parameter set type is defined by identifying orbiting point and its central body.
    eCrdnParameterSetTypeOrbit = 3
    # A parameter set type is defined by identifying vector in reference axes.
    eCrdnParameterSetTypeVector = 4

AgECrdnParameterSetType.eCrdnParameterSetTypeUnknown.__doc__ = "Unknown or unsupported parameter set"
AgECrdnParameterSetType.eCrdnParameterSetTypeAttitude.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
AgECrdnParameterSetType.eCrdnParameterSetTypeGroundTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
AgECrdnParameterSetType.eCrdnParameterSetTypeOrbit.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeVector.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["AgECrdnParameterSetType"] = AgECrdnParameterSetType

class AgECrdnPruneFilter(IntEnum):
    """Specify the filter for filtering interval lists or time arrays"""
    # Unknown or unsupported prune filter
    eCrdnPruneFilterUnknown = 0
    # Selects specified number of first intervals from original list
    eCrdnPruneFilterFirstIntervals = 1
    # Selects specified number of last intervals from original list
    eCrdnPruneFilterLastIntervals = 2
    # Selects intervals which satisfy additional duration condition.
    eCrdnPruneFilterIntervals = 3
    # Selects gaps between intervals which satisfy additional duration condition.
    eCrdnPruneFilterGaps = 4
    # Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterSatisfactionIntervals = 5
    # Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterRelativeSatisfactionIntervals = 6

AgECrdnPruneFilter.eCrdnPruneFilterUnknown.__doc__ = "Unknown or unsupported prune filter"
AgECrdnPruneFilter.eCrdnPruneFilterFirstIntervals.__doc__ = "Selects specified number of first intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterLastIntervals.__doc__ = "Selects specified number of last intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterIntervals.__doc__ = "Selects intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterGaps.__doc__ = "Selects gaps between intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterSatisfactionIntervals.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
AgECrdnPruneFilter.eCrdnPruneFilterRelativeSatisfactionIntervals.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["AgECrdnPruneFilter"] = AgECrdnPruneFilter

class AgECrdnSampledReferenceTime(IntEnum):
    """Event array reference type."""
    # Use a Time Instant as the reference time
    eCrdnSampledReferenceTimeReferenceEvent = 0
    # Use the start of each interval as the reference time
    eCrdnSampledReferenceTimeStartOfEachInterval = 1
    # Use the stop of each interval as the reference time
    eCrdnSampledReferenceTimeStopOfEachInterval = 2
    # Use the start of each interval list as the reference time
    eCrdnSampledReferenceTimeStartOfIntervalList = 3
    # Use the stop of each interval list as the reference time
    eCrdnSampledReferenceTimeStopOfIntervalList = 4

AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeReferenceEvent.__doc__ = "Use a Time Instant as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfEachInterval.__doc__ = "Use the start of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfEachInterval.__doc__ = "Use the stop of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfIntervalList.__doc__ = "Use the start of each interval list as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfIntervalList.__doc__ = "Use the stop of each interval list as the reference time"

agcls.AgTypeNameMap["AgECrdnSampledReferenceTime"] = AgECrdnSampledReferenceTime

class AgECrdnSamplingMethod(IntEnum):
    """Defines the Sampling Method"""
    # Unknown or unsupported sampling method
    eCrdnSamplingMethodUnknown = 0
    # Fixed step sampling method
    eCrdnSamplingMethodFixedStep = 1
    # Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples.
    eCrdnSamplingMethodRelativeTolerance = 2
    # Curvature tolerance also uses changes in slope between samples
    eCrdnSamplingMethodCurvatureTolerance = 3

AgECrdnSamplingMethod.eCrdnSamplingMethodUnknown.__doc__ = "Unknown or unsupported sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodFixedStep.__doc__ = "Fixed step sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodRelativeTolerance.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
AgECrdnSamplingMethod.eCrdnSamplingMethodCurvatureTolerance.__doc__ = "Curvature tolerance also uses changes in slope between samples"

agcls.AgTypeNameMap["AgECrdnSamplingMethod"] = AgECrdnSamplingMethod

class AgECrdnSatisfactionCrossing(IntEnum):
    """Direction crossing flags."""
    # Use either off-to-on or on-to-off condition to determine satisfaction
    eCrdnSatisfactionCrossingNone = 0
    # Satisfaction occurs when crossing from off to on condition
    eCrdnSatisfactionCrossingIn = 1
    # Satisfaction occurs when crossing from on to off condition
    eCrdnSatisfactionCrossingOut = 2

AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingNone.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingIn.__doc__ = "Satisfaction occurs when crossing from off to on condition"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingOut.__doc__ = "Satisfaction occurs when crossing from on to off condition"

agcls.AgTypeNameMap["AgECrdnSatisfactionCrossing"] = AgECrdnSatisfactionCrossing

class AgECrdnSaveDataOption(IntEnum):
    """Method for saving computed data"""
    # Use the application setting to determine whether computed data should be saved/loaded.
    eCrdnSaveDataOptionApplicationSettings = -1
    # Save/load computed data.
    eCrdnSaveDataOptionYes = 100
    # Don't save computed data, recompute data on load.
    eCrdnSaveDataOptionNo = 10

AgECrdnSaveDataOption.eCrdnSaveDataOptionApplicationSettings.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
AgECrdnSaveDataOption.eCrdnSaveDataOptionYes.__doc__ = "Save/load computed data."
AgECrdnSaveDataOption.eCrdnSaveDataOptionNo.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["AgECrdnSaveDataOption"] = AgECrdnSaveDataOption

class AgECrdnSignalPathReferenceSystem(IntEnum):
    """Signal path reference system types."""
    # Use Access default system
    eCrdnSignalPathReferenceSystemUseAccessDefault = -1
    # Use central body inertial system
    eCrdnSignalPathReferenceSystemCentralBodyInertial = 0
    # Use solar system barycenter system
    eCrdnSignalPathReferenceSystemSolarSystemBarycenter = 1
    # User will specify a system
    eCrdnSignalPathReferenceSystemCustom = 2

AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemUseAccessDefault.__doc__ = "Use Access default system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCentralBodyInertial.__doc__ = "Use central body inertial system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemSolarSystemBarycenter.__doc__ = "Use solar system barycenter system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCustom.__doc__ = "User will specify a system"

agcls.AgTypeNameMap["AgECrdnSignalPathReferenceSystem"] = AgECrdnSignalPathReferenceSystem

class AgECrdnSmartEpochState(IntEnum):
    """Smart epoch states."""
    # Smart epoch is specified explicitly using a time.
    eCrdnSmartEpochStateExplicit = 0
    # Smart epoch is specified implicitly.
    eCrdnSmartEpochStateImplicit = 3

AgECrdnSmartEpochState.eCrdnSmartEpochStateExplicit.__doc__ = "Smart epoch is specified explicitly using a time."
AgECrdnSmartEpochState.eCrdnSmartEpochStateImplicit.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["AgECrdnSmartEpochState"] = AgECrdnSmartEpochState

class AgECrdnSmartIntervalState(IntEnum):
    """Smart interval states."""
    # Smart interval is specified explicitly using start/stop times.
    eCrdnSmartIntervalStateExplicit = 0
    # Smart interval is specified implicitly using start/stop times.
    eCrdnSmartIntervalStateImplicit = 1
    # Smart interval is specified using smart epochs.
    eCrdnSmartIntervalStateStartStop = 2
    # Smart interval is specified using a start epoch and duration.
    eCrdnSmartIntervalStateStartDuration = 4
    # Smart interval is specified using a start time and explicit duration.
    eCrdnSmartIntervalStateExplicitDuration = 3

AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicit.__doc__ = "Smart interval is specified explicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateImplicit.__doc__ = "Smart interval is specified implicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartStop.__doc__ = "Smart interval is specified using smart epochs."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartDuration.__doc__ = "Smart interval is specified using a start epoch and duration."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicitDuration.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["AgECrdnSmartIntervalState"] = AgECrdnSmartIntervalState

class AgECrdnSpeedOptions(IntEnum):
    """Defines various speed options."""
    # Light transmission speed.
    eCrdnLightTransmissionSpeed = 1
    # Custom transmission speed.
    eCrdnCustomTransmissionSpeed = 2

AgECrdnSpeedOptions.eCrdnLightTransmissionSpeed.__doc__ = "Light transmission speed."
AgECrdnSpeedOptions.eCrdnCustomTransmissionSpeed.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["AgECrdnSpeedOptions"] = AgECrdnSpeedOptions

class AgECrdnStartStopOption(IntEnum):
    """Start/stop options."""
    # Use the start time of the interval
    eCrdnStartStopOptionCountStartOnly = 1
    # Use the stop time of the interval
    eCrdnStartStopOptionCountStopOnly = 2
    # Use the start time and stop time of the interval
    eCrdnStartStopOptionCountStartStop = 3

AgECrdnStartStopOption.eCrdnStartStopOptionCountStartOnly.__doc__ = "Use the start time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStopOnly.__doc__ = "Use the stop time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStartStop.__doc__ = "Use the start time and stop time of the interval"

agcls.AgTypeNameMap["AgECrdnStartStopOption"] = AgECrdnStartStopOption

class AgECrdnThreshConvergeSense(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
    # Just converge within tolerance.
    eCrdnThreshConvergeSenseSimple = 0
    # Result above or at threshold.
    eCrdnThreshConvergeSenseAbove = 1
    # Result below or at threshold.
    eCrdnThreshConvergeSenseBelow = 2

AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseSimple.__doc__ = "Just converge within tolerance."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseAbove.__doc__ = "Result above or at threshold."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseBelow.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["AgECrdnThreshConvergeSense"] = AgECrdnThreshConvergeSense

class AgECrdnVectorComponentType(IntEnum):
    """Defines component directions for a vector."""
    # X component.
    eCrdnVectorComponentX = 0
    # Y component.
    eCrdnVectorComponentY = 1
    # Z component.
    eCrdnVectorComponentZ = 2
    # -X component.
    eCrdnVectorComponentMinusX = 3
    # -Y component.
    eCrdnVectorComponentMinusY = 4
    # -Z component.
    eCrdnVectorComponentMinusZ = 5

AgECrdnVectorComponentType.eCrdnVectorComponentX.__doc__ = "X component."
AgECrdnVectorComponentType.eCrdnVectorComponentY.__doc__ = "Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentZ.__doc__ = "Z component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusX.__doc__ = "-X component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusY.__doc__ = "-Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusZ.__doc__ = "-Z component."

agcls.AgTypeNameMap["AgECrdnVectorComponentType"] = AgECrdnVectorComponentType

class AgECrdnVolumeCalcAltitudeReferenceType(IntEnum):
    """Defines volume calc altitude reference types."""
    # Volume calc altitude above reference ellipsoid.
    eCrdnVolumeCalcAltitudeReferenceEllipsoid = 0
    # Volume calc altitude reference above terrain.
    eCrdnVolumeCalcAltitudeReferenceTerrain = 1
    # Volume calc altitude reference above mean sea level.
    eCrdnVolumeCalcAltitudeReferenceMSL = 2

AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceEllipsoid.__doc__ = "Volume calc altitude above reference ellipsoid."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceTerrain.__doc__ = "Volume calc altitude reference above terrain."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceMSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAltitudeReferenceType"] = AgECrdnVolumeCalcAltitudeReferenceType

class AgECrdnVolumeCalcAngleOffVectorType(IntEnum):
    """Defines volume calc angle off vector reference types."""
    # Volume calc angle off plane signed.
    eCrdnVolumeCalcAngleOffPlaneSigned = 1
    # Volume calc angle off plane unsigned.
    eCrdnVolumeCalcAngleOffPlaneUnsigned = 2
    # Volume calc angle about vector signed.
    eCrdnVolumeCalcAngleAboutVectorSigned = 4
    # Volume calc angle about vector unsigned.
    eCrdnVolumeCalcAngleAboutVectorUnsigned = 8
    # Volume calc angle off vector.
    eCrdnVolumeCalcAngleOffVector = 16

AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneSigned.__doc__ = "Volume calc angle off plane signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneUnsigned.__doc__ = "Volume calc angle off plane unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorSigned.__doc__ = "Volume calc angle about vector signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorUnsigned.__doc__ = "Volume calc angle about vector unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffVector.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAngleOffVectorType"] = AgECrdnVolumeCalcAngleOffVectorType

class AgECrdnVolumeCalcRangeDistanceType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceFromPoint = 0
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceAlongVectorSigned = 1
    # Volume calc range distance type along vector unsigned
    eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned = 2
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneSigned = 4
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneUnsigned = 8

AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceFromPoint.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorSigned.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned.__doc__ = "Volume calc range distance type along vector unsigned"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneSigned.__doc__ = "Volume calc range distance type plane signed"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneUnsigned.__doc__ = "Volume calc range distance type plane signed"

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeDistanceType"] = AgECrdnVolumeCalcRangeDistanceType

class AgECrdnVolumeCalcRangeSpeedType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedLight = 1
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedCustom = 2

AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedLight.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedCustom.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeSpeedType"] = AgECrdnVolumeCalcRangeSpeedType

class AgECrdnVolumeCalcType(IntEnum):
    """Defines volume calc types."""
    # Unknown or unsupported volume calc.
    eCrdnVolumeCalcTypeUnknown = -1
    # volume calc type altitude to location.
    eCrdnVolumeCalcTypeAltitude = 0
    # volume calc type angle to location.
    eCrdnVolumeCalcTypeAngleOffVector = 1
    # volume calc type File.
    eCrdnVolumeCalcTypeFile = 2
    # volume calc type scalar at location.
    eCrdnVolumeCalcTypeFromScalar = 3
    # volume calc type Solar Intensity.
    eCrdnVolumeCalcTypeSolarIntensity = 4
    # volume calc type Spatial Condition Satisfaction Metric.
    eCrdnVolumeCalcTypeVolumeSatisfactionMetric = 5
    # volume calc type Distance to Location.
    eCrdnVolumeCalcTypeRange = 6
    # volume calc type Propagation Delay to Location.
    eCrdnVolumeCalcTypeDelayRange = 7

AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeUnknown.__doc__ = "Unknown or unsupported volume calc."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAltitude.__doc__ = "volume calc type altitude to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAngleOffVector.__doc__ = "volume calc type angle to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFile.__doc__ = "volume calc type File."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFromScalar.__doc__ = "volume calc type scalar at location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeSolarIntensity.__doc__ = "volume calc type Solar Intensity."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeVolumeSatisfactionMetric.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeRange.__doc__ = "volume calc type Distance to Location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeDelayRange.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["AgECrdnVolumeCalcType"] = AgECrdnVolumeCalcType

class AgECrdnVolumeCalcVolumeSatisfactionAccumulationType(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
    # Volume calc spatial condition satisfaction accumulation type up to current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime = -1
    # Volume calc spatial condition satisfaction accumulation type current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime = 0
    # Volume calc spatial condition satisfaction accumulation type from current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime = 1
    # Volume calc spatial condition satisfaction accumulation type total.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal = 10

AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionAccumulationType"] = AgECrdnVolumeCalcVolumeSatisfactionAccumulationType

class AgECrdnVolumeCalcVolumeSatisfactionDurationType(IntEnum):
    """Defines volume calc spatial condition duration types."""
    # Volume calc spatial condition satisfaction duration type minimum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMin = -1
    # Volume calc spatial condition satisfaction duration type sum.
    eCrdnVolumeCalcVolumeSatisfactionDurationSum = 0
    # Volume calc spatial condition satisfaction duration type maximum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMax = 1

AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMin.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationSum.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMax.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionDurationType"] = AgECrdnVolumeCalcVolumeSatisfactionDurationType

class AgECrdnVolumeCalcVolumeSatisfactionFilterType(IntEnum):
    """Defines volume calc spatial condition filter types."""
    # Volume calc spatial condition satisfaction filter type first intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals = -10
    # Volume calc spatial condition satisfaction filter type last intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals = -20
    # Volume calc spatial condition satisfaction filter type none.
    eCrdnVolumeCalcVolumeSatisfactionFilterNone = 0
    # Volume calc spatial condition satisfaction filter type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration = 1
    # Volume calc spatial condition satisfaction filter type interval duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration = 2

AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterNone.__doc__ = "Volume calc spatial condition satisfaction filter type none."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionFilterType"] = AgECrdnVolumeCalcVolumeSatisfactionFilterType

class AgECrdnVolumeCalcVolumeSatisfactionMetricType(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
    # Volume calc spatial condition satisfaction metric type number of gaps.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps = -2
    # Volume calc spatial condition satisfaction metric type number of intervals.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals = -1
    # Volume calc spatial condition satisfaction metric type time since last satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction = 1
    # Volume calc spatial condition satisfaction metric type time until next satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction = 2
    # Volume calc spatial condition satisfaction metric type interbnal duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration = 10
    # Volume calc spatial condition satisfaction metric type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration = 20

AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionMetricType"] = AgECrdnVolumeCalcVolumeSatisfactionMetricType

class AgECrdnVolumeGridType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume grid.
    eCrdnVolumeGridTypeUnknown = -1
    # volume grid type cartesian.
    eCrdnVolumeGridTypeCartesian = 0
    # volume grid type Cylindrical.
    eCrdnVolumeGridTypeCylindrical = 1
    # volume grid type Spherical.
    eCrdnVolumeGridTypeSpherical = 2
    # volume grid type Constrained.
    eCrdnVolumeGridTypeConstrained = 3
    # volume grid type LatLonAlt (Cartographic).
    eCrdnVolumeGridTypeLatLonAlt = 4
    # volume grid type BearingAlt (Surface Bearing).
    eCrdnVolumeGridTypeBearingAlt = 5

AgECrdnVolumeGridType.eCrdnVolumeGridTypeUnknown.__doc__ = "Unknown or unsupported volume grid."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCartesian.__doc__ = "volume grid type cartesian."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCylindrical.__doc__ = "volume grid type Cylindrical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeSpherical.__doc__ = "volume grid type Spherical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeConstrained.__doc__ = "volume grid type Constrained."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeLatLonAlt.__doc__ = "volume grid type LatLonAlt (Cartographic)."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeBearingAlt.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["AgECrdnVolumeGridType"] = AgECrdnVolumeGridType

class AgECrdnVolumeResultVectorRequest(IntEnum):
    """Defines volume result vector request types."""
    # volume result vector request pos type
    eCrdnVolumeResultVectorRequestPos = 1
    # volume result vector request native pos type
    eCrdnVolumeResultVectorRequestNativePos = 2
    # volume result vector request metric type
    eCrdnVolumeResultVectorRequestMetric = 16
    # volume result vector request satisfaction type
    eCrdnVolumeResultVectorRequestSatisfaction = 32
    # volume result vector request gradient type
    eCrdnVolumeResultVectorRequestGradient = 256

AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestPos.__doc__ = "volume result vector request pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestNativePos.__doc__ = "volume result vector request native pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestMetric.__doc__ = "volume result vector request metric type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestSatisfaction.__doc__ = "volume result vector request satisfaction type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestGradient.__doc__ = "volume result vector request gradient type"

agcls.AgTypeNameMap["AgECrdnVolumeResultVectorRequest"] = AgECrdnVolumeResultVectorRequest

class AgECrdnVolumeType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume.
    eCrdnVolumeTypeUnknown = -1
    # volume type combined.
    eCrdnVolumeTypeCombined = 0
    # volume type lighting.
    eCrdnVolumeTypeLighting = 1
    # volume type over time.
    eCrdnVolumeTypeOverTime = 2
    # volume type from grid (Grid Bounding Volume).
    eCrdnVolumeTypeFromGrid = 3
    # volume type from calc (Spatial Calculation Bounds).
    eCrdnVolumeTypeFromCalc = 4
    # volume type from time satisfaction (Valid Time At Location).
    eCrdnVolumeTypeFromTimeSatisfaction = 5
    # volume type from condition (Condition At Location).
    eCrdnVolumeTypeFromCondition = 6
    # volume type Inview (Access To Location).
    eCrdnVolumeTypeInview = 7

AgECrdnVolumeType.eCrdnVolumeTypeUnknown.__doc__ = "Unknown or unsupported volume."
AgECrdnVolumeType.eCrdnVolumeTypeCombined.__doc__ = "volume type combined."
AgECrdnVolumeType.eCrdnVolumeTypeLighting.__doc__ = "volume type lighting."
AgECrdnVolumeType.eCrdnVolumeTypeOverTime.__doc__ = "volume type over time."
AgECrdnVolumeType.eCrdnVolumeTypeFromGrid.__doc__ = "volume type from grid (Grid Bounding Volume)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCalc.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
AgECrdnVolumeType.eCrdnVolumeTypeFromTimeSatisfaction.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCondition.__doc__ = "volume type from condition (Condition At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeInview.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["AgECrdnVolumeType"] = AgECrdnVolumeType

class AgECrdnVolumeAberrationType(IntEnum):
    """Defines the model of aberration to use."""
    # Aberration type unknown.
    eCrdnVolumeAberrationUnknown = -1
    # Aberration type total.
    eCrdnVolumeAberrationTotal = 0
    # SAberration type annual.
    eCrdnVolumeAberrationAnnual = 1
    # Aberration type none.
    eCrdnVolumeAberrationNone = 2

AgECrdnVolumeAberrationType.eCrdnVolumeAberrationUnknown.__doc__ = "Aberration type unknown."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationTotal.__doc__ = "Aberration type total."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationAnnual.__doc__ = "SAberration type annual."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationNone.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["AgECrdnVolumeAberrationType"] = AgECrdnVolumeAberrationType

class AgECrdnVolumeClockHostType(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
    # Unknown
    eCrdnVolumeClockHostUnknown = -1
    # Base object holds time instance.
    eCrdnVolumeClockHostBase = 0
    # Target object holds time instance.
    eCrdnVolumeClockHostTarget = 1

AgECrdnVolumeClockHostType.eCrdnVolumeClockHostUnknown.__doc__ = "Unknown"
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostBase.__doc__ = "Base object holds time instance."
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostTarget.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["AgECrdnVolumeClockHostType"] = AgECrdnVolumeClockHostType

class AgECrdnVolumeCombinedOperationType(IntEnum):
    """Defines spatial condition combined operation types."""
    # Spatial condition combined AND operation.
    eCrdnVolumeCombinedOperationTypeAND = 1
    # Spatial condition combined OR operation.
    eCrdnVolumeCombinedOperationTypeOR = 2
    # Spatial condition combined XOR operation.
    eCrdnVolumeCombinedOperationTypeXOR = 3
    # Spatial condition combined MINUS operation.
    eCrdnVolumeCombinedOperationTypeMINUS = 4

AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeAND.__doc__ = "Spatial condition combined AND operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeOR.__doc__ = "Spatial condition combined OR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeXOR.__doc__ = "Spatial condition combined XOR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeMINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnVolumeCombinedOperationType"] = AgECrdnVolumeCombinedOperationType

class AgECrdnVolumeFromGridEdgeType(IntEnum):
    """Defines spatial condition from grid edge type."""
    # Spatial condition over time from grid edge type mask points.
    eCrdnVolumeFromGridEdgeTypeMaskPoints = 16
    # Spatial condition over time from grid edge type mask voxels.
    eCrdnVolumeFromGridEdgeTypeMaskVoxels = 32

AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskPoints.__doc__ = "Spatial condition over time from grid edge type mask points."
AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskVoxels.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["AgECrdnVolumeFromGridEdgeType"] = AgECrdnVolumeFromGridEdgeType

class AgECrdnVolumeLightingConditionsType(IntFlag):
    """Defines spatial condition lighting conditions types."""
    # Spatial condition lighting undefined.
    eCrdnVolumeLightingConditionTypeUndefined = 0
    # Spatial condition lighting sun light.
    eCrdnVolumeLightingConditionTypeSunlight = 1
    # Spatial condition lighting penumbra.
    eCrdnVolumeLightingConditionTypePenumbra = 2
    # Spatial condition lighting umbra.
    eCrdnVolumeLightingConditionTypeUmbra = 4

AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUndefined.__doc__ = "Spatial condition lighting undefined."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeSunlight.__doc__ = "Spatial condition lighting sun light."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypePenumbra.__doc__ = "Spatial condition lighting penumbra."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUmbra.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["AgECrdnVolumeLightingConditionsType"] = AgECrdnVolumeLightingConditionsType

class AgECrdnVolumeOverTimeDurationType(IntEnum):
    """Defines spatial condition over time duration type."""
    # Spatial condition over time duration type Static.
    eCrdnVolumeOverTimeDurationTypeStatic = 0
    # Spatial condition over time duration type CumulativeToCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent = 1
    # Spatial condition over time duration type CumulativeFromCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent = 2
    # Spatial condition over time duration type SlidingWindow.
    eCrdnVolumeOverTimeDurationTypeSlidingWindow = 3

AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeStatic.__doc__ = "Spatial condition over time duration type Static."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeSlidingWindow.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["AgECrdnVolumeOverTimeDurationType"] = AgECrdnVolumeOverTimeDurationType

class AgECrdnVolumeTimeSenseType(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
    # Unklnown
    eCrdnVolumeTimeSenseUnknown = -1
    # Position is computed in Time Sense
    eCrdnVolumeTimeSenseTransmit = 0
    # Position is computed in Receive Sense
    eCrdnVolumeTimeSenseReceive = 1

AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseUnknown.__doc__ = "Unklnown"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseTransmit.__doc__ = "Position is computed in Time Sense"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseReceive.__doc__ = "Position is computed in Receive Sense"

agcls.AgTypeNameMap["AgECrdnVolumeTimeSenseType"] = AgECrdnVolumeTimeSenseType

class AgECrdnVolumetricGridValuesMethodType(IntEnum):
    """Defines volumetric grid values method types."""
    # Unknown or unsupportedgrid values method.
    eCrdnVolumetricGridValuesMethodMethodUnknown = -1
    # Fixed number steps grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedNumSteps = 0
    # Fixed step size grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedStepSize = 1
    # Custom grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodCustomValues = 2

AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodUnknown.__doc__ = "Unknown or unsupportedgrid values method."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedNumSteps.__doc__ = "Fixed number steps grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedStepSize.__doc__ = "Fixed step size grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodCustomValues.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["AgECrdnVolumetricGridValuesMethodType"] = AgECrdnVolumetricGridValuesMethodType

class AgECrdnKind(IntEnum):
    """Represents kinds of vectory geometry components."""
    # Unsupported component kind.
    eCrdnKindUnknown = -1
    # Invalid component.
    eCrdnKindInvalid = 0
    # Axes component.
    eCrdnKindAxes = 1
    # Angle component.
    eCrdnKindAngle = 2
    # Vector component.
    eCrdnKindVector = 3
    # Point component.
    eCrdnKindPoint = 4
    # Plane component.
    eCrdnKindPlane = 5
    # System component.
    eCrdnKindSystem = 6
    # An event.
    eCrdnKindEvent = 7
    # An event array.
    eCrdnKindEventArray = 8
    # An event interval.
    eCrdnKindEventInterval = 9
    # An event interval collection.
    eCrdnKindEventIntervalCollection = 10
    # A list of event intervals.
    eCrdnKindEventIntervalList = 11
    # A parameter set.
    eCrdnKindParameterSet = 12
    # A scalar.
    eCrdnKindCalcScalar = 13
    # A condition.
    eCrdnKindCondition = 14
    # A condition set.
    eCrdnKindConditionSet = 15
    # A volume grid.
    eCrdnKindVolumeGrid = 16
    # A volume.
    eCrdnKindVolume = 17
    # A volume calc.
    eCrdnKindVolumeCalc = 18

AgECrdnKind.eCrdnKindUnknown.__doc__ = "Unsupported component kind."
AgECrdnKind.eCrdnKindInvalid.__doc__ = "Invalid component."
AgECrdnKind.eCrdnKindAxes.__doc__ = "Axes component."
AgECrdnKind.eCrdnKindAngle.__doc__ = "Angle component."
AgECrdnKind.eCrdnKindVector.__doc__ = "Vector component."
AgECrdnKind.eCrdnKindPoint.__doc__ = "Point component."
AgECrdnKind.eCrdnKindPlane.__doc__ = "Plane component."
AgECrdnKind.eCrdnKindSystem.__doc__ = "System component."
AgECrdnKind.eCrdnKindEvent.__doc__ = "An event."
AgECrdnKind.eCrdnKindEventArray.__doc__ = "An event array."
AgECrdnKind.eCrdnKindEventInterval.__doc__ = "An event interval."
AgECrdnKind.eCrdnKindEventIntervalCollection.__doc__ = "An event interval collection."
AgECrdnKind.eCrdnKindEventIntervalList.__doc__ = "A list of event intervals."
AgECrdnKind.eCrdnKindParameterSet.__doc__ = "A parameter set."
AgECrdnKind.eCrdnKindCalcScalar.__doc__ = "A scalar."
AgECrdnKind.eCrdnKindCondition.__doc__ = "A condition."
AgECrdnKind.eCrdnKindConditionSet.__doc__ = "A condition set."
AgECrdnKind.eCrdnKindVolumeGrid.__doc__ = "A volume grid."
AgECrdnKind.eCrdnKindVolume.__doc__ = "A volume."
AgECrdnKind.eCrdnKindVolumeCalc.__doc__ = "A volume calc."

agcls.AgTypeNameMap["AgECrdnKind"] = AgECrdnKind

class AgECrdnAngleType(IntEnum):
    """Represents angle types."""
    # Unknown or unsupported type.
    eCrdnAngleTypeUnknown = -1
    # An angle between two vectors.
    eCrdnAngleTypeBetweenVectors = 0
    # An angle between two planes.
    eCrdnAngleTypeBetweenPlanes = 1
    # An angle between two vectors about an axis.
    eCrdnAngleTypeDihedralAngle = 2
    # Angle of the shortest rotation between the two specified axes.
    eCrdnAngleTypeRotation = 3
    # An angle between a vector and a plane.
    eCrdnAngleTypeToPlane = 4
    # Represents a VGT angle created from a template. This type of angle is not creatable.
    eCrdnAngleTypeTemplate = 5

AgECrdnAngleType.eCrdnAngleTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAngleType.eCrdnAngleTypeBetweenVectors.__doc__ = "An angle between two vectors."
AgECrdnAngleType.eCrdnAngleTypeBetweenPlanes.__doc__ = "An angle between two planes."
AgECrdnAngleType.eCrdnAngleTypeDihedralAngle.__doc__ = "An angle between two vectors about an axis."
AgECrdnAngleType.eCrdnAngleTypeRotation.__doc__ = "Angle of the shortest rotation between the two specified axes."
AgECrdnAngleType.eCrdnAngleTypeToPlane.__doc__ = "An angle between a vector and a plane."
AgECrdnAngleType.eCrdnAngleTypeTemplate.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["AgECrdnAngleType"] = AgECrdnAngleType

class AgECrdnAxesType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported type.
    eCrdnAxesTypeUnknown = -1
    # Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type.
    eCrdnAxesTypeLagrangeLibration = 0
    # Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset.
    eCrdnAxesTypeAngularOffset = 1
    # Axes based on another set fixed at a specified epoch.
    eCrdnAxesTypeFixedAtEpoch = 2
    # B-Plane axes using the selected target body and reference vector.
    eCrdnAxesTypeBPlane = 3
    # Customized axes offset with respect to a set of reference Axes.
    eCrdnAxesTypeCustomScript = 4
    # Axes fixed in reference axes.
    eCrdnAxesTypeFixed = 6
    # Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference.
    eCrdnAxesTypeAlignedAndConstrained = 7
    # Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element.
    eCrdnAxesTypeModelAttachment = 8
    # Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset.
    eCrdnAxesTypeSpinning = 9
    # Projection of the reference point onto the central body.
    eCrdnAxesTypeOnSurface = 10
    # Axes based on trajectory of the point relative to the reference coordinate system.
    eCrdnAxesTypeTrajectory = 11
    # Represents a VGT axes created from a template. This type of axes is not creatable.
    eCrdnAxesTypeTemplate = 12
    # Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant.
    eCrdnAxesTypeAtTimeInstant = 13
    # An axes plugin point.
    eCrdnAxesTypePlugin = 14
    # Axes specified by data from a file.
    eCrdnAxesTypeFile = 5

AgECrdnAxesType.eCrdnAxesTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAxesType.eCrdnAxesTypeLagrangeLibration.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
AgECrdnAxesType.eCrdnAxesTypeAngularOffset.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeFixedAtEpoch.__doc__ = "Axes based on another set fixed at a specified epoch."
AgECrdnAxesType.eCrdnAxesTypeBPlane.__doc__ = "B-Plane axes using the selected target body and reference vector."
AgECrdnAxesType.eCrdnAxesTypeCustomScript.__doc__ = "Customized axes offset with respect to a set of reference Axes."
AgECrdnAxesType.eCrdnAxesTypeFixed.__doc__ = "Axes fixed in reference axes."
AgECrdnAxesType.eCrdnAxesTypeAlignedAndConstrained.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
AgECrdnAxesType.eCrdnAxesTypeModelAttachment.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
AgECrdnAxesType.eCrdnAxesTypeSpinning.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeOnSurface.__doc__ = "Projection of the reference point onto the central body."
AgECrdnAxesType.eCrdnAxesTypeTrajectory.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
AgECrdnAxesType.eCrdnAxesTypeTemplate.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
AgECrdnAxesType.eCrdnAxesTypeAtTimeInstant.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
AgECrdnAxesType.eCrdnAxesTypePlugin.__doc__ = "An axes plugin point."
AgECrdnAxesType.eCrdnAxesTypeFile.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["AgECrdnAxesType"] = AgECrdnAxesType

class AgECrdnPlaneType(IntEnum):
    """Represents plane types."""
    # Unknown or unsupported type.
    eCrdnPlaneTypeUnknown = -1
    # A plane normal to a vector at a given point.
    eCrdnPlaneTypeNormal = 0
    # A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system.
    eCrdnPlaneTypeQuadrant = 1
    # A plane is defined on the basis of a trajectory of a selected point with respect to a reference point.
    eCrdnPlaneTypeTrajectory = 2
    # A plane is defined by the three points.
    eCrdnPlaneTypeTriad = 3
    # Represents a VGT plane created from a template. This type of plane is not creatable.
    eCrdnPlaneTypeTemplate = 4
    # A plane passing through point and containing two given vectors.
    eCrdnPlaneTypeTwoVector = 5

AgECrdnPlaneType.eCrdnPlaneTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPlaneType.eCrdnPlaneTypeNormal.__doc__ = "A plane normal to a vector at a given point."
AgECrdnPlaneType.eCrdnPlaneTypeQuadrant.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
AgECrdnPlaneType.eCrdnPlaneTypeTrajectory.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
AgECrdnPlaneType.eCrdnPlaneTypeTriad.__doc__ = "A plane is defined by the three points."
AgECrdnPlaneType.eCrdnPlaneTypeTemplate.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
AgECrdnPlaneType.eCrdnPlaneTypeTwoVector.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["AgECrdnPlaneType"] = AgECrdnPlaneType

class AgECrdnPointType(IntEnum):
    """Represents point types."""
    # Unknown or unsupported type.
    eCrdnPointTypeUnknown = -1
    # B-Plane point using the selected target body.
    eCrdnPointTypeBPlane = 0
    # The grazing point is the point of closest approach to the surface of the selected central body along a defined direction.
    eCrdnPointTypeGrazing = 1
    # The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option.
    eCrdnPointTypeCovarianceGrazing = 2
    # Point fixed in a reference coordinate system.
    eCrdnPointTypeFixedInSystem = 4
    # Point on central body surface that reflects from source to observer.
    eCrdnPointTypeGlint = 5
    # Point on a plane located along a given direction looking from a given origin.
    eCrdnPointTypePlaneIntersection = 6
    # Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point.
    eCrdnPointTypeModelAttachment = 7
    # The projection of a point onto a reference plane.
    eCrdnPointTypePlaneProjection = 8
    # The detic subpoint of the reference point as projected onto the central body.
    eCrdnPointTypeOnSurface = 9
    # Libration point using one primary and multiple secondary central bodies.
    eCrdnPointTypeLagrangeLibration = 10
    # Represents a VGT point created from a template. This type of point is not creatable.
    eCrdnPointTypeTemplate = 11
    # Point on central body surface along direction vector originating at source point.
    eCrdnPointTypeCentralBodyIntersect = 12
    # Point fixed relative to reference system based on another point evaluated at specified time instant.
    eCrdnPointTypeAtTimeInstant = 13
    # A point plugin point.
    eCrdnPointTypePlugin = 14
    # Point specified by data from a file.
    eCrdnPointTypeFile = 3
    # Point fixed on a central body.
    eCrdnPointTypeFixedOnCentralBody = 15
    # A point placed at the center of mass of a specified satellite of the satellite collection.
    eCrdnPointTypeSatelliteCollectionEntry = 16

AgECrdnPointType.eCrdnPointTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPointType.eCrdnPointTypeBPlane.__doc__ = "B-Plane point using the selected target body."
AgECrdnPointType.eCrdnPointTypeGrazing.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
AgECrdnPointType.eCrdnPointTypeCovarianceGrazing.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
AgECrdnPointType.eCrdnPointTypeFixedInSystem.__doc__ = "Point fixed in a reference coordinate system."
AgECrdnPointType.eCrdnPointTypeGlint.__doc__ = "Point on central body surface that reflects from source to observer."
AgECrdnPointType.eCrdnPointTypePlaneIntersection.__doc__ = "Point on a plane located along a given direction looking from a given origin."
AgECrdnPointType.eCrdnPointTypeModelAttachment.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
AgECrdnPointType.eCrdnPointTypePlaneProjection.__doc__ = "The projection of a point onto a reference plane."
AgECrdnPointType.eCrdnPointTypeOnSurface.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
AgECrdnPointType.eCrdnPointTypeLagrangeLibration.__doc__ = "Libration point using one primary and multiple secondary central bodies."
AgECrdnPointType.eCrdnPointTypeTemplate.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
AgECrdnPointType.eCrdnPointTypeCentralBodyIntersect.__doc__ = "Point on central body surface along direction vector originating at source point."
AgECrdnPointType.eCrdnPointTypeAtTimeInstant.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
AgECrdnPointType.eCrdnPointTypePlugin.__doc__ = "A point plugin point."
AgECrdnPointType.eCrdnPointTypeFile.__doc__ = "Point specified by data from a file."
AgECrdnPointType.eCrdnPointTypeFixedOnCentralBody.__doc__ = "Point fixed on a central body."
AgECrdnPointType.eCrdnPointTypeSatelliteCollectionEntry.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["AgECrdnPointType"] = AgECrdnPointType

class AgECrdnSystemType(IntEnum):
    """Represents system types."""
    # Unknown or unsupported system type.
    eCrdnSystemTypeUnknown = -1
    # A system assembled from an origin point and a set of reference axes.
    eCrdnSystemTypeAssembled = 0
    # A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle.
    eCrdnSystemTypeOnSurface = 1
    # Represents a VGT system created from a template. This type of system is not creatable.
    eCrdnSystemTypeTemplate = 2

AgECrdnSystemType.eCrdnSystemTypeUnknown.__doc__ = "Unknown or unsupported system type."
AgECrdnSystemType.eCrdnSystemTypeAssembled.__doc__ = "A system assembled from an origin point and a set of reference axes."
AgECrdnSystemType.eCrdnSystemTypeOnSurface.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
AgECrdnSystemType.eCrdnSystemTypeTemplate.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["AgECrdnSystemType"] = AgECrdnSystemType

class AgECrdnVectorType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported vector type.
    eCrdnVectorTypeUnknown = -1
    # Vector defined by its start and end points.
    eCrdnVectorTypeDisplacement = 0
    # Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeApoapsis = 1
    # Based on another vector fixed at a specified epoch.
    eCrdnVectorTypeFixedAtEpoch = 2
    # Angular velocity vector of one set of axes computed with respect to the reference set.
    eCrdnVectorTypeAngularVelocity = 3
    # Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode.
    eCrdnVectorTypeConing = 4
    # The vector cross product of two vectors.
    eCrdnVectorTypeCrossProduct = 5
    # Customized vector components defined with respect to reference axes.
    eCrdnVectorTypeCustomScript = 6
    # Derivative of a vector computed with respect to specified axes.
    eCrdnVectorTypeDerivative = 7
    # Angle rate vector perpendicular to the plane in which the angle is defined.
    eCrdnVectorTypeAngleRate = 8
    # Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeEccentricity = 9
    # Vector fixed in reference axes.
    eCrdnVectorTypeFixedInAxes = 10
    # Defined along the intersection of two planes.
    eCrdnVectorTypeTwoPlanesIntersection = 12
    # Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body.
    eCrdnVectorTypeLineOfNodes = 13
    # Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element.
    eCrdnVectorTypeModelAttachment = 14
    # Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitAngularMomentum = 15
    # Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitNormal = 16
    # Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypePeriapsis = 17
    # A projection of a vector computed with respect to a reference plane.
    eCrdnVectorTypeProjection = 18
    # Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane.
    eCrdnVectorTypeReflection = 19
    # Scaled version of the input vector.
    eCrdnVectorTypeScaled = 20
    # Defined with respect to a star object.
    eCrdnVectorTypeDirectionToStar = 21
    # Represents a VGT vector created from a template. This type of vector is not creatable.
    eCrdnVectorTypeTemplate = 22
    # Vector fixed relative to reference axes based on another vector evaluated at specified time instant.
    eCrdnVectorTypeAtTimeInstant = 23
    # Linear combination of two input vectors.
    eCrdnVectorTypeLinearCombination = 24
    # A projection of a source vector in the direction of another vector.
    eCrdnVectorTypeProjectAlong = 25
    # Linear combination of two input vectors using scalars.
    eCrdnVectorTypeScalarLinearCombination = 26
    # Scaled version of the input vector using scalar.
    eCrdnVectorTypeScalarScaled = 27
    # Velocity vector of a point in a coordinate system.
    eCrdnVectorTypeVelocity = 28
    # A vector plugin point.
    eCrdnVectorTypePlugin = 29
    # Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis.
    eCrdnVectorTypeRotationVector = 30
    # Displacement between origin and destination points using surface distance and altitude difference.
    eCrdnVectorTypeDisplacementOnSurface = 31

AgECrdnVectorType.eCrdnVectorTypeUnknown.__doc__ = "Unknown or unsupported vector type."
AgECrdnVectorType.eCrdnVectorTypeDisplacement.__doc__ = "Vector defined by its start and end points."
AgECrdnVectorType.eCrdnVectorTypeApoapsis.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedAtEpoch.__doc__ = "Based on another vector fixed at a specified epoch."
AgECrdnVectorType.eCrdnVectorTypeAngularVelocity.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
AgECrdnVectorType.eCrdnVectorTypeConing.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
AgECrdnVectorType.eCrdnVectorTypeCrossProduct.__doc__ = "The vector cross product of two vectors."
AgECrdnVectorType.eCrdnVectorTypeCustomScript.__doc__ = "Customized vector components defined with respect to reference axes."
AgECrdnVectorType.eCrdnVectorTypeDerivative.__doc__ = "Derivative of a vector computed with respect to specified axes."
AgECrdnVectorType.eCrdnVectorTypeAngleRate.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
AgECrdnVectorType.eCrdnVectorTypeEccentricity.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedInAxes.__doc__ = "Vector fixed in reference axes."
AgECrdnVectorType.eCrdnVectorTypeTwoPlanesIntersection.__doc__ = "Defined along the intersection of two planes."
AgECrdnVectorType.eCrdnVectorTypeLineOfNodes.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeModelAttachment.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
AgECrdnVectorType.eCrdnVectorTypeOrbitAngularMomentum.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeOrbitNormal.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypePeriapsis.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeProjection.__doc__ = "A projection of a vector computed with respect to a reference plane."
AgECrdnVectorType.eCrdnVectorTypeReflection.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
AgECrdnVectorType.eCrdnVectorTypeScaled.__doc__ = "Scaled version of the input vector."
AgECrdnVectorType.eCrdnVectorTypeDirectionToStar.__doc__ = "Defined with respect to a star object."
AgECrdnVectorType.eCrdnVectorTypeTemplate.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
AgECrdnVectorType.eCrdnVectorTypeAtTimeInstant.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
AgECrdnVectorType.eCrdnVectorTypeLinearCombination.__doc__ = "Linear combination of two input vectors."
AgECrdnVectorType.eCrdnVectorTypeProjectAlong.__doc__ = "A projection of a source vector in the direction of another vector."
AgECrdnVectorType.eCrdnVectorTypeScalarLinearCombination.__doc__ = "Linear combination of two input vectors using scalars."
AgECrdnVectorType.eCrdnVectorTypeScalarScaled.__doc__ = "Scaled version of the input vector using scalar."
AgECrdnVectorType.eCrdnVectorTypeVelocity.__doc__ = "Velocity vector of a point in a coordinate system."
AgECrdnVectorType.eCrdnVectorTypePlugin.__doc__ = "A vector plugin point."
AgECrdnVectorType.eCrdnVectorTypeRotationVector.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
AgECrdnVectorType.eCrdnVectorTypeDisplacementOnSurface.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["AgECrdnVectorType"] = AgECrdnVectorType

class AgECrdnMeanElementTheory(IntEnum):
    """Mean element theory types for approximating motion."""
    # Osculating elements (six standard Keplerian orbital elements).
    eCrdnMeanElementTheoryOsculating = 1
    # The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377.
    eCrdnMeanElementTheoryKozai = 2
    # Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eCrdnMeanElementTheoryBrouwerLyddane_Long = 3
    # Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eCrdnMeanElementTheoryBrouwerLyddane_Short = 4

AgECrdnMeanElementTheory.eCrdnMeanElementTheoryOsculating.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryKozai.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper ``The Motion of a Close earth satellite,`` Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Long.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Short.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["AgECrdnMeanElementTheory"] = AgECrdnMeanElementTheory

class AgECrdnDirectionType(IntEnum):
    """Direction options."""
    # Incoming direction.
    eCrdnDirectionIncomingAsymptote = 1
    # Outgoing direction.
    eCrdnDirectionOutgoingAsymptote = 2

AgECrdnDirectionType.eCrdnDirectionIncomingAsymptote.__doc__ = "Incoming direction."
AgECrdnDirectionType.eCrdnDirectionOutgoingAsymptote.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["AgECrdnDirectionType"] = AgECrdnDirectionType

class AgECrdnLagrangeLibrationPointType(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
    # A point between the Sun and Earth.
    eCrdnLagrangeLibrationPointTypeL1 = 1
    # Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth.
    eCrdnLagrangeLibrationPointTypeL2 = 2
    # L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times.
    eCrdnLagrangeLibrationPointTypeL3 = 3
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL4 = 4
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL5 = 5

AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL1.__doc__ = "A point between the Sun and Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."

agcls.AgTypeNameMap["AgECrdnLagrangeLibrationPointType"] = AgECrdnLagrangeLibrationPointType

class AgECrdnQuadrantType(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY),"""
    # XY quadrant.
    eCrdnQuadrantXY = 1
    # YX quadrant.
    eCrdnQuadrantYX = 2
    # XZ quadrant.
    eCrdnQuadrantXZ = 3
    # ZX quadrant.
    eCrdnQuadrantZX = 4
    # YZ quadrant.
    eCrdnQuadrantYZ = 5
    # ZY quadrant.
    eCrdnQuadrantZY = 6

AgECrdnQuadrantType.eCrdnQuadrantXY.__doc__ = "XY quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYX.__doc__ = "YX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantXZ.__doc__ = "XZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZX.__doc__ = "ZX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYZ.__doc__ = "YZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["AgECrdnQuadrantType"] = AgECrdnQuadrantType

class AgECrdnTrajectoryAxesType(IntEnum):
    """Trajectory axes coordinate types."""
    # Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack).
    eCrdnTrajectoryAxesICR = 0
    # Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal).
    eCrdnTrajectoryAxesVNC = 1
    # Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack).
    eCrdnTrajectoryAxesRIC = 2
    # Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal).
    eCrdnTrajectoryAxesLVLH = 3
    # Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity).
    eCrdnTrajectoryAxesVVLH = 4
    # Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesBBR = 5
    # Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesEquinoctial = 6
    # Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal).
    eCrdnTrajectoryAxesNTC = 7

AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesRIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesLVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesBBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesEquinoctial.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesNTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["AgECrdnTrajectoryAxesType"] = AgECrdnTrajectoryAxesType

class AgECrdnDisplayAxisSelector(IntEnum):
    """Rotation directions."""
    # Rotate about Axis X.
    eCrdnDisplayAxisX = 0
    # Rotate about Axis Y.
    eCrdnDisplayAxisY = 1
    # Rotate about Axis Z.
    eCrdnDisplayAxisZ = 2

AgECrdnDisplayAxisSelector.eCrdnDisplayAxisX.__doc__ = "Rotate about Axis X."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisY.__doc__ = "Rotate about Axis Y."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisZ.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["AgECrdnDisplayAxisSelector"] = AgECrdnDisplayAxisSelector

class AgECrdnSignedAngleType(IntEnum):
    """Defines options for computing an angle."""
    # Choose the option to use unsigned angle.
    eCrdnSignedAngleNone = 0
    # Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAnglePositive = 1
    # Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAngleNegative = 2

AgECrdnSignedAngleType.eCrdnSignedAngleNone.__doc__ = "Choose the option to use unsigned angle."
AgECrdnSignedAngleType.eCrdnSignedAnglePositive.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
AgECrdnSignedAngleType.eCrdnSignedAngleNegative.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["AgECrdnSignedAngleType"] = AgECrdnSignedAngleType

class AgECrdnPointBPlaneType(IntEnum):
    """B-Plane point types."""
    # Asymptote.
    eCrdnPointBPlaneAsymptote = 1
    # Two body.
    eCrdnPointBPlaneATwoBody = 2

AgECrdnPointBPlaneType.eCrdnPointBPlaneAsymptote.__doc__ = "Asymptote."
AgECrdnPointBPlaneType.eCrdnPointBPlaneATwoBody.__doc__ = "Two body."

agcls.AgTypeNameMap["AgECrdnPointBPlaneType"] = AgECrdnPointBPlaneType

class AgECrdnReferenceShapeType(IntEnum):
    """Surface shape types."""
    # An ellipsoid reference shape as defined by the central body (by default, it is WSG84).
    eCrdnReferenceShapeEllipsoid = 1
    # Terrain as the terrain reference.
    eCrdnReferenceShapeTerrain = 2
    # Mean Sea Level as the terrain reference.
    eCrdnReferenceShapeMSL = 3

AgECrdnReferenceShapeType.eCrdnReferenceShapeEllipsoid.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
AgECrdnReferenceShapeType.eCrdnReferenceShapeTerrain.__doc__ = "Terrain as the terrain reference."
AgECrdnReferenceShapeType.eCrdnReferenceShapeMSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["AgECrdnReferenceShapeType"] = AgECrdnReferenceShapeType

class AgECrdnSurfaceType(IntEnum):
    """Surface types."""
    # Detic surface model.
    eCrdnSurfaceDetic = 1
    # Centric surface model.
    eCrdnSurfaceCentric = 2

AgECrdnSurfaceType.eCrdnSurfaceDetic.__doc__ = "Detic surface model."
AgECrdnSurfaceType.eCrdnSurfaceCentric.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["AgECrdnSurfaceType"] = AgECrdnSurfaceType

class AgECrdnSweepMode(IntEnum):
    """The rotation sweeping modes."""
    # Bidirectional sweeping mode.
    eCrdnSweepModeBidirectional = 1
    # Unidirectional sweeping mode.
    eCrdnSweepModeUnidirectional = 2

AgECrdnSweepMode.eCrdnSweepModeBidirectional.__doc__ = "Bidirectional sweeping mode."
AgECrdnSweepMode.eCrdnSweepModeUnidirectional.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["AgECrdnSweepMode"] = AgECrdnSweepMode

class AgECrdnSignalSense(IntEnum):
    """Signal sense transmission options."""
    # Signal receive.
    eCrdnSignalSenseReceive = 1
    # Signal transmit.
    eCrdnSignalSenseTransmit = 2

AgECrdnSignalSense.eCrdnSignalSenseReceive.__doc__ = "Signal receive."
AgECrdnSignalSense.eCrdnSignalSenseTransmit.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["AgECrdnSignalSense"] = AgECrdnSignalSense

class AgECrdnIntersectionSurface(IntEnum):
    """Intersection surface flags."""
    # Intersection with central body ellipsoid.
    eCrdnIntersectionSurfaceAtCentralBodyEllipsoid = 0
    # Intersection at altitude.
    eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid = 1
    # Use terrain as intersection surface.
    eCrdnIntersectionSurfaceAtTerrain = 2

AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtCentralBodyEllipsoid.__doc__ = "Intersection with central body ellipsoid."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid.__doc__ = "Intersection at altitude."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtTerrain.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["AgECrdnIntersectionSurface"] = AgECrdnIntersectionSurface

class AgECrdnVectorScaledDimensionInheritance(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
    # Do not inherit dimension.
    eCrdnVectorScaledDimensionInheritanceNone = 0
    # Inherit dimension from scalar.
    eCrdnVectorScaledDimensionInheritanceFromScalar = 1
    # Inherit dimension from vector.
    eCrdnVectorScaledDimensionInheritanceFromVector = 2

AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromScalar.__doc__ = "Inherit dimension from scalar."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromVector.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["AgECrdnVectorScaledDimensionInheritance"] = AgECrdnVectorScaledDimensionInheritance


class ITimeToolIntervalCollection(object):
    """The interface represents a collection of intervals."""
    _uuid = "{DAE5D702-43F1-4544-8039-97E746D019AB}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolIntervalCollection = agcom.GUID(ITimeToolIntervalCollection._uuid)
        vtable_offset_local = ITimeToolIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolIntervalCollection.__dict__ and type(ITimeToolIntervalCollection.__dict__[attrname]) == property:
            return ITimeToolIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Return a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ITimeToolInterval":
        """Returns an interval at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DAE5D702-43F1-4544-8039-97E746D019AB}", ITimeToolIntervalCollection)
agcls.AgTypeNameMap["ITimeToolIntervalCollection"] = ITimeToolIntervalCollection

class ITimeToolInterval(object):
    """The interface represents an interval."""
    _uuid = "{4A5031BC-45C0-4E75-9190-31F1802C173D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolInterval = agcom.GUID(ITimeToolInterval._uuid)
        vtable_offset_local = ITimeToolInterval._vtable_offset - 1
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolInterval, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ITimeToolInterval, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolInterval.__dict__ and type(ITimeToolInterval.__dict__[attrname]) == property:
            return ITimeToolInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolInterval.")
    
    @property
    def Start(self) -> typing.Any:
        """The interval's start time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The interval's stop time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A5031BC-45C0-4E75-9190-31F1802C173D}", ITimeToolInterval)
agcls.AgTypeNameMap["ITimeToolInterval"] = ITimeToolInterval

class IVectorGeometryToolPoint(object):
    """The interface defines methods and properties common to all points."""
    _uuid = "{086D1AA7-D85D-402D-9347-0B51EB552537}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPoint = agcom.GUID(IVectorGeometryToolPoint._uuid)
        vtable_offset_local = IVectorGeometryToolPoint._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPoint, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_LocateInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPoint, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_LocateInSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPoint, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPoint.__dict__ and type(IVectorGeometryToolPoint.__dict__[attrname]) == property:
            return IVectorGeometryToolPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPoint.")
    
    @property
    def Type(self) -> "AgECrdnPointType":
        """Returns a type of the point object."""
        with agmarshall.AgEnum_arg(AgECrdnPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def LocateInSystemWithRate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def LocateInSystem(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{086D1AA7-D85D-402D-9347-0B51EB552537}", IVectorGeometryToolPoint)
agcls.AgTypeNameMap["IVectorGeometryToolPoint"] = IVectorGeometryToolPoint

class IVectorGeometryToolVector(object):
    """The interface defines methods and properties common to all vectors."""
    _uuid = "{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVector = agcom.GUID(IVectorGeometryToolVector._uuid)
        vtable_offset_local = IVectorGeometryToolVector._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVector, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVector, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVector.__dict__ and type(IVectorGeometryToolVector.__dict__[attrname]) == property:
            return IVectorGeometryToolVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVector.")
    
    @property
    def Type(self) -> "AgECrdnVectorType":
        """Returns a type of the vector object."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolVectorFindInAxesResult":
        """Computes the vector in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolVectorFindInAxesWithRateResult":
        """Computes the vector and its rate in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}", IVectorGeometryToolVector)
agcls.AgTypeNameMap["IVectorGeometryToolVector"] = IVectorGeometryToolVector

class IVectorGeometryToolSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""
    _uuid = "{14687421-5E90-4275-9DE5-21295EC14F65}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystem = agcom.GUID(IVectorGeometryToolSystem._uuid)
        vtable_offset_local = IVectorGeometryToolSystem._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystem, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystem, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystem, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystem, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystem.__dict__ and type(IVectorGeometryToolSystem.__dict__[attrname]) == property:
            return IVectorGeometryToolSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystem.")
    
    @property
    def Type(self) -> "AgECrdnSystemType":
        """Returns a type of the system object."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector") -> "IVectorGeometryToolSystemTransformResult":
        """Translates the position vector from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, IVectorGeometryToolSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector", velocityInMySystem:"ICartesian3Vector") -> "IVectorGeometryToolSystemTransformWithRateResult":
        """Translates the position and rate vectors from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, IVectorGeometryToolSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_in_arg(velocityInMySystem, ICartesian3Vector) as arg_velocityInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, arg_velocityInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14687421-5E90-4275-9DE5-21295EC14F65}", IVectorGeometryToolSystem)
agcls.AgTypeNameMap["IVectorGeometryToolSystem"] = IVectorGeometryToolSystem

class IVectorGeometryToolAxes(object):
    """The interface defines methods and properties common to all axes."""
    _uuid = "{EE2FCF98-9315-406A-835C-40C56428C888}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxes = agcom.GUID(IVectorGeometryToolAxes._uuid)
        vtable_offset_local = IVectorGeometryToolAxes._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+8, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxes, vtable_offset_local+9, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxes.__dict__ and type(IVectorGeometryToolAxes.__dict__[attrname]) == property:
            return IVectorGeometryToolAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxes.")
    
    @property
    def Type(self) -> "AgECrdnAxesType":
        """Returns a type of the axes object."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IVectorGeometryToolAxesLabels":
        """Returns an object that allows modifying the axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def X(self) -> "IVectorGeometryToolVector":
        """Returns the X axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Y(self) -> "IVectorGeometryToolVector":
        """Returns the Y axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Z(self) -> "IVectorGeometryToolVector":
        """Returns the Z axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector") -> "IVectorGeometryToolAxesTransformResult":
        """Transforms the input vector from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IVectorGeometryToolAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector", rateInMyAxes:"ICartesian3Vector") -> "IVectorGeometryToolAxesTransformWithRateResult":
        """Transforms the input vector and vector's rate from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IVectorGeometryToolAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_in_arg(rateInMyAxes, ICartesian3Vector) as arg_rateInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, arg_rateInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE2FCF98-9315-406A-835C-40C56428C888}", IVectorGeometryToolAxes)
agcls.AgTypeNameMap["IVectorGeometryToolAxes"] = IVectorGeometryToolAxes

class IVectorGeometryToolAngle(object):
    """The interface defines methods and properties common to all angles."""
    _uuid = "{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindAngle"] = _raise_uninitialized_error
        self.__dict__["_FindAngleWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinates"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinatesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngle = agcom.GUID(IVectorGeometryToolAngle._uuid)
        vtable_offset_local = IVectorGeometryToolAngle._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngle, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngle, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindAngleWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngle, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinates"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngle, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinatesWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngle, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngle.__dict__ and type(IVectorGeometryToolAngle.__dict__[attrname]) == property:
            return IVectorGeometryToolAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngle.")
    
    @property
    def Type(self) -> "AgECrdnAngleType":
        """Returns a type of the angle object."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindAngle(self, epoch:typing.Any) -> "IVectorGeometryToolAngleFindAngleResult":
        """Finds an angle at the specified epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngle"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindAngleWithRate(self, epoch:typing.Any) -> "IVectorGeometryToolAngleFindAngleWithRateResult":
        """Finds an angle and angle rate."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngleWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinates(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAngleFindResult":
        """Finds the angle value and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinates"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinatesWithRate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAngleFindWithRateResult":
        """Finds the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinatesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}", IVectorGeometryToolAngle)
agcls.AgTypeNameMap["IVectorGeometryToolAngle"] = IVectorGeometryToolAngle

class IVectorGeometryToolPlane(object):
    """The interface defines methods and properties common to all VGT planes."""
    _uuid = "{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_FindInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlane = agcom.GUID(IVectorGeometryToolPlane._uuid)
        vtable_offset_local = IVectorGeometryToolPlane._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlane, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlane.__dict__ and type(IVectorGeometryToolPlane.__dict__[attrname]) == property:
            return IVectorGeometryToolPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlane.")
    
    @property
    def Type(self) -> "AgECrdnPlaneType":
        """Returns a type of the plane object."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolPlaneFindInAxesResult":
        """Computes the plane's axes vectors in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolPlaneFindInAxesWithRateResult":
        """Computes the plane's axes vectors and their rates in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPlaneFindInSystemResult":
        """Computes the position and X and Y axes in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystemWithRate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "IVectorGeometryToolPlaneFindInSystemWithRateResult":
        """Computes the position, X and Y axes and their rates of change in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IVectorGeometryToolPlaneLabels":
        """Allows configuring the plane's X and Y axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}", IVectorGeometryToolPlane)
agcls.AgTypeNameMap["IVectorGeometryToolPlane"] = IVectorGeometryToolPlane

class IAnalysisWorkbenchContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""
    _uuid = "{1003D700-A64E-438C-954A-AD3AA9EA9773}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchContext._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchContext from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchContext = agcom.GUID(IAnalysisWorkbenchContext._uuid)
        vtable_offset_local = IAnalysisWorkbenchContext._vtable_offset - 1
        self.__dict__["_GetIsTemplate"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchContext, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchContext.__dict__ and type(IAnalysisWorkbenchContext.__dict__[attrname]) == property:
            return IAnalysisWorkbenchContext.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchContext.")
    
    @property
    def IsTemplate(self) -> bool:
        """Returns whether the current instance is a VGT template."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsTemplate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1003D700-A64E-438C-954A-AD3AA9EA9773}", IAnalysisWorkbenchContext)
agcls.AgTypeNameMap["IAnalysisWorkbenchContext"] = IAnalysisWorkbenchContext

class IAnalysisWorkbenchComponent(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""
    _uuid = "{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetKind"] = _raise_uninitialized_error
        self.__dict__["_GetCategory"] = _raise_uninitialized_error
        self.__dict__["_SetCategory"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetDescription"] = _raise_uninitialized_error
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsDuplicable"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_GetTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetQualifiedPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIsReady"] = _raise_uninitialized_error
        self.__dict__["_GetIsReadOnly"] = _raise_uninitialized_error
        self.__dict__["_Duplicate"] = _raise_uninitialized_error
        self.__dict__["_AnonymousDuplicate"] = _raise_uninitialized_error
        self.__dict__["_DependsOn"] = _raise_uninitialized_error
        self.__dict__["_GetEmbeddedComponents"] = _raise_uninitialized_error
        self.__dict__["_Export"] = _raise_uninitialized_error
        self.__dict__["_Rename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchComponent = agcom.GUID(IAnalysisWorkbenchComponent._uuid)
        vtable_offset_local = IAnalysisWorkbenchComponent._vtable_offset - 1
        self.__dict__["_GetKind"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetCategory"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetCategory"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetDescription"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetIsDuplicable"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetQualifiedPath"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReady"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReadOnly"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Duplicate"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_AnonymousDuplicate"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_DependsOn"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+16, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEmbeddedComponents"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_Export"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+18, agcom.BSTR, agcom.BSTR)
        self.__dict__["_Rename"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchComponent, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchComponent.__dict__ and type(IAnalysisWorkbenchComponent.__dict__[attrname]) == property:
            return IAnalysisWorkbenchComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchComponent.")
    
    @property
    def Kind(self) -> "AgECrdnKind":
        """Returns the component kind."""
        with agmarshall.AgEnum_arg(AgECrdnKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Category(self) -> str:
        """Allows the user to access or change the component category (Folder)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCategory"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Category.setter
    def Category(self, category:str) -> None:
        with agmarshall.BSTR_arg(category) as arg_category:
            agcls.evaluate_hresult(self.__dict__["_SetCategory"](arg_category.COM_val))

    @property
    def Name(self) -> str:
        """Returns the component name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Description(self) -> str:
        """Returns the component description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Path(self) -> str:
        """Returns the component's fully qualified path (ie. ``CentralBody/Earth Body``, etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsDuplicable(self) -> bool:
        """Returns whether the VGT component can be duplicated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsDuplicable"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns the context object associated with the instance. The returned object is either an instance of IAgCrdnInstance or IAgCrdnTemplate interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TypeInfo(self) -> "IAnalysisWorkbenchTypeInfo":
        """Returns the component type information."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def QualifiedPath(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. ``CentralBody/Earth Body Vector``, etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQualifiedPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsValid(self) -> bool:
        """Returns whether the component is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReady(self) -> bool:
        """Returns whether the component is ready. The component is ready if it's been fully initialized."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReady"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReadOnly(self) -> bool:
        """Returns whether the component is modifiable."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReadOnly"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Duplicate(self, newName:str, description:str) -> "IAnalysisWorkbenchComponent":
        """Creates a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        with agmarshall.BSTR_arg(newName) as arg_newName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Duplicate"](arg_newName.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def AnonymousDuplicate(self) -> "IAnalysisWorkbenchComponent":
        """Creates an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_AnonymousDuplicate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def DependsOn(self, component:"IAnalysisWorkbenchComponent") -> bool:
        """Tests if the instance depends on another component."""
        with agmarshall.AgInterface_in_arg(component, IAnalysisWorkbenchComponent) as arg_component, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_DependsOn"](arg_component.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def EmbeddedComponents(self) -> "IAnalysisWorkbenchCollection":
        """Returns a collection of embedded components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEmbeddedComponents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Export(self, filename:str, comments:str) -> None:
        """Exports the component to a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.BSTR_arg(comments) as arg_comments:
            agcls.evaluate_hresult(self.__dict__["_Export"](arg_filename.COM_val, arg_comments.COM_val))

    def Rename(self, newName:str) -> None:
        """Renames the component."""
        with agmarshall.BSTR_arg(newName) as arg_newName:
            agcls.evaluate_hresult(self.__dict__["_Rename"](arg_newName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}", IAnalysisWorkbenchComponent)
agcls.AgTypeNameMap["IAnalysisWorkbenchComponent"] = IAnalysisWorkbenchComponent

class ICalculationToolEvaluateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolEvaluateResult = agcom.GUID(ICalculationToolEvaluateResult._uuid)
        vtable_offset_local = ICalculationToolEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolEvaluateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolEvaluateResult.__dict__ and type(ICalculationToolEvaluateResult.__dict__[attrname]) == property:
            return ICalculationToolEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """The scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}", ICalculationToolEvaluateResult)
agcls.AgTypeNameMap["ICalculationToolEvaluateResult"] = ICalculationToolEvaluateResult

class ICalculationToolEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{E9B2DA30-1317-43E2-8D47-9D675A28F748}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolEvaluateWithRateResult = agcom.GUID(ICalculationToolEvaluateWithRateResult._uuid)
        vtable_offset_local = ICalculationToolEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolEvaluateWithRateResult.__dict__ and type(ICalculationToolEvaluateWithRateResult.__dict__[attrname]) == property:
            return ICalculationToolEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """Computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Rate(self) -> float:
        """A rate of change of the computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9B2DA30-1317-43E2-8D47-9D675A28F748}", ICalculationToolEvaluateWithRateResult)
agcls.AgTypeNameMap["ICalculationToolEvaluateWithRateResult"] = ICalculationToolEvaluateWithRateResult

class ITimeToolEventIntervalResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalResult = agcom.GUID(ITimeToolEventIntervalResult._uuid)
        vtable_offset_local = ITimeToolEventIntervalResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalResult.__dict__ and type(ITimeToolEventIntervalResult.__dict__[attrname]) == property:
            return ITimeToolEventIntervalResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interval(self) -> "ITimeToolInterval":
        """An interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}", ITimeToolEventIntervalResult)
agcls.AgTypeNameMap["ITimeToolEventIntervalResult"] = ITimeToolEventIntervalResult

class ITimeToolEventFindOccurrenceResult(object):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    _uuid = "{20F964F0-8466-415E-9344-D6FBA53AF8B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventFindOccurrenceResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventFindOccurrenceResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventFindOccurrenceResult = agcom.GUID(ITimeToolEventFindOccurrenceResult._uuid)
        vtable_offset_local = ITimeToolEventFindOccurrenceResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFindOccurrenceResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFindOccurrenceResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventFindOccurrenceResult.__dict__ and type(ITimeToolEventFindOccurrenceResult.__dict__[attrname]) == property:
            return ITimeToolEventFindOccurrenceResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventFindOccurrenceResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{20F964F0-8466-415E-9344-D6FBA53AF8B0}", ITimeToolEventFindOccurrenceResult)
agcls.AgTypeNameMap["ITimeToolEventFindOccurrenceResult"] = ITimeToolEventFindOccurrenceResult

class ITimeToolFindTimesResult(object):
    """Returns a collection of intervals and an array of times."""
    _uuid = "{F7B644F0-0728-434D-8C86-C6267B625860}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolFindTimesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolFindTimesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolFindTimesResult = agcom.GUID(ITimeToolFindTimesResult._uuid)
        vtable_offset_local = ITimeToolFindTimesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFindTimesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFindTimesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFindTimesResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFindTimesResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFindTimesResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolFindTimesResult.__dict__ and type(ITimeToolFindTimesResult.__dict__[attrname]) == property:
            return ITimeToolFindTimesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolFindTimesResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ITimeToolIntervalCollection":
        """A collection of found intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Times(self) -> list:
        """An array of found times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F7B644F0-0728-434D-8C86-C6267B625860}", ITimeToolFindTimesResult)
agcls.AgTypeNameMap["ITimeToolFindTimesResult"] = ITimeToolFindTimesResult

class ITimeToolIntervalsVectorResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    _uuid = "{87F76F41-61FB-4DFF-A76E-25270023BE34}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalCollections"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolIntervalsVectorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolIntervalsVectorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolIntervalsVectorResult = agcom.GUID(ITimeToolIntervalsVectorResult._uuid)
        vtable_offset_local = ITimeToolIntervalsVectorResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsVectorResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsVectorResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolIntervalsVectorResult.__dict__ and type(ITimeToolIntervalsVectorResult.__dict__[attrname]) == property:
            return ITimeToolIntervalsVectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolIntervalsVectorResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IntervalCollections(self) -> "ITimeToolIntervalVectorCollection":
        """A collection of interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{87F76F41-61FB-4DFF-A76E-25270023BE34}", ITimeToolIntervalsVectorResult)
agcls.AgTypeNameMap["ITimeToolIntervalsVectorResult"] = ITimeToolIntervalsVectorResult

class ITimeToolEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    _uuid = "{A829181E-A9CD-452D-AC81-19C2DA96C490}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIndex"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionOccurredResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionOccurredResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionOccurredResult = agcom.GUID(ITimeToolEventIntervalCollectionOccurredResult._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionOccurredResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionOccurredResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionOccurredResult, vtable_offset_local+2, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionOccurredResult.__dict__ and type(ITimeToolEventIntervalCollectionOccurredResult.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionOccurredResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionOccurredResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Index(self) -> int:
        """Index of an interval in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIndex"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A829181E-A9CD-452D-AC81-19C2DA96C490}", ITimeToolEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionOccurredResult"] = ITimeToolEventIntervalCollectionOccurredResult

class ITimeToolIntervalListResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{D0FDA46F-8B86-4052-8EC7-1448284EABCF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolIntervalListResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolIntervalListResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolIntervalListResult = agcom.GUID(ITimeToolIntervalListResult._uuid)
        vtable_offset_local = ITimeToolIntervalListResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalListResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalListResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolIntervalListResult.__dict__ and type(ITimeToolIntervalListResult.__dict__[attrname]) == property:
            return ITimeToolIntervalListResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolIntervalListResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ITimeToolIntervalCollection":
        """A list of intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D0FDA46F-8B86-4052-8EC7-1448284EABCF}", ITimeToolIntervalListResult)
agcls.AgTypeNameMap["ITimeToolIntervalListResult"] = ITimeToolIntervalListResult

class ITimeToolIntervalVectorCollection(object):
    """A collection of interval collections."""
    _uuid = "{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolIntervalVectorCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolIntervalVectorCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolIntervalVectorCollection = agcom.GUID(ITimeToolIntervalVectorCollection._uuid)
        vtable_offset_local = ITimeToolIntervalVectorCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalVectorCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalVectorCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalVectorCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolIntervalVectorCollection.__dict__ and type(ITimeToolIntervalVectorCollection.__dict__[attrname]) == property:
            return ITimeToolIntervalVectorCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolIntervalVectorCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ITimeToolIntervalCollection":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}", ITimeToolIntervalVectorCollection)
agcls.AgTypeNameMap["ITimeToolIntervalVectorCollection"] = ITimeToolIntervalVectorCollection

class ITimeToolEventGroup(object):
    """Access or create VGT events associated with an object."""
    _uuid = "{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventGroup = agcom.GUID(ITimeToolEventGroup._uuid)
        vtable_offset_local = ITimeToolEventGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventGroup.__dict__ and type(ITimeToolEventGroup.__dict__[attrname]) == property:
            return ITimeToolEventGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolEvent":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ITimeToolEventFactory":
        """Returns a Factory object used to create custom events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ITimeToolEvent":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ITimeToolEvent":
        """Retrieves an event from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ITimeToolEvent":
        """Retrieves an event from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}", ITimeToolEventGroup)
agcls.AgTypeNameMap["ITimeToolEventGroup"] = ITimeToolEventGroup

class ITimeToolEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""
    _uuid = "{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalGroup = agcom.GUID(ITimeToolEventIntervalGroup._uuid)
        vtable_offset_local = ITimeToolEventIntervalGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalGroup.__dict__ and type(ITimeToolEventIntervalGroup.__dict__[attrname]) == property:
            return ITimeToolEventIntervalGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolEventInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventIntervalName:str) -> None:
        """Removes an element by name."""
        with agmarshall.BSTR_arg(eventIntervalName) as arg_eventIntervalName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventIntervalName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ITimeToolEventIntervalFactory":
        """Returns a Factory object used to create custom event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ITimeToolEventInterval":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ITimeToolEventInterval":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ITimeToolEventInterval":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}", ITimeToolEventIntervalGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalGroup"] = ITimeToolEventIntervalGroup

class ITimeToolEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""
    _uuid = "{E5721039-AE57-448A-9891-048ECB8BDC63}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListGroup = agcom.GUID(ITimeToolEventIntervalListGroup._uuid)
        vtable_offset_local = ITimeToolEventIntervalListGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListGroup.__dict__ and type(ITimeToolEventIntervalListGroup.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalList":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ITimeToolEventIntervalListFactory":
        """Returns a factory object used to create custom event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalList":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ITimeToolEventIntervalList":
        """Retrieves an event interval list from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ITimeToolEventIntervalList":
        """Retrieves an event interval list from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{E5721039-AE57-448A-9891-048ECB8BDC63}", ITimeToolEventIntervalListGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalListGroup"] = ITimeToolEventIntervalListGroup

class ITimeToolEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""
    _uuid = "{37A14DB3-3A49-4A6B-B238-922B59737548}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayGroup = agcom.GUID(ITimeToolEventArrayGroup._uuid)
        vtable_offset_local = ITimeToolEventArrayGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayGroup.__dict__ and type(ITimeToolEventArrayGroup.__dict__[attrname]) == property:
            return ITimeToolEventArrayGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolEventArray":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ITimeToolEventArrayFactory":
        """Returns a Factory object used to create event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ITimeToolEventArray":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ITimeToolEventArray":
        """Retrieves an event array from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ITimeToolEventArray":
        """Retrieves an event array from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{37A14DB3-3A49-4A6B-B238-922B59737548}", ITimeToolEventArrayGroup)
agcls.AgTypeNameMap["ITimeToolEventArrayGroup"] = ITimeToolEventArrayGroup

class ICalculationToolScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    _uuid = "{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarGroup = agcom.GUID(ICalculationToolScalarGroup._uuid)
        vtable_offset_local = ICalculationToolScalarGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarGroup.__dict__ and type(ICalculationToolScalarGroup.__dict__[attrname]) == property:
            return ICalculationToolScalarGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICalculationToolScalar":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICalculationToolScalarFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICalculationToolScalar":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICalculationToolScalar":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICalculationToolScalar":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}", ICalculationToolScalarGroup)
agcls.AgTypeNameMap["ICalculationToolScalarGroup"] = ICalculationToolScalarGroup

class ITimeToolEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""
    _uuid = "{0166467D-9328-4E1B-A982-D9B1396A025E}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionGroup = agcom.GUID(ITimeToolEventIntervalCollectionGroup._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionGroup.__dict__ and type(ITimeToolEventIntervalCollectionGroup.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ITimeToolEventIntervalCollectionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalCollection":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ITimeToolEventIntervalCollection":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ITimeToolEventIntervalCollection":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{0166467D-9328-4E1B-A982-D9B1396A025E}", ITimeToolEventIntervalCollectionGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionGroup"] = ITimeToolEventIntervalCollectionGroup

class ICalculationToolParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""
    _uuid = "{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetGroup = agcom.GUID(ICalculationToolParameterSetGroup._uuid)
        vtable_offset_local = ICalculationToolParameterSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetGroup.__dict__ and type(ICalculationToolParameterSetGroup.__dict__[attrname]) == property:
            return ICalculationToolParameterSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICalculationToolParameterSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICalculationToolParameterSetFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICalculationToolParameterSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICalculationToolParameterSet":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICalculationToolParameterSet":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}", ICalculationToolParameterSetGroup)
agcls.AgTypeNameMap["ICalculationToolParameterSetGroup"] = ICalculationToolParameterSetGroup

class ICalculationToolConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""
    _uuid = "{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionGroup = agcom.GUID(ICalculationToolConditionGroup._uuid)
        vtable_offset_local = ICalculationToolConditionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionGroup.__dict__ and type(ICalculationToolConditionGroup.__dict__[attrname]) == property:
            return ICalculationToolConditionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICalculationToolCondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICalculationToolConditionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICalculationToolCondition":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICalculationToolCondition":
        """Retrieves a condition from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICalculationToolCondition":
        """Retrieves a condition from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}", ICalculationToolConditionGroup)
agcls.AgTypeNameMap["ICalculationToolConditionGroup"] = ICalculationToolConditionGroup

class ICalculationToolConditionSetGroup(object):
    """Allows accessing and creating condition set components."""
    _uuid = "{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSetGroup = agcom.GUID(ICalculationToolConditionSetGroup._uuid)
        vtable_offset_local = ICalculationToolConditionSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSetGroup.__dict__ and type(ICalculationToolConditionSetGroup.__dict__[attrname]) == property:
            return ICalculationToolConditionSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICalculationToolConditionSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICalculationToolConditionSetFactory":
        """Returns a factory object used to create condition set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICalculationToolConditionSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICalculationToolConditionSet":
        """Retrieves a condition set from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICalculationToolConditionSet":
        """Retrieves a condition set from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}", ICalculationToolConditionSetGroup)
agcls.AgTypeNameMap["ICalculationToolConditionSetGroup"] = ICalculationToolConditionSetGroup

class ICalculationToolConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""
    _uuid = "{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSetEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSetEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSetEvaluateResult = agcom.GUID(ICalculationToolConditionSetEvaluateResult._uuid)
        vtable_offset_local = ICalculationToolConditionSetEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetEvaluateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSetEvaluateResult.__dict__ and type(ICalculationToolConditionSetEvaluateResult.__dict__[attrname]) == property:
            return ICalculationToolConditionSetEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSetEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}", ICalculationToolConditionSetEvaluateResult)
agcls.AgTypeNameMap["ICalculationToolConditionSetEvaluateResult"] = ICalculationToolConditionSetEvaluateResult

class ICalculationToolConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    _uuid = "{39814D49-3CF5-42B0-A46C-766781F45AB7}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_GetRates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSetEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSetEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSetEvaluateWithRateResult = agcom.GUID(ICalculationToolConditionSetEvaluateWithRateResult._uuid)
        vtable_offset_local = ICalculationToolConditionSetEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetRates"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSetEvaluateWithRateResult.__dict__ and type(ICalculationToolConditionSetEvaluateWithRateResult.__dict__[attrname]) == property:
            return ICalculationToolConditionSetEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSetEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rates(self) -> list:
        """Computed rates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{39814D49-3CF5-42B0-A46C-766781F45AB7}", ICalculationToolConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["ICalculationToolConditionSetEvaluateWithRateResult"] = ICalculationToolConditionSetEvaluateWithRateResult

class ISpatialAnalysisToolVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""
    _uuid = "{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridGroup = agcom.GUID(ISpatialAnalysisToolVolumeGridGroup._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridGroup.__dict__ and type(ISpatialAnalysisToolVolumeGridGroup.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeGrid":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ISpatialAnalysisToolVolumeGridFactory":
        """Returns a factory object used to create volume grid components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeGrid":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieves a volume grid from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieves a volume grid from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}", ISpatialAnalysisToolVolumeGridGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridGroup"] = ISpatialAnalysisToolVolumeGridGroup

class ISpatialAnalysisToolVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""
    _uuid = "{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGroup = agcom.GUID(ISpatialAnalysisToolVolumeGroup._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGroup.__dict__ and type(ISpatialAnalysisToolVolumeGroup.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolume":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ISpatialAnalysisToolVolumeFactory":
        """Returns a factory object used to create spatial condition components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolume":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ISpatialAnalysisToolVolume":
        """Retrieves an volume from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ISpatialAnalysisToolVolume":
        """Retrieves volume from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}", ISpatialAnalysisToolVolumeGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGroup"] = ISpatialAnalysisToolVolumeGroup

class ISpatialAnalysisToolVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""
    _uuid = "{02991465-35ec-486a-913d-bf204afc9fb6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcGroup = agcom.GUID(ISpatialAnalysisToolVolumeCalcGroup._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcGroup.__dict__ and type(ISpatialAnalysisToolVolumeCalcGroup.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeCalc":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ISpatialAnalysisToolVolumeCalcFactory":
        """Returns a factory object used to create volume calc components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeCalc":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieves a volume calculation from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieves a volume calculation from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{02991465-35ec-486a-913d-bf204afc9fb6}", ISpatialAnalysisToolVolumeCalcGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcGroup"] = ISpatialAnalysisToolVolumeCalcGroup

class ICalculationToolScalar(object):
    """Any scalar calculation that is not constant by construction."""
    _uuid = "{55A75307-E283-4146-A456-732D08E47070}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        self.__dict__["_GetUnitOfMeasure"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateEventArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateEventArray"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalar = agcom.GUID(ICalculationToolScalar._uuid)
        vtable_offset_local = ICalculationToolScalar._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetUnitOfMeasure"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_QuickEvaluateArray"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+8, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateArray"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalar, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalar.__dict__ and type(ICalculationToolScalar.__dict__[attrname]) == property:
            return ICalculationToolScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalar.")
    
    @property
    def Type(self) -> "AgECrdnCalcScalarType":
        """Returns the scalar calculation type."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICalculationToolEvaluateResult":
        """Evaluates the scalar calculation at the specified time instant."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICalculationToolEvaluateWithRateResult":
        """Evaluates the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetAvailability(self) -> "ITimeToolIntervalCollection":
        """Returns a list of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UnitOfMeasure(self) -> str:
        """Returns calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitOfMeasure"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def QuickEvaluateArray(self, times:list) -> list:
        """Evaluates the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateArray(self, times:list) -> list:
        """Evaluates the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateEventArray(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, ITimeToolEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateEventArray(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, ITimeToolEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{55A75307-E283-4146-A456-732D08E47070}", ICalculationToolScalar)
agcls.AgTypeNameMap["ICalculationToolScalar"] = ICalculationToolScalar

class ICalculationToolScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    _uuid = "{52FB9533-9332-44D2-92B2-8AA2D8633112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputAngle"] = _raise_uninitialized_error
        self.__dict__["_SetInputAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarAngle = agcom.GUID(ICalculationToolScalarAngle._uuid)
        vtable_offset_local = ICalculationToolScalarAngle._vtable_offset - 1
        self.__dict__["_GetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarAngle, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarAngle.__dict__ and type(ICalculationToolScalarAngle.__dict__[attrname]) == property:
            return ICalculationToolScalarAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarAngle.")
    
    @property
    def InputAngle(self) -> "IVectorGeometryToolAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputAngle.setter
    def InputAngle(self, inputAngle:"IVectorGeometryToolAngle") -> None:
        with agmarshall.AgInterface_in_arg(inputAngle, IVectorGeometryToolAngle) as arg_inputAngle:
            agcls.evaluate_hresult(self.__dict__["_SetInputAngle"](arg_inputAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52FB9533-9332-44D2-92B2-8AA2D8633112}", ICalculationToolScalarAngle)
agcls.AgTypeNameMap["ICalculationToolScalarAngle"] = ICalculationToolScalarAngle

class ICalculationToolScalarConstant(object):
    """Constant scalar value of specified dimension."""
    _uuid = "{96A1ABA9-663C-4CCC-A066-0166E285C3C2}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarConstant = agcom.GUID(ICalculationToolScalarConstant._uuid)
        vtable_offset_local = ICalculationToolScalarConstant._vtable_offset - 1
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarConstant, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarConstant, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarConstant.__dict__ and type(ICalculationToolScalarConstant.__dict__[attrname]) == property:
            return ICalculationToolScalarConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarConstant.")
    
    @property
    def Value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Value.setter
    def Value(self, value:float) -> None:
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_value.COM_val))

    @property
    def Dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96A1ABA9-663C-4CCC-A066-0166E285C3C2}", ICalculationToolScalarConstant)
agcls.AgTypeNameMap["ICalculationToolScalarConstant"] = ICalculationToolScalarConstant

class ICalculationToolScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    _uuid = "{6267B685-4486-4B11-A2CA-056D6A9B558C}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarCustom = agcom.GUID(ICalculationToolScalarCustom._uuid)
        vtable_offset_local = ICalculationToolScalarCustom._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarCustom, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarCustom, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarCustom, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarCustom.__dict__ and type(ICalculationToolScalarCustom.__dict__[attrname]) == property:
            return ICalculationToolScalarCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarCustom.")
    
    @property
    def Filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{6267B685-4486-4B11-A2CA-056D6A9B558C}", ICalculationToolScalarCustom)
agcls.AgTypeNameMap["ICalculationToolScalarCustom"] = ICalculationToolScalarCustom

class ICalculationToolScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    _uuid = "{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDataProvider"] = _raise_uninitialized_error
        self.__dict__["_GetElementName"] = _raise_uninitialized_error
        self.__dict__["_GetGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_SetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_SetWithGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInvalidDataIndicator"] = _raise_uninitialized_error
        self.__dict__["_SetInvalidDataIndicator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarDataElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarDataElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarDataElement = agcom.GUID(ICalculationToolScalarDataElement._uuid)
        vtable_offset_local = ICalculationToolScalarDataElement._vtable_offset - 1
        self.__dict__["_GetDataProvider"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetElementName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetGroup"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_GetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+12, agcom.BSTR, agcom.BSTR)
        self.__dict__["_SetWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDataElement, vtable_offset_local+15, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarDataElement.__dict__ and type(ICalculationToolScalarDataElement.__dict__[attrname]) == property:
            return ICalculationToolScalarDataElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarDataElement.")
    
    @property
    def DataProvider(self) -> str:
        """The name of the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataProvider"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ElementName(self) -> str:
        """The name of the data element within the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGroup"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IAnalysisWorkbenchInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def UseSamples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSamples"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseSamples.setter
    def UseSamples(self, useSamples:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useSamples) as arg_useSamples:
            agcls.evaluate_hresult(self.__dict__["_SetUseSamples"](arg_useSamples.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    def Set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_dataProvider.COM_val, arg_elementName.COM_val))

    def SetWithGroup(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(typeName) as arg_typeName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_SetWithGroup"](arg_dataProvider.COM_val, arg_typeName.COM_val, arg_elementName.COM_val))

    @property
    def InvalidDataIndicator(self) -> float:
        """Sets the value to display in a report or graph when the actual value is not a valid real number"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInvalidDataIndicator"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InvalidDataIndicator.setter
    def InvalidDataIndicator(self, invalidDataIndicator:float) -> None:
        with agmarshall.DOUBLE_arg(invalidDataIndicator) as arg_invalidDataIndicator:
            agcls.evaluate_hresult(self.__dict__["_SetInvalidDataIndicator"](arg_invalidDataIndicator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}", ICalculationToolScalarDataElement)
agcls.AgTypeNameMap["ICalculationToolScalarDataElement"] = ICalculationToolScalarDataElement

class ICalculationToolScalarDerivative(object):
    """Derivative of an input scalar calculation."""
    _uuid = "{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarDerivative = agcom.GUID(ICalculationToolScalarDerivative._uuid)
        vtable_offset_local = ICalculationToolScalarDerivative._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarDerivative.__dict__ and type(ICalculationToolScalarDerivative.__dict__[attrname]) == property:
            return ICalculationToolScalarDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarDerivative.")
    
    @property
    def Scalar(self) -> "ICalculationToolScalar":
        """The input scalar component used to compute the derivative."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalculationToolScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}", ICalculationToolScalarDerivative)
agcls.AgTypeNameMap["ICalculationToolScalarDerivative"] = ICalculationToolScalarDerivative

class ICalculationToolScalarDotProduct(object):
    """Dot product between two vectors."""
    _uuid = "{ffb69fa2-d123-413e-bb34-db750b7775ea}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarDotProduct from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarDotProduct = agcom.GUID(ICalculationToolScalarDotProduct._uuid)
        vtable_offset_local = ICalculationToolScalarDotProduct._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarDotProduct, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarDotProduct.__dict__ and type(ICalculationToolScalarDotProduct.__dict__[attrname]) == property:
            return ICalculationToolScalarDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarDotProduct.")
    
    @property
    def VectorA(self) -> "IVectorGeometryToolVector":
        """First vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVectorGeometryToolVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IVectorGeometryToolVector":
        """Second vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVectorGeometryToolVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'Angle', 'Distance', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ffb69fa2-d123-413e-bb34-db750b7775ea}", ICalculationToolScalarDotProduct)
agcls.AgTypeNameMap["ICalculationToolScalarDotProduct"] = ICalculationToolScalarDotProduct

class ICalculationToolScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""
    _uuid = "{81238610-6A1B-499A-8C43-12337F64BC42}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarElapsedTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarElapsedTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarElapsedTime = agcom.GUID(ICalculationToolScalarElapsedTime._uuid)
        vtable_offset_local = ICalculationToolScalarElapsedTime._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarElapsedTime, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarElapsedTime, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarElapsedTime.__dict__ and type(ICalculationToolScalarElapsedTime.__dict__[attrname]) == property:
            return ICalculationToolScalarElapsedTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarElapsedTime.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{81238610-6A1B-499A-8C43-12337F64BC42}", ICalculationToolScalarElapsedTime)
agcls.AgTypeNameMap["ICalculationToolScalarElapsedTime"] = ICalculationToolScalarElapsedTime

class ICalculationToolScalarFactory(object):
    """The factory creates scalar calculation components."""
    _uuid = "{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarAngle"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarConstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElement"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDerivative"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarElapsedTime"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFile"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarIntegral"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction2Var"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFromCustomScript"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDotProduct"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarFactory = agcom.GUID(ICalculationToolScalarFactory._uuid)
        vtable_offset_local = ICalculationToolScalarFactory._vtable_offset - 1
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarAngle"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarConstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElement"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDerivative"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarElapsedTime"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFile"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+11, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+12, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction2Var"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+15, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+16, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateCalcScalarFromCustomScript"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+17, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+18, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDotProduct"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+19, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorComponent"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFactory, vtable_offset_local+20, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarFactory.__dict__ and type(ICalculationToolScalarFactory.__dict__[attrname]) == property:
            return ICalculationToolScalarFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarFactory.")
    
    @property
    def AvailableCalcScalarPluginDisplayNames(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnCalcScalarType") -> "ICalculationToolScalar":
        """Creates and registers a scalar calculation using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnCalcScalarType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarAngle(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarAngle"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFixedAtTimeInstant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFixedAtTimeInstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarConstant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarConstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElement(self, name:str, description:str, dataProvider:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElement"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElementWithGroup(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(groupName) as arg_groupName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElementWithGroup"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_groupName.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDerivative(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDerivative"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarElapsedTime(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarElapsedTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFile(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create scalar calculation specified by external data file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFile"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarIntegral(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarIntegral"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction2Var(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction2Var"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorMagnitude(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorMagnitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarPluginFromDisplayName(self, name:str, description:str, displayName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarPluginFromDisplayName"](arg_name.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnCalcScalarType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateCalcScalarFromCustomScript(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFromCustomScript"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarSurfaceDistanceBetweenPoints(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDotProduct(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDotProduct"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorComponent(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorComponent"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}", ICalculationToolScalarFactory)
agcls.AgTypeNameMap["ICalculationToolScalarFactory"] = ICalculationToolScalarFactory

class ICalculationToolScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    _uuid = "{98BC97CE-DA0B-4783-BB98-A988CA16447A}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarFile = agcom.GUID(ICalculationToolScalarFile._uuid)
        vtable_offset_local = ICalculationToolScalarFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_SetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+8, agcom.INT)
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFile, vtable_offset_local+10, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarFile.__dict__ and type(ICalculationToolScalarFile.__dict__[attrname]) == property:
            return ICalculationToolScalarFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarFile.")
    
    @property
    def Filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "ITimeToolEventIntervalResult":
        """Computes the interval time span of the file."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FileInterpolationType(self) -> "AgECrdnFileInterpolatorType":
        """The interpolation method used with the data."""
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationType.setter
    def FileInterpolationType(self, fileInterpolationType:"AgECrdnFileInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType, fileInterpolationType) as arg_fileInterpolationType:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationType"](arg_fileInterpolationType.COM_val))

    @property
    def FileInterpolationOrder(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationOrder.setter
    def FileInterpolationOrder(self, fileInterpolationOrder:int) -> None:
        with agmarshall.INT_arg(fileInterpolationOrder) as arg_fileInterpolationOrder:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationOrder"](arg_fileInterpolationOrder.COM_val))

    @property
    def UseNativeFileInterpolationSettings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseNativeFileInterpolationSettings"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseNativeFileInterpolationSettings.setter
    def UseNativeFileInterpolationSettings(self, useNativeFileInterpolationSettings:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useNativeFileInterpolationSettings) as arg_useNativeFileInterpolationSettings:
            agcls.evaluate_hresult(self.__dict__["_SetUseNativeFileInterpolationSettings"](arg_useNativeFileInterpolationSettings.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{98BC97CE-DA0B-4783-BB98-A988CA16447A}", ICalculationToolScalarFile)
agcls.AgTypeNameMap["ICalculationToolScalarFile"] = ICalculationToolScalarFile

class ICalculationToolScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    _uuid = "{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarFixedAtTimeInstant = agcom.GUID(ICalculationToolScalarFixedAtTimeInstant._uuid)
        vtable_offset_local = ICalculationToolScalarFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarFixedAtTimeInstant.__dict__ and type(ICalculationToolScalarFixedAtTimeInstant.__dict__[attrname]) == property:
            return ICalculationToolScalarFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarFixedAtTimeInstant.")
    
    @property
    def InputScalar(self) -> "ICalculationToolScalar":
        """The input scalar component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalculationToolScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}", ICalculationToolScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["ICalculationToolScalarFixedAtTimeInstant"] = ICalculationToolScalarFixedAtTimeInstant

class ICalculationToolScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""
    _uuid = "{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_SetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputTime"] = _raise_uninitialized_error
        self.__dict__["_SetInputTime"] = _raise_uninitialized_error
        self.__dict__["_GetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetD"] = _raise_uninitialized_error
        self.__dict__["_SetD"] = _raise_uninitialized_error
        self.__dict__["_GetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_SetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_SetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarFunction = agcom.GUID(ICalculationToolScalarFunction._uuid)
        vtable_offset_local = ICalculationToolScalarFunction._vtable_offset - 1
        self.__dict__["_GetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetD"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetD"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+18, agcom.SAFEARRAY)
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+23, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+29, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction, vtable_offset_local+31, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarFunction.__dict__ and type(ICalculationToolScalarFunction.__dict__[attrname]) == property:
            return ICalculationToolScalarFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarFunction.")
    
    @property
    def UseScalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScalar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScalar.setter
    def UseScalar(self, useScalar:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScalar) as arg_useScalar:
            agcls.evaluate_hresult(self.__dict__["_SetUseScalar"](arg_useScalar.COM_val))

    @property
    def InputScalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalculationToolScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def InputTime(self) -> "ITimeToolEvent":
        """The input time instant (used if UseScalar is false)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputTime"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputTime.setter
    def InputTime(self, inputTime:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(inputTime, ITimeToolEvent) as arg_inputTime:
            agcls.evaluate_hresult(self.__dict__["_SetInputTime"](arg_inputTime.COM_val))

    @property
    def InputUnit(self) -> str:
        """The input time unit to interpret input time."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InputUnit.setter
    def InputUnit(self, inputUnit:str) -> None:
        with agmarshall.BSTR_arg(inputUnit) as arg_inputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetInputUnit"](arg_inputUnit.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def D(self) -> float:
        """The constant coefficient D."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetD"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @D.setter
    def D(self, d:float) -> None:
        with agmarshall.DOUBLE_arg(d) as arg_d:
            agcls.evaluate_hresult(self.__dict__["_SetD"](arg_d.COM_val))

    @property
    def Coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoefficients"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Coefficients.setter
    def Coefficients(self, coefficients:list) -> None:
        with agmarshall.SAFEARRAY_arg(coefficients) as arg_coefficients:
            agcls.evaluate_hresult(self.__dict__["_SetCoefficients"](arg_coefficients.COM_val))

    @property
    def SelectedFunction(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """Get the available function names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def InheritDimensionFromInput(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInheritDimensionFromInput"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InheritDimensionFromInput.setter
    def InheritDimensionFromInput(self, inheritDimensionFromInput:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inheritDimensionFromInput) as arg_inheritDimensionFromInput:
            agcls.evaluate_hresult(self.__dict__["_SetInheritDimensionFromInput"](arg_inheritDimensionFromInput.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def OutputUnit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}", ICalculationToolScalarFunction)
agcls.AgTypeNameMap["ICalculationToolScalarFunction"] = ICalculationToolScalarFunction

class ICalculationToolScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""
    _uuid = "{E56D021E-AD96-4ABE-857E-708CDCC4FF14}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetUnitX"] = _raise_uninitialized_error
        self.__dict__["_SetUnitX"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetUnitY"] = _raise_uninitialized_error
        self.__dict__["_SetUnitY"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarFunction2Var._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarFunction2Var from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarFunction2Var = agcom.GUID(ICalculationToolScalarFunction2Var._uuid)
        vtable_offset_local = ICalculationToolScalarFunction2Var._vtable_offset - 1
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+19, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+22, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarFunction2Var, vtable_offset_local+23, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarFunction2Var.__dict__ and type(ICalculationToolScalarFunction2Var.__dict__[attrname]) == property:
            return ICalculationToolScalarFunction2Var.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarFunction2Var.")
    
    @property
    def X(self) -> "ICalculationToolScalar":
        """The scalar argument X."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @X.setter
    def X(self, x:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(x, ICalculationToolScalar) as arg_x:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_x.COM_val))

    @property
    def UnitX(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitX.setter
    def UnitX(self, unitX:str) -> None:
        with agmarshall.BSTR_arg(unitX) as arg_unitX:
            agcls.evaluate_hresult(self.__dict__["_SetUnitX"](arg_unitX.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def Y(self) -> "ICalculationToolScalar":
        """The scalar argument Y."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Y.setter
    def Y(self, y:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(y, ICalculationToolScalar) as arg_y:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_y.COM_val))

    @property
    def UnitY(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitY.setter
    def UnitY(self, unitY:str) -> None:
        with agmarshall.BSTR_arg(unitY) as arg_unitY:
            agcls.evaluate_hresult(self.__dict__["_SetUnitY"](arg_unitY.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Specifies whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SelectedFunction(self) -> str:
        """The selected function."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def OutputUnit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E56D021E-AD96-4ABE-857E-708CDCC4FF14}", ICalculationToolScalarFunction2Var)
agcls.AgTypeNameMap["ICalculationToolScalarFunction2Var"] = ICalculationToolScalarFunction2Var

class ICalculationToolScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    _uuid = "{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_SetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_GetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_SetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetIntegral"] = _raise_uninitialized_error
        self.__dict__["_SetIntegral"] = _raise_uninitialized_error
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetOffsets"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarIntegral = agcom.GUID(ICalculationToolScalarIntegral._uuid)
        vtable_offset_local = ICalculationToolScalarIntegral._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+18, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+20, agcom.PVOID)
        self.__dict__["_GetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_SetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+22, agcom.PVOID)
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_SetOffsets"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarIntegral, vtable_offset_local+25, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarIntegral.__dict__ and type(ICalculationToolScalarIntegral.__dict__[attrname]) == property:
            return ICalculationToolScalarIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarIntegral.")
    
    @property
    def InputScalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalculationToolScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ComputeAsAverage(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputeAsAverage"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ComputeAsAverage.setter
    def ComputeAsAverage(self, computeAsAverage:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(computeAsAverage) as arg_computeAsAverage:
            agcls.evaluate_hresult(self.__dict__["_SetComputeAsAverage"](arg_computeAsAverage.COM_val))

    @property
    def IntegrationWindowType(self) -> "AgECrdnIntegrationWindowType":
        """The integration window, or accumulation, type."""
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegrationWindowType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntegrationWindowType.setter
    def IntegrationWindowType(self, integrationWindowType:"AgECrdnIntegrationWindowType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType, integrationWindowType) as arg_integrationWindowType:
            agcls.evaluate_hresult(self.__dict__["_SetIntegrationWindowType"](arg_integrationWindowType.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IAnalysisWorkbenchInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Integral(self) -> "IAnalysisWorkbenchIntegral":
        """The numerical integration method."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegral"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Integral.setter
    def Integral(self, integral:"IAnalysisWorkbenchIntegral") -> None:
        with agmarshall.AgInterface_in_arg(integral, IAnalysisWorkbenchIntegral) as arg_integral:
            agcls.evaluate_hresult(self.__dict__["_SetIntegral"](arg_integral.COM_val))

    @property
    def KeepConstantOutsideTimeLimits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKeepConstantOutsideTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @KeepConstantOutsideTimeLimits.setter
    def KeepConstantOutsideTimeLimits(self, keepConstantOutsideTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(keepConstantOutsideTimeLimits) as arg_keepConstantOutsideTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetKeepConstantOutsideTimeLimits"](arg_keepConstantOutsideTimeLimits.COM_val))

    def SetOffsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset, \
             agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetOffsets"](arg_startOffset.COM_val, arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}", ICalculationToolScalarIntegral)
agcls.AgTypeNameMap["ICalculationToolScalarIntegral"] = ICalculationToolScalarIntegral

class ICalculationToolScalarPlugin(object):
    """Use a scalar calculation plugin."""
    _uuid = "{1459313C-59BD-42FF-9F0D-AF4604F13D4C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarPlugin = agcom.GUID(ICalculationToolScalarPlugin._uuid)
        vtable_offset_local = ICalculationToolScalarPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarPlugin.__dict__ and type(ICalculationToolScalarPlugin.__dict__[attrname]) == property:
            return ICalculationToolScalarPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1459313C-59BD-42FF-9F0D-AF4604F13D4C}", ICalculationToolScalarPlugin)
agcls.AgTypeNameMap["ICalculationToolScalarPlugin"] = ICalculationToolScalarPlugin

class ICalculationToolScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    _uuid = "{DC5C0166-111F-4E8A-9650-012CE6A57911}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint1"] = _raise_uninitialized_error
        self.__dict__["_SetPoint1"] = _raise_uninitialized_error
        self.__dict__["_GetPoint2"] = _raise_uninitialized_error
        self.__dict__["_SetPoint2"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarSurfaceDistanceBetweenPoints._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarSurfaceDistanceBetweenPoints from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarSurfaceDistanceBetweenPoints = agcom.GUID(ICalculationToolScalarSurfaceDistanceBetweenPoints._uuid)
        vtable_offset_local = ICalculationToolScalarSurfaceDistanceBetweenPoints._vtable_offset - 1
        self.__dict__["_GetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarSurfaceDistanceBetweenPoints, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarSurfaceDistanceBetweenPoints.__dict__ and type(ICalculationToolScalarSurfaceDistanceBetweenPoints.__dict__[attrname]) == property:
            return ICalculationToolScalarSurfaceDistanceBetweenPoints.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarSurfaceDistanceBetweenPoints.")
    
    @property
    def Point1(self) -> "IVectorGeometryToolPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint1"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point1.setter
    def Point1(self, point1:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(point1, IVectorGeometryToolPoint) as arg_point1:
            agcls.evaluate_hresult(self.__dict__["_SetPoint1"](arg_point1.COM_val))

    @property
    def Point2(self) -> "IVectorGeometryToolPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point2.setter
    def Point2(self, point2:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(point2, IVectorGeometryToolPoint) as arg_point2:
            agcls.evaluate_hresult(self.__dict__["_SetPoint2"](arg_point2.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC5C0166-111F-4E8A-9650-012CE6A57911}", ICalculationToolScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["ICalculationToolScalarSurfaceDistanceBetweenPoints"] = ICalculationToolScalarSurfaceDistanceBetweenPoints

class ICalculationToolScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""
    _uuid = "{2adb8ac1-7836-45af-b7f1-77b13a9db586}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetComponent"] = _raise_uninitialized_error
        self.__dict__["_SetComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarVectorComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarVectorComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarVectorComponent = agcom.GUID(ICalculationToolScalarVectorComponent._uuid)
        vtable_offset_local = ICalculationToolScalarVectorComponent._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetComponent"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetComponent"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorComponent, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarVectorComponent.__dict__ and type(ICalculationToolScalarVectorComponent.__dict__[attrname]) == property:
            return ICalculationToolScalarVectorComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarVectorComponent.")
    
    @property
    def InputVector(self) -> "IVectorGeometryToolVector":
        """Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVectorGeometryToolVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxes":
        """Axes used to resolve the vector's components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))

    @property
    def Component(self) -> "AgECrdnVectorComponentType":
        """The component of the vector to return as the value of the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComponent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Component.setter
    def Component(self, component:"AgECrdnVectorComponentType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType, component) as arg_component:
            agcls.evaluate_hresult(self.__dict__["_SetComponent"](arg_component.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2adb8ac1-7836-45af-b7f1-77b13a9db586}", ICalculationToolScalarVectorComponent)
agcls.AgTypeNameMap["ICalculationToolScalarVectorComponent"] = ICalculationToolScalarVectorComponent

class ICalculationToolScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""
    _uuid = "{57FC76A1-A63F-4A25-A3A6-3953275A15E4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolScalarVectorMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolScalarVectorMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolScalarVectorMagnitude = agcom.GUID(ICalculationToolScalarVectorMagnitude._uuid)
        vtable_offset_local = ICalculationToolScalarVectorMagnitude._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorMagnitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolScalarVectorMagnitude, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolScalarVectorMagnitude.__dict__ and type(ICalculationToolScalarVectorMagnitude.__dict__[attrname]) == property:
            return ICalculationToolScalarVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolScalarVectorMagnitude.")
    
    @property
    def InputVector(self) -> "IVectorGeometryToolVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVectorGeometryToolVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{57FC76A1-A63F-4A25-A3A6-3953275A15E4}", ICalculationToolScalarVectorMagnitude)
agcls.AgTypeNameMap["ICalculationToolScalarVectorMagnitude"] = ICalculationToolScalarVectorMagnitude

class ICalculationToolCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    _uuid = "{8CA43B7E-6345-4F97-97B2-A4C4517739C8}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolCondition = agcom.GUID(ICalculationToolCondition._uuid)
        vtable_offset_local = ICalculationToolCondition._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolCondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolCondition, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolCondition, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolCondition.__dict__ and type(ICalculationToolCondition.__dict__[attrname]) == property:
            return ICalculationToolCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolCondition.")
    
    @property
    def Type(self) -> "AgECrdnConditionType":
        """Returns the type of condition."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICalculationToolEvaluateResult":
        """Returns result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICalculationToolEvaluateWithRateResult":
        """Returns result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8CA43B7E-6345-4F97-97B2-A4C4517739C8}", ICalculationToolCondition)
agcls.AgTypeNameMap["ICalculationToolCondition"] = ICalculationToolCondition

class ICalculationToolConditionCombined(object):
    """Defines a condition which combines multiple conditions."""
    _uuid = "{EB19E942-0C28-4AB9-B2C0-D31693564C99}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        self.__dict__["_AddCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionCombined = agcom.GUID(ICalculationToolConditionCombined._uuid)
        vtable_offset_local = ICalculationToolConditionCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+7, agcom.PVOID, agcom.INT)
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+8, agcom.INT)
        self.__dict__["_AddCondition"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionCombined, vtable_offset_local+9, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionCombined.__dict__ and type(ICalculationToolConditionCombined.__dict__[attrname]) == property:
            return ICalculationToolConditionCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnConditionCombinedOperationType":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnConditionCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Gets the number of conditions in the combined condition."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all conditions that are being combined."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def GetCondition(self, pos:int) -> "ICalculationToolCondition":
        """Get the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetCondition(self, ref:"ICalculationToolCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        with agmarshall.AgInterface_in_arg(ref, ICalculationToolCondition) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def RemoveCondition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))

    def AddCondition(self, ref:"ICalculationToolCondition") -> None:
        """Adds a condition at the end of the list."""
        with agmarshall.AgInterface_in_arg(ref, ICalculationToolCondition) as arg_ref:
            agcls.evaluate_hresult(self.__dict__["_AddCondition"](arg_ref.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB19E942-0C28-4AB9-B2C0-D31693564C99}", ICalculationToolConditionCombined)
agcls.AgTypeNameMap["ICalculationToolConditionCombined"] = ICalculationToolConditionCombined

class ICalculationToolConditionFactory(object):
    """The factory creates condition components."""
    _uuid = "{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionScalarBounds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionPointInVolume"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionFactory = agcom.GUID(ICalculationToolConditionFactory._uuid)
        vtable_offset_local = ICalculationToolConditionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionScalarBounds"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateConditionCombined"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionPointInVolume"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionFactory.__dict__ and type(ICalculationToolConditionFactory.__dict__[attrname]) == property:
            return ICalculationToolConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionType") -> "ICalculationToolCondition":
        """Creates and registers a condition using specified name, description and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionScalarBounds(self, name:str, description:str) -> "ICalculationToolCondition":
        """Creates a condition placing bounds on specified scalar."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionScalarBounds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateConditionCombined(self, name:str, description:str) -> "ICalculationToolCondition":
        """Creates a condition which combines multiple conditions."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionPointInVolume(self, name:str, description:str) -> "ICalculationToolCondition":
        """Creates a condition for point in volume."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionPointInVolume"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}", ICalculationToolConditionFactory)
agcls.AgTypeNameMap["ICalculationToolConditionFactory"] = ICalculationToolConditionFactory

class ICalculationToolConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    _uuid = "{3C354DF9-E914-4542-9E21-F70A637C4EA4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionPointInVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionPointInVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionPointInVolume = agcom.GUID(ICalculationToolConditionPointInVolume._uuid)
        vtable_offset_local = ICalculationToolConditionPointInVolume._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionPointInVolume, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionPointInVolume, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionPointInVolume, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionPointInVolume, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionPointInVolume.__dict__ and type(ICalculationToolConditionPointInVolume.__dict__[attrname]) == property:
            return ICalculationToolConditionPointInVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionPointInVolume.")
    
    @property
    def Point(self) -> "IVectorGeometryToolPoint":
        """Get the trajectory point from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def Constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, ISpatialAnalysisToolVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3C354DF9-E914-4542-9E21-F70A637C4EA4}", ICalculationToolConditionPointInVolume)
agcls.AgTypeNameMap["ICalculationToolConditionPointInVolume"] = ICalculationToolConditionPointInVolume

class ICalculationToolConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    _uuid = "{FE3FB52B-9784-4707-8266-28F1E13B79D1}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetUnitless"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionScalarBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionScalarBounds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionScalarBounds = agcom.GUID(ICalculationToolConditionScalarBounds._uuid)
        vtable_offset_local = ICalculationToolConditionScalarBounds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
        self.__dict__["_GetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_SetUnitless"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionScalarBounds, vtable_offset_local+14, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionScalarBounds.__dict__ and type(ICalculationToolConditionScalarBounds.__dict__[attrname]) == property:
            return ICalculationToolConditionScalarBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionScalarBounds.")
    
    @property
    def Scalar(self) -> "ICalculationToolScalar":
        """Get the scalar calculation from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalculationToolScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))

    def GetMinimumUnitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMinimumUnitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumUnitless"](arg_value.COM_val))

    def GetMaximumUnitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMaximumUnitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumUnitless"](arg_value.COM_val))

    def SetUnitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetUnitless"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FE3FB52B-9784-4707-8266-28F1E13B79D1}", ICalculationToolConditionScalarBounds)
agcls.AgTypeNameMap["ICalculationToolConditionScalarBounds"] = ICalculationToolConditionScalarBounds

class ICalculationToolConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    _uuid = "{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSet = agcom.GUID(ICalculationToolConditionSet._uuid)
        vtable_offset_local = ICalculationToolConditionSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSet, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSet, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSet.__dict__ and type(ICalculationToolConditionSet.__dict__[attrname]) == property:
            return ICalculationToolConditionSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSet.")
    
    @property
    def Type(self) -> "AgECrdnConditionSetType":
        """Returns the type of condition set."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICalculationToolConditionSetEvaluateResult":
        """Returns an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICalculationToolConditionSetEvaluateWithRateResult":
        """Returns an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}", ICalculationToolConditionSet)
agcls.AgTypeNameMap["ICalculationToolConditionSet"] = ICalculationToolConditionSet

class ICalculationToolConditionSetFactory(object):
    """The factory creates condition set components."""
    _uuid = "{698D592C-B264-426D-8577-AC7087E3EE44}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateScalarThresholds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSetFactory = agcom.GUID(ICalculationToolConditionSetFactory._uuid)
        vtable_offset_local = ICalculationToolConditionSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateScalarThresholds"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSetFactory.__dict__ and type(ICalculationToolConditionSetFactory.__dict__[attrname]) == property:
            return ICalculationToolConditionSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionSetType") -> "ICalculationToolConditionSet":
        """Creates and registers a condition set using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateScalarThresholds(self, name:str, description:str) -> "ICalculationToolConditionSet":
        """Create a scalar thresholds condition set."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateScalarThresholds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{698D592C-B264-426D-8577-AC7087E3EE44}", ICalculationToolConditionSetFactory)
agcls.AgTypeNameMap["ICalculationToolConditionSetFactory"] = ICalculationToolConditionSetFactory

class ICalculationToolConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    _uuid = "{57392078-7821-4910-B734-76B5C70CB6D9}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetThresholds"] = _raise_uninitialized_error
        self.__dict__["_GetThresholdLabels"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetThresholdsAndLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConditionSetScalarThresholds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConditionSetScalarThresholds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConditionSetScalarThresholds = agcom.GUID(ICalculationToolConditionSetScalarThresholds._uuid)
        vtable_offset_local = ICalculationToolConditionSetScalarThresholds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThresholds"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetThresholdLabels"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_SetThresholdsAndLabels"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConditionSetScalarThresholds, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConditionSetScalarThresholds.__dict__ and type(ICalculationToolConditionSetScalarThresholds.__dict__[attrname]) == property:
            return ICalculationToolConditionSetScalarThresholds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConditionSetScalarThresholds.")
    
    @property
    def Scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalculationToolScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ThresholdLabels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholdLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IncludeAboveHighestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeAboveHighestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeAboveHighestThreshold.setter
    def IncludeAboveHighestThreshold(self, includeAboveHighestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeAboveHighestThreshold) as arg_includeAboveHighestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeAboveHighestThreshold"](arg_includeAboveHighestThreshold.COM_val))

    @property
    def IncludeBelowLowestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBelowLowestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeBelowLowestThreshold.setter
    def IncludeBelowLowestThreshold(self, includeBelowLowestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeBelowLowestThreshold) as arg_includeBelowLowestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBelowLowestThreshold"](arg_includeBelowLowestThreshold.COM_val))

    def SetThresholdsAndLabels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        with agmarshall.SAFEARRAY_arg(thresholds) as arg_thresholds, \
             agmarshall.SAFEARRAY_arg(thresholdLabels) as arg_thresholdLabels:
            agcls.evaluate_hresult(self.__dict__["_SetThresholdsAndLabels"](byref(arg_thresholds.COM_val), byref(arg_thresholdLabels.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{57392078-7821-4910-B734-76B5C70CB6D9}", ICalculationToolConditionSetScalarThresholds)
agcls.AgTypeNameMap["ICalculationToolConditionSetScalarThresholds"] = ICalculationToolConditionSetScalarThresholds

class IAnalysisWorkbenchConverge(object):
    """Represents a base class for convergence definitions."""
    _uuid = "{28B17124-9BE6-4437-A7ED-0DDC24353430}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchConverge._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchConverge from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchConverge = agcom.GUID(IAnalysisWorkbenchConverge._uuid)
        vtable_offset_local = IAnalysisWorkbenchConverge._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchConverge.__dict__ and type(IAnalysisWorkbenchConverge.__dict__[attrname]) == property:
            return IAnalysisWorkbenchConverge.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchConverge.")
    

agcls.AgClassCatalog.add_catalog_entry("{28B17124-9BE6-4437-A7ED-0DDC24353430}", IAnalysisWorkbenchConverge)
agcls.AgTypeNameMap["IAnalysisWorkbenchConverge"] = IAnalysisWorkbenchConverge

class ICalculationToolConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    _uuid = "{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSense"] = _raise_uninitialized_error
        self.__dict__["_SetSense"] = _raise_uninitialized_error
        self.__dict__["_GetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolConvergeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolConvergeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolConvergeBasic = agcom.GUID(ICalculationToolConvergeBasic._uuid)
        vtable_offset_local = ICalculationToolConvergeBasic._vtable_offset - 1
        self.__dict__["_GetSense"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSense"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolConvergeBasic, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolConvergeBasic.__dict__ and type(ICalculationToolConvergeBasic.__dict__[attrname]) == property:
            return ICalculationToolConvergeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolConvergeBasic.")
    
    @property
    def Sense(self) -> "AgECrdnThreshConvergeSense":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Sense.setter
    def Sense(self, sense:"AgECrdnThreshConvergeSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense, sense) as arg_sense:
            agcls.evaluate_hresult(self.__dict__["_SetSense"](arg_sense.COM_val))

    @property
    def TimeTolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeTolerance.setter
    def TimeTolerance(self, timeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(timeTolerance) as arg_timeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTimeTolerance"](arg_timeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}", ICalculationToolConvergeBasic)
agcls.AgTypeNameMap["ICalculationToolConvergeBasic"] = ICalculationToolConvergeBasic

class IAnalysisWorkbenchDerivative(object):
    """Represents a base class for derivative definitions."""
    _uuid = "{737042BD-D873-4CF6-B5D5-6769849156FD}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchDerivative = agcom.GUID(IAnalysisWorkbenchDerivative._uuid)
        vtable_offset_local = IAnalysisWorkbenchDerivative._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchDerivative.__dict__ and type(IAnalysisWorkbenchDerivative.__dict__[attrname]) == property:
            return IAnalysisWorkbenchDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchDerivative.")
    

agcls.AgClassCatalog.add_catalog_entry("{737042BD-D873-4CF6-B5D5-6769849156FD}", IAnalysisWorkbenchDerivative)
agcls.AgTypeNameMap["IAnalysisWorkbenchDerivative"] = IAnalysisWorkbenchDerivative

class ICalculationToolDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    _uuid = "{CD450BBA-9F54-4F15-B067-C5A80C970FA9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolDerivativeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolDerivativeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolDerivativeBasic = agcom.GUID(ICalculationToolDerivativeBasic._uuid)
        vtable_offset_local = ICalculationToolDerivativeBasic._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolDerivativeBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolDerivativeBasic, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolDerivativeBasic.__dict__ and type(ICalculationToolDerivativeBasic.__dict__[attrname]) == property:
            return ICalculationToolDerivativeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolDerivativeBasic.")
    
    @property
    def TimeStep(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CD450BBA-9F54-4F15-B067-C5A80C970FA9}", ICalculationToolDerivativeBasic)
agcls.AgTypeNameMap["ICalculationToolDerivativeBasic"] = ICalculationToolDerivativeBasic

class ITimeToolEvent(object):
    """Defines an event (time instant)."""
    _uuid = "{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_GetNoonToday"] = _raise_uninitialized_error
        self.__dict__["_GetNoonTomorrow"] = _raise_uninitialized_error
        self.__dict__["_FindOccurrence"] = _raise_uninitialized_error
        self.__dict__["_OccursBefore"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEvent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEvent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEvent = agcom.GUID(ITimeToolEvent._uuid)
        vtable_offset_local = ITimeToolEvent._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonToday"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonTomorrow"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_FindOccurrence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_OccursBefore"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEvent, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEvent.__dict__ and type(ITimeToolEvent.__dict__[attrname]) == property:
            return ITimeToolEvent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEvent.")
    
    @property
    def Type(self) -> "AgECrdnEventType":
        """Return the type of time instant."""
        with agmarshall.AgEnum_arg(AgECrdnEventType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Today(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonToday(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonTomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindOccurrence(self) -> "ITimeToolEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindOccurrence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def OccursBefore(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_OccursBefore"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}", ITimeToolEvent)
agcls.AgTypeNameMap["ITimeToolEvent"] = ITimeToolEvent

class ITimeToolEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""
    _uuid = "{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArray from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArray = agcom.GUID(ITimeToolEventArray._uuid)
        vtable_offset_local = ITimeToolEventArray._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArray, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArray, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArray.__dict__ and type(ITimeToolEventArray.__dict__[attrname]) == property:
            return ITimeToolEventArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArray.")
    
    @property
    def Type(self) -> "AgECrdnEventArrayType":
        """Return the type of time array."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindTimes(self) -> "ITimeToolFindTimesResult":
        """Return computed array of times."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}", ITimeToolEventArray)
agcls.AgTypeNameMap["ITimeToolEventArray"] = ITimeToolEventArray

class ITimeToolEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    _uuid = "{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayConditionCrossings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayConditionCrossings from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayConditionCrossings = agcom.GUID(ITimeToolEventArrayConditionCrossings._uuid)
        vtable_offset_local = ITimeToolEventArrayConditionCrossings._vtable_offset - 1
        self.__dict__["_GetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayConditionCrossings, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayConditionCrossings.__dict__ and type(ITimeToolEventArrayConditionCrossings.__dict__[attrname]) == property:
            return ITimeToolEventArrayConditionCrossings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayConditionCrossings.")
    
    @property
    def SatisfactionCrossing(self) -> "AgECrdnSatisfactionCrossing":
        """The direction of interest for satisfaction crossing."""
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionCrossing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionCrossing.setter
    def SatisfactionCrossing(self, satisfactionCrossing:"AgECrdnSatisfactionCrossing") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing, satisfactionCrossing) as arg_satisfactionCrossing:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionCrossing"](arg_satisfactionCrossing.COM_val))

    @property
    def Condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICalculationToolCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICalculationToolCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}", ITimeToolEventArrayConditionCrossings)
agcls.AgTypeNameMap["ITimeToolEventArrayConditionCrossings"] = ITimeToolEventArrayConditionCrossings

class ITimeToolEventArrayExtrema(object):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{664C3048-BB87-4841-988A-0580F2976C0D}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_SetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayExtrema._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayExtrema from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayExtrema = agcom.GUID(ITimeToolEventArrayExtrema._uuid)
        vtable_offset_local = ITimeToolEventArrayExtrema._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayExtrema, vtable_offset_local+16, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayExtrema.__dict__ and type(ITimeToolEventArrayExtrema.__dict__[attrname]) == property:
            return ITimeToolEventArrayExtrema.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayExtrema.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def IsGlobal(self) -> bool:
        """Indicates whether to perform local or global search. The default is false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsGlobal"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsGlobal.setter
    def IsGlobal(self, isGlobal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isGlobal) as arg_isGlobal:
            agcls.evaluate_hresult(self.__dict__["_SetIsGlobal"](arg_isGlobal.COM_val))

    @property
    def Calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICalculationToolScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{664C3048-BB87-4841-988A-0580F2976C0D}", ITimeToolEventArrayExtrema)
agcls.AgTypeNameMap["ITimeToolEventArrayExtrema"] = ITimeToolEventArrayExtrema

class ITimeToolEventArrayFactory(object):
    """The factory creates event arrays."""
    _uuid = "{CE43C07E-4626-4CEA-A625-C42052111CDE}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayExtrema"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayStartStopTimes"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayConditionCrossings"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArraySignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayFactory = agcom.GUID(ITimeToolEventArrayFactory._uuid)
        vtable_offset_local = ITimeToolEventArrayFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayExtrema"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayStartStopTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayMerged"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFiltered"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFixedStep"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayConditionCrossings"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArraySignaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventArrayFixedTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayFactory.__dict__ and type(ITimeToolEventArrayFactory.__dict__[attrname]) == property:
            return ITimeToolEventArrayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventArrayType") -> "ITimeToolEventArray":
        """Create and register an event array using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventArrayType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayExtrema(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayExtrema"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayStartStopTimes(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayStartStopTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayMerged(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFiltered(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFixedStep(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedStep"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayConditionCrossings(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayConditionCrossings"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArraySignaled(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArraySignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventArrayType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventArrayFixedTimes(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using specified times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE43C07E-4626-4CEA-A625-C42052111CDE}", ITimeToolEventArrayFactory)
agcls.AgTypeNameMap["ITimeToolEventArrayFactory"] = ITimeToolEventArrayFactory

class ITimeToolEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""
    _uuid = "{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        self.__dict__["_SetFilterType"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_SetCount"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_GetFilterIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetFilterIntervalList"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayFiltered = agcom.GUID(ITimeToolEventArrayFiltered._uuid)
        vtable_offset_local = ITimeToolEventArrayFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetFilterType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFiltered, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayFiltered.__dict__ and type(ITimeToolEventArrayFiltered.__dict__[attrname]) == property:
            return ITimeToolEventArrayFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayFiltered.")
    
    @property
    def OriginalTimeArray(self) -> "ITimeToolEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"ITimeToolEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, ITimeToolEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def FilterType(self) -> "AgECrdnEventArrayFilterType":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FilterType.setter
    def FilterType(self, filterType:"AgECrdnEventArrayFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType, filterType) as arg_filterType:
            agcls.evaluate_hresult(self.__dict__["_SetFilterType"](arg_filterType.COM_val))

    @property
    def Count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Count.setter
    def Count(self, count:int) -> None:
        with agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_SetCount"](arg_count.COM_val))

    @property
    def Step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))

    @property
    def IncludeIntervalStopTimes(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalStopTimes"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalStopTimes.setter
    def IncludeIntervalStopTimes(self, includeIntervalStopTimes:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalStopTimes) as arg_includeIntervalStopTimes:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalStopTimes"](arg_includeIntervalStopTimes.COM_val))

    @property
    def FilterIntervalList(self) -> "ITimeToolEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @FilterIntervalList.setter
    def FilterIntervalList(self, filterIntervalList:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(filterIntervalList, ITimeToolEventIntervalList) as arg_filterIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetFilterIntervalList"](arg_filterIntervalList.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}", ITimeToolEventArrayFiltered)
agcls.AgTypeNameMap["ITimeToolEventArrayFiltered"] = ITimeToolEventArrayFiltered

class ITimeToolEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    _uuid = "{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayFixedStep = agcom.GUID(ITimeToolEventArrayFixedStep._uuid)
        vtable_offset_local = ITimeToolEventArrayFixedStep._vtable_offset - 1
        self.__dict__["_GetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedStep, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayFixedStep.__dict__ and type(ITimeToolEventArrayFixedStep.__dict__[attrname]) == property:
            return ITimeToolEventArrayFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayFixedStep.")
    
    @property
    def BoundingIntervalList(self) -> "ITimeToolEventIntervalList":
        """The bounding interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBoundingIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BoundingIntervalList.setter
    def BoundingIntervalList(self, boundingIntervalList:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(boundingIntervalList, ITimeToolEventIntervalList) as arg_boundingIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetBoundingIntervalList"](arg_boundingIntervalList.COM_val))

    @property
    def SamplingTimeStep(self) -> float:
        """The sampling time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SamplingTimeStep.setter
    def SamplingTimeStep(self, samplingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(samplingTimeStep) as arg_samplingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingTimeStep"](arg_samplingTimeStep.COM_val))

    @property
    def IncludeIntervalEdges(self) -> bool:
        """Specify whether to include interval edges."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalEdges"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalEdges.setter
    def IncludeIntervalEdges(self, includeIntervalEdges:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalEdges) as arg_includeIntervalEdges:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalEdges"](arg_includeIntervalEdges.COM_val))

    @property
    def ReferenceType(self) -> "AgECrdnSampledReferenceTime":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, referenceType:"AgECrdnSampledReferenceTime") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime, referenceType) as arg_referenceType:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceType"](arg_referenceType.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}", ITimeToolEventArrayFixedStep)
agcls.AgTypeNameMap["ITimeToolEventArrayFixedStep"] = ITimeToolEventArrayFixedStep

class ITimeToolEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""
    _uuid = "{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetArrayTimes"] = _raise_uninitialized_error
        self.__dict__["_SetArrayTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayFixedTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayFixedTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayFixedTimes = agcom.GUID(ITimeToolEventArrayFixedTimes._uuid)
        vtable_offset_local = ITimeToolEventArrayFixedTimes._vtable_offset - 1
        self.__dict__["_GetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedTimes, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayFixedTimes, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayFixedTimes.__dict__ and type(ITimeToolEventArrayFixedTimes.__dict__[attrname]) == property:
            return ITimeToolEventArrayFixedTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayFixedTimes.")
    
    @property
    def ArrayTimes(self) -> list:
        """The array of times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetArrayTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetArrayTimes(self, times:list) -> None:
        """Sets array of times."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times:
            agcls.evaluate_hresult(self.__dict__["_SetArrayTimes"](byref(arg_times.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}", ITimeToolEventArrayFixedTimes)
agcls.AgTypeNameMap["ITimeToolEventArrayFixedTimes"] = ITimeToolEventArrayFixedTimes

class ITimeToolEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    _uuid = "{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_GetTimeArrayB"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayMerged = agcom.GUID(ITimeToolEventArrayMerged._uuid)
        vtable_offset_local = ITimeToolEventArrayMerged._vtable_offset - 1
        self.__dict__["_GetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayMerged, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayMerged, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayMerged, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayMerged.__dict__ and type(ITimeToolEventArrayMerged.__dict__[attrname]) == property:
            return ITimeToolEventArrayMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayMerged.")
    
    @property
    def TimeArrayA(self) -> "ITimeToolEventArray":
        """The first time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayA.setter
    def TimeArrayA(self, timeArrayA:"ITimeToolEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayA, ITimeToolEventArray) as arg_timeArrayA:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayA"](arg_timeArrayA.COM_val))

    @property
    def TimeArrayB(self) -> "ITimeToolEventArray":
        """The second time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayB.setter
    def TimeArrayB(self, timeArrayB:"ITimeToolEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayB, ITimeToolEventArray) as arg_timeArrayB:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayB"](arg_timeArrayB.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}", ITimeToolEventArrayMerged)
agcls.AgTypeNameMap["ITimeToolEventArrayMerged"] = ITimeToolEventArrayMerged

class ITimeToolEventArraySignaled(object):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    _uuid = "{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArraySignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArraySignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArraySignaled = agcom.GUID(ITimeToolEventArraySignaled._uuid)
        vtable_offset_local = ITimeToolEventArraySignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArraySignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArraySignaled.__dict__ and type(ITimeToolEventArraySignaled.__dict__[attrname]) == property:
            return ITimeToolEventArraySignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArraySignaled.")
    
    @property
    def OriginalTimeArray(self) -> "ITimeToolEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"ITimeToolEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, ITimeToolEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IVectorGeometryToolPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IVectorGeometryToolPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAnalysisWorkbenchSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}", ITimeToolEventArraySignaled)
agcls.AgTypeNameMap["ITimeToolEventArraySignaled"] = ITimeToolEventArraySignaled

class ITimeToolEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    _uuid = "{1AB79442-7711-4342-B944-81C51D14FBE4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_SetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventArrayStartStopTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventArrayStartStopTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventArrayStartStopTimes = agcom.GUID(ITimeToolEventArrayStartStopTimes._uuid)
        vtable_offset_local = ITimeToolEventArrayStartStopTimes._vtable_offset - 1
        self.__dict__["_GetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayStartStopTimes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayStartStopTimes, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayStartStopTimes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventArrayStartStopTimes, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventArrayStartStopTimes.__dict__ and type(ITimeToolEventArrayStartStopTimes.__dict__[attrname]) == property:
            return ITimeToolEventArrayStartStopTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventArrayStartStopTimes.")
    
    @property
    def StartStopOption(self) -> "AgECrdnStartStopOption":
        """The edge type. At least one of the two edge types must be selected."""
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartStopOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartStopOption.setter
    def StartStopOption(self, startStopOption:"AgECrdnStartStopOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption, startStopOption) as arg_startStopOption:
            agcls.evaluate_hresult(self.__dict__["_SetStartStopOption"](arg_startStopOption.COM_val))

    @property
    def ReferenceIntervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ITimeToolEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1AB79442-7711-4342-B944-81C51D14FBE4}", ITimeToolEventArrayStartStopTimes)
agcls.AgTypeNameMap["ITimeToolEventArrayStartStopTimes"] = ITimeToolEventArrayStartStopTimes

class ITimeToolEventEpoch(object):
    """Event set at specified date/time."""
    _uuid = "{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventEpoch = agcom.GUID(ITimeToolEventEpoch._uuid)
        vtable_offset_local = ITimeToolEventEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventEpoch, vtable_offset_local+2, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventEpoch.__dict__ and type(ITimeToolEventEpoch.__dict__[attrname]) == property:
            return ITimeToolEventEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}", ITimeToolEventEpoch)
agcls.AgTypeNameMap["ITimeToolEventEpoch"] = ITimeToolEventEpoch

class ITimeToolEventExtremum(object):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{C588FDD4-2008-4C33-AA63-1C59565AE4F3}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventExtremum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventExtremum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventExtremum = agcom.GUID(ITimeToolEventExtremum._uuid)
        vtable_offset_local = ITimeToolEventExtremum._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventExtremum, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventExtremum.__dict__ and type(ITimeToolEventExtremum.__dict__[attrname]) == property:
            return ITimeToolEventExtremum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventExtremum.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def Calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICalculationToolScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C588FDD4-2008-4C33-AA63-1C59565AE4F3}", ITimeToolEventExtremum)
agcls.AgTypeNameMap["ITimeToolEventExtremum"] = ITimeToolEventExtremum

class ITimeToolEventFactory(object):
    """The factory creates events."""
    _uuid = "{803DD343-F271-47D9-8D71-2092DD2A3387}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventEpoch"] = _raise_uninitialized_error
        self.__dict__["_CreateEventExtremum"] = _raise_uninitialized_error
        self.__dict__["_CreateEventStartStopTime"] = _raise_uninitialized_error
        self.__dict__["_CreateEventSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromTime"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromEvent"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventFactory = agcom.GUID(ITimeToolEventFactory._uuid)
        vtable_offset_local = ITimeToolEventFactory._vtable_offset - 1
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventExtremum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventStartStopTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventSignaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+9, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromEvent"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventFactory, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventFactory.__dict__ and type(ITimeToolEventFactory.__dict__[attrname]) == property:
            return ITimeToolEventFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventFactory.")
    
    @property
    def Today(self) -> "ITimeToolEvent":
        """Returns Today time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "ITimeToolEvent":
        """Returns Tomorrow time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnEventType") -> "ITimeToolEvent":
        """Creates and registers an event using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventEpoch(self, name:str, description:str) -> "ITimeToolEvent":
        """Creates an event set at a specified date/time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventEpoch"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventExtremum(self, name:str, description:str) -> "ITimeToolEvent":
        """Creates an event that determines the time of global minimum or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventExtremum"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventStartStopTime(self, name:str, description:str) -> "ITimeToolEvent":
        """Creates an event that is either the start or stop time selected from a reference interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventStartStopTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventSignaled(self, name:str, description:str) -> "ITimeToolEvent":
        """Creates an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventTimeOffset(self, name:str, description:str) -> "ITimeToolEvent":
        """Creates an event at fixed offset from specified reference event."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromTime(self, epoch:typing.Any) -> "ITimeToolEventSmartEpoch":
        """Creates a smart epoch from STK epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromTime"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromEvent(self, refEvent:"ITimeToolEvent") -> "ITimeToolEventSmartEpoch":
        """Creates a smart epoch from an event."""
        with agmarshall.AgInterface_in_arg(refEvent, ITimeToolEvent) as arg_refEvent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromEvent"](arg_refEvent.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{803DD343-F271-47D9-8D71-2092DD2A3387}", ITimeToolEventFactory)
agcls.AgTypeNameMap["ITimeToolEventFactory"] = ITimeToolEventFactory

class ITimeToolEventInterval(object):
    """A single time interval."""
    _uuid = "{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStartDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStopDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStart"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStop"] = _raise_uninitialized_error
        self.__dict__["_FindInterval"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventInterval = agcom.GUID(ITimeToolEventInterval._uuid)
        vtable_offset_local = ITimeToolEventInterval._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabelStartDescription"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStopDescription"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStop"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_FindInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventInterval, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventInterval.__dict__ and type(ITimeToolEventInterval.__dict__[attrname]) == property:
            return ITimeToolEventInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventInterval.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalType":
        """Return the type of interval."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStartDescription(self) -> str:
        """The start description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStartDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStopDescription(self) -> str:
        """The stop description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStopDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStart(self) -> str:
        """A label associated with the interval start."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStop(self) -> str:
        """A label associated with the interval stop."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInterval(self) -> "ITimeToolEventIntervalResult":
        """Return computed interval if it exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}", ITimeToolEventInterval)
agcls.AgTypeNameMap["ITimeToolEventInterval"] = ITimeToolEventInterval

class ITimeToolEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    _uuid = "{18236EC1-B691-4FFD-995B-FB4896BAFD71}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStopTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStopTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalBetweenTimeInstants._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalBetweenTimeInstants from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalBetweenTimeInstants = agcom.GUID(ITimeToolEventIntervalBetweenTimeInstants._uuid)
        vtable_offset_local = ITimeToolEventIntervalBetweenTimeInstants._vtable_offset - 1
        self.__dict__["_GetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalBetweenTimeInstants, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalBetweenTimeInstants, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalBetweenTimeInstants, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalBetweenTimeInstants, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalBetweenTimeInstants.__dict__ and type(ITimeToolEventIntervalBetweenTimeInstants.__dict__[attrname]) == property:
            return ITimeToolEventIntervalBetweenTimeInstants.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalBetweenTimeInstants.")
    
    @property
    def StartTimeInstant(self) -> "ITimeToolEvent":
        """The start time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StartTimeInstant.setter
    def StartTimeInstant(self, startTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(startTimeInstant, ITimeToolEvent) as arg_startTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeInstant"](arg_startTimeInstant.COM_val))

    @property
    def StopTimeInstant(self) -> "ITimeToolEvent":
        """The stop time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StopTimeInstant.setter
    def StopTimeInstant(self, stopTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(stopTimeInstant, ITimeToolEvent) as arg_stopTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStopTimeInstant"](arg_stopTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18236EC1-B691-4FFD-995B-FB4896BAFD71}", ITimeToolEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["ITimeToolEventIntervalBetweenTimeInstants"] = ITimeToolEventIntervalBetweenTimeInstants

class ITimeToolEventIntervalCollection(object):
    """A collection of related interval lists."""
    _uuid = "{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_FindIntervalCollection"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollection = agcom.GUID(ITimeToolEventIntervalCollection._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollection._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollection, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervalCollection"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollection, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollection.__dict__ and type(ITimeToolEventIntervalCollection.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollection.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalCollectionType":
        """Return the type of collection of interval lists."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervalCollection(self) -> "ITimeToolIntervalsVectorResult":
        """Return computed collection of interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> "ITimeToolEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}", ITimeToolEventIntervalCollection)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollection"] = ITimeToolEventIntervalCollection

class ITimeToolEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{0253FA16-73AA-4F0A-9904-0789EC873ECB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_SetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionCondition = agcom.GUID(ITimeToolEventIntervalCollectionCondition._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionCondition._vtable_offset - 1
        self.__dict__["_GetConditionSet"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetConditionSet"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionCondition.__dict__ and type(ITimeToolEventIntervalCollectionCondition.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionCondition.")
    
    @property
    def ConditionSet(self) -> "ICalculationToolConditionSet":
        """Get/set the condition set object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ConditionSet.setter
    def ConditionSet(self, conditionSet:"ICalculationToolConditionSet") -> None:
        with agmarshall.AgInterface_in_arg(conditionSet, ICalculationToolConditionSet) as arg_conditionSet:
            agcls.evaluate_hresult(self.__dict__["_SetConditionSet"](arg_conditionSet.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0253FA16-73AA-4F0A-9904-0789EC873ECB}", ITimeToolEventIntervalCollectionCondition)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionCondition"] = ITimeToolEventIntervalCollectionCondition

class ITimeToolEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""
    _uuid = "{15E2D2CF-61F9-4468-A5E1-770149F6B08C}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionFactory = agcom.GUID(ITimeToolEventIntervalCollectionFactory._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionLighting"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionFactory, vtable_offset_local+4, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionFactory.__dict__ and type(ITimeToolEventIntervalCollectionFactory.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalCollectionType") -> "ITimeToolEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionLighting(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionSignaled(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalCollectionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalCollectionSatisfaction(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15E2D2CF-61F9-4468-A5E1-770149F6B08C}", ITimeToolEventIntervalCollectionFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionFactory"] = ITimeToolEventIntervalCollectionFactory

class ITimeToolEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    _uuid = "{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionLighting = agcom.GUID(ITimeToolEventIntervalCollectionLighting._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionLighting._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionLighting, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionLighting.__dict__ and type(ITimeToolEventIntervalCollectionLighting.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionLighting.")
    
    @property
    def Location(self) -> "IVectorGeometryToolPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IVectorGeometryToolPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}", ITimeToolEventIntervalCollectionLighting)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionLighting"] = ITimeToolEventIntervalCollectionLighting

class ITimeToolEventIntervalCollectionSignaled(object):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    _uuid = "{AE464683-EEEC-46CF-8886-91F7A30B7859}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalCollectionSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalCollectionSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalCollectionSignaled = agcom.GUID(ITimeToolEventIntervalCollectionSignaled._uuid)
        vtable_offset_local = ITimeToolEventIntervalCollectionSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalCollectionSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalCollectionSignaled.__dict__ and type(ITimeToolEventIntervalCollectionSignaled.__dict__[attrname]) == property:
            return ITimeToolEventIntervalCollectionSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalCollectionSignaled.")
    
    @property
    def OriginalCollection(self) -> "ITimeToolEventIntervalCollection":
        """The original interval list collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalCollection.setter
    def OriginalCollection(self, originalCollection:"ITimeToolEventIntervalCollection") -> None:
        with agmarshall.AgInterface_in_arg(originalCollection, ITimeToolEventIntervalCollection) as arg_originalCollection:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalCollection"](arg_originalCollection.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IVectorGeometryToolPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IVectorGeometryToolPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAnalysisWorkbenchSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AE464683-EEEC-46CF-8886-91F7A30B7859}", ITimeToolEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionSignaled"] = ITimeToolEventIntervalCollectionSignaled

class ITimeToolEventIntervalFactory(object):
    """The factory creates event intervals."""
    _uuid = "{F87C00CA-725C-425C-941E-6987709D788F}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixed"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixedDuration"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFromIntervalList"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalFactory = agcom.GUID(ITimeToolEventIntervalFactory._uuid)
        vtable_offset_local = ITimeToolEventIntervalFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixed"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixedDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFromIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalScaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalSignaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalFactory.__dict__ and type(ITimeToolEventIntervalFactory.__dict__[attrname]) == property:
            return ITimeToolEventIntervalFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalType") -> "ITimeToolEventInterval":
        """Create and register an interval using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixed(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixedDuration(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixedDuration"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalBetweenTimeInstants(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval using specified start and stop time instants."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalBetweenTimeInstants"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFromIntervalList(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFromIntervalList"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalScaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalSignaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalTimeOffset(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F87C00CA-725C-425C-941E-6987709D788F}", ITimeToolEventIntervalFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalFactory"] = ITimeToolEventIntervalFactory

class ITimeToolEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    _uuid = "{2DBC4523-FDD0-413B-B933-9F74B9B17BED}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTime"] = _raise_uninitialized_error
        self.__dict__["_GetStopTime"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalFixed = agcom.GUID(ITimeToolEventIntervalFixed._uuid)
        vtable_offset_local = ITimeToolEventIntervalFixed._vtable_offset - 1
        self.__dict__["_GetStartTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixed, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStopTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixed, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixed, vtable_offset_local+3, agcom.VARIANT, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalFixed.__dict__ and type(ITimeToolEventIntervalFixed.__dict__[attrname]) == property:
            return ITimeToolEventIntervalFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalFixed.")
    
    @property
    def StartTime(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def StopTime(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetInterval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch, \
             agmarshall.VARIANT_arg(stopEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_startEpoch.COM_val, arg_stopEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2DBC4523-FDD0-413B-B933-9F74B9B17BED}", ITimeToolEventIntervalFixed)
agcls.AgTypeNameMap["ITimeToolEventIntervalFixed"] = ITimeToolEventIntervalFixed

class ITimeToolEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    _uuid = "{2A20830B-D576-4DF1-9C15-51EB59AEC23F}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalFixedDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalFixedDuration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalFixedDuration = agcom.GUID(ITimeToolEventIntervalFixedDuration._uuid)
        vtable_offset_local = ITimeToolEventIntervalFixedDuration._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFixedDuration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalFixedDuration.__dict__ and type(ITimeToolEventIntervalFixedDuration.__dict__[attrname]) == property:
            return ITimeToolEventIntervalFixedDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalFixedDuration.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def StartOffset(self) -> float:
        """The start time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """The stop time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A20830B-D576-4DF1-9C15-51EB59AEC23F}", ITimeToolEventIntervalFixedDuration)
agcls.AgTypeNameMap["ITimeToolEventIntervalFixedDuration"] = ITimeToolEventIntervalFixedDuration

class ITimeToolEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""
    _uuid = "{DCF8AA30-67A3-4856-956D-C4952BF3818E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalNumber"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalNumber"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalFromIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalFromIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalFromIntervalList = agcom.GUID(ITimeToolEventIntervalFromIntervalList._uuid)
        vtable_offset_local = ITimeToolEventIntervalFromIntervalList._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalFromIntervalList, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalFromIntervalList.__dict__ and type(ITimeToolEventIntervalFromIntervalList.__dict__[attrname]) == property:
            return ITimeToolEventIntervalFromIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalFromIntervalList.")
    
    @property
    def ReferenceIntervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ITimeToolEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def IntervalSelection(self) -> "AgECrdnIntervalSelection":
        """The method used to select an interval from the reference interval list."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalSelection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalSelection.setter
    def IntervalSelection(self, intervalSelection:"AgECrdnIntervalSelection") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection, intervalSelection) as arg_intervalSelection:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalSelection"](arg_intervalSelection.COM_val))

    @property
    def IntervalNumber(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd"""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalNumber"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalNumber.setter
    def IntervalNumber(self, intervalNumber:int) -> None:
        with agmarshall.INT_arg(intervalNumber) as arg_intervalNumber:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalNumber"](arg_intervalNumber.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DCF8AA30-67A3-4856-956D-C4952BF3818E}", ITimeToolEventIntervalFromIntervalList)
agcls.AgTypeNameMap["ITimeToolEventIntervalFromIntervalList"] = ITimeToolEventIntervalFromIntervalList

class ITimeToolEventIntervalList(object):
    """An ordered list of time intervals."""
    _uuid = "{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDescriptions"] = _raise_uninitialized_error
        self.__dict__["_FindIntervals"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalList = agcom.GUID(ITimeToolEventIntervalList._uuid)
        vtable_offset_local = ITimeToolEventIntervalList._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalList, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalList, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDescriptions"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalList, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalList, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalList, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalList.__dict__ and type(ITimeToolEventIntervalList.__dict__[attrname]) == property:
            return ITimeToolEventIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalList.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalListType":
        """Return the type of interval list."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescriptions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervals(self) -> "ITimeToolIntervalListResult":
        """Return computed interval list that can be empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}", ITimeToolEventIntervalList)
agcls.AgTypeNameMap["ITimeToolEventIntervalList"] = ITimeToolEventIntervalList

class ITimeToolEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{D073568A-7398-45C2-998A-CD2EC12F06E0}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListCondition = agcom.GUID(ITimeToolEventIntervalListCondition._uuid)
        vtable_offset_local = ITimeToolEventIntervalListCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListCondition.__dict__ and type(ITimeToolEventIntervalListCondition.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListCondition.")
    
    @property
    def Condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICalculationToolCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICalculationToolCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D073568A-7398-45C2-998A-CD2EC12F06E0}", ITimeToolEventIntervalListCondition)
agcls.AgTypeNameMap["ITimeToolEventIntervalListCondition"] = ITimeToolEventIntervalListCondition

class ITimeToolEventIntervalListFactory(object):
    """The factory creates event interval lists."""
    _uuid = "{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFile"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFixed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListFactory = agcom.GUID(ITimeToolEventIntervalListFactory._uuid)
        vtable_offset_local = ITimeToolEventIntervalListFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListMerged"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFiltered"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListScaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListSignaled"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalListFile"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFixed"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListFactory.__dict__ and type(ITimeToolEventIntervalListFactory.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalListType") -> "ITimeToolEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListMerged(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFiltered(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListCondition(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListScaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListSignaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListTimeOffset(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalListType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalListFile(self, name:str, description:str, filePath:str) -> "ITimeToolEventIntervalList":
        """Create an interval list based on specified interval file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filePath) as arg_filePath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFile"](arg_name.COM_val, arg_description.COM_val, arg_filePath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFixed(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}", ITimeToolEventIntervalListFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFactory"] = ITimeToolEventIntervalListFactory

class ITimeToolEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    _uuid = "{A17588F4-C944-44F8-B8D8-275B13D27E3A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListFile = agcom.GUID(ITimeToolEventIntervalListFile._uuid)
        vtable_offset_local = ITimeToolEventIntervalListFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFile, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListFile.__dict__ and type(ITimeToolEventIntervalListFile.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the interval list file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "ITimeToolEventIntervalResult":
        """Computes the interval list file span."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A17588F4-C944-44F8-B8D8-275B13D27E3A}", ITimeToolEventIntervalListFile)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFile"] = ITimeToolEventIntervalListFile

class ITimeToolEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    _uuid = "{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetFilterFactory"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListFiltered = agcom.GUID(ITimeToolEventIntervalListFiltered._uuid)
        vtable_offset_local = ITimeToolEventIntervalListFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterFactory"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFiltered, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFiltered, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFiltered, vtable_offset_local+5, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListFiltered.__dict__ and type(ITimeToolEventIntervalListFiltered.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListFiltered.")
    
    @property
    def OriginalIntervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ITimeToolEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def FilterFactory(self) -> "ITimeToolPruneFilterFactory":
        """Get the prune filter factory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filter(self) -> "ITimeToolPruneFilter":
        """The pruning filter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"ITimeToolPruneFilter") -> None:
        with agmarshall.AgInterface_in_arg(filter, ITimeToolPruneFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}", ITimeToolEventIntervalListFiltered)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFiltered"] = ITimeToolEventIntervalListFiltered

class ITimeToolEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    _uuid = "{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListFixed = agcom.GUID(ITimeToolEventIntervalListFixed._uuid)
        vtable_offset_local = ITimeToolEventIntervalListFixed._vtable_offset - 1
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFixed, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListFixed, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListFixed.__dict__ and type(ITimeToolEventIntervalListFixed.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListFixed.")
    
    def GetIntervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetIntervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg(intervals) as arg_intervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervals"](byref(arg_intervals.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}", ITimeToolEventIntervalListFixed)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFixed"] = ITimeToolEventIntervalListFixed

class ITimeToolEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    _uuid = "{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervalListOrIntervalA"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalListOrIntervalB"] = _raise_uninitialized_error
        self.__dict__["_GetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListB"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalB"] = _raise_uninitialized_error
        self.__dict__["_AddInterval"] = _raise_uninitialized_error
        self.__dict__["_AddIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponent"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponentSize"] = _raise_uninitialized_error
        self.__dict__["_RemoveTimeComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListMerged = agcom.GUID(ITimeToolEventIntervalListMerged._uuid)
        vtable_offset_local = ITimeToolEventIntervalListMerged._vtable_offset - 1
        self.__dict__["_GetIntervalListOrIntervalA"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetIntervalListOrIntervalB"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetIntervalListA"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_SetIntervalA"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_SetIntervalListB"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_SetIntervalB"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_AddInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_AddIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+11, agcom.PVOID, agcom.INT)
        self.__dict__["_SetIntervalList"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+12, agcom.PVOID, agcom.INT)
        self.__dict__["_GetTimeComponent"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+13, agcom.INT, POINTER(agcom.BSTR))
        self.__dict__["_GetTimeComponentSize"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+14, POINTER(agcom.INT))
        self.__dict__["_RemoveTimeComponent"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListMerged, vtable_offset_local+15, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListMerged.__dict__ and type(ITimeToolEventIntervalListMerged.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListMerged.")
    
    @property
    def IntervalListOrIntervalA(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IntervalListOrIntervalB(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MergeOperation(self) -> "AgECrdnEventListMergeOperation":
        """The merge operation."""
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMergeOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MergeOperation.setter
    def MergeOperation(self, mergeOperation:"AgECrdnEventListMergeOperation") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation, mergeOperation) as arg_mergeOperation:
            agcls.evaluate_hresult(self.__dict__["_SetMergeOperation"](arg_mergeOperation.COM_val))

    def SetIntervalListA(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Sets the interval list A."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListA"](arg_refIntervals.COM_val))

    def SetIntervalA(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Sets the interval A."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalA"](arg_refIntervals.COM_val))

    def SetIntervalListB(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Sets the interval list B."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListB"](arg_refIntervals.COM_val))

    def SetIntervalB(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Sets the interval B."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalB"](arg_refIntervals.COM_val))

    def AddInterval(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Add interval."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddInterval"](arg_refIntervals.COM_val))

    def AddIntervalList(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Add interval list."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddIntervalList"](arg_refIntervals.COM_val))

    def SetInterval(self, refIntervals:"ITimeToolEventInterval", pos:int) -> None:
        """Sets the interval at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventInterval) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def SetIntervalList(self, refIntervals:"ITimeToolEventIntervalList", pos:int) -> None:
        """Sets the interval list at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, ITimeToolEventIntervalList) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalList"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def GetTimeComponent(self, pos:int) -> str:
        """Gets time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponent"](arg_pos.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetTimeComponentSize(self) -> int:
        """Gets time component list size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponentSize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def RemoveTimeComponent(self, pos:int) -> None:
        """Remove time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveTimeComponent"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}", ITimeToolEventIntervalListMerged)
agcls.AgTypeNameMap["ITimeToolEventIntervalListMerged"] = ITimeToolEventIntervalListMerged

class ITimeToolEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    _uuid = "{7DDA88F8-A738-464E-9CDC-613E107F57D0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListScaled = agcom.GUID(ITimeToolEventIntervalListScaled._uuid)
        vtable_offset_local = ITimeToolEventIntervalListScaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListScaled.__dict__ and type(ITimeToolEventIntervalListScaled.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListScaled.")
    
    @property
    def OriginalIntervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ITimeToolEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7DDA88F8-A738-464E-9CDC-613E107F57D0}", ITimeToolEventIntervalListScaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalListScaled"] = ITimeToolEventIntervalListScaled

class ITimeToolEventIntervalListSignaled(object):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    _uuid = "{C40EA24E-E258-4B0E-8A0F-89424F93F837}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListSignaled = agcom.GUID(ITimeToolEventIntervalListSignaled._uuid)
        vtable_offset_local = ITimeToolEventIntervalListSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListSignaled.__dict__ and type(ITimeToolEventIntervalListSignaled.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListSignaled.")
    
    @property
    def OriginalIntervals(self) -> "ITimeToolEventIntervalList":
        """The original time interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ITimeToolEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IVectorGeometryToolPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IVectorGeometryToolPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAnalysisWorkbenchSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C40EA24E-E258-4B0E-8A0F-89424F93F837}", ITimeToolEventIntervalListSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalListSignaled"] = ITimeToolEventIntervalListSignaled

class ITimeToolEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    _uuid = "{EEA120D3-8E9F-419B-B11C-A034007EB2D0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalListTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalListTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalListTimeOffset = agcom.GUID(ITimeToolEventIntervalListTimeOffset._uuid)
        vtable_offset_local = ITimeToolEventIntervalListTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalListTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalListTimeOffset.__dict__ and type(ITimeToolEventIntervalListTimeOffset.__dict__[attrname]) == property:
            return ITimeToolEventIntervalListTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalListTimeOffset.")
    
    @property
    def ReferenceIntervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ITimeToolEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEA120D3-8E9F-419B-B11C-A034007EB2D0}", ITimeToolEventIntervalListTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventIntervalListTimeOffset"] = ITimeToolEventIntervalListTimeOffset

class ITimeToolEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    _uuid = "{FA9613FB-7341-4785-AD95-51CFA2B605BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalScaled = agcom.GUID(ITimeToolEventIntervalScaled._uuid)
        vtable_offset_local = ITimeToolEventIntervalScaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalScaled.__dict__ and type(ITimeToolEventIntervalScaled.__dict__[attrname]) == property:
            return ITimeToolEventIntervalScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalScaled.")
    
    @property
    def OriginalInterval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"ITimeToolEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, ITimeToolEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FA9613FB-7341-4785-AD95-51CFA2B605BC}", ITimeToolEventIntervalScaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalScaled"] = ITimeToolEventIntervalScaled

class ITimeToolEventIntervalSignaled(object):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    _uuid = "{51B9DE87-9220-40B2-AA57-01F7B17BD945}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalSignaled = agcom.GUID(ITimeToolEventIntervalSignaled._uuid)
        vtable_offset_local = ITimeToolEventIntervalSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalSignaled.__dict__ and type(ITimeToolEventIntervalSignaled.__dict__[attrname]) == property:
            return ITimeToolEventIntervalSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalSignaled.")
    
    @property
    def OriginalInterval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"ITimeToolEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, ITimeToolEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IVectorGeometryToolPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IVectorGeometryToolPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAnalysisWorkbenchSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{51B9DE87-9220-40B2-AA57-01F7B17BD945}", ITimeToolEventIntervalSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalSignaled"] = ITimeToolEventIntervalSignaled

class ITimeToolEventIntervalSmartInterval(object):
    """A smart interval."""
    _uuid = "{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_SetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_FindStartTime"] = _raise_uninitialized_error
        self.__dict__["_FindStopTime"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopEpochs"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpochAndDuration"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeAndDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalSmartInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalSmartInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalSmartInterval = agcom.GUID(ITimeToolEventIntervalSmartInterval._uuid)
        vtable_offset_local = ITimeToolEventIntervalSmartInterval._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_SetImplicitInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_FindStartTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_FindStopTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_SetExplicitInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+13, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartAndStopEpochs"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+14, agcom.PVOID, agcom.PVOID)
        self.__dict__["_SetStartAndStopTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+15, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartEpochAndDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+16, agcom.PVOID, agcom.BSTR)
        self.__dict__["_SetStartTimeAndDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalSmartInterval, vtable_offset_local+17, agcom.VARIANT, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalSmartInterval.__dict__ and type(ITimeToolEventIntervalSmartInterval.__dict__[attrname]) == property:
            return ITimeToolEventIntervalSmartInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalSmartInterval.")
    
    @property
    def ReferenceInterval(self) -> "ITimeToolEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DurationAsString(self) -> str:
        """The duration of the interval"""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationAsString"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationAsString.setter
    def DurationAsString(self, durationAsString:str) -> None:
        with agmarshall.BSTR_arg(durationAsString) as arg_durationAsString:
            agcls.evaluate_hresult(self.__dict__["_SetDurationAsString"](arg_durationAsString.COM_val))

    @property
    def State(self) -> "AgECrdnSmartIntervalState":
        """A state of the smart interval."""
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartIntervalState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetImplicitInterval(self, eventInterval:"ITimeToolEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventInterval, ITimeToolEventInterval) as arg_eventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitInterval"](arg_eventInterval.COM_val))

    def FindStartTime(self) -> typing.Any:
        """Finds a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindStopTime(self) -> typing.Any:
        """Finds a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetStartEpoch(self) -> "ITimeToolEventSmartEpoch":
        """Returns a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStartEpoch(self, startEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Sets a start of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(startEpoch, ITimeToolEventSmartEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    def GetStopEpoch(self) -> "ITimeToolEventSmartEpoch":
        """Returns a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStopEpoch(self, stopEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Sets a stop of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(stopEpoch, ITimeToolEventSmartEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStopEpoch"](arg_stopEpoch.COM_val))

    def SetExplicitInterval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(start) as arg_start, \
             agmarshall.VARIANT_arg(stop) as arg_stop:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitInterval"](arg_start.COM_val, arg_stop.COM_val))

    def SetStartAndStopEpochs(self, refStartEpoch:"ITimeToolEventSmartEpoch", refStopEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Sets the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, ITimeToolEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.AgInterface_in_arg(refStopEpoch, ITimeToolEventSmartEpoch) as arg_refStopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopEpochs"](arg_refStartEpoch.COM_val, arg_refStopEpoch.COM_val))

    def SetStartAndStopTimes(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Sets the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(startTime) as arg_startTime, \
             agmarshall.VARIANT_arg(stopTime) as arg_stopTime:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopTimes"](arg_startTime.COM_val, arg_stopTime.COM_val))

    def SetStartEpochAndDuration(self, refStartEpoch:"ITimeToolEventSmartEpoch", durationStr:str) -> None:
        """Sets the interval's start epoch and the interval's duration."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, ITimeToolEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpochAndDuration"](arg_refStartEpoch.COM_val, arg_durationStr.COM_val))

    def SetStartTimeAndDuration(self, epoch:typing.Any, durationStr:str) -> None:
        """Sets the interval's start time and the interval's duration."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeAndDuration"](arg_epoch.COM_val, arg_durationStr.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}", ITimeToolEventIntervalSmartInterval)
agcls.AgTypeNameMap["ITimeToolEventIntervalSmartInterval"] = ITimeToolEventIntervalSmartInterval

class ITimeToolEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    _uuid = "{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventIntervalTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventIntervalTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventIntervalTimeOffset = agcom.GUID(ITimeToolEventIntervalTimeOffset._uuid)
        vtable_offset_local = ITimeToolEventIntervalTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventIntervalTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventIntervalTimeOffset.__dict__ and type(ITimeToolEventIntervalTimeOffset.__dict__[attrname]) == property:
            return ITimeToolEventIntervalTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventIntervalTimeOffset.")
    
    @property
    def ReferenceInterval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceInterval.setter
    def ReferenceInterval(self, referenceInterval:"ITimeToolEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceInterval, ITimeToolEventInterval) as arg_referenceInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceInterval"](arg_referenceInterval.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}", ITimeToolEventIntervalTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventIntervalTimeOffset"] = ITimeToolEventIntervalTimeOffset

class ITimeToolEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    _uuid = "{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventSignaled = agcom.GUID(ITimeToolEventSignaled._uuid)
        vtable_offset_local = ITimeToolEventSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventSignaled.__dict__ and type(ITimeToolEventSignaled.__dict__[attrname]) == property:
            return ITimeToolEventSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventSignaled.")
    
    @property
    def OriginalTimeInstant(self) -> "ITimeToolEvent":
        """The original time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeInstant.setter
    def OriginalTimeInstant(self, originalTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeInstant, ITimeToolEvent) as arg_originalTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeInstant"](arg_originalTimeInstant.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IVectorGeometryToolPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IVectorGeometryToolPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAnalysisWorkbenchSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}", ITimeToolEventSignaled)
agcls.AgTypeNameMap["ITimeToolEventSignaled"] = ITimeToolEventSignaled

class ITimeToolEventSmartEpoch(object):
    """A smart epoch."""
    _uuid = "{4C5542F5-5B94-498B-90BC-CC7CB7C86629}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEvent"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitTime"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventSmartEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventSmartEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventSmartEpoch = agcom.GUID(ITimeToolEventSmartEpoch._uuid)
        vtable_offset_local = ITimeToolEventSmartEpoch._vtable_offset - 1
        self.__dict__["_GetTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetReferenceEvent"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetExplicitTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_SetImplicitTime"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventSmartEpoch, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventSmartEpoch.__dict__ and type(ITimeToolEventSmartEpoch.__dict__[attrname]) == property:
            return ITimeToolEventSmartEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventSmartEpoch.")
    
    @property
    def TimeInstant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeInstant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ReferenceEvent(self) -> "ITimeToolEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEvent"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def State(self) -> "AgECrdnSmartEpochState":
        """State of the event."""
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartEpochState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetExplicitTime(self, epoch:typing.Any) -> None:
        """Sets explicit time instant and the smart epoch's state to Explicit."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitTime"](arg_epoch.COM_val))

    def SetImplicitTime(self, eventEpoch:"ITimeToolEvent") -> None:
        """Sets the reference event and the smart epoch's state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventEpoch, ITimeToolEvent) as arg_eventEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitTime"](arg_eventEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4C5542F5-5B94-498B-90BC-CC7CB7C86629}", ITimeToolEventSmartEpoch)
agcls.AgTypeNameMap["ITimeToolEventSmartEpoch"] = ITimeToolEventSmartEpoch

class ITimeToolEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""
    _uuid = "{EB96850C-18E7-4269-8D35-67FB7E55BD59}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseStart"] = _raise_uninitialized_error
        self.__dict__["_SetUseStart"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEventInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEventInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventStartStopTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventStartStopTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventStartStopTime = agcom.GUID(ITimeToolEventStartStopTime._uuid)
        vtable_offset_local = ITimeToolEventStartStopTime._vtable_offset - 1
        self.__dict__["_GetUseStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventStartStopTime, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventStartStopTime, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventStartStopTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventStartStopTime, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventStartStopTime.__dict__ and type(ITimeToolEventStartStopTime.__dict__[attrname]) == property:
            return ITimeToolEventStartStopTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventStartStopTime.")
    
    @property
    def UseStart(self) -> bool:
        """Indicates whether to use start (true) or stop (false)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseStart.setter
    def UseStart(self, useStart:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useStart) as arg_useStart:
            agcls.evaluate_hresult(self.__dict__["_SetUseStart"](arg_useStart.COM_val))

    @property
    def ReferenceEventInterval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEventInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceEventInterval.setter
    def ReferenceEventInterval(self, referenceEventInterval:"ITimeToolEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceEventInterval, ITimeToolEventInterval) as arg_referenceEventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEventInterval"](arg_referenceEventInterval.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB96850C-18E7-4269-8D35-67FB7E55BD59}", ITimeToolEventStartStopTime)
agcls.AgTypeNameMap["ITimeToolEventStartStopTime"] = ITimeToolEventStartStopTime

class ITimeToolEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""
    _uuid = "{EB95E24E-6BDF-434C-A278-BF64475E4EB5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset2"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset2"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolEventTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolEventTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolEventTimeOffset = agcom.GUID(ITimeToolEventTimeOffset._uuid)
        vtable_offset_local = ITimeToolEventTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_ITimeToolEventTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolEventTimeOffset.__dict__ and type(ITimeToolEventTimeOffset.__dict__[attrname]) == property:
            return ITimeToolEventTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolEventTimeOffset.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def TimeOffset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in ``TimeUnit`` dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset2"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset2.setter
    def TimeOffset2(self, timeOffset2:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset2) as arg_timeOffset2:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset2"](arg_timeOffset2.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB95E24E-6BDF-434C-A278-BF64475E4EB5}", ITimeToolEventTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventTimeOffset"] = ITimeToolEventTimeOffset

class ITimeToolFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""
    _uuid = "{032A1F18-16B1-48B3-BB59-AFE83A834880}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolFirstIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolFirstIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolFirstIntervalsFilter = agcom.GUID(ITimeToolFirstIntervalsFilter._uuid)
        vtable_offset_local = ITimeToolFirstIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFirstIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolFirstIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolFirstIntervalsFilter.__dict__ and type(ITimeToolFirstIntervalsFilter.__dict__[attrname]) == property:
            return ITimeToolFirstIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolFirstIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{032A1F18-16B1-48B3-BB59-AFE83A834880}", ITimeToolFirstIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolFirstIntervalsFilter"] = ITimeToolFirstIntervalsFilter

class ITimeToolGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    _uuid = "{97B393F6-5E70-4D67-80C1-F85080D818F3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetGapDuration"] = _raise_uninitialized_error
        self.__dict__["_SetGapDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolGapsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolGapsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolGapsFilter = agcom.GUID(ITimeToolGapsFilter._uuid)
        vtable_offset_local = ITimeToolGapsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolGapsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolGapsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetGapDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolGapsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGapDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolGapsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolGapsFilter.__dict__ and type(ITimeToolGapsFilter.__dict__[attrname]) == property:
            return ITimeToolGapsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolGapsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def GapDuration(self) -> float:
        """Duration of the gap."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGapDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GapDuration.setter
    def GapDuration(self, gapDuration:float) -> None:
        with agmarshall.DOUBLE_arg(gapDuration) as arg_gapDuration:
            agcls.evaluate_hresult(self.__dict__["_SetGapDuration"](arg_gapDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{97B393F6-5E70-4D67-80C1-F85080D818F3}", ITimeToolGapsFilter)
agcls.AgTypeNameMap["ITimeToolGapsFilter"] = ITimeToolGapsFilter

class IAnalysisWorkbenchIntegral(object):
    """Represents a base class for integral definitions."""
    _uuid = "{61D34977-CC2E-43C1-9103-692FF9B3DEF0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchIntegral = agcom.GUID(IAnalysisWorkbenchIntegral._uuid)
        vtable_offset_local = IAnalysisWorkbenchIntegral._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchIntegral.__dict__ and type(IAnalysisWorkbenchIntegral.__dict__[attrname]) == property:
            return IAnalysisWorkbenchIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchIntegral.")
    

agcls.AgClassCatalog.add_catalog_entry("{61D34977-CC2E-43C1-9103-692FF9B3DEF0}", IAnalysisWorkbenchIntegral)
agcls.AgTypeNameMap["IAnalysisWorkbenchIntegral"] = IAnalysisWorkbenchIntegral

class ICalculationToolIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""
    _uuid = "{19DEEA25-F655-487B-86FF-429B55093F77}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolIntegralBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolIntegralBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolIntegralBasic = agcom.GUID(ICalculationToolIntegralBasic._uuid)
        vtable_offset_local = ICalculationToolIntegralBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolIntegralBasic, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolIntegralBasic.__dict__ and type(ICalculationToolIntegralBasic.__dict__[attrname]) == property:
            return ICalculationToolIntegralBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolIntegralBasic.")
    
    @property
    def Type(self) -> "AgECrdnIntegralType":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        with agmarshall.AgEnum_arg(AgECrdnIntegralType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnIntegralType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegralType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Tolerance.setter
    def Tolerance(self, tolerance:float) -> None:
        with agmarshall.DOUBLE_arg(tolerance) as arg_tolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_tolerance.COM_val))

    @property
    def MaximumIterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumIterations"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumIterations.setter
    def MaximumIterations(self, maximumIterations:int) -> None:
        with agmarshall.INT_arg(maximumIterations) as arg_maximumIterations:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumIterations"](arg_maximumIterations.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{19DEEA25-F655-487B-86FF-429B55093F77}", ICalculationToolIntegralBasic)
agcls.AgTypeNameMap["ICalculationToolIntegralBasic"] = ICalculationToolIntegralBasic

class IAnalysisWorkbenchInterp(object):
    """Represents a base class for interpolation definitions."""
    _uuid = "{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchInterp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchInterp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchInterp = agcom.GUID(IAnalysisWorkbenchInterp._uuid)
        vtable_offset_local = IAnalysisWorkbenchInterp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchInterp.__dict__ and type(IAnalysisWorkbenchInterp.__dict__[attrname]) == property:
            return IAnalysisWorkbenchInterp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchInterp.")
    

agcls.AgClassCatalog.add_catalog_entry("{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}", IAnalysisWorkbenchInterp)
agcls.AgTypeNameMap["IAnalysisWorkbenchInterp"] = IAnalysisWorkbenchInterp

class ICalculationToolInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    _uuid = "{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOrder"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolInterpBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolInterpBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolInterpBasic = agcom.GUID(ICalculationToolInterpBasic._uuid)
        vtable_offset_local = ICalculationToolInterpBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolInterpBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolInterpBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetOrder"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolInterpBasic, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_SetOrder"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolInterpBasic, vtable_offset_local+4, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolInterpBasic.__dict__ and type(ICalculationToolInterpBasic.__dict__[attrname]) == property:
            return ICalculationToolInterpBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolInterpBasic.")
    
    @property
    def Type(self) -> "AgECrdnInterpolatorType":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Order.setter
    def Order(self, order:int) -> None:
        with agmarshall.INT_arg(order) as arg_order:
            agcls.evaluate_hresult(self.__dict__["_SetOrder"](arg_order.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}", ICalculationToolInterpBasic)
agcls.AgTypeNameMap["ICalculationToolInterpBasic"] = ICalculationToolInterpBasic

class ITimeToolIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""
    _uuid = "{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolIntervalsFilter = agcom.GUID(ITimeToolIntervalsFilter._uuid)
        vtable_offset_local = ITimeToolIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolIntervalsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolIntervalsFilter.__dict__ and type(ITimeToolIntervalsFilter.__dict__[attrname]) == property:
            return ITimeToolIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolIntervalsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """The interval duration."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}", ITimeToolIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolIntervalsFilter"] = ITimeToolIntervalsFilter

class ITimeToolLastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""
    _uuid = "{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolLastIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolLastIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolLastIntervalsFilter = agcom.GUID(ITimeToolLastIntervalsFilter._uuid)
        vtable_offset_local = ITimeToolLastIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLastIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLastIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolLastIntervalsFilter.__dict__ and type(ITimeToolLastIntervalsFilter.__dict__[attrname]) == property:
            return ITimeToolLastIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolLastIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}", ITimeToolLastIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolLastIntervalsFilter"] = ITimeToolLastIntervalsFilter

class ICalculationToolParameterSet(object):
    """Parameter set contains various sets of scalar computations."""
    _uuid = "{285664E8-604B-4C0A-9ED0-5EE27CA1539D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDimensions"] = _raise_uninitialized_error
        self.__dict__["_GetScalarNames"] = _raise_uninitialized_error
        self.__dict__["_Calculate"] = _raise_uninitialized_error
        self.__dict__["_CalculateWithDerivative"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSet = agcom.GUID(ICalculationToolParameterSet._uuid)
        vtable_offset_local = ICalculationToolParameterSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDimensions"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetScalarNames"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Calculate"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CalculateWithDerivative"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSet, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSet.__dict__ and type(ICalculationToolParameterSet.__dict__[attrname]) == property:
            return ICalculationToolParameterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSet.")
    
    @property
    def Type(self) -> "AgECrdnParameterSetType":
        """Get the type of parameter set."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScalarNames(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Calculate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CalculateWithDerivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CalculateWithDerivative"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{285664E8-604B-4C0A-9ED0-5EE27CA1539D}", ICalculationToolParameterSet)
agcls.AgTypeNameMap["ICalculationToolParameterSet"] = ICalculationToolParameterSet

class ICalculationToolParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    _uuid = "{8B7DCF32-3CA4-4794-8468-81A3627B4043}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetAttitude = agcom.GUID(ICalculationToolParameterSetAttitude._uuid)
        vtable_offset_local = ICalculationToolParameterSetAttitude._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetAttitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetAttitude, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetAttitude, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetAttitude, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetAttitude.__dict__ and type(ICalculationToolParameterSetAttitude.__dict__[attrname]) == property:
            return ICalculationToolParameterSetAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetAttitude.")
    
    @property
    def Axes(self) -> "IVectorGeometryToolAxes":
        """Get the axes for which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Axes.setter
    def Axes(self, axes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B7DCF32-3CA4-4794-8468-81A3627B4043}", ICalculationToolParameterSetAttitude)
agcls.AgTypeNameMap["ICalculationToolParameterSetAttitude"] = ICalculationToolParameterSetAttitude

class ICalculationToolParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""
    _uuid = "{4D20E85F-1DEA-4963-9114-6B0407E53C5E}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetAttitude"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetGroundTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetOrbit"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetVector"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetFactory = agcom.GUID(ICalculationToolParameterSetFactory._uuid)
        vtable_offset_local = ICalculationToolParameterSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetAttitude"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetGroundTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetOrbit"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetFactory, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetFactory.__dict__ and type(ICalculationToolParameterSetFactory.__dict__[attrname]) == property:
            return ICalculationToolParameterSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnParameterSetType") -> "ICalculationToolParameterSet":
        """Creates and registers a parameter set using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnParameterSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetAttitude(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Creates a parameter set defined by identifying one set of axes in reference to another."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetAttitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetGroundTrajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Creates a parameter set defined by identifying location in reference central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetGroundTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetTrajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Creates a parameter set defined by identifying location in reference coordinate system."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetOrbit(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Creates a parameter set defined by identifying orbiting point and its central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetOrbit"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetVector(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Creates a parameter set defined by identifying vector in reference axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnParameterSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4D20E85F-1DEA-4963-9114-6B0407E53C5E}", ICalculationToolParameterSetFactory)
agcls.AgTypeNameMap["ICalculationToolParameterSetFactory"] = ICalculationToolParameterSetFactory

class ICalculationToolParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    _uuid = "{53ABEB95-F846-4574-BA87-C76220FDC19F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetGroundTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetGroundTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetGroundTrajectory = agcom.GUID(ICalculationToolParameterSetGroundTrajectory._uuid)
        vtable_offset_local = ICalculationToolParameterSetGroundTrajectory._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroundTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroundTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroundTrajectory, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetGroundTrajectory, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetGroundTrajectory.__dict__ and type(ICalculationToolParameterSetGroundTrajectory.__dict__[attrname]) == property:
            return ICalculationToolParameterSetGroundTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetGroundTrajectory.")
    
    @property
    def Location(self) -> "IVectorGeometryToolPoint":
        """Get the point for which ground trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IVectorGeometryToolPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{53ABEB95-F846-4574-BA87-C76220FDC19F}", ICalculationToolParameterSetGroundTrajectory)
agcls.AgTypeNameMap["ICalculationToolParameterSetGroundTrajectory"] = ICalculationToolParameterSetGroundTrajectory

class ICalculationToolParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    _uuid = "{141AEAB7-C017-4044-BE2C-EFE4AD724022}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyInertial"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetOrbit from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetOrbit = agcom.GUID(ICalculationToolParameterSetOrbit._uuid)
        vtable_offset_local = ICalculationToolParameterSetOrbit._vtable_offset - 1
        self.__dict__["_GetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetOrbit, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetOrbit.__dict__ and type(ICalculationToolParameterSetOrbit.__dict__[attrname]) == property:
            return ICalculationToolParameterSetOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetOrbit.")
    
    @property
    def OrbitingPoint(self) -> "IVectorGeometryToolPoint":
        """Get the point for which orbital parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitingPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OrbitingPoint.setter
    def OrbitingPoint(self, orbitingPoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(orbitingPoint, IVectorGeometryToolPoint) as arg_orbitingPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitingPoint"](arg_orbitingPoint.COM_val))

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def GravitationalParameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GravitationalParameter.setter
    def GravitationalParameter(self, gravitationalParameter:float) -> None:
        with agmarshall.DOUBLE_arg(gravitationalParameter) as arg_gravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetGravitationalParameter"](arg_gravitationalParameter.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def UseCentralBodyGravitationalParameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyGravitationalParameter.setter
    def UseCentralBodyGravitationalParameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyGravitationalParameter) as arg_useCentralBodyGravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyGravitationalParameter"](arg_useCentralBodyGravitationalParameter.COM_val))

    @property
    def UseCentralBodyInertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyInertial"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyInertial.setter
    def UseCentralBodyInertial(self, useCentralBodyInertial:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyInertial) as arg_useCentralBodyInertial:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyInertial"](arg_useCentralBodyInertial.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{141AEAB7-C017-4044-BE2C-EFE4AD724022}", ICalculationToolParameterSetOrbit)
agcls.AgTypeNameMap["ICalculationToolParameterSetOrbit"] = ICalculationToolParameterSetOrbit

class ICalculationToolParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    _uuid = "{0FE9C601-61BB-4579-B91F-B1123A19AFB4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetTrajectory = agcom.GUID(ICalculationToolParameterSetTrajectory._uuid)
        vtable_offset_local = ICalculationToolParameterSetTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetTrajectory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetTrajectory, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetTrajectory.__dict__ and type(ICalculationToolParameterSetTrajectory.__dict__[attrname]) == property:
            return ICalculationToolParameterSetTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetTrajectory.")
    
    @property
    def Point(self) -> "IVectorGeometryToolPoint":
        """Get the point for which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0FE9C601-61BB-4579-B91F-B1123A19AFB4}", ICalculationToolParameterSetTrajectory)
agcls.AgTypeNameMap["ICalculationToolParameterSetTrajectory"] = ICalculationToolParameterSetTrajectory

class ICalculationToolParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    _uuid = "{5B99EEC1-21BD-48B5-96A0-0230894532F1}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolParameterSetVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolParameterSetVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolParameterSetVector = agcom.GUID(ICalculationToolParameterSetVector._uuid)
        vtable_offset_local = ICalculationToolParameterSetVector._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolParameterSetVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolParameterSetVector.__dict__ and type(ICalculationToolParameterSetVector.__dict__[attrname]) == property:
            return ICalculationToolParameterSetVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolParameterSetVector.")
    
    @property
    def Vector(self) -> "IVectorGeometryToolVector":
        """Get the vector for which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Vector.setter
    def Vector(self, vector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vector, IVectorGeometryToolVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5B99EEC1-21BD-48B5-96A0-0230894532F1}", ICalculationToolParameterSetVector)
agcls.AgTypeNameMap["ICalculationToolParameterSetVector"] = ICalculationToolParameterSetVector

class ITimeToolPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""
    _uuid = "{89E95CD7-CDB2-4B17-9E47-DE17F551F873}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolPruneFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolPruneFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolPruneFilter = agcom.GUID(ITimeToolPruneFilter._uuid)
        vtable_offset_local = ITimeToolPruneFilter._vtable_offset - 1
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPruneFilter, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolPruneFilter.__dict__ and type(ITimeToolPruneFilter.__dict__[attrname]) == property:
            return ITimeToolPruneFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolPruneFilter.")
    
    @property
    def FilterType(self) -> "AgECrdnPruneFilter":
        """Returns a type of the filter."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{89E95CD7-CDB2-4B17-9E47-DE17F551F873}", ITimeToolPruneFilter)
agcls.AgTypeNameMap["ITimeToolPruneFilter"] = ITimeToolPruneFilter

class ITimeToolPruneFilterFactory(object):
    """The factory creates pruning filters."""
    _uuid = "{77E7099E-9B41-45FA-B50F-F8DE5964FABD}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolPruneFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolPruneFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolPruneFilterFactory = agcom.GUID(ITimeToolPruneFilterFactory._uuid)
        vtable_offset_local = ITimeToolPruneFilterFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPruneFilterFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolPruneFilterFactory.__dict__ and type(ITimeToolPruneFilterFactory.__dict__[attrname]) == property:
            return ITimeToolPruneFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolPruneFilterFactory.")
    
    def Create(self, eFilter:"AgECrdnPruneFilter") -> "ITimeToolPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter, eFilter) as arg_eFilter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_eFilter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{77E7099E-9B41-45FA-B50F-F8DE5964FABD}", ITimeToolPruneFilterFactory)
agcls.AgTypeNameMap["ITimeToolPruneFilterFactory"] = ITimeToolPruneFilterFactory

class ITimeToolRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    _uuid = "{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolRelativeSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolRelativeSatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolRelativeSatisfactionConditionFilter = agcom.GUID(ITimeToolRelativeSatisfactionConditionFilter._uuid)
        vtable_offset_local = ITimeToolRelativeSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolRelativeSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolRelativeSatisfactionConditionFilter.__dict__ and type(ITimeToolRelativeSatisfactionConditionFilter.__dict__[attrname]) == property:
            return ITimeToolRelativeSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolRelativeSatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICalculationToolCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICalculationToolCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICalculationToolCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def RelativeIntervalDuration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIntervalDuration.setter
    def RelativeIntervalDuration(self, relativeIntervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIntervalDuration) as arg_relativeIntervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIntervalDuration"](arg_relativeIntervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}", ITimeToolRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["ITimeToolRelativeSatisfactionConditionFilter"] = ITimeToolRelativeSatisfactionConditionFilter

class IAnalysisWorkbenchSampling(object):
    """Base sampling interface."""
    _uuid = "{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchSampling._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchSampling from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchSampling = agcom.GUID(IAnalysisWorkbenchSampling._uuid)
        vtable_offset_local = IAnalysisWorkbenchSampling._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchSampling.__dict__ and type(IAnalysisWorkbenchSampling.__dict__[attrname]) == property:
            return IAnalysisWorkbenchSampling.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchSampling.")
    

agcls.AgClassCatalog.add_catalog_entry("{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}", IAnalysisWorkbenchSampling)
agcls.AgTypeNameMap["IAnalysisWorkbenchSampling"] = IAnalysisWorkbenchSampling

class ICalculationToolSamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    _uuid = "{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_GetMethodFactory"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingBasic = agcom.GUID(ICalculationToolSamplingBasic._uuid)
        vtable_offset_local = ICalculationToolSamplingBasic._vtable_offset - 1
        self.__dict__["_GetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingBasic, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingBasic, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetMethodFactory"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingBasic.__dict__ and type(ICalculationToolSamplingBasic.__dict__[attrname]) == property:
            return ICalculationToolSamplingBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingBasic.")
    
    @property
    def SamplingMethod(self) -> "ICalculationToolSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SamplingMethod.setter
    def SamplingMethod(self, samplingMethod:"ICalculationToolSamplingMethod") -> None:
        with agmarshall.AgInterface_in_arg(samplingMethod, ICalculationToolSamplingMethod) as arg_samplingMethod:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingMethod"](arg_samplingMethod.COM_val))

    @property
    def MethodFactory(self) -> "ICalculationToolSamplingMethodFactory":
        """Creates sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}", ICalculationToolSamplingBasic)
agcls.AgTypeNameMap["ICalculationToolSamplingBasic"] = ICalculationToolSamplingBasic

class ICalculationToolSamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    _uuid = "{618ADA55-9E3D-4CEC-815A-B028995774CB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetCurvatureTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingCurvatureTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingCurvatureTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingCurvatureTolerance = agcom.GUID(ICalculationToolSamplingCurvatureTolerance._uuid)
        vtable_offset_local = ICalculationToolSamplingCurvatureTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingCurvatureTolerance, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingCurvatureTolerance.__dict__ and type(ICalculationToolSamplingCurvatureTolerance.__dict__[attrname]) == property:
            return ICalculationToolSamplingCurvatureTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingCurvatureTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def CurvatureTolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurvatureTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CurvatureTolerance.setter
    def CurvatureTolerance(self, curvatureTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetCurvatureTolerance"](arg_curvatureTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{618ADA55-9E3D-4CEC-815A-B028995774CB}", ICalculationToolSamplingCurvatureTolerance)
agcls.AgTypeNameMap["ICalculationToolSamplingCurvatureTolerance"] = ICalculationToolSamplingCurvatureTolerance

class ICalculationToolSamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    _uuid = "{68784D1E-776C-4212-B35E-121FFE569627}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingFixedStep = agcom.GUID(ICalculationToolSamplingFixedStep._uuid)
        vtable_offset_local = ICalculationToolSamplingFixedStep._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingFixedStep, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingFixedStep.__dict__ and type(ICalculationToolSamplingFixedStep.__dict__[attrname]) == property:
            return ICalculationToolSamplingFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingFixedStep.")
    
    @property
    def TimeStep(self) -> float:
        """Get the fixed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68784D1E-776C-4212-B35E-121FFE569627}", ICalculationToolSamplingFixedStep)
agcls.AgTypeNameMap["ICalculationToolSamplingFixedStep"] = ICalculationToolSamplingFixedStep

class ICalculationToolSamplingMethod(object):
    """A sampling method."""
    _uuid = "{1D14391E-F22F-42FF-B3FA-902F061A6F7B}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingMethod = agcom.GUID(ICalculationToolSamplingMethod._uuid)
        vtable_offset_local = ICalculationToolSamplingMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingMethod.__dict__ and type(ICalculationToolSamplingMethod.__dict__[attrname]) == property:
            return ICalculationToolSamplingMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnSamplingMethod":
        """A sampling method type."""
        with agmarshall.AgEnum_arg(AgECrdnSamplingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1D14391E-F22F-42FF-B3FA-902F061A6F7B}", ICalculationToolSamplingMethod)
agcls.AgTypeNameMap["ICalculationToolSamplingMethod"] = ICalculationToolSamplingMethod

class ICalculationToolSamplingMethodFactory(object):
    """The factory creates sampling method components."""
    _uuid = "{C214929B-45FA-4023-9C40-6DCE747C151B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_CreateRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingMethodFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingMethodFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingMethodFactory = agcom.GUID(ICalculationToolSamplingMethodFactory._uuid)
        vtable_offset_local = ICalculationToolSamplingMethodFactory._vtable_offset - 1
        self.__dict__["_CreateFixedStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingMethodFactory, vtable_offset_local+1, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingMethodFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingMethodFactory, vtable_offset_local+3, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingMethodFactory.__dict__ and type(ICalculationToolSamplingMethodFactory.__dict__[attrname]) == property:
            return ICalculationToolSamplingMethodFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingMethodFactory.")
    
    def CreateFixedStep(self, fixedStep:float) -> "ICalculationToolSamplingMethod":
        """Create a fixed time step sampling definition."""
        with agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedStep"](arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCurvatureTolerance(self, curvatureTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCurvatureTolerance"](arg_curvatureTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateRelativeTolerance(self, relativeTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateRelativeTolerance"](arg_relativeTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C214929B-45FA-4023-9C40-6DCE747C151B}", ICalculationToolSamplingMethodFactory)
agcls.AgTypeNameMap["ICalculationToolSamplingMethodFactory"] = ICalculationToolSamplingMethodFactory

class ICalculationToolSamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    _uuid = "{32BB5026-A93C-41F7-ADE8-0A04A43627BC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationToolSamplingRelativeTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationToolSamplingRelativeTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationToolSamplingRelativeTolerance = agcom.GUID(ICalculationToolSamplingRelativeTolerance._uuid)
        vtable_offset_local = ICalculationToolSamplingRelativeTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICalculationToolSamplingRelativeTolerance, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationToolSamplingRelativeTolerance.__dict__ and type(ICalculationToolSamplingRelativeTolerance.__dict__[attrname]) == property:
            return ICalculationToolSamplingRelativeTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationToolSamplingRelativeTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{32BB5026-A93C-41F7-ADE8-0A04A43627BC}", ICalculationToolSamplingRelativeTolerance)
agcls.AgTypeNameMap["ICalculationToolSamplingRelativeTolerance"] = ICalculationToolSamplingRelativeTolerance

class ITimeToolSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    _uuid = "{84F129C1-1D47-4FE2-B87B-013BEF12269C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolSatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolSatisfactionConditionFilter = agcom.GUID(ITimeToolSatisfactionConditionFilter._uuid)
        vtable_offset_local = ITimeToolSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolSatisfactionConditionFilter.__dict__ and type(ITimeToolSatisfactionConditionFilter.__dict__[attrname]) == property:
            return ITimeToolSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolSatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICalculationToolCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICalculationToolCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICalculationToolCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """A duration of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{84F129C1-1D47-4FE2-B87B-013BEF12269C}", ITimeToolSatisfactionConditionFilter)
agcls.AgTypeNameMap["ITimeToolSatisfactionConditionFilter"] = ITimeToolSatisfactionConditionFilter

class IAnalysisWorkbenchSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{5ED53953-1C55-431D-88AF-1AF23B2FE424}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchSignalDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchSignalDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchSignalDelay = agcom.GUID(IAnalysisWorkbenchSignalDelay._uuid)
        vtable_offset_local = IAnalysisWorkbenchSignalDelay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchSignalDelay.__dict__ and type(IAnalysisWorkbenchSignalDelay.__dict__[attrname]) == property:
            return IAnalysisWorkbenchSignalDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchSignalDelay.")
    

agcls.AgClassCatalog.add_catalog_entry("{5ED53953-1C55-431D-88AF-1AF23B2FE424}", IAnalysisWorkbenchSignalDelay)
agcls.AgTypeNameMap["IAnalysisWorkbenchSignalDelay"] = IAnalysisWorkbenchSignalDelay

class ITimeToolSignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_GetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolSignalDelayBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolSignalDelayBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolSignalDelayBasic = agcom.GUID(ITimeToolSignalDelayBasic._uuid)
        vtable_offset_local = ITimeToolSignalDelayBasic._vtable_offset - 1
        self.__dict__["_GetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolSignalDelayBasic, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolSignalDelayBasic.__dict__ and type(ITimeToolSignalDelayBasic.__dict__[attrname]) == property:
            return ITimeToolSignalDelayBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolSignalDelayBasic.")
    
    @property
    def SignalPathReferenceSystem(self) -> "AgECrdnSignalPathReferenceSystem":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalPathReferenceSystem"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalPathReferenceSystem.setter
    def SignalPathReferenceSystem(self, signalPathReferenceSystem:"AgECrdnSignalPathReferenceSystem") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem, signalPathReferenceSystem) as arg_signalPathReferenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetSignalPathReferenceSystem"](arg_signalPathReferenceSystem.COM_val))

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def SpeedOption(self) -> "AgECrdnSpeedOptions":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedOption.setter
    def SpeedOption(self, speedOption:"AgECrdnSpeedOptions") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions, speedOption) as arg_speedOption:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedOption"](arg_speedOption.COM_val))

    @property
    def TransferSpeed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTransferSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TransferSpeed.setter
    def TransferSpeed(self, transferSpeed:float) -> None:
        with agmarshall.DOUBLE_arg(transferSpeed) as arg_transferSpeed:
            agcls.evaluate_hresult(self.__dict__["_SetTransferSpeed"](arg_transferSpeed.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}", ITimeToolSignalDelayBasic)
agcls.AgTypeNameMap["ITimeToolSignalDelayBasic"] = ITimeToolSignalDelayBasic

class ISpatialAnalysisToolVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""
    _uuid = "{42eb6d4a-5cff-471f-997d-3f624cb4a416}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAltitude"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFile"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFromScalar"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcRange"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcDelayRange"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcFactory = agcom.GUID(ISpatialAnalysisToolVolumeCalcFactory._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcFactory._vtable_offset - 1
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAltitude"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFile"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFromScalar"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcRange"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcDelayRange"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcFactory.__dict__ and type(ISpatialAnalysisToolVolumeCalcFactory.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcFactory.")
    
    def IsTypeSupported(self, eType:"AgECrdnVolumeCalcType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnVolumeCalcType") -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a volume calc using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAltitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a altitude to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAltitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAngleOffVector(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a angle to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAngleOffVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFile(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a file volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFile"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFromScalar(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a scalar to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFromScalar"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcSolarIntensity(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a solar intensity volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcSolarIntensity"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcVolumeSatisfactionMetric(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcRange(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcDelayRange(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcDelayRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{42eb6d4a-5cff-471f-997d-3f624cb4a416}", ISpatialAnalysisToolVolumeCalcFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFactory"] = ISpatialAnalysisToolVolumeCalcFactory

class ISpatialAnalysisToolVolumeFactory(object):
    """The factory is used to create instances of volumes."""
    _uuid = "{FE97990E-A152-417C-883E-64C42AB9B913}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeOverTime"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromGrid"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCalc"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeInview"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeFactory = agcom.GUID(ISpatialAnalysisToolVolumeFactory._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeCombined"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeLighting"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeOverTime"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromGrid"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCalc"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeInview"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeFactory.__dict__ and type(ISpatialAnalysisToolVolumeFactory.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeType") -> "ISpatialAnalysisToolVolume":
        """Creates and registers a volume using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeCombined(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type combined."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeLighting(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type lighting."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeOverTime(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type over time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeOverTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromGrid(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type from grid."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromGrid"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCalc(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type from calc."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCalc"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromTimeSatisfaction(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type from time satisfaction."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromTimeSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCondition(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type condition."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeInview(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Creates a volume type Inview."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeInview"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE97990E-A152-417C-883E-64C42AB9B913}", ISpatialAnalysisToolVolumeFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFactory"] = ISpatialAnalysisToolVolumeFactory

class ISpatialAnalysisToolVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""
    _uuid = "{4533DEA1-D754-4579-A79D-B5A639C2CD39}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCartesian"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCylindrical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridSpherical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridConstrained"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridLatLonAlt"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridBearingAlt"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridFactory = agcom.GUID(ISpatialAnalysisToolVolumeGridFactory._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridCartesian"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeGridCylindrical"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridSpherical"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridConstrained"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridLatLonAlt"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridBearingAlt"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridFactory.__dict__ and type(ISpatialAnalysisToolVolumeGridFactory.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeGridType") -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a volume grid using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeGridType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridCartesian(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a cartesian volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCartesian"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeGridType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeGridType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeGridCylindrical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a cylindrical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCylindrical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridSpherical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a spherical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridSpherical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridConstrained(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridConstrained"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridLatLonAlt(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers cartographic volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridLatLonAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridBearingAlt(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Creates and registers a volume grid of type surface bearing using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridBearingAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4533DEA1-D754-4579-A79D-B5A639C2CD39}", ISpatialAnalysisToolVolumeGridFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridFactory"] = ISpatialAnalysisToolVolumeGridFactory

class ISpatialAnalysisToolGridCoordinateDefinition(object):
    """Defines a set of coordinate values."""
    _uuid = "{96875D1C-9CBC-4732-A678-2CB17995C0E9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        self.__dict__["_GetGridValuesMethod"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesCustom"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolGridCoordinateDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolGridCoordinateDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolGridCoordinateDefinition = agcom.GUID(ISpatialAnalysisToolGridCoordinateDefinition._uuid)
        vtable_offset_local = ISpatialAnalysisToolGridCoordinateDefinition._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetGridValuesMethod"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedStep"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+3, agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+4, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesCustom"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+5, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridCoordinateDefinition, vtable_offset_local+6, agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolGridCoordinateDefinition.__dict__ and type(ISpatialAnalysisToolGridCoordinateDefinition.__dict__[attrname]) == property:
            return ISpatialAnalysisToolGridCoordinateDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolGridCoordinateDefinition.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def GridValuesMethod(self) -> "ISpatialAnalysisToolGridValuesMethod":
        """Sets/Returns the grid values interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGridValuesMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedStep(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "ISpatialAnalysisToolGridValuesFixedStep":
        """Sets grid values type to fixed step."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax, \
             agmarshall.DOUBLE_arg(refValue) as arg_refValue, \
             agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedStep"](arg_min.COM_val, arg_max.COM_val, arg_includeMinMax.COM_val, arg_refValue.COM_val, arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfSteps(self, min:float, max:float, numSteps:int) -> "ISpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfSteps"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesCustom(self, values:list) -> "ISpatialAnalysisToolGridValuesCustom":
        """Sets grid values type to custom values."""
        with agmarshall.SAFEARRAY_arg(values) as arg_values, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesCustom"](byref(arg_values.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfStepsEx(self, min:"IQuantity", max:"IQuantity", numSteps:int) -> "ISpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """Sets grid values type to fixed number of steps with min and max as IAgQuantity"""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfStepsEx"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{96875D1C-9CBC-4732-A678-2CB17995C0E9}", ISpatialAnalysisToolGridCoordinateDefinition)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridCoordinateDefinition"] = ISpatialAnalysisToolGridCoordinateDefinition

class ISpatialAnalysisToolGridValuesCustom(object):
    """Fixed step grid values."""
    _uuid = "{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_SetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolGridValuesCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolGridValuesCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolGridValuesCustom = agcom.GUID(ISpatialAnalysisToolGridValuesCustom._uuid)
        vtable_offset_local = ISpatialAnalysisToolGridValuesCustom._vtable_offset - 1
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesCustom, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetValues"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesCustom, vtable_offset_local+2, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolGridValuesCustom.__dict__ and type(ISpatialAnalysisToolGridValuesCustom.__dict__[attrname]) == property:
            return ISpatialAnalysisToolGridValuesCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolGridValuesCustom.")
    
    @property
    def Values(self) -> list:
        """Custom set of coordinate values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Values.setter
    def Values(self, values:list) -> None:
        with agmarshall.SAFEARRAY_arg(values) as arg_values:
            agcls.evaluate_hresult(self.__dict__["_SetValues"](arg_values.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}", ISpatialAnalysisToolGridValuesCustom)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesCustom"] = ISpatialAnalysisToolGridValuesCustom

class ISpatialAnalysisToolGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""
    _uuid = "{379ACEFA-1B1E-4753-BA9A-87939E5B8893}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_GetMinEx"] = _raise_uninitialized_error
        self.__dict__["_SetMinEx"] = _raise_uninitialized_error
        self.__dict__["_GetMaxEx"] = _raise_uninitialized_error
        self.__dict__["_SetMaxEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolGridValuesFixedNumberOfSteps from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps = agcom.GUID(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._uuid)
        vtable_offset_local = ISpatialAnalysisToolGridValuesFixedNumberOfSteps._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetMinEx"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMinEx"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetMaxEx"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetMaxEx"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedNumberOfSteps, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolGridValuesFixedNumberOfSteps.__dict__ and type(ISpatialAnalysisToolGridValuesFixedNumberOfSteps.__dict__[attrname]) == property:
            return ISpatialAnalysisToolGridValuesFixedNumberOfSteps.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolGridValuesFixedNumberOfSteps.")
    
    @property
    def Min(self) -> float:
        """This property is deprecated. Use MinEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def NumberOfSteps(self) -> int:
        """The number of steps between coordinate values."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumberOfSteps"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NumberOfSteps.setter
    def NumberOfSteps(self, numberOfSteps:int) -> None:
        with agmarshall.INT_arg(numberOfSteps) as arg_numberOfSteps:
            agcls.evaluate_hresult(self.__dict__["_SetNumberOfSteps"](arg_numberOfSteps.COM_val))

    @property
    def MinEx(self) -> "IQuantity":
        """Minimum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MinEx.setter
    def MinEx(self, minEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(minEx, IQuantity) as arg_minEx:
            agcls.evaluate_hresult(self.__dict__["_SetMinEx"](arg_minEx.COM_val))

    @property
    def MaxEx(self) -> "IQuantity":
        """Maximum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MaxEx.setter
    def MaxEx(self, maxEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(maxEx, IQuantity) as arg_maxEx:
            agcls.evaluate_hresult(self.__dict__["_SetMaxEx"](arg_maxEx.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{379ACEFA-1B1E-4753-BA9A-87939E5B8893}", ISpatialAnalysisToolGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesFixedNumberOfSteps"] = ISpatialAnalysisToolGridValuesFixedNumberOfSteps

class ISpatialAnalysisToolGridValuesFixedStep(object):
    """Fixed step grid values."""
    _uuid = "{7C18BF81-7E22-4A28-B462-37ED86EC3050}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolGridValuesFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolGridValuesFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolGridValuesFixedStep = agcom.GUID(ISpatialAnalysisToolGridValuesFixedStep._uuid)
        vtable_offset_local = ISpatialAnalysisToolGridValuesFixedStep._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesFixedStep, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolGridValuesFixedStep.__dict__ and type(ISpatialAnalysisToolGridValuesFixedStep.__dict__[attrname]) == property:
            return ISpatialAnalysisToolGridValuesFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolGridValuesFixedStep.")
    
    @property
    def Min(self) -> float:
        """Minimum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """Maximum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def IncludeMinMax(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeMinMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeMinMax.setter
    def IncludeMinMax(self, includeMinMax:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeMinMax"](arg_includeMinMax.COM_val))

    @property
    def ReferenceValue(self) -> float:
        """Reference coordinate value from which steps are taken."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceValue.setter
    def ReferenceValue(self, referenceValue:float) -> None:
        with agmarshall.DOUBLE_arg(referenceValue) as arg_referenceValue:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceValue"](arg_referenceValue.COM_val))

    @property
    def Step(self) -> float:
        """Step between subsequent coordinate values."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7C18BF81-7E22-4A28-B462-37ED86EC3050}", ISpatialAnalysisToolGridValuesFixedStep)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesFixedStep"] = ISpatialAnalysisToolGridValuesFixedStep

class ISpatialAnalysisToolGridValuesMethod(object):
    """A grid values method."""
    _uuid = "{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolGridValuesMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolGridValuesMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolGridValuesMethod = agcom.GUID(ISpatialAnalysisToolGridValuesMethod._uuid)
        vtable_offset_local = ISpatialAnalysisToolGridValuesMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolGridValuesMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolGridValuesMethod.__dict__ and type(ISpatialAnalysisToolGridValuesMethod.__dict__[attrname]) == property:
            return ISpatialAnalysisToolGridValuesMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolGridValuesMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}", ISpatialAnalysisToolGridValuesMethod)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesMethod"] = ISpatialAnalysisToolGridValuesMethod

class ITimeToolLightTimeDelay(object):
    """Manage Light Time Delay options.."""
    _uuid = "{82765B62-B9AB-4D52-900E-52ADAC0365D0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_SetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_GetClockHost"] = _raise_uninitialized_error
        self.__dict__["_SetClockHost"] = _raise_uninitialized_error
        self.__dict__["_GetTimeSense"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSense"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolLightTimeDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolLightTimeDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolLightTimeDelay = agcom.GUID(ITimeToolLightTimeDelay._uuid)
        vtable_offset_local = ITimeToolLightTimeDelay._vtable_offset - 1
        self.__dict__["_GetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetClockHost"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetClockHost"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ITimeToolLightTimeDelay, vtable_offset_local+10, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolLightTimeDelay.__dict__ and type(ITimeToolLightTimeDelay.__dict__[attrname]) == property:
            return ITimeToolLightTimeDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolLightTimeDelay.")
    
    @property
    def UseLightTimeDelay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseLightTimeDelay"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, useLightTimeDelay:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useLightTimeDelay) as arg_useLightTimeDelay:
            agcls.evaluate_hresult(self.__dict__["_SetUseLightTimeDelay"](arg_useLightTimeDelay.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Set light Time Delay Convergence."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))

    @property
    def AberrationType(self) -> "AgECrdnVolumeAberrationType":
        """Method used to Aberration Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAberrationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AberrationType.setter
    def AberrationType(self, aberrationType:"AgECrdnVolumeAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType, aberrationType) as arg_aberrationType:
            agcls.evaluate_hresult(self.__dict__["_SetAberrationType"](arg_aberrationType.COM_val))

    @property
    def ClockHost(self) -> "AgECrdnVolumeClockHostType":
        """Indicates whether object1 or object2 of an Access instance holds the clock for Access times."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockHost"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockHost.setter
    def ClockHost(self, clockHost:"AgECrdnVolumeClockHostType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType, clockHost) as arg_clockHost:
            agcls.evaluate_hresult(self.__dict__["_SetClockHost"](arg_clockHost.COM_val))

    @property
    def TimeSense(self) -> "AgECrdnVolumeTimeSenseType":
        """Indicates whether apparent position is computed in a transmit or receive sense"""
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeSense.setter
    def TimeSense(self, timeSense:"AgECrdnVolumeTimeSenseType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType, timeSense) as arg_timeSense:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSense"](arg_timeSense.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{82765B62-B9AB-4D52-900E-52ADAC0365D0}", ITimeToolLightTimeDelay)
agcls.AgTypeNameMap["ITimeToolLightTimeDelay"] = ITimeToolLightTimeDelay

class ISpatialAnalysisToolVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    _uuid = "{F85958EC-F470-432F-81B1-8517D3952F1E}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolume = agcom.GUID(ISpatialAnalysisToolVolume._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolume._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolume.__dict__ and type(ISpatialAnalysisToolVolume.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolume.")
    

agcls.AgClassCatalog.add_catalog_entry("{F85958EC-F470-432F-81B1-8517D3952F1E}", ISpatialAnalysisToolVolume)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolume"] = ISpatialAnalysisToolVolume

class ISpatialAnalysisToolVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    _uuid = "{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalc = agcom.GUID(ISpatialAnalysisToolVolumeCalc._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalc._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalc.__dict__ and type(ISpatialAnalysisToolVolumeCalc.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalc.")
    

agcls.AgClassCatalog.add_catalog_entry("{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}", ISpatialAnalysisToolVolumeCalc)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalc"] = ISpatialAnalysisToolVolumeCalc

class ISpatialAnalysisToolVolumeCalcAltitude(object):
    """A volume calc altitude interface."""
    _uuid = "{6039868a-acea-4918-966b-c6f952fd94d3}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_SetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcAltitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcAltitude = agcom.GUID(ISpatialAnalysisToolVolumeCalcAltitude._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcAltitude._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetShapeModel"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShapeModel"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAltitude, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcAltitude.__dict__ and type(ISpatialAnalysisToolVolumeCalcAltitude.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcAltitude.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ShapeModel(self) -> "AgECrdnVolumeCalcAltitudeReferenceType":
        """The Volume Calc Altitude Reference Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShapeModel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ShapeModel.setter
    def ShapeModel(self, shapeModel:"AgECrdnVolumeCalcAltitudeReferenceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType, shapeModel) as arg_shapeModel:
            agcls.evaluate_hresult(self.__dict__["_SetShapeModel"](arg_shapeModel.COM_val))

    @property
    def UseCustomReference(self) -> bool:
        """Whether to use custom reference."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomReference"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomReference.setter
    def UseCustomReference(self, useCustomReference:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomReference) as arg_useCustomReference:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomReference"](arg_useCustomReference.COM_val))

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6039868a-acea-4918-966b-c6f952fd94d3}", ISpatialAnalysisToolVolumeCalcAltitude)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcAltitude"] = ISpatialAnalysisToolVolumeCalcAltitude

class ISpatialAnalysisToolVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""
    _uuid = "{ad6880b4-afc1-47ba-b964-f38916955c7b}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_SetAboutVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcAngleOffVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcAngleOffVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcAngleOffVector = agcom.GUID(ISpatialAnalysisToolVolumeCalcAngleOffVector._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcAngleOffVector._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetAboutVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcAngleOffVector, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcAngleOffVector.__dict__ and type(ISpatialAnalysisToolVolumeCalcAngleOffVector.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcAngleOffVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcAngleOffVector.")
    
    @property
    def Angle(self) -> "AgECrdnVolumeCalcAngleOffVectorType":
        """The Volume Calc Angle Off Vector Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Angle.setter
    def Angle(self, angle:"AgECrdnVolumeCalcAngleOffVectorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType, angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IVectorGeometryToolPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Angle Off Vector reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVector.setter
    def ReferenceVector(self, referenceVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(referenceVector, IVectorGeometryToolVector) as arg_referenceVector:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVector"](arg_referenceVector.COM_val))

    @property
    def AboutVector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AboutVector.setter
    def AboutVector(self, aboutVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(aboutVector, IVectorGeometryToolVector) as arg_aboutVector:
            agcls.evaluate_hresult(self.__dict__["_SetAboutVector"](arg_aboutVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ad6880b4-afc1-47ba-b964-f38916955c7b}", ISpatialAnalysisToolVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcAngleOffVector"] = ISpatialAnalysisToolVolumeCalcAngleOffVector

class ISpatialAnalysisToolVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""
    _uuid = "{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_SetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_GetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_GetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_SetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumDurationTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcConditionSatMetric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcConditionSatMetric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric = agcom.GUID(ISpatialAnalysisToolVolumeCalcConditionSatMetric._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcConditionSatMetric._vtable_offset - 1
        self.__dict__["_GetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+11, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+12, agcom.INT)
        self.__dict__["_GetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcConditionSatMetric, vtable_offset_local+20, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcConditionSatMetric.__dict__ and type(ISpatialAnalysisToolVolumeCalcConditionSatMetric.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcConditionSatMetric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcConditionSatMetric.")
    
    @property
    def SpatialCondition(self) -> "ISpatialAnalysisToolVolume":
        """A spatial condition for satisfaction metric."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpatialCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SpatialCondition.setter
    def SpatialCondition(self, spatialCondition:"ISpatialAnalysisToolVolume") -> None:
        with agmarshall.AgInterface_in_arg(spatialCondition, ISpatialAnalysisToolVolume) as arg_spatialCondition:
            agcls.evaluate_hresult(self.__dict__["_SetSpatialCondition"](arg_spatialCondition.COM_val))

    @property
    def SatisfactionMetric(self) -> "AgECrdnVolumeCalcVolumeSatisfactionMetricType":
        """Spatial condition satisfaction metric types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionMetric"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionMetric.setter
    def SatisfactionMetric(self, satisfactionMetric:"AgECrdnVolumeCalcVolumeSatisfactionMetricType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType, satisfactionMetric) as arg_satisfactionMetric:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionMetric"](arg_satisfactionMetric.COM_val))

    @property
    def AccumulationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType":
        """Spatial condition satisfaction accumulation types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAccumulationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AccumulationType.setter
    def AccumulationType(self, accumulationType:"AgECrdnVolumeCalcVolumeSatisfactionAccumulationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType, accumulationType) as arg_accumulationType:
            agcls.evaluate_hresult(self.__dict__["_SetAccumulationType"](arg_accumulationType.COM_val))

    @property
    def DurationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionDurationType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeCalcVolumeSatisfactionDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def Filter(self) -> "AgECrdnVolumeCalcVolumeSatisfactionFilterType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"AgECrdnVolumeCalcVolumeSatisfactionFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType, filter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))

    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))

    @property
    def UseMinimumDuration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumDuration.setter
    def UseMinimumDuration(self, useMinimumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumDuration) as arg_useMinimumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumDuration"](arg_useMinimumDuration.COM_val))

    @property
    def UseMaximumDuration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumDuration.setter
    def UseMaximumDuration(self, useMaximumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumDuration) as arg_useMaximumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumDuration"](arg_useMaximumDuration.COM_val))

    @property
    def MinimumDurationTime(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumDurationTime.setter
    def MinimumDurationTime(self, minimumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDurationTime) as arg_minimumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumDurationTime"](arg_minimumDurationTime.COM_val))

    @property
    def MaximumDurationTime(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumDurationTime.setter
    def MaximumDurationTime(self, maximumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDurationTime) as arg_maximumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumDurationTime"](arg_maximumDurationTime.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}", ISpatialAnalysisToolVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcConditionSatMetric"] = ISpatialAnalysisToolVolumeCalcConditionSatMetric

class ISpatialAnalysisToolVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""
    _uuid = "{874bf6c9-20d7-486c-918a-a0094093879a}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_GetSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetSpeed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcDelayRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcDelayRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcDelayRange = agcom.GUID(ISpatialAnalysisToolVolumeCalcDelayRange._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcDelayRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSpeedType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSpeed"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpeed"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcDelayRange, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcDelayRange.__dict__ and type(ISpatialAnalysisToolVolumeCalcDelayRange.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcDelayRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcDelayRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IVectorGeometryToolPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVectorGeometryToolVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))

    @property
    def SpeedType(self) -> "AgECrdnVolumeCalcRangeSpeedType":
        """The Volume Calc range speed types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedType.setter
    def SpeedType(self, speedType:"AgECrdnVolumeCalcRangeSpeedType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType, speedType) as arg_speedType:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedType"](arg_speedType.COM_val))

    @property
    def Speed(self) -> float:
        """The Volume Calc range speed value"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Speed.setter
    def Speed(self, speed:float) -> None:
        with agmarshall.DOUBLE_arg(speed) as arg_speed:
            agcls.evaluate_hresult(self.__dict__["_SetSpeed"](arg_speed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{874bf6c9-20d7-486c-918a-a0094093879a}", ISpatialAnalysisToolVolumeCalcDelayRange)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcDelayRange"] = ISpatialAnalysisToolVolumeCalcDelayRange

class ISpatialAnalysisToolVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    _uuid = "{362b7405-edf6-486c-8fcf-1f9a93b75000}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcFile = agcom.GUID(ISpatialAnalysisToolVolumeCalcFile._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFile, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcFile.__dict__ and type(ISpatialAnalysisToolVolumeCalcFile.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the volume calc file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{362b7405-edf6-486c-8fcf-1f9a93b75000}", ISpatialAnalysisToolVolumeCalcFile)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFile"] = ISpatialAnalysisToolVolumeCalcFile

class ISpatialAnalysisToolVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""
    _uuid = "{6e537b27-ee55-44c5-89b2-f2c504a44bb6}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcFromScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcFromScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcFromScalar = agcom.GUID(ISpatialAnalysisToolVolumeCalcFromScalar._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcFromScalar._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFromScalar, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcFromScalar, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcFromScalar.__dict__ and type(ISpatialAnalysisToolVolumeCalcFromScalar.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcFromScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcFromScalar.")
    
    @property
    def Scalar(self) -> "ICalculationToolScalar":
        """The Volume calc scalar to location Type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICalculationToolScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6e537b27-ee55-44c5-89b2-f2c504a44bb6}", ISpatialAnalysisToolVolumeCalcFromScalar)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFromScalar"] = ISpatialAnalysisToolVolumeCalcFromScalar

class ISpatialAnalysisToolVolumeCalcRange(object):
    """A volume calc distance to location interface."""
    _uuid = "{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcRange = agcom.GUID(ISpatialAnalysisToolVolumeCalcRange._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcRange, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcRange.__dict__ and type(ISpatialAnalysisToolVolumeCalcRange.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IVectorGeometryToolPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVectorGeometryToolVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}", ISpatialAnalysisToolVolumeCalcRange)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcRange"] = ISpatialAnalysisToolVolumeCalcRange

class ISpatialAnalysisToolVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""
    _uuid = "{40e35f2b-9a83-449a-9a4e-35bdee832061}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCalcSolarIntensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCalcSolarIntensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCalcSolarIntensity = agcom.GUID(ISpatialAnalysisToolVolumeCalcSolarIntensity._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCalcSolarIntensity._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcSolarIntensity, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcSolarIntensity, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcSolarIntensity, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCalcSolarIntensity, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCalcSolarIntensity.__dict__ and type(ISpatialAnalysisToolVolumeCalcSolarIntensity.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCalcSolarIntensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCalcSolarIntensity.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{40e35f2b-9a83-449a-9a4e-35bdee832061}", ISpatialAnalysisToolVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcSolarIntensity"] = ISpatialAnalysisToolVolumeCalcSolarIntensity

class ISpatialAnalysisToolVolumeCombined(object):
    """A combined volume interface."""
    _uuid = "{96684FB4-3839-44DB-AD80-B772BF58A39A}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeCombined = agcom.GUID(ISpatialAnalysisToolVolumeCombined._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+6, agcom.PVOID, agcom.INT)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeCombined, vtable_offset_local+8, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeCombined.__dict__ and type(ISpatialAnalysisToolVolumeCombined.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnVolumeCombinedOperationType":
        """Sets/Returns volume combined operation."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnVolumeCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Returns the spatial condition vector size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all spatial conditions."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def SetCondition(self, ref:"ISpatialAnalysisToolVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        with agmarshall.AgInterface_in_arg(ref, ISpatialAnalysisToolVolume) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def GetCondition(self, pos:int) -> "ISpatialAnalysisToolVolume":
        """Get spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def RemoveCondition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96684FB4-3839-44DB-AD80-B772BF58A39A}", ISpatialAnalysisToolVolumeCombined)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCombined"] = ISpatialAnalysisToolVolumeCombined

class ISpatialAnalysisToolVolumeFromCalc(object):
    """An volume from calc volume interface."""
    _uuid = "{018666E1-C0E6-46F6-A682-F91FBF3C74F3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeFromCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeFromCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeFromCalc = agcom.GUID(ISpatialAnalysisToolVolumeFromCalc._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeFromCalc._vtable_offset - 1
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCalc, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeFromCalc.__dict__ and type(ISpatialAnalysisToolVolumeFromCalc.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeFromCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeFromCalc.")
    
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    @property
    def VolumeCalc(self) -> "ISpatialAnalysisToolVolumeCalc":
        """Get the volume calc from the bounds."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalc"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeCalc.setter
    def VolumeCalc(self, volumeCalc:"ISpatialAnalysisToolVolumeCalc") -> None:
        with agmarshall.AgInterface_in_arg(volumeCalc, ISpatialAnalysisToolVolumeCalc) as arg_volumeCalc:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeCalc"](arg_volumeCalc.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{018666E1-C0E6-46F6-A682-F91FBF3C74F3}", ISpatialAnalysisToolVolumeFromCalc)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromCalc"] = ISpatialAnalysisToolVolumeFromCalc

class ISpatialAnalysisToolVolumeFromCondition(object):
    """A volume from conditioninterface."""
    _uuid = "{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeFromCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeFromCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeFromCondition = agcom.GUID(ISpatialAnalysisToolVolumeFromCondition._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeFromCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromCondition, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeFromCondition.__dict__ and type(ISpatialAnalysisToolVolumeFromCondition.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeFromCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeFromCondition.")
    
    @property
    def Condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICalculationToolCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICalculationToolCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ITimeToolEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def Sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAnalysisWorkbenchSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAnalysisWorkbenchConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}", ISpatialAnalysisToolVolumeFromCondition)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromCondition"] = ISpatialAnalysisToolVolumeFromCondition

class ISpatialAnalysisToolVolumeFromGrid(object):
    """An over time volume interface."""
    _uuid = "{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_SetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrid"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeGrid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeFromGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeFromGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeFromGrid = agcom.GUID(ISpatialAnalysisToolVolumeFromGrid._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeFromGrid._vtable_offset - 1
        self.__dict__["_GetEdgeType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromGrid, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetEdgeType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromGrid, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromGrid, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromGrid, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeFromGrid.__dict__ and type(ISpatialAnalysisToolVolumeFromGrid.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeFromGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeFromGrid.")
    
    @property
    def EdgeType(self) -> "AgECrdnVolumeFromGridEdgeType":
        """Sets/Returns the edge type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEdgeType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EdgeType.setter
    def EdgeType(self, edgeType:"AgECrdnVolumeFromGridEdgeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType, edgeType) as arg_edgeType:
            agcls.evaluate_hresult(self.__dict__["_SetEdgeType"](arg_edgeType.COM_val))

    @property
    def VolumeGrid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Sets/Returns the volume grid for bounding."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeGrid.setter
    def VolumeGrid(self, volumeGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(volumeGrid, ISpatialAnalysisToolVolumeGrid) as arg_volumeGrid:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeGrid"](arg_volumeGrid.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}", ISpatialAnalysisToolVolumeFromGrid)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromGrid"] = ISpatialAnalysisToolVolumeFromGrid

class ISpatialAnalysisToolVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""
    _uuid = "{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeFromTimeSatisfaction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeFromTimeSatisfaction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeFromTimeSatisfaction = agcom.GUID(ISpatialAnalysisToolVolumeFromTimeSatisfaction._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeFromTimeSatisfaction._vtable_offset - 1
        self.__dict__["_GetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromTimeSatisfaction, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeFromTimeSatisfaction, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeFromTimeSatisfaction.__dict__ and type(ISpatialAnalysisToolVolumeFromTimeSatisfaction.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeFromTimeSatisfaction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeFromTimeSatisfaction.")
    
    @property
    def TimeSatisfaction(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSatisfaction"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeSatisfaction.setter
    def TimeSatisfaction(self, timeSatisfaction:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(timeSatisfaction, ITimeToolEventIntervalList) as arg_timeSatisfaction:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSatisfaction"](arg_timeSatisfaction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}", ISpatialAnalysisToolVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromTimeSatisfaction"] = ISpatialAnalysisToolVolumeFromTimeSatisfaction

class ISpatialAnalysisToolVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    _uuid = "{88BBE781-85C1-439D-A4F4-58006B9A35EC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGrid = agcom.GUID(ISpatialAnalysisToolVolumeGrid._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGrid._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGrid.__dict__ and type(ISpatialAnalysisToolVolumeGrid.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGrid.")
    

agcls.AgClassCatalog.add_catalog_entry("{88BBE781-85C1-439D-A4F4-58006B9A35EC}", ISpatialAnalysisToolVolumeGrid)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGrid"] = ISpatialAnalysisToolVolumeGrid

class ISpatialAnalysisToolVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""
    _uuid = "{2814A890-E858-41A6-B640-19F9D27E5ACB}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAlongBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetCrossBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_GetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_SetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceLocation"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceLocation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridBearingAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridBearingAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridBearingAlt = agcom.GUID(ISpatialAnalysisToolVolumeGridBearingAlt._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridBearingAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetAlongBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCrossBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_GetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridBearingAlt, vtable_offset_local+11, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridBearingAlt.__dict__ and type(ISpatialAnalysisToolVolumeGridBearingAlt.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridBearingAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridBearingAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def AlongBearingCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns AlongBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CrossBearingCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns CrossBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCrossBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns altitude Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))

    @property
    def BearingAngle(self) -> float:
        """Specify the Bearing Angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBearingAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @BearingAngle.setter
    def BearingAngle(self, bearingAngle:float) -> None:
        with agmarshall.DOUBLE_arg(bearingAngle) as arg_bearingAngle:
            agcls.evaluate_hresult(self.__dict__["_SetBearingAngle"](arg_bearingAngle.COM_val))

    @property
    def ReferenceLocation(self) -> list:
        """Get lat/lon for reference location"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceLocation.setter
    def ReferenceLocation(self, referenceLocation:list) -> None:
        with agmarshall.SAFEARRAY_arg(referenceLocation) as arg_referenceLocation:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceLocation"](arg_referenceLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2814A890-E858-41A6-B640-19F9D27E5ACB}", ISpatialAnalysisToolVolumeGridBearingAlt)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridBearingAlt"] = ISpatialAnalysisToolVolumeGridBearingAlt

class ISpatialAnalysisToolVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""
    _uuid = "{E959F851-165E-4201-8C13-81FA4C2D3E2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetXCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetYCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetZCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridCartesian = agcom.GUID(ISpatialAnalysisToolVolumeGridCartesian._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridCartesian._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCartesian, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCartesian, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetXCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCartesian, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCartesian, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetZCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCartesian, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridCartesian.__dict__ and type(ISpatialAnalysisToolVolumeGridCartesian.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridCartesian.")
    
    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def XCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns X Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns Y Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ZCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns Z Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E959F851-165E-4201-8C13-81FA4C2D3E2D}", ISpatialAnalysisToolVolumeGridCartesian)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridCartesian"] = ISpatialAnalysisToolVolumeGridCartesian

class ISpatialAnalysisToolVolumeGridConstrained(object):
    """A volume grid constrained interface."""
    _uuid = "{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridConstrained = agcom.GUID(ISpatialAnalysisToolVolumeGridConstrained._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridConstrained._vtable_offset - 1
        self.__dict__["_GetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridConstrained, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridConstrained, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridConstrained.__dict__ and type(ISpatialAnalysisToolVolumeGridConstrained.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridConstrained.")
    
    @property
    def ReferenceGrid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceGrid.setter
    def ReferenceGrid(self, referenceGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(referenceGrid, ISpatialAnalysisToolVolumeGrid) as arg_referenceGrid:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceGrid"](arg_referenceGrid.COM_val))

    @property
    def Constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on the grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, ISpatialAnalysisToolVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}", ISpatialAnalysisToolVolumeGridConstrained)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridConstrained"] = ISpatialAnalysisToolVolumeGridConstrained

class ISpatialAnalysisToolVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""
    _uuid = "{0CF87427-CC2B-4282-9B41-0A2D86395AD4}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetThetaCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetHeightCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridCylindrical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridCylindrical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridCylindrical = agcom.GUID(ISpatialAnalysisToolVolumeGridCylindrical._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridCylindrical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCylindrical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCylindrical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThetaCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCylindrical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRadiusCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCylindrical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetHeightCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridCylindrical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridCylindrical.__dict__ and type(ISpatialAnalysisToolVolumeGridCylindrical.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridCylindrical.")
    
    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def ThetaCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns theta Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThetaCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RadiusCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns radius Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def HeightCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns height Coordinates parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetHeightCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0CF87427-CC2B-4282-9B41-0A2D86395AD4}", ISpatialAnalysisToolVolumeGridCylindrical)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridCylindrical"] = ISpatialAnalysisToolVolumeGridCylindrical

class ISpatialAnalysisToolVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    _uuid = "{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetLatitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetLongitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridLatLonAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridLatLonAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridLatLonAlt = agcom.GUID(ISpatialAnalysisToolVolumeGridLatLonAlt._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridLatLonAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLatitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetLongitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridLatLonAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridLatLonAlt.__dict__ and type(ISpatialAnalysisToolVolumeGridLatLonAlt.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridLatLonAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridLatLonAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def LatitudeCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns latitude Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LongitudeCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns longtitude Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns altitude parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}", ISpatialAnalysisToolVolumeGridLatLonAlt)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridLatLonAlt"] = ISpatialAnalysisToolVolumeGridLatLonAlt

class ISpatialAnalysisToolVolumeGridResult(object):
    """An interface that generates Volume Grid results."""
    _uuid = "{1C3B106C-011E-4C51-B321-20389C8EAF76}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSizeI"] = _raise_uninitialized_error
        self.__dict__["_GetSizeJ"] = _raise_uninitialized_error
        self.__dict__["_GetSizeK"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricDataVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricPositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricNativePositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricGradientVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridResult = agcom.GUID(ISpatialAnalysisToolVolumeGridResult._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridResult._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetSizeI"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_GetSizeJ"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetSizeK"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+4, POINTER(agcom.INT))
        self.__dict__["_GetVolumeMetricDataVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricPositionVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+6, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricNativePositionVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricGradientVector"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridResult, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridResult.__dict__ and type(ISpatialAnalysisToolVolumeGridResult.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridResult.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeI(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeI"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeJ(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeJ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeK(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeK"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VolumeMetricDataVector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricDataVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricPositionVector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricPositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricNativePositionVector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricNativePositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricGradientVector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricGradientVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1C3B106C-011E-4C51-B321-20389C8EAF76}", ISpatialAnalysisToolVolumeGridResult)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridResult"] = ISpatialAnalysisToolVolumeGridResult

class ISpatialAnalysisToolVolumeGridSpherical(object):
    """A volume grid spherical interface."""
    _uuid = "{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetElevationCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRangeCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeGridSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeGridSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeGridSpherical = agcom.GUID(ISpatialAnalysisToolVolumeGridSpherical._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeGridSpherical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridSpherical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridSpherical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAzimuthCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridSpherical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetElevationCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridSpherical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetRangeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeGridSpherical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeGridSpherical.__dict__ and type(ISpatialAnalysisToolVolumeGridSpherical.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeGridSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeGridSpherical.")
    
    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def AzimuthCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns azimuth coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ElevationCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns elevation coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElevationCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RangeCoordinates(self) -> "ISpatialAnalysisToolGridCoordinateDefinition":
        """Returns range coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRangeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}", ISpatialAnalysisToolVolumeGridSpherical)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridSpherical"] = ISpatialAnalysisToolVolumeGridSpherical

class ISpatialAnalysisToolVolumeInview(object):
    """An Inview volume interface."""
    _uuid = "{EF724630-CEB6-4818-A5BB-F74CF1B9D931}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_SetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_GetLightTimeDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeInview._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeInview from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeInview = agcom.GUID(ISpatialAnalysisToolVolumeInview._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeInview._vtable_offset - 1
        self.__dict__["_GetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeInview, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeInview, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeInview, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeInview.__dict__ and type(ISpatialAnalysisToolVolumeInview.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeInview.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeInview.")
    
    @property
    def ConstraintObject(self) -> typing.Any:
        """A constraint object of the access."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintObject"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ConstraintObject.setter
    def ConstraintObject(self, constraintObject:typing.Any) -> None:
        with agmarshall.VARIANT_arg(constraintObject) as arg_constraintObject:
            agcls.evaluate_hresult(self.__dict__["_SetConstraintObject"](arg_constraintObject.COM_val))

    @property
    def LightTimeDelay(self) -> "ITimeToolLightTimeDelay":
        """Returns Light Time Delay options parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightTimeDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF724630-CEB6-4818-A5BB-F74CF1B9D931}", ISpatialAnalysisToolVolumeInview)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeInview"] = ISpatialAnalysisToolVolumeInview

class ISpatialAnalysisToolVolumeLighting(object):
    """A lighting volume interface."""
    _uuid = "{CE134C08-274E-4E29-9337-03E9C73AA8F9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetLightingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetLightingConditions"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeLighting = agcom.GUID(ISpatialAnalysisToolVolumeLighting._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeLighting._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeLighting, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeLighting.__dict__ and type(ISpatialAnalysisToolVolumeLighting.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeLighting.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))

    @property
    def LightingConditions(self) -> "AgECrdnVolumeLightingConditionsType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightingConditions"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LightingConditions.setter
    def LightingConditions(self, lightingConditions:"AgECrdnVolumeLightingConditionsType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType, lightingConditions) as arg_lightingConditions:
            agcls.evaluate_hresult(self.__dict__["_SetLightingConditions"](arg_lightingConditions.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CE134C08-274E-4E29-9337-03E9C73AA8F9}", ISpatialAnalysisToolVolumeLighting)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeLighting"] = ISpatialAnalysisToolVolumeLighting

class ISpatialAnalysisToolVolumeOverTime(object):
    """An over time volume interface."""
    _uuid = "{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpatialAnalysisToolVolumeOverTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpatialAnalysisToolVolumeOverTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpatialAnalysisToolVolumeOverTime = agcom.GUID(ISpatialAnalysisToolVolumeOverTime._uuid)
        vtable_offset_local = ISpatialAnalysisToolVolumeOverTime._vtable_offset - 1
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ISpatialAnalysisToolVolumeOverTime, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpatialAnalysisToolVolumeOverTime.__dict__ and type(ISpatialAnalysisToolVolumeOverTime.__dict__[attrname]) == property:
            return ISpatialAnalysisToolVolumeOverTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpatialAnalysisToolVolumeOverTime.")
    
    @property
    def DurationType(self) -> "AgECrdnVolumeOverTimeDurationType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeOverTimeDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def ReferenceVolume(self) -> "ISpatialAnalysisToolVolume":
        """Sets/Returns the reference volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVolume"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVolume.setter
    def ReferenceVolume(self, referenceVolume:"ISpatialAnalysisToolVolume") -> None:
        with agmarshall.AgInterface_in_arg(referenceVolume, ISpatialAnalysisToolVolume) as arg_referenceVolume:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVolume"](arg_referenceVolume.COM_val))

    @property
    def ReferenceIntervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list for the over time volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ITimeToolEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}", ISpatialAnalysisToolVolumeOverTime)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeOverTime"] = ISpatialAnalysisToolVolumeOverTime

class ITimeToolTimeProperties(object):
    """Defines methods to compute time properties such as availability and special times."""
    _uuid = "{E95B72AA-F8DE-4122-AC60-54E46A208E19}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolTimeProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolTimeProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolTimeProperties = agcom.GUID(ITimeToolTimeProperties._uuid)
        vtable_offset_local = ITimeToolTimeProperties._vtable_offset - 1
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ITimeToolTimeProperties, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolTimeProperties.__dict__ and type(ITimeToolTimeProperties.__dict__[attrname]) == property:
            return ITimeToolTimeProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolTimeProperties.")
    
    def GetAvailability(self) -> "ITimeToolIntervalCollection":
        """Returns a collection of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E95B72AA-F8DE-4122-AC60-54E46A208E19}", ITimeToolTimeProperties)
agcls.AgTypeNameMap["ITimeToolTimeProperties"] = ITimeToolTimeProperties

class IAnalysisWorkbenchTypeInfo(object):
    """Provides information about the type of VGT components."""
    _uuid = "{67E20A46-9550-4A68-9276-697DC821A23A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTypeDescription"] = _raise_uninitialized_error
        self.__dict__["_GetTypeName"] = _raise_uninitialized_error
        self.__dict__["_GetShortTypeDescription"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchTypeInfo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchTypeInfo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchTypeInfo = agcom.GUID(IAnalysisWorkbenchTypeInfo._uuid)
        vtable_offset_local = IAnalysisWorkbenchTypeInfo._vtable_offset - 1
        self.__dict__["_GetTypeDescription"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchTypeInfo, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTypeName"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchTypeInfo, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetShortTypeDescription"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchTypeInfo, vtable_offset_local+3, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchTypeInfo.__dict__ and type(IAnalysisWorkbenchTypeInfo.__dict__[attrname]) == property:
            return IAnalysisWorkbenchTypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchTypeInfo.")
    
    @property
    def TypeDescription(self) -> str:
        """Return the type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def TypeName(self) -> str:
        """Return the type name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShortTypeDescription(self) -> str:
        """Return the short type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShortTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{67E20A46-9550-4A68-9276-697DC821A23A}", IAnalysisWorkbenchTypeInfo)
agcls.AgTypeNameMap["IAnalysisWorkbenchTypeInfo"] = IAnalysisWorkbenchTypeInfo

class IAnalysisWorkbenchRefTo(object):
    """A base interface for all VGT component references."""
    _uuid = "{2F3A17A6-4304-4565-BC1C-7A064DCFE310}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchRefTo = agcom.GUID(IAnalysisWorkbenchRefTo._uuid)
        vtable_offset_local = IAnalysisWorkbenchRefTo._vtable_offset - 1
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchRefTo, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchRefTo.__dict__ and type(IAnalysisWorkbenchRefTo.__dict__[attrname]) == property:
            return IAnalysisWorkbenchRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchRefTo.")
    
    @property
    def Path(self) -> str:
        """Returns a path to the referenced VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2F3A17A6-4304-4565-BC1C-7A064DCFE310}", IAnalysisWorkbenchRefTo)
agcls.AgTypeNameMap["IAnalysisWorkbenchRefTo"] = IAnalysisWorkbenchRefTo

class IAnalysisWorkbenchTemplate(object):
    """The IAgCrdnTemplate interface enables to obtain information about the STK class that owns the VGT component."""
    _uuid = "{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetClassName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchTemplate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchTemplate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchTemplate = agcom.GUID(IAnalysisWorkbenchTemplate._uuid)
        vtable_offset_local = IAnalysisWorkbenchTemplate._vtable_offset - 1
        self.__dict__["_GetClassName"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchTemplate, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchTemplate.__dict__ and type(IAnalysisWorkbenchTemplate.__dict__[attrname]) == property:
            return IAnalysisWorkbenchTemplate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchTemplate.")
    
    @property
    def ClassName(self) -> str:
        """Returns a class name (i.e. 'Satellite', 'Facility', etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClassName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}", IAnalysisWorkbenchTemplate)
agcls.AgTypeNameMap["IAnalysisWorkbenchTemplate"] = IAnalysisWorkbenchTemplate

class IAnalysisWorkbenchInstance(object):
    """The IAgCrdnInstance interface enables to obtain information about the parent object that owns the VGT component."""
    _uuid = "{17633665-9601-4FFF-8227-4D5DF0AAEA06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInstancePath"] = _raise_uninitialized_error
        self.__dict__["_GetTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchInstance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchInstance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchInstance = agcom.GUID(IAnalysisWorkbenchInstance._uuid)
        vtable_offset_local = IAnalysisWorkbenchInstance._vtable_offset - 1
        self.__dict__["_GetInstancePath"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchInstance, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTemplate"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchInstance, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchInstance.__dict__ and type(IAnalysisWorkbenchInstance.__dict__[attrname]) == property:
            return IAnalysisWorkbenchInstance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchInstance.")
    
    @property
    def InstancePath(self) -> str:
        """Returns a path to the parent object that owns the VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInstancePath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Template(self) -> "IAnalysisWorkbenchComponent":
        """Returns a template object the VGT component was created from or null if the VGT component was not created from a template."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{17633665-9601-4FFF-8227-4D5DF0AAEA06}", IAnalysisWorkbenchInstance)
agcls.AgTypeNameMap["IAnalysisWorkbenchInstance"] = IAnalysisWorkbenchInstance

class IVectorGeometryToolPointRefTo(object):
    """Represents a reference to a VGT point."""
    _uuid = "{B553DE32-05C9-4944-918A-90552E039DBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointRefTo = agcom.GUID(IVectorGeometryToolPointRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolPointRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointRefTo.__dict__ and type(IVectorGeometryToolPointRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolPointRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new point."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPoint(self, point:"IVectorGeometryToolPoint") -> None:
        """Sets a new point."""
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    def GetPoint(self) -> "IVectorGeometryToolPoint":
        """Returns the actual point object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, point:"IVectorGeometryToolPoint") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_point.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B553DE32-05C9-4944-918A-90552E039DBE}", IVectorGeometryToolPointRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolPointRefTo"] = IVectorGeometryToolPointRefTo

class IVectorGeometryToolVectorRefTo(object):
    """Represents a reference to a VGT vector."""
    _uuid = "{EDF2E070-340E-456C-BDA8-BE9B9B40E728}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorRefTo = agcom.GUID(IVectorGeometryToolVectorRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolVectorRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorRefTo.__dict__ and type(IVectorGeometryToolVectorRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new vector."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetVector(self, vector:"IVectorGeometryToolVector") -> None:
        """Sets a new vector."""
        with agmarshall.AgInterface_in_arg(vector, IVectorGeometryToolVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    def GetVector(self) -> "IVectorGeometryToolVector":
        """Returns the actual vector object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, vector:"IVectorGeometryToolVector") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(vector, IVectorGeometryToolVector) as arg_vector, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_vector.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EDF2E070-340E-456C-BDA8-BE9B9B40E728}", IVectorGeometryToolVectorRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolVectorRefTo"] = IVectorGeometryToolVectorRefTo

class IVectorGeometryToolAxesRefTo(object):
    """Represents a reference to a VGT axes."""
    _uuid = "{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesRefTo = agcom.GUID(IVectorGeometryToolAxesRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolAxesRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesRefTo.__dict__ and type(IVectorGeometryToolAxesRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new axes."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAxes(self, axes:"IVectorGeometryToolAxes") -> None:
        """Sets a new axes."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    def GetAxes(self) -> "IVectorGeometryToolAxes":
        """Returns the actual axes object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, axes:"IVectorGeometryToolAxes") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_axes.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}", IVectorGeometryToolAxesRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolAxesRefTo"] = IVectorGeometryToolAxesRefTo

class IVectorGeometryToolAngleRefTo(object):
    """Represents a reference to a VGT angle."""
    _uuid = "{7A9D809F-D819-4458-9855-2DA8507F6E57}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleRefTo = agcom.GUID(IVectorGeometryToolAngleRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolAngleRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleRefTo.__dict__ and type(IVectorGeometryToolAngleRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new angle."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAngle(self, angle:"IVectorGeometryToolAngle") -> None:
        """Sets a new angle."""
        with agmarshall.AgInterface_in_arg(angle, IVectorGeometryToolAngle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    def GetAngle(self) -> "IVectorGeometryToolAngle":
        """Returns the actual angle object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, angle:"IVectorGeometryToolAngle") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(angle, IVectorGeometryToolAngle) as arg_angle, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_angle.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7A9D809F-D819-4458-9855-2DA8507F6E57}", IVectorGeometryToolAngleRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolAngleRefTo"] = IVectorGeometryToolAngleRefTo

class IVectorGeometryToolSystemRefTo(object):
    """Represents a reference to a VGT system."""
    _uuid = "{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSystem"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemRefTo = agcom.GUID(IVectorGeometryToolSystemRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolSystemRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemRefTo.__dict__ and type(IVectorGeometryToolSystemRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new system."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetSystem(self, system:"IVectorGeometryToolSystem") -> None:
        """Sets a new system."""
        with agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system:
            agcls.evaluate_hresult(self.__dict__["_SetSystem"](arg_system.COM_val))

    def GetSystem(self) -> "IVectorGeometryToolSystem":
        """Returns the actual system object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, system:"IVectorGeometryToolSystem") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(system, IVectorGeometryToolSystem) as arg_system, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_system.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}", IVectorGeometryToolSystemRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolSystemRefTo"] = IVectorGeometryToolSystemRefTo

class IVectorGeometryToolPlaneRefTo(object):
    """Represents a reference to a VGT plane."""
    _uuid = "{CE3D70F2-61E0-4A23-803F-A734005DC36D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPlane"] = _raise_uninitialized_error
        self.__dict__["_GetPlane"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneRefTo = agcom.GUID(IVectorGeometryToolPlaneRefTo._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneRefTo.__dict__ and type(IVectorGeometryToolPlaneRefTo.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new plane using a specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPlane(self, plane:"IVectorGeometryToolPlane") -> None:
        """Sets a new plane."""
        with agmarshall.AgInterface_in_arg(plane, IVectorGeometryToolPlane) as arg_plane:
            agcls.evaluate_hresult(self.__dict__["_SetPlane"](arg_plane.COM_val))

    def GetPlane(self) -> "IVectorGeometryToolPlane":
        """Returns the actual plane object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, plane:"IVectorGeometryToolPlane") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(plane, IVectorGeometryToolPlane) as arg_plane, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_plane.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE3D70F2-61E0-4A23-803F-A734005DC36D}", IVectorGeometryToolPlaneRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneRefTo"] = IVectorGeometryToolPlaneRefTo

class IVectorGeometryToolAxesLabels(object):
    """Allows configuring the VGT axes labels."""
    _uuid = "{0CD79528-D932-4473-9CC4-0BF5C936A6CD}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLabelX"] = _raise_uninitialized_error
        self.__dict__["_SetLabelX"] = _raise_uninitialized_error
        self.__dict__["_GetLabelY"] = _raise_uninitialized_error
        self.__dict__["_SetLabelY"] = _raise_uninitialized_error
        self.__dict__["_GetLabelZ"] = _raise_uninitialized_error
        self.__dict__["_SetLabelZ"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesLabels = agcom.GUID(IVectorGeometryToolAxesLabels._uuid)
        vtable_offset_local = IVectorGeometryToolAxesLabels._vtable_offset - 1
        self.__dict__["_GetLabelX"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelX"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLabelY"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelY"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetLabelZ"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelZ"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLabels, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesLabels.__dict__ and type(IVectorGeometryToolAxesLabels.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesLabels.")
    
    @property
    def LabelX(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelX.setter
    def LabelX(self, labelX:str) -> None:
        with agmarshall.BSTR_arg(labelX) as arg_labelX:
            agcls.evaluate_hresult(self.__dict__["_SetLabelX"](arg_labelX.COM_val))

    @property
    def LabelY(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelY.setter
    def LabelY(self, labelY:str) -> None:
        with agmarshall.BSTR_arg(labelY) as arg_labelY:
            agcls.evaluate_hresult(self.__dict__["_SetLabelY"](arg_labelY.COM_val))

    @property
    def LabelZ(self) -> str:
        """Specify a Z axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelZ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelZ.setter
    def LabelZ(self, labelZ:str) -> None:
        with agmarshall.BSTR_arg(labelZ) as arg_labelZ:
            agcls.evaluate_hresult(self.__dict__["_SetLabelZ"](arg_labelZ.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0CD79528-D932-4473-9CC4-0BF5C936A6CD}", IVectorGeometryToolAxesLabels)
agcls.AgTypeNameMap["IVectorGeometryToolAxesLabels"] = IVectorGeometryToolAxesLabels

class IVectorGeometryToolPlaneLabels(object):
    """Allows configuring the X and Y axes labels."""
    _uuid = "{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetYAxisLabel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneLabels = agcom.GUID(IVectorGeometryToolPlaneLabels._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneLabels._vtable_offset - 1
        self.__dict__["_GetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneLabels, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneLabels.__dict__ and type(IVectorGeometryToolPlaneLabels.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneLabels.")
    
    @property
    def XAxisLabel(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @XAxisLabel.setter
    def XAxisLabel(self, xAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(xAxisLabel) as arg_xAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetXAxisLabel"](arg_xAxisLabel.COM_val))

    @property
    def YAxisLabel(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxisLabel.setter
    def YAxisLabel(self, yAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(yAxisLabel) as arg_yAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetYAxisLabel"](arg_yAxisLabel.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}", IVectorGeometryToolPlaneLabels)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneLabels"] = IVectorGeometryToolPlaneLabels

class IVectorGeometryToolAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    _uuid = "{19991E4F-F368-41CD-AE27-96CF11EC963F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAlignmentReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlignmentDirection"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesAlignedAndConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesAlignedAndConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesAlignedAndConstrained = agcom.GUID(IVectorGeometryToolAxesAlignedAndConstrained._uuid)
        vtable_offset_local = IVectorGeometryToolAxesAlignedAndConstrained._vtable_offset - 1
        self.__dict__["_GetAlignmentReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAlignedAndConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAlignedAndConstrained, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAlignmentDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAlignedAndConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAlignedAndConstrained, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesAlignedAndConstrained.__dict__ and type(IVectorGeometryToolAxesAlignedAndConstrained.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesAlignedAndConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesAlignedAndConstrained.")
    
    @property
    def AlignmentReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify an alignment reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a constraint reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AlignmentDirection(self) -> "IDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintDirection(self) -> "IDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{19991E4F-F368-41CD-AE27-96CF11EC963F}", IVectorGeometryToolAxesAlignedAndConstrained)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAlignedAndConstrained"] = IVectorGeometryToolAxesAlignedAndConstrained

class IVectorGeometryToolAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    _uuid = "{0096F935-281A-4EC9-92A4-7400BD2DEF60}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetRotationAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOffsetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetFixedOffsetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesAngularOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesAngularOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesAngularOffset = agcom.GUID(IVectorGeometryToolAxesAngularOffset._uuid)
        vtable_offset_local = IVectorGeometryToolAxesAngularOffset._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAngularOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAngularOffset, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAngularOffset, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAngularOffset, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAngularOffset, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesAngularOffset.__dict__ and type(IVectorGeometryToolAxesAngularOffset.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesAngularOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesAngularOffset.")
    
    @property
    def SpinVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationAngle(self) -> "IVectorGeometryToolAngleRefTo":
        """Specify a rotational angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOffsetAngle(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOffsetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FixedOffsetAngle.setter
    def FixedOffsetAngle(self, fixedOffsetAngle:float) -> None:
        with agmarshall.DOUBLE_arg(fixedOffsetAngle) as arg_fixedOffsetAngle:
            agcls.evaluate_hresult(self.__dict__["_SetFixedOffsetAngle"](arg_fixedOffsetAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0096F935-281A-4EC9-92A4-7400BD2DEF60}", IVectorGeometryToolAxesAngularOffset)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAngularOffset"] = IVectorGeometryToolAxesAngularOffset

class IVectorGeometryToolAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""
    _uuid = "{CEB9E066-A9F8-4B74-AF7A-0301BF611843}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesFixedAtEpoch = agcom.GUID(IVectorGeometryToolAxesFixedAtEpoch._uuid)
        vtable_offset_local = IVectorGeometryToolAxesFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixedAtEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixedAtEpoch, vtable_offset_local+4, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesFixedAtEpoch.__dict__ and type(IVectorGeometryToolAxesFixedAtEpoch.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesFixedAtEpoch.")
    
    @property
    def SourceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a source axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CEB9E066-A9F8-4B74-AF7A-0301BF611843}", IVectorGeometryToolAxesFixedAtEpoch)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFixedAtEpoch"] = IVectorGeometryToolAxesFixedAtEpoch

class IVectorGeometryToolAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""
    _uuid = "{72FD97D1-AE64-45D2-973E-E4F491B474AC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesBPlane = agcom.GUID(IVectorGeometryToolAxesBPlane._uuid)
        vtable_offset_local = IVectorGeometryToolAxesBPlane._vtable_offset - 1
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesBPlane, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesBPlane, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesBPlane, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesBPlane.__dict__ and type(IVectorGeometryToolAxesBPlane.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesBPlane.")
    
    @property
    def Trajectory(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72FD97D1-AE64-45D2-973E-E4F491B474AC}", IVectorGeometryToolAxesBPlane)
agcls.AgTypeNameMap["IVectorGeometryToolAxesBPlane"] = IVectorGeometryToolAxesBPlane

class IVectorGeometryToolAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""
    _uuid = "{F5A690E6-0304-49E0-BAB5-229F848B0401}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesCustomScript = agcom.GUID(IVectorGeometryToolAxesCustomScript._uuid)
        vtable_offset_local = IVectorGeometryToolAxesCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCustomScript, vtable_offset_local+3, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesCustomScript.__dict__ and type(IVectorGeometryToolAxesCustomScript.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filename(self) -> str:
        """Can be MATLAB (.m or .dll), VB Script (.vbs) or Perl (.pl) script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F5A690E6-0304-49E0-BAB5-229F848B0401}", IVectorGeometryToolAxesCustomScript)
agcls.AgTypeNameMap["IVectorGeometryToolAxesCustomScript"] = IVectorGeometryToolAxesCustomScript

class IVectorGeometryToolAxesAttitudeFile(object):
    """Axes specified by data from a file."""
    _uuid = "{E4A194BD-44ED-498F-ACB2-9911C19F52E8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesAttitudeFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesAttitudeFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesAttitudeFile = agcom.GUID(IVectorGeometryToolAxesAttitudeFile._uuid)
        vtable_offset_local = IVectorGeometryToolAxesAttitudeFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAttitudeFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAttitudeFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesAttitudeFile.__dict__ and type(IVectorGeometryToolAxesAttitudeFile.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesAttitudeFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesAttitudeFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E4A194BD-44ED-498F-ACB2-9911C19F52E8}", IVectorGeometryToolAxesAttitudeFile)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAttitudeFile"] = IVectorGeometryToolAxesAttitudeFile

class IVectorGeometryToolAxesFixed(object):
    """Axes fixed in reference axes."""
    _uuid = "{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesFixed = agcom.GUID(IVectorGeometryToolAxesFixed._uuid)
        vtable_offset_local = IVectorGeometryToolAxesFixed._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixed, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOrientation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFixed, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesFixed.__dict__ and type(IVectorGeometryToolAxesFixed.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesFixed.")
    
    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOrientation(self) -> "IOrientation":
        """Specify a desired orientation and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}", IVectorGeometryToolAxesFixed)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFixed"] = IVectorGeometryToolAxesFixed

class IVectorGeometryToolAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{3A20DEC4-2D89-416C-8B47-D76E859763B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesModelAttach = agcom.GUID(IVectorGeometryToolAxesModelAttach._uuid)
        vtable_offset_local = IVectorGeometryToolAxesModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesModelAttach.__dict__ and type(IVectorGeometryToolAxesModelAttach.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A20DEC4-2D89-416C-8B47-D76E859763B0}", IVectorGeometryToolAxesModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolAxesModelAttach"] = IVectorGeometryToolAxesModelAttach

class IVectorGeometryToolAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    _uuid = "{ECB36015-B534-40C6-B50F-298217335C38}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_SetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_GetSpinRate"] = _raise_uninitialized_error
        self.__dict__["_SetSpinRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesSpinning._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesSpinning from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesSpinning = agcom.GUID(IVectorGeometryToolAxesSpinning._uuid)
        vtable_offset_local = IVectorGeometryToolAxesSpinning._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetSpinRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpinRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesSpinning, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesSpinning.__dict__ and type(IVectorGeometryToolAxesSpinning.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesSpinning.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesSpinning.")
    
    @property
    def SpinVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def InitialOffset(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitialOffset.setter
    def InitialOffset(self, initialOffset:float) -> None:
        with agmarshall.DOUBLE_arg(initialOffset) as arg_initialOffset:
            agcls.evaluate_hresult(self.__dict__["_SetInitialOffset"](arg_initialOffset.COM_val))

    @property
    def SpinRate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpinRate.setter
    def SpinRate(self, spinRate:float) -> None:
        with agmarshall.DOUBLE_arg(spinRate) as arg_spinRate:
            agcls.evaluate_hresult(self.__dict__["_SetSpinRate"](arg_spinRate.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ECB36015-B534-40C6-B50F-298217335C38}", IVectorGeometryToolAxesSpinning)
agcls.AgTypeNameMap["IVectorGeometryToolAxesSpinning"] = IVectorGeometryToolAxesSpinning

class IVectorGeometryToolAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""
    _uuid = "{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesOnSurface = agcom.GUID(IVectorGeometryToolAxesOnSurface._uuid)
        vtable_offset_local = IVectorGeometryToolAxesOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesOnSurface, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesOnSurface, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesOnSurface.__dict__ and type(IVectorGeometryToolAxesOnSurface.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesOnSurface.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseMSL(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}", IVectorGeometryToolAxesOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolAxesOnSurface"] = IVectorGeometryToolAxesOnSurface

class IVectorGeometryToolAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    _uuid = "{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectoryPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectoryAxesType"] = _raise_uninitialized_error
        self.__dict__["_SetTrajectoryAxesType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesTrajectory = agcom.GUID(IVectorGeometryToolAxesTrajectory._uuid)
        vtable_offset_local = IVectorGeometryToolAxesTrajectory._vtable_offset - 1
        self.__dict__["_GetTrajectoryPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTrajectory, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTrajectory, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesTrajectory.__dict__ and type(IVectorGeometryToolAxesTrajectory.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesTrajectory.")
    
    @property
    def TrajectoryPoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TrajectoryAxesType(self) -> "AgECrdnTrajectoryAxesType":
        """Specify a type of the trajectory's coordinate frame."""
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryAxesType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TrajectoryAxesType.setter
    def TrajectoryAxesType(self, trajectoryAxesType:"AgECrdnTrajectoryAxesType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType, trajectoryAxesType) as arg_trajectoryAxesType:
            agcls.evaluate_hresult(self.__dict__["_SetTrajectoryAxesType"](arg_trajectoryAxesType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}", IVectorGeometryToolAxesTrajectory)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTrajectory"] = IVectorGeometryToolAxesTrajectory

class IVectorGeometryToolAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    _uuid = "{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPrimaryCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesLagrangeLibration = agcom.GUID(IVectorGeometryToolAxesLagrangeLibration._uuid)
        vtable_offset_local = IVectorGeometryToolAxesLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetPrimaryCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesLagrangeLibration.__dict__ and type(IVectorGeometryToolAxesLagrangeLibration.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesLagrangeLibration.")
    
    @property
    def PrimaryCentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a primary central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPrimaryCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "IAnalysisWorkbenchCentralBodyCollection":
        """Specify secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}", IVectorGeometryToolAxesLagrangeLibration)
agcls.AgTypeNameMap["IVectorGeometryToolAxesLagrangeLibration"] = IVectorGeometryToolAxesLagrangeLibration

class IVectorGeometryToolAxesCommonTasks(object):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateTopocentricAxesQuaternion"] = _raise_uninitialized_error
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = _raise_uninitialized_error
        self.__dict__["_CreateFixed"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesCommonTasks = agcom.GUID(IVectorGeometryToolAxesCommonTasks._uuid)
        vtable_offset_local = IVectorGeometryToolAxesCommonTasks._vtable_offset - 1
        self.__dict__["_CreateTopocentricAxesQuaternion"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixed"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCommonTasks, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesCommonTasks, vtable_offset_local+4, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesCommonTasks.__dict__ and type(IVectorGeometryToolAxesCommonTasks.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesCommonTasks.")
    
    def CreateTopocentricAxesQuaternion(self, originPoint:"IVectorGeometryToolPoint", qx:float, qy:float, qz:float, qs:float) -> "IVectorGeometryToolAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IVectorGeometryToolPoint) as arg_originPoint, \
             agmarshall.DOUBLE_arg(qx) as arg_qx, \
             agmarshall.DOUBLE_arg(qy) as arg_qy, \
             agmarshall.DOUBLE_arg(qz) as arg_qz, \
             agmarshall.DOUBLE_arg(qs) as arg_qs, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesQuaternion"](arg_originPoint.COM_val, arg_qx.COM_val, arg_qy.COM_val, arg_qz.COM_val, arg_qs.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateTopocentricAxesEulerAngles(self, originPoint:"IVectorGeometryToolPoint", sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> "IVectorGeometryToolAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IVectorGeometryToolPoint) as arg_originPoint, \
             agmarshall.AgEnum_arg(AgEEulerOrientationSequence, sequence) as arg_sequence, \
             agmarshall.VARIANT_arg(a) as arg_a, \
             agmarshall.VARIANT_arg(b) as arg_b, \
             agmarshall.VARIANT_arg(c) as arg_c, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesEulerAngles"](arg_originPoint.COM_val, arg_sequence.COM_val, arg_a.COM_val, arg_b.COM_val, arg_c.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixed(self, referenceAxes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolAxesFixed":
        """Creates non-persistent fixed axes based on specified axes."""
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixed"](arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, axes:"IVectorGeometryToolAxes", referenceAxes:"IVectorGeometryToolAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "ITimeToolAxesSamplingResult":
        """Computes and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(axes, IVectorGeometryToolAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_axes.COM_val, arg_referenceAxes.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}", IVectorGeometryToolAxesCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolAxesCommonTasks"] = IVectorGeometryToolAxesCommonTasks

class IVectorGeometryToolAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    _uuid = "{193F4A55-5E79-43A1-8A2C-3C001F7608A5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesAtTimeInstant = agcom.GUID(IVectorGeometryToolAxesAtTimeInstant._uuid)
        vtable_offset_local = IVectorGeometryToolAxesAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesAtTimeInstant.__dict__ and type(IVectorGeometryToolAxesAtTimeInstant.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceAxes(self) -> "IVectorGeometryToolAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceAxes.setter
    def SourceAxes(self, sourceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(sourceAxes, IVectorGeometryToolAxes) as arg_sourceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetSourceAxes"](arg_sourceAxes.COM_val))

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{193F4A55-5E79-43A1-8A2C-3C001F7608A5}", IVectorGeometryToolAxesAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAtTimeInstant"] = IVectorGeometryToolAxesAtTimeInstant

class IVectorGeometryToolAxesPlugin(object):
    """A VGT axes plugin."""
    _uuid = "{E63FD5E1-B844-4893-9E4C-3F02210AE74C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesPlugin = agcom.GUID(IVectorGeometryToolAxesPlugin._uuid)
        vtable_offset_local = IVectorGeometryToolAxesPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesPlugin.__dict__ and type(IVectorGeometryToolAxesPlugin.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E63FD5E1-B844-4893-9E4C-3F02210AE74C}", IVectorGeometryToolAxesPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolAxesPlugin"] = IVectorGeometryToolAxesPlugin

class IVectorGeometryToolAngleBetweenVectors(object):
    """An angle between two vectors."""
    _uuid = "{B3986E8E-A8CB-414F-8214-71C53ED00740}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleBetweenVectors._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleBetweenVectors from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleBetweenVectors = agcom.GUID(IVectorGeometryToolAngleBetweenVectors._uuid)
        vtable_offset_local = IVectorGeometryToolAngleBetweenVectors._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleBetweenVectors, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleBetweenVectors, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleBetweenVectors.__dict__ and type(IVectorGeometryToolAngleBetweenVectors.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleBetweenVectors.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleBetweenVectors.")
    
    @property
    def FromVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3986E8E-A8CB-414F-8214-71C53ED00740}", IVectorGeometryToolAngleBetweenVectors)
agcls.AgTypeNameMap["IVectorGeometryToolAngleBetweenVectors"] = IVectorGeometryToolAngleBetweenVectors

class IVectorGeometryToolAngleBetweenPlanes(object):
    """An angle between two planes."""
    _uuid = "{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromPlane"] = _raise_uninitialized_error
        self.__dict__["_GetToPlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleBetweenPlanes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleBetweenPlanes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleBetweenPlanes = agcom.GUID(IVectorGeometryToolAngleBetweenPlanes._uuid)
        vtable_offset_local = IVectorGeometryToolAngleBetweenPlanes._vtable_offset - 1
        self.__dict__["_GetFromPlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleBetweenPlanes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToPlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleBetweenPlanes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleBetweenPlanes.__dict__ and type(IVectorGeometryToolAngleBetweenPlanes.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleBetweenPlanes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleBetweenPlanes.")
    
    @property
    def FromPlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToPlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}", IVectorGeometryToolAngleBetweenPlanes)
agcls.AgTypeNameMap["IVectorGeometryToolAngleBetweenPlanes"] = IVectorGeometryToolAngleBetweenPlanes

class IVectorGeometryToolAngleDihedral(object):
    """An angle between two vectors about an axis."""
    _uuid = "{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        self.__dict__["_GetPoleAbout"] = _raise_uninitialized_error
        self.__dict__["_GetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_SetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_GetSignedAngle"] = _raise_uninitialized_error
        self.__dict__["_SetSignedAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleDihedral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleDihedral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleDihedral = agcom.GUID(IVectorGeometryToolAngleDihedral._uuid)
        vtable_offset_local = IVectorGeometryToolAngleDihedral._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPoleAbout"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleDihedral, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleDihedral.__dict__ and type(IVectorGeometryToolAngleDihedral.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleDihedral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleDihedral.")
    
    @property
    def FromVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a first vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a second vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PoleAbout(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a vector about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoleAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CounterClockwiseRotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCounterClockwiseRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, counterClockwiseRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(counterClockwiseRotation) as arg_counterClockwiseRotation:
            agcls.evaluate_hresult(self.__dict__["_SetCounterClockwiseRotation"](arg_counterClockwiseRotation.COM_val))

    @property
    def SignedAngle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignedAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignedAngle.setter
    def SignedAngle(self, signedAngle:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(signedAngle) as arg_signedAngle:
            agcls.evaluate_hresult(self.__dict__["_SetSignedAngle"](arg_signedAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}", IVectorGeometryToolAngleDihedral)
agcls.AgTypeNameMap["IVectorGeometryToolAngleDihedral"] = IVectorGeometryToolAngleDihedral

class IVectorGeometryToolAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    _uuid = "{9E842F77-B3A8-475C-96AA-E692B35E8E05}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromAxes"] = _raise_uninitialized_error
        self.__dict__["_GetToAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDirection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleRotation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleRotation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleRotation = agcom.GUID(IVectorGeometryToolAngleRotation._uuid)
        vtable_offset_local = IVectorGeometryToolAngleRotation._vtable_offset - 1
        self.__dict__["_GetFromAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRotation, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRotation, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRotation, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleRotation, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleRotation.__dict__ and type(IVectorGeometryToolAngleRotation.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleRotation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleRotation.")
    
    @property
    def FromAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify an axes to rotate from."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify an axes to rotate to."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceDirection(self) -> "AgECrdnDisplayAxisSelector":
        """Specify a rotation direction."""
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, referenceDirection:"AgECrdnDisplayAxisSelector") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector, referenceDirection) as arg_referenceDirection:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDirection"](arg_referenceDirection.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9E842F77-B3A8-475C-96AA-E692B35E8E05}", IVectorGeometryToolAngleRotation)
agcls.AgTypeNameMap["IVectorGeometryToolAngleRotation"] = IVectorGeometryToolAngleRotation

class IVectorGeometryToolAngleToPlane(object):
    """An angle between a vector and a plane."""
    _uuid = "{DDFA25AD-174D-407B-B90C-747B3E43F7C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetSigned"] = _raise_uninitialized_error
        self.__dict__["_SetSigned"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleToPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleToPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleToPlane = agcom.GUID(IVectorGeometryToolAngleToPlane._uuid)
        vtable_offset_local = IVectorGeometryToolAngleToPlane._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleToPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleToPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetSigned"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleToPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSigned"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleToPlane, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleToPlane.__dict__ and type(IVectorGeometryToolAngleToPlane.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleToPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleToPlane.")
    
    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Signed(self) -> "AgECrdnSignedAngleType":
        """Controls whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSigned"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Signed.setter
    def Signed(self, signed:"AgECrdnSignedAngleType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType, signed) as arg_signed:
            agcls.evaluate_hresult(self.__dict__["_SetSigned"](arg_signed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DDFA25AD-174D-407B-B90C-747B3E43F7C9}", IVectorGeometryToolAngleToPlane)
agcls.AgTypeNameMap["IVectorGeometryToolAngleToPlane"] = IVectorGeometryToolAngleToPlane

class IVectorGeometryToolPlaneNormal(object):
    """A plane normal to a vector at a given point."""
    _uuid = "{AAF66E5C-B310-4387-BDAE-D45F24F226BC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneNormal = agcom.GUID(IVectorGeometryToolPlaneNormal._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneNormal._vtable_offset - 1
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneNormal, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneNormal.__dict__ and type(IVectorGeometryToolPlaneNormal.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneNormal.")
    
    @property
    def NormalVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AAF66E5C-B310-4387-BDAE-D45F24F226BC}", IVectorGeometryToolPlaneNormal)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneNormal"] = IVectorGeometryToolPlaneNormal

class IVectorGeometryToolPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""
    _uuid = "{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetQuadrant"] = _raise_uninitialized_error
        self.__dict__["_SetQuadrant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneQuadrant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneQuadrant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneQuadrant = agcom.GUID(IVectorGeometryToolPlaneQuadrant._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneQuadrant._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneQuadrant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetQuadrant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneQuadrant, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetQuadrant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneQuadrant, vtable_offset_local+3, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneQuadrant.__dict__ and type(IVectorGeometryToolPlaneQuadrant.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneQuadrant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneQuadrant.")
    
    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quadrant(self) -> "AgECrdnQuadrantType":
        """Specify a quadrant."""
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuadrant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Quadrant.setter
    def Quadrant(self, quadrant:"AgECrdnQuadrantType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType, quadrant) as arg_quadrant:
            agcls.evaluate_hresult(self.__dict__["_SetQuadrant"](arg_quadrant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}", IVectorGeometryToolPlaneQuadrant)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneQuadrant"] = IVectorGeometryToolPlaneQuadrant

class IVectorGeometryToolPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    _uuid = "{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneTrajectory = agcom.GUID(IVectorGeometryToolPlaneTrajectory._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTrajectory, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTrajectory, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneTrajectory.__dict__ and type(IVectorGeometryToolPlaneTrajectory.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneTrajectory.")
    
    @property
    def Point(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}", IVectorGeometryToolPlaneTrajectory)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTrajectory"] = IVectorGeometryToolPlaneTrajectory

class IVectorGeometryToolPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""
    _uuid = "{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointA"] = _raise_uninitialized_error
        self.__dict__["_GetPointB"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneTriad._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneTriad from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneTriad = agcom.GUID(IVectorGeometryToolPlaneTriad._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneTriad._vtable_offset - 1
        self.__dict__["_GetPointA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTriad, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTriad, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTriad, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTriad, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTriad, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneTriad.__dict__ and type(IVectorGeometryToolPlaneTriad.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneTriad.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneTriad.")
    
    @property
    def PointA(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a point A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointB(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a point B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}", IVectorGeometryToolPlaneTriad)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTriad"] = IVectorGeometryToolPlaneTriad

class IVectorGeometryToolPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""
    _uuid = "{345761f0-0ace-494c-8d9c-0f3e3af9c2da}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector2"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneTwoVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneTwoVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneTwoVector = agcom.GUID(IVectorGeometryToolPlaneTwoVector._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneTwoVector._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTwoVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetVector2"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTwoVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneTwoVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneTwoVector.__dict__ and type(IVectorGeometryToolPlaneTwoVector.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneTwoVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneTwoVector.")
    
    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Vector2(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{345761f0-0ace-494c-8d9c-0f3e3af9c2da}", IVectorGeometryToolPlaneTwoVector)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTwoVector"] = IVectorGeometryToolPlaneTwoVector

class IVectorGeometryToolPointBPlane(object):
    """B-Plane point using the selected target body."""
    _uuid = "{CC3B797F-5327-4D04-911D-8ED499E056AF}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointBPlane = agcom.GUID(IVectorGeometryToolPointBPlane._uuid)
        vtable_offset_local = IVectorGeometryToolPointBPlane._vtable_offset - 1
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointBPlane, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointBPlane.__dict__ and type(IVectorGeometryToolPointBPlane.__dict__[attrname]) == property:
            return IVectorGeometryToolPointBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointBPlane.")
    
    @property
    def TargetBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Trajectory(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnPointBPlaneType":
        """Specify a point type."""
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnPointBPlaneType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC3B797F-5327-4D04-911D-8ED499E056AF}", IVectorGeometryToolPointBPlane)
agcls.AgTypeNameMap["IVectorGeometryToolPointBPlane"] = IVectorGeometryToolPointBPlane

class IVectorGeometryToolPointFile(object):
    """Point specified by data from a file."""
    _uuid = "{9612277C-2238-42BD-89D7-E54D7701D8F2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointFile = agcom.GUID(IVectorGeometryToolPointFile._uuid)
        vtable_offset_local = IVectorGeometryToolPointFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointFile.__dict__ and type(IVectorGeometryToolPointFile.__dict__[attrname]) == property:
            return IVectorGeometryToolPointFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9612277C-2238-42BD-89D7-E54D7701D8F2}", IVectorGeometryToolPointFile)
agcls.AgTypeNameMap["IVectorGeometryToolPointFile"] = IVectorGeometryToolPointFile

class IVectorGeometryToolPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    _uuid = "{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetFixedPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointFixedInSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointFixedInSystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointFixedInSystem = agcom.GUID(IVectorGeometryToolPointFixedInSystem._uuid)
        vtable_offset_local = IVectorGeometryToolPointFixedInSystem._vtable_offset - 1
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFixedInSystem, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFixedInSystem, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointFixedInSystem.__dict__ and type(IVectorGeometryToolPointFixedInSystem.__dict__[attrname]) == property:
            return IVectorGeometryToolPointFixedInSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointFixedInSystem.")
    
    @property
    def Reference(self) -> "IVectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedPoint(self) -> "IPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}", IVectorGeometryToolPointFixedInSystem)
agcls.AgTypeNameMap["IVectorGeometryToolPointFixedInSystem"] = IVectorGeometryToolPointFixedInSystem

class IVectorGeometryToolPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    _uuid = "{7FDF037E-1367-4590-A330-660EF3442DE1}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointGrazing = agcom.GUID(IVectorGeometryToolPointGrazing._uuid)
        vtable_offset_local = IVectorGeometryToolPointGrazing._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGrazing, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGrazing, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGrazing, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointGrazing.__dict__ and type(IVectorGeometryToolPointGrazing.__dict__[attrname]) == property:
            return IVectorGeometryToolPointGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointGrazing.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FDF037E-1367-4590-A330-660EF3442DE1}", IVectorGeometryToolPointGrazing)
agcls.AgTypeNameMap["IVectorGeometryToolPointGrazing"] = IVectorGeometryToolPointGrazing

class IVectorGeometryToolPointGlint(object):
    """Point on central body surface that reflects from source to observer."""
    _uuid = "{C4168949-A6F2-42B7-8019-671FF808836D}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetObserverPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointGlint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointGlint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointGlint = agcom.GUID(IVectorGeometryToolPointGlint._uuid)
        vtable_offset_local = IVectorGeometryToolPointGlint._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGlint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGlint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetObserverPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGlint, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointGlint.__dict__ and type(IVectorGeometryToolPointGlint.__dict__[attrname]) == property:
            return IVectorGeometryToolPointGlint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointGlint.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SourcePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ObserverPoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify an observer point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetObserverPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4168949-A6F2-42B7-8019-671FF808836D}", IVectorGeometryToolPointGlint)
agcls.AgTypeNameMap["IVectorGeometryToolPointGlint"] = IVectorGeometryToolPointGlint

class IVectorGeometryToolPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    _uuid = "{CC9E8B92-77D8-46A9-BD52-3DABB173913D}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetName"] = _raise_uninitialized_error
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetProbability"] = _raise_uninitialized_error
        self.__dict__["_SetProbability"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetUseProbability"] = _raise_uninitialized_error
        self.__dict__["_SetUseProbability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointCovarianceGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointCovarianceGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointCovarianceGrazing = agcom.GUID(IVectorGeometryToolPointCovarianceGrazing._uuid)
        vtable_offset_local = IVectorGeometryToolPointCovarianceGrazing._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetProbability"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetProbability"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseProbability"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseProbability"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCovarianceGrazing, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointCovarianceGrazing.__dict__ and type(IVectorGeometryToolPointCovarianceGrazing.__dict__[attrname]) == property:
            return IVectorGeometryToolPointCovarianceGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointCovarianceGrazing.")
    
    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetName(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TargetName.setter
    def TargetName(self, targetName:str) -> None:
        with agmarshall.BSTR_arg(targetName) as arg_targetName:
            agcls.evaluate_hresult(self.__dict__["_SetTargetName"](arg_targetName.COM_val))

    @property
    def Distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:float) -> None:
        with agmarshall.DOUBLE_arg(distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def Probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Probability.setter
    def Probability(self, probability:float) -> None:
        with agmarshall.DOUBLE_arg(probability) as arg_probability:
            agcls.evaluate_hresult(self.__dict__["_SetProbability"](arg_probability.COM_val))

    @property
    def Scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def UseProbability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseProbability.setter
    def UseProbability(self, useProbability:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useProbability) as arg_useProbability:
            agcls.evaluate_hresult(self.__dict__["_SetUseProbability"](arg_useProbability.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC9E8B92-77D8-46A9-BD52-3DABB173913D}", IVectorGeometryToolPointCovarianceGrazing)
agcls.AgTypeNameMap["IVectorGeometryToolPointCovarianceGrazing"] = IVectorGeometryToolPointCovarianceGrazing

class IVectorGeometryToolPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""
    _uuid = "{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointPlaneIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointPlaneIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointPlaneIntersection = agcom.GUID(IVectorGeometryToolPointPlaneIntersection._uuid)
        vtable_offset_local = IVectorGeometryToolPointPlaneIntersection._vtable_offset - 1
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlaneIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlaneIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlaneIntersection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointPlaneIntersection.__dict__ and type(IVectorGeometryToolPointPlaneIntersection.__dict__[attrname]) == property:
            return IVectorGeometryToolPointPlaneIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointPlaneIntersection.")
    
    @property
    def DirectionVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a direction vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginPoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify the origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}", IVectorGeometryToolPointPlaneIntersection)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlaneIntersection"] = IVectorGeometryToolPointPlaneIntersection

class IVectorGeometryToolPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""
    _uuid = "{AED0D41F-BB69-4672-A513-17A43B12873D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceType"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointOnSurface = agcom.GUID(IVectorGeometryToolPointOnSurface._uuid)
        vtable_offset_local = IVectorGeometryToolPointOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointOnSurface, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointOnSurface.__dict__ and type(IVectorGeometryToolPointOnSurface.__dict__[attrname]) == property:
            return IVectorGeometryToolPointOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointOnSurface.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Specify a reference shape."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def SurfaceType(self) -> "AgECrdnSurfaceType":
        """Specify a surface type."""
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceType.setter
    def SurfaceType(self, surfaceType:"AgECrdnSurfaceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType, surfaceType) as arg_surfaceType:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceType"](arg_surfaceType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AED0D41F-BB69-4672-A513-17A43B12873D}", IVectorGeometryToolPointOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolPointOnSurface"] = IVectorGeometryToolPointOnSurface

class IVectorGeometryToolPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    _uuid = "{CFEB5448-9053-44F6-BCB5-35280361131F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_GetUseScale"] = _raise_uninitialized_error
        self.__dict__["_SetUseScale"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointModelAttach = agcom.GUID(IVectorGeometryToolPointModelAttach._uuid)
        vtable_offset_local = IVectorGeometryToolPointModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointModelAttach, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUseScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointModelAttach, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointModelAttach, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointModelAttach.__dict__ and type(IVectorGeometryToolPointModelAttach.__dict__[attrname]) == property:
            return IVectorGeometryToolPointModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a model attachment point."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))

    @property
    def UseScale(self) -> bool:
        """Specify whether to use the model scale."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScale.setter
    def UseScale(self, useScale:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScale) as arg_useScale:
            agcls.evaluate_hresult(self.__dict__["_SetUseScale"](arg_useScale.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFEB5448-9053-44F6-BCB5-35280361131F}", IVectorGeometryToolPointModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolPointModelAttach"] = IVectorGeometryToolPointModelAttach

class IVectorGeometryToolPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    _uuid = "{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEntryName"] = _raise_uninitialized_error
        self.__dict__["_SetEntryName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointSatelliteCollectionEntry._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointSatelliteCollectionEntry from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointSatelliteCollectionEntry = agcom.GUID(IVectorGeometryToolPointSatelliteCollectionEntry._uuid)
        vtable_offset_local = IVectorGeometryToolPointSatelliteCollectionEntry._vtable_offset - 1
        self.__dict__["_GetEntryName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointSatelliteCollectionEntry, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetEntryName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointSatelliteCollectionEntry, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointSatelliteCollectionEntry.__dict__ and type(IVectorGeometryToolPointSatelliteCollectionEntry.__dict__[attrname]) == property:
            return IVectorGeometryToolPointSatelliteCollectionEntry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointSatelliteCollectionEntry.")
    
    @property
    def EntryName(self) -> str:
        """Specify a satellite collection entry name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEntryName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EntryName.setter
    def EntryName(self, entryName:str) -> None:
        with agmarshall.BSTR_arg(entryName) as arg_entryName:
            agcls.evaluate_hresult(self.__dict__["_SetEntryName"](arg_entryName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}", IVectorGeometryToolPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["IVectorGeometryToolPointSatelliteCollectionEntry"] = IVectorGeometryToolPointSatelliteCollectionEntry

class IVectorGeometryToolPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    _uuid = "{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointPlaneProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointPlaneProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointPlaneProjection = agcom.GUID(IVectorGeometryToolPointPlaneProjection._uuid)
        vtable_offset_local = IVectorGeometryToolPointPlaneProjection._vtable_offset - 1
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlaneProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlaneProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointPlaneProjection.__dict__ and type(IVectorGeometryToolPointPlaneProjection.__dict__[attrname]) == property:
            return IVectorGeometryToolPointPlaneProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointPlaneProjection.")
    
    @property
    def SourcePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}", IVectorGeometryToolPointPlaneProjection)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlaneProjection"] = IVectorGeometryToolPointPlaneProjection

class IVectorGeometryToolPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    _uuid = "{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointLagrangeLibration = agcom.GUID(IVectorGeometryToolPointLagrangeLibration._uuid)
        vtable_offset_local = IVectorGeometryToolPointLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointLagrangeLibration.__dict__ and type(IVectorGeometryToolPointLagrangeLibration.__dict__[attrname]) == property:
            return IVectorGeometryToolPointLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointLagrangeLibration.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "IAnalysisWorkbenchCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}", IVectorGeometryToolPointLagrangeLibration)
agcls.AgTypeNameMap["IVectorGeometryToolPointLagrangeLibration"] = IVectorGeometryToolPointLagrangeLibration

class IVectorGeometryToolPointCommonTasks(object):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{C357C0A5-3F2A-499C-83F3-6824532C969E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedInSystemCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateFixedInSystemCartesian"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointCommonTasks = agcom.GUID(IVectorGeometryToolPointCommonTasks._uuid)
        vtable_offset_local = IVectorGeometryToolPointCommonTasks._vtable_offset - 1
        self.__dict__["_CreateFixedInSystemCartographic"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixedInSystemCartesian"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCommonTasks, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointCommonTasks.__dict__ and type(IVectorGeometryToolPointCommonTasks.__dict__[attrname]) == property:
            return IVectorGeometryToolPointCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointCommonTasks.")
    
    def CreateFixedInSystemCartographic(self, referenceSystem:"IVectorGeometryToolSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IVectorGeometryToolPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartographic"](arg_referenceSystem.COM_val, arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixedInSystemCartesian(self, referenceSystem:"IVectorGeometryToolSystem", x:float, y:float, z:float) -> "IVectorGeometryToolPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem, \
             agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartesian"](arg_referenceSystem.COM_val, arg_x.COM_val, arg_y.COM_val, arg_z.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, point:"IVectorGeometryToolPoint", referenceSystem:"IVectorGeometryToolSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "ITimeToolPointSamplingResult":
        """Computes and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point, \
             agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_point.COM_val, arg_referenceSystem.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C357C0A5-3F2A-499C-83F3-6824532C969E}", IVectorGeometryToolPointCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolPointCommonTasks"] = IVectorGeometryToolPointCommonTasks

class IVectorGeometryToolPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""
    _uuid = "{C0F5946B-9467-44AC-B16A-9276CE4EA141}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_SetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_SetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetRange"] = _raise_uninitialized_error
        self.__dict__["_GetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        self.__dict__["_SetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointCentBodyIntersect._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointCentBodyIntersect from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointCentBodyIntersect = agcom.GUID(IVectorGeometryToolPointCentBodyIntersect._uuid)
        vtable_offset_local = IVectorGeometryToolPointCentBodyIntersect._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_SetRange"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+21, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_GetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCentBodyIntersect, vtable_offset_local+23, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointCentBodyIntersect.__dict__ and type(IVectorGeometryToolPointCentBodyIntersect.__dict__[attrname]) == property:
            return IVectorGeometryToolPointCentBodyIntersect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointCentBodyIntersect.")
    
    @property
    def CentralBody(self) -> str:
        """Central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IVectorGeometryToolPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def DirectionVector(self) -> "IVectorGeometryToolVector":
        """A direction vector. Can be any vector from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DirectionVector.setter
    def DirectionVector(self, directionVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(directionVector, IVectorGeometryToolVector) as arg_directionVector:
            agcls.evaluate_hresult(self.__dict__["_SetDirectionVector"](arg_directionVector.COM_val))

    @property
    def IntersectionSurface(self) -> "AgECrdnIntersectionSurface":
        """An intersection surface."""
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntersectionSurface"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntersectionSurface.setter
    def IntersectionSurface(self, intersectionSurface:"AgECrdnIntersectionSurface") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface, intersectionSurface) as arg_intersectionSurface:
            agcls.evaluate_hresult(self.__dict__["_SetIntersectionSurface"](arg_intersectionSurface.COM_val))

    @property
    def Altitude(self) -> float:
        """An altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))

    @property
    def UseRangeConstraint(self) -> bool:
        """Whether to use range constraint."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseRangeConstraint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseRangeConstraint.setter
    def UseRangeConstraint(self, useRangeConstraint:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useRangeConstraint) as arg_useRangeConstraint:
            agcls.evaluate_hresult(self.__dict__["_SetUseRangeConstraint"](arg_useRangeConstraint.COM_val))

    @property
    def MinimumRange(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumRange.setter
    def MinimumRange(self, minimumRange:float) -> None:
        with agmarshall.DOUBLE_arg(minimumRange) as arg_minimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumRange"](arg_minimumRange.COM_val))

    @property
    def MaximumRange(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumRange.setter
    def MaximumRange(self, maximumRange:float) -> None:
        with agmarshall.DOUBLE_arg(maximumRange) as arg_maximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumRange"](arg_maximumRange.COM_val))

    @property
    def UseMinimumRange(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumRange.setter
    def UseMinimumRange(self, useMinimumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumRange) as arg_useMinimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumRange"](arg_useMinimumRange.COM_val))

    @property
    def UseMaximumRange(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumRange.setter
    def UseMaximumRange(self, useMaximumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumRange) as arg_useMaximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumRange"](arg_useMaximumRange.COM_val))

    def SetRange(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg(minimum) as arg_minimum, \
             agmarshall.DOUBLE_arg(maximum) as arg_maximum:
            agcls.evaluate_hresult(self.__dict__["_SetRange"](arg_minimum.COM_val, arg_maximum.COM_val))

    @property
    def AllowIntersectionFromBelow(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowIntersectionFromBelow"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowIntersectionFromBelow.setter
    def AllowIntersectionFromBelow(self, allowIntersectionFromBelow:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowIntersectionFromBelow) as arg_allowIntersectionFromBelow:
            agcls.evaluate_hresult(self.__dict__["_SetAllowIntersectionFromBelow"](arg_allowIntersectionFromBelow.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C0F5946B-9467-44AC-B16A-9276CE4EA141}", IVectorGeometryToolPointCentBodyIntersect)
agcls.AgTypeNameMap["IVectorGeometryToolPointCentBodyIntersect"] = IVectorGeometryToolPointCentBodyIntersect

class IVectorGeometryToolPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    _uuid = "{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_SetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointAtTimeInstant = agcom.GUID(IVectorGeometryToolPointAtTimeInstant._uuid)
        vtable_offset_local = IVectorGeometryToolPointAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointAtTimeInstant.__dict__ and type(IVectorGeometryToolPointAtTimeInstant.__dict__[attrname]) == property:
            return IVectorGeometryToolPointAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourcePoint(self) -> "IVectorGeometryToolPoint":
        """A source point. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourcePoint.setter
    def SourcePoint(self, sourcePoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(sourcePoint, IVectorGeometryToolPoint) as arg_sourcePoint:
            agcls.evaluate_hresult(self.__dict__["_SetSourcePoint"](arg_sourcePoint.COM_val))

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """A reference system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}", IVectorGeometryToolPointAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolPointAtTimeInstant"] = IVectorGeometryToolPointAtTimeInstant

class IVectorGeometryToolPointPlugin(object):
    """A VGT point plugin."""
    _uuid = "{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointPlugin = agcom.GUID(IVectorGeometryToolPointPlugin._uuid)
        vtable_offset_local = IVectorGeometryToolPointPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointPlugin.__dict__ and type(IVectorGeometryToolPointPlugin.__dict__[attrname]) == property:
            return IVectorGeometryToolPointPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}", IVectorGeometryToolPointPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlugin"] = IVectorGeometryToolPointPlugin

class IVectorGeometryToolPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""
    _uuid = "{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointCBFixedOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointCBFixedOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointCBFixedOffset = agcom.GUID(IVectorGeometryToolPointCBFixedOffset._uuid)
        vtable_offset_local = IVectorGeometryToolPointCBFixedOffset._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCBFixedOffset, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCBFixedOffset, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCBFixedOffset, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCBFixedOffset, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointCBFixedOffset, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointCBFixedOffset.__dict__ and type(IVectorGeometryToolPointCBFixedOffset.__dict__[attrname]) == property:
            return IVectorGeometryToolPointCBFixedOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointCBFixedOffset.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def Position(self) -> "IPosition":
        """A position of the point fixed on the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}", IVectorGeometryToolPointCBFixedOffset)
agcls.AgTypeNameMap["IVectorGeometryToolPointCBFixedOffset"] = IVectorGeometryToolPointCBFixedOffset

class IVectorGeometryToolSystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""
    _uuid = "{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemAssembled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemAssembled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemAssembled = agcom.GUID(IVectorGeometryToolSystemAssembled._uuid)
        vtable_offset_local = IVectorGeometryToolSystemAssembled._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemAssembled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemAssembled, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemAssembled.__dict__ and type(IVectorGeometryToolSystemAssembled.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemAssembled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemAssembled.")
    
    @property
    def OriginPoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a point of origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}", IVectorGeometryToolSystemAssembled)
agcls.AgTypeNameMap["IVectorGeometryToolSystemAssembled"] = IVectorGeometryToolSystemAssembled

class IVectorGeometryToolSystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    _uuid = "{15798E36-1EC0-4A73-A910-FC28CC404082}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemOnSurface = agcom.GUID(IVectorGeometryToolSystemOnSurface._uuid)
        vtable_offset_local = IVectorGeometryToolSystemOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemOnSurface, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemOnSurface.__dict__ and type(IVectorGeometryToolSystemOnSurface.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemOnSurface.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AzimuthAngle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AzimuthAngle.setter
    def AzimuthAngle(self, azimuthAngle:float) -> None:
        with agmarshall.DOUBLE_arg(azimuthAngle) as arg_azimuthAngle:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuthAngle"](arg_azimuthAngle.COM_val))

    @property
    def UseMSL(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))

    @property
    def Position(self) -> "IAnalysisWorkbenchLLAPosition":
        """Specify the position of the system's origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15798E36-1EC0-4A73-A910-FC28CC404082}", IVectorGeometryToolSystemOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolSystemOnSurface"] = IVectorGeometryToolSystemOnSurface

class IAnalysisWorkbenchLLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""
    _uuid = "{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchLLAPosition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchLLAPosition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchLLAPosition = agcom.GUID(IAnalysisWorkbenchLLAPosition._uuid)
        vtable_offset_local = IAnalysisWorkbenchLLAPosition._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchLLAPosition, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchLLAPosition.__dict__ and type(IAnalysisWorkbenchLLAPosition.__dict__[attrname]) == property:
            return IAnalysisWorkbenchLLAPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchLLAPosition.")
    
    @property
    def Latitude(self) -> float:
        """Specify a latitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Latitude.setter
    def Latitude(self, latitude:float) -> None:
        with agmarshall.DOUBLE_arg(latitude) as arg_latitude:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_latitude.COM_val))

    @property
    def Longitude(self) -> float:
        """Specify a longitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Longitude.setter
    def Longitude(self, longitude:float) -> None:
        with agmarshall.DOUBLE_arg(longitude) as arg_longitude:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_longitude.COM_val))

    @property
    def Altitude(self) -> float:
        """Specify an altitude value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}", IAnalysisWorkbenchLLAPosition)
agcls.AgTypeNameMap["IAnalysisWorkbenchLLAPosition"] = IAnalysisWorkbenchLLAPosition

class IVectorGeometryToolSystemCommonTasks(object):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateEastNorthUpCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateAssembled"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemCommonTasks = agcom.GUID(IVectorGeometryToolSystemCommonTasks._uuid)
        vtable_offset_local = IVectorGeometryToolSystemCommonTasks._vtable_offset - 1
        self.__dict__["_CreateEastNorthUpCartographic"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemCommonTasks, vtable_offset_local+1, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateAssembled"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemCommonTasks.__dict__ and type(IVectorGeometryToolSystemCommonTasks.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemCommonTasks.")
    
    def CreateEastNorthUpCartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IVectorGeometryToolSystemAssembled":
        """Creates a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        with agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEastNorthUpCartographic"](arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAssembled(self, originPoint:"IVectorGeometryToolPoint", referenceAxes:"IVectorGeometryToolAxes") -> "IVectorGeometryToolSystemAssembled":
        """Creates a non-persistent system component assembled from an origin point and a set of reference axes."""
        with agmarshall.AgInterface_in_arg(originPoint, IVectorGeometryToolPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAssembled"](arg_originPoint.COM_val, arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}", IVectorGeometryToolSystemCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolSystemCommonTasks"] = IVectorGeometryToolSystemCommonTasks

class IVectorGeometryToolVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    _uuid = "{CFC40EEB-A99F-4DAD-A366-1C7908C15128}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorAngleRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorAngleRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorAngleRate = agcom.GUID(IVectorGeometryToolVectorAngleRate._uuid)
        vtable_offset_local = IVectorGeometryToolVectorAngleRate._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngleRate, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngleRate, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngleRate, vtable_offset_local+3, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorAngleRate.__dict__ and type(IVectorGeometryToolVectorAngleRate.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorAngleRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorAngleRate.")
    
    @property
    def Angle(self) -> "IVectorGeometryToolAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFC40EEB-A99F-4DAD-A366-1C7908C15128}", IVectorGeometryToolVectorAngleRate)
agcls.AgTypeNameMap["IVectorGeometryToolVectorAngleRate"] = IVectorGeometryToolVectorAngleRate

class IVectorGeometryToolVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{A082FC52-1C33-4D63-B02E-1D163FC2F837}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorApoapsis = agcom.GUID(IVectorGeometryToolVectorApoapsis._uuid)
        vtable_offset_local = IVectorGeometryToolVectorApoapsis._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorApoapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorApoapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorApoapsis.__dict__ and type(IVectorGeometryToolVectorApoapsis.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorApoapsis.")
    
    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A082FC52-1C33-4D63-B02E-1D163FC2F837}", IVectorGeometryToolVectorApoapsis)
agcls.AgTypeNameMap["IVectorGeometryToolVectorApoapsis"] = IVectorGeometryToolVectorApoapsis

class IVectorGeometryToolVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""
    _uuid = "{7F816808-CF9D-434A-82CE-78F4A88BC75D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFixedAtEpoch = agcom.GUID(IVectorGeometryToolVectorFixedAtEpoch._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtEpoch, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtEpoch, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFixedAtEpoch.__dict__ and type(IVectorGeometryToolVectorFixedAtEpoch.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFixedAtEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def SourceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7F816808-CF9D-434A-82CE-78F4A88BC75D}", IVectorGeometryToolVectorFixedAtEpoch)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedAtEpoch"] = IVectorGeometryToolVectorFixedAtEpoch

class IVectorGeometryToolVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    _uuid = "{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorAngularVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorAngularVelocity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorAngularVelocity = agcom.GUID(IVectorGeometryToolVectorAngularVelocity._uuid)
        vtable_offset_local = IVectorGeometryToolVectorAngularVelocity._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngularVelocity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngularVelocity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngularVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorAngularVelocity, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorAngularVelocity.__dict__ and type(IVectorGeometryToolVectorAngularVelocity.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorAngularVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorAngularVelocity.")
    
    @property
    def Axes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}", IVectorGeometryToolVectorAngularVelocity)
agcls.AgTypeNameMap["IVectorGeometryToolVectorAngularVelocity"] = IVectorGeometryToolVectorAngularVelocity

class IVectorGeometryToolVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    _uuid = "{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_SetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetMode"] = _raise_uninitialized_error
        self.__dict__["_SetMode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorConing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorConing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorConing = agcom.GUID(IVectorGeometryToolVectorConing._uuid)
        vtable_offset_local = IVectorGeometryToolVectorConing._vtable_offset - 1
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMode"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetMode"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorConing, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorConing.__dict__ and type(IVectorGeometryToolVectorConing.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorConing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorConing.")
    
    @property
    def AboutVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def StartClockAngle(self) -> float:
        """Specify a start angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartClockAngle.setter
    def StartClockAngle(self, startClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(startClockAngle) as arg_startClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStartClockAngle"](arg_startClockAngle.COM_val))

    @property
    def StopClockAngle(self) -> float:
        """Specify a stop angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopClockAngle.setter
    def StopClockAngle(self, stopClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(stopClockAngle) as arg_stopClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStopClockAngle"](arg_stopClockAngle.COM_val))

    @property
    def StartEpoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartEpoch.setter
    def StartEpoch(self, startEpoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    @property
    def ClockAngleRate(self) -> float:
        """Specify a rotation rate."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockAngleRate.setter
    def ClockAngleRate(self, clockAngleRate:float) -> None:
        with agmarshall.DOUBLE_arg(clockAngleRate) as arg_clockAngleRate:
            agcls.evaluate_hresult(self.__dict__["_SetClockAngleRate"](arg_clockAngleRate.COM_val))

    @property
    def Mode(self) -> "AgECrdnSweepMode":
        """Specify either unidirectional or bidirectional mode."""
        with agmarshall.AgEnum_arg(AgECrdnSweepMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Mode.setter
    def Mode(self, mode:"AgECrdnSweepMode") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSweepMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_SetMode"](arg_mode.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}", IVectorGeometryToolVectorConing)
agcls.AgTypeNameMap["IVectorGeometryToolVectorConing"] = IVectorGeometryToolVectorConing

class IVectorGeometryToolVectorCross(object):
    """The vector cross product of two vectors."""
    _uuid = "{F695FE24-7AE1-4935-837F-D7106A3C99A4}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFrom"] = _raise_uninitialized_error
        self.__dict__["_GetTo"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorCross._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorCross from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorCross = agcom.GUID(IVectorGeometryToolVectorCross._uuid)
        vtable_offset_local = IVectorGeometryToolVectorCross._vtable_offset - 1
        self.__dict__["_GetFrom"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTo"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCross, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorCross.__dict__ and type(IVectorGeometryToolVectorCross.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorCross.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorCross.")
    
    @property
    def From(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def To(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IsNormalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F695FE24-7AE1-4935-837F-D7106A3C99A4}", IVectorGeometryToolVectorCross)
agcls.AgTypeNameMap["IVectorGeometryToolVectorCross"] = IVectorGeometryToolVectorCross

class IVectorGeometryToolVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""
    _uuid = "{66756C64-795C-4E24-9D6A-E560851BBDE0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_GetInitializationScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetInitializationScriptFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorCustomScript = agcom.GUID(IVectorGeometryToolVectorCustomScript._uuid)
        vtable_offset_local = IVectorGeometryToolVectorCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCustomScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCustomScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorCustomScript, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorCustomScript.__dict__ and type(IVectorGeometryToolVectorCustomScript.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptFile(self) -> str:
        """Specify a script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScriptFile.setter
    def ScriptFile(self, scriptFile:str) -> None:
        with agmarshall.BSTR_arg(scriptFile) as arg_scriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetScriptFile"](arg_scriptFile.COM_val))

    @property
    def InitializationScriptFile(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitializationScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitializationScriptFile.setter
    def InitializationScriptFile(self, initializationScriptFile:str) -> None:
        with agmarshall.BSTR_arg(initializationScriptFile) as arg_initializationScriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetInitializationScriptFile"](arg_initializationScriptFile.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{66756C64-795C-4E24-9D6A-E560851BBDE0}", IVectorGeometryToolVectorCustomScript)
agcls.AgTypeNameMap["IVectorGeometryToolVectorCustomScript"] = IVectorGeometryToolVectorCustomScript

class IVectorGeometryToolVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""
    _uuid = "{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorDerivative = agcom.GUID(IVectorGeometryToolVectorDerivative._uuid)
        vtable_offset_local = IVectorGeometryToolVectorDerivative._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorDerivative.__dict__ and type(IVectorGeometryToolVectorDerivative.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorDerivative.")
    
    @property
    def Vector(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a base vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}", IVectorGeometryToolVectorDerivative)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDerivative"] = IVectorGeometryToolVectorDerivative

class IVectorGeometryToolVectorDisplacement(object):
    """Vector defined by its start and end points."""
    _uuid = "{457E8D69-0F1F-4C02-A9D6-F48F86F63853}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrigin"] = _raise_uninitialized_error
        self.__dict__["_GetDestination"] = _raise_uninitialized_error
        self.__dict__["_GetApparent"] = _raise_uninitialized_error
        self.__dict__["_SetApparent"] = _raise_uninitialized_error
        self.__dict__["_GetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_SetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorDisplacement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorDisplacement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorDisplacement = agcom.GUID(IVectorGeometryToolVectorDisplacement._uuid)
        vtable_offset_local = IVectorGeometryToolVectorDisplacement._vtable_offset - 1
        self.__dict__["_GetOrigin"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDestination"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetApparent"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetApparent"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDisplacement, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorDisplacement.__dict__ and type(IVectorGeometryToolVectorDisplacement.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorDisplacement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorDisplacement.")
    
    @property
    def Origin(self) -> "IVectorGeometryToolPointRefTo":
        """Specify the vector's origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrigin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Destination(self) -> "IVectorGeometryToolPointRefTo":
        """Specify the vector's destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestination"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Apparent(self) -> bool:
        """Controls whether to take a light speed delay into account."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetApparent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Apparent.setter
    def Apparent(self, apparent:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(apparent) as arg_apparent:
            agcls.evaluate_hresult(self.__dict__["_SetApparent"](arg_apparent.COM_val))

    @property
    def IgnoreAberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIgnoreAberration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IgnoreAberration.setter
    def IgnoreAberration(self, ignoreAberration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(ignoreAberration) as arg_ignoreAberration:
            agcls.evaluate_hresult(self.__dict__["_SetIgnoreAberration"](arg_ignoreAberration.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{457E8D69-0F1F-4C02-A9D6-F48F86F63853}", IVectorGeometryToolVectorDisplacement)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDisplacement"] = IVectorGeometryToolVectorDisplacement

class IVectorGeometryToolVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""
    _uuid = "{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPlaneA"] = _raise_uninitialized_error
        self.__dict__["_GetPlaneB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorTwoPlanesIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorTwoPlanesIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorTwoPlanesIntersection = agcom.GUID(IVectorGeometryToolVectorTwoPlanesIntersection._uuid)
        vtable_offset_local = IVectorGeometryToolVectorTwoPlanesIntersection._vtable_offset - 1
        self.__dict__["_GetPlaneA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorTwoPlanesIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPlaneB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorTwoPlanesIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorTwoPlanesIntersection.__dict__ and type(IVectorGeometryToolVectorTwoPlanesIntersection.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorTwoPlanesIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorTwoPlanesIntersection.")
    
    @property
    def PlaneA(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PlaneB(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}", IVectorGeometryToolVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorTwoPlanesIntersection"] = IVectorGeometryToolVectorTwoPlanesIntersection

class IVectorGeometryToolVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{C4CCEE5C-B053-413F-8456-6A43720BD314}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorModelAttach = agcom.GUID(IVectorGeometryToolVectorModelAttach._uuid)
        vtable_offset_local = IVectorGeometryToolVectorModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorModelAttach.__dict__ and type(IVectorGeometryToolVectorModelAttach.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C4CCEE5C-B053-413F-8456-6A43720BD314}", IVectorGeometryToolVectorModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolVectorModelAttach"] = IVectorGeometryToolVectorModelAttach

class IVectorGeometryToolVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""
    _uuid = "{2050D921-A98C-408C-8170-FDBB23FEA6E5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSource"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorProjection = agcom.GUID(IVectorGeometryToolVectorProjection._uuid)
        vtable_offset_local = IVectorGeometryToolVectorProjection._vtable_offset - 1
        self.__dict__["_GetSource"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorProjection.__dict__ and type(IVectorGeometryToolVectorProjection.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorProjection.")
    
    @property
    def Source(self) -> "IVectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSource"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IVectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2050D921-A98C-408C-8170-FDBB23FEA6E5}", IVectorGeometryToolVectorProjection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorProjection"] = IVectorGeometryToolVectorProjection

class IVectorGeometryToolVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    _uuid = "{7D89412E-17A8-43D2-9153-58F45E7072F6}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorScaled = agcom.GUID(IVectorGeometryToolVectorScaled._uuid)
        vtable_offset_local = IVectorGeometryToolVectorScaled._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScaled, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScaled, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScaled, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScaled, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorScaled.__dict__ and type(IVectorGeometryToolVectorScaled.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorScaled.")
    
    @property
    def ReferenceVector(self) -> "IVectorGeometryToolVectorRefTo":
        """A vector being scaled."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Scale(self) -> float:
        """A scaling multiple."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def IsNormalized(self) -> bool:
        """Controls whether to convert the reference vector to a unit vector before scalling."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D89412E-17A8-43D2-9153-58F45E7072F6}", IVectorGeometryToolVectorScaled)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScaled"] = IVectorGeometryToolVectorScaled

class IVectorGeometryToolVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorEccentricity = agcom.GUID(IVectorGeometryToolVectorEccentricity._uuid)
        vtable_offset_local = IVectorGeometryToolVectorEccentricity._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorEccentricity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorEccentricity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorEccentricity.__dict__ and type(IVectorGeometryToolVectorEccentricity.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorEccentricity.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}", IVectorGeometryToolVectorEccentricity)
agcls.AgTypeNameMap["IVectorGeometryToolVectorEccentricity"] = IVectorGeometryToolVectorEccentricity

class IVectorGeometryToolVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""
    _uuid = "{912ECDDB-B23C-4B7A-A173-AC22170DA343}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFixedInAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFixedInAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFixedInAxes = agcom.GUID(IVectorGeometryToolVectorFixedInAxes._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFixedInAxes._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedInAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedInAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFixedInAxes.__dict__ and type(IVectorGeometryToolVectorFixedInAxes.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFixedInAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFixedInAxes.")
    
    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "IDirection":
        """Specify the vector direction."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{912ECDDB-B23C-4B7A-A173-AC22170DA343}", IVectorGeometryToolVectorFixedInAxes)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedInAxes"] = IVectorGeometryToolVectorFixedInAxes

class IVectorGeometryToolVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    _uuid = "{DC23EB21-198C-4E01-9898-D565E937AFF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorLineOfNodes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorLineOfNodes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorLineOfNodes = agcom.GUID(IVectorGeometryToolVectorLineOfNodes._uuid)
        vtable_offset_local = IVectorGeometryToolVectorLineOfNodes._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLineOfNodes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLineOfNodes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorLineOfNodes.__dict__ and type(IVectorGeometryToolVectorLineOfNodes.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorLineOfNodes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorLineOfNodes.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{DC23EB21-198C-4E01-9898-D565E937AFF1}", IVectorGeometryToolVectorLineOfNodes)
agcls.AgTypeNameMap["IVectorGeometryToolVectorLineOfNodes"] = IVectorGeometryToolVectorLineOfNodes

class IVectorGeometryToolVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{22C8270A-7B36-40D7-9EC5-44FED3DEE541}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorOrbitAngularMomentum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorOrbitAngularMomentum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorOrbitAngularMomentum = agcom.GUID(IVectorGeometryToolVectorOrbitAngularMomentum._uuid)
        vtable_offset_local = IVectorGeometryToolVectorOrbitAngularMomentum._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitAngularMomentum, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitAngularMomentum, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitAngularMomentum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitAngularMomentum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorOrbitAngularMomentum.__dict__ and type(IVectorGeometryToolVectorOrbitAngularMomentum.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorOrbitAngularMomentum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorOrbitAngularMomentum.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22C8270A-7B36-40D7-9EC5-44FED3DEE541}", IVectorGeometryToolVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["IVectorGeometryToolVectorOrbitAngularMomentum"] = IVectorGeometryToolVectorOrbitAngularMomentum

class IVectorGeometryToolVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{296D4695-53FE-40B7-BA3E-41A3C04A805F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorOrbitNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorOrbitNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorOrbitNormal = agcom.GUID(IVectorGeometryToolVectorOrbitNormal._uuid)
        vtable_offset_local = IVectorGeometryToolVectorOrbitNormal._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitNormal, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorOrbitNormal, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorOrbitNormal.__dict__ and type(IVectorGeometryToolVectorOrbitNormal.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorOrbitNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorOrbitNormal.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{296D4695-53FE-40B7-BA3E-41A3C04A805F}", IVectorGeometryToolVectorOrbitNormal)
agcls.AgTypeNameMap["IVectorGeometryToolVectorOrbitNormal"] = IVectorGeometryToolVectorOrbitNormal

class IVectorGeometryToolVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorPeriapsis = agcom.GUID(IVectorGeometryToolVectorPeriapsis._uuid)
        vtable_offset_local = IVectorGeometryToolVectorPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPeriapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPeriapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorPeriapsis.__dict__ and type(IVectorGeometryToolVectorPeriapsis.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorPeriapsis.")
    
    @property
    def CentralBody(self) -> "IAnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IVectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}", IVectorGeometryToolVectorPeriapsis)
agcls.AgTypeNameMap["IVectorGeometryToolVectorPeriapsis"] = IVectorGeometryToolVectorPeriapsis

class IVectorGeometryToolVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    _uuid = "{AF054174-278A-41E6-B8FA-0FC48E19A8BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIncomingVector"] = _raise_uninitialized_error
        self.__dict__["_GetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_SetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_SetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorReflection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorReflection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorReflection = agcom.GUID(IVectorGeometryToolVectorReflection._uuid)
        vtable_offset_local = IVectorGeometryToolVectorReflection._vtable_offset - 1
        self.__dict__["_GetIncomingVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorReflection, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorReflection.__dict__ and type(IVectorGeometryToolVectorReflection.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorReflection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorReflection.")
    
    @property
    def IncomingVector(self) -> "IVectorGeometryToolVectorRefTo":
        """The reflecting vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncomingVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseOppositeOfSelectedVector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseOppositeOfSelectedVector"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseOppositeOfSelectedVector.setter
    def UseOppositeOfSelectedVector(self, useOppositeOfSelectedVector:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useOppositeOfSelectedVector) as arg_useOppositeOfSelectedVector:
            agcls.evaluate_hresult(self.__dict__["_SetUseOppositeOfSelectedVector"](arg_useOppositeOfSelectedVector.COM_val))

    @property
    def NormalVector(self) -> "IVectorGeometryToolVectorRefTo":
        """The vector defines the reflection surface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AllowReflectionsOnBackside(self) -> bool:
        """Controls whether to reflect the indicent vector on both sides of the plane."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowReflectionsOnBackside"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowReflectionsOnBackside.setter
    def AllowReflectionsOnBackside(self, allowReflectionsOnBackside:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowReflectionsOnBackside) as arg_allowReflectionsOnBackside:
            agcls.evaluate_hresult(self.__dict__["_SetAllowReflectionsOnBackside"](arg_allowReflectionsOnBackside.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """The vector's scale factor."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AF054174-278A-41E6-B8FA-0FC48E19A8BC}", IVectorGeometryToolVectorReflection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorReflection"] = IVectorGeometryToolVectorReflection

class IVectorGeometryToolVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    _uuid = "{2dc152fa-f029-4bc6-bc47-f27d92219a32}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetForceMinimumRotation"] = _raise_uninitialized_error
        self.__dict__["_SetForceMinimumRotation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorRotationVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorRotationVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorRotationVector = agcom.GUID(IVectorGeometryToolVectorRotationVector._uuid)
        vtable_offset_local = IVectorGeometryToolVectorRotationVector._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRotationVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRotationVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRotationVector, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorRotationVector, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorRotationVector.__dict__ and type(IVectorGeometryToolVectorRotationVector.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorRotationVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorRotationVector.")
    
    @property
    def Axes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ForceMinimumRotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceMinimumRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceMinimumRotation.setter
    def ForceMinimumRotation(self, forceMinimumRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceMinimumRotation) as arg_forceMinimumRotation:
            agcls.evaluate_hresult(self.__dict__["_SetForceMinimumRotation"](arg_forceMinimumRotation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2dc152fa-f029-4bc6-bc47-f27d92219a32}", IVectorGeometryToolVectorRotationVector)
agcls.AgTypeNameMap["IVectorGeometryToolVectorRotationVector"] = IVectorGeometryToolVectorRotationVector

class IVectorGeometryToolVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    _uuid = "{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSelectedStar"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedStar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorDirectionToStar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorDirectionToStar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorDirectionToStar = agcom.GUID(IVectorGeometryToolVectorDirectionToStar._uuid)
        vtable_offset_local = IVectorGeometryToolVectorDirectionToStar._vtable_offset - 1
        self.__dict__["_GetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDirectionToStar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDirectionToStar, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorDirectionToStar.__dict__ and type(IVectorGeometryToolVectorDirectionToStar.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorDirectionToStar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorDirectionToStar.")
    
    @property
    def SelectedStar(self) -> str:
        """A fully qualified path to a Star object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedStar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedStar.setter
    def SelectedStar(self, selectedStar:str) -> None:
        with agmarshall.BSTR_arg(selectedStar) as arg_selectedStar:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedStar"](arg_selectedStar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}", IVectorGeometryToolVectorDirectionToStar)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDirectionToStar"] = IVectorGeometryToolVectorDirectionToStar

class IVectorGeometryToolVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    _uuid = "{B35CE60F-7CC5-4289-9052-2203B609087E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFixedAtTimeInstant = agcom.GUID(IVectorGeometryToolVectorFixedAtTimeInstant._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFixedAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFixedAtTimeInstant.__dict__ and type(IVectorGeometryToolVectorFixedAtTimeInstant.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFixedAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ITimeToolEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceVector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IVectorGeometryToolVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IVectorGeometryToolAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B35CE60F-7CC5-4289-9052-2203B609087E}", IVectorGeometryToolVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedAtTimeInstant"] = IVectorGeometryToolVectorFixedAtTimeInstant

class IVectorGeometryToolVectorLinearCombination(object):
    """Linear combination of two input vectors."""
    _uuid = "{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorLinearCombination = agcom.GUID(IVectorGeometryToolVectorLinearCombination._uuid)
        vtable_offset_local = IVectorGeometryToolVectorLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorLinearCombination, vtable_offset_local+16, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorLinearCombination.__dict__ and type(IVectorGeometryToolVectorLinearCombination.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorLinearCombination.")
    
    @property
    def VectorA(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVectorGeometryToolVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVectorGeometryToolVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}", IVectorGeometryToolVectorLinearCombination)
agcls.AgTypeNameMap["IVectorGeometryToolVectorLinearCombination"] = IVectorGeometryToolVectorLinearCombination

class IVectorGeometryToolVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""
    _uuid = "{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorProjectAlongVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorProjectAlongVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorProjectAlongVector = agcom.GUID(IVectorGeometryToolVectorProjectAlongVector._uuid)
        vtable_offset_local = IVectorGeometryToolVectorProjectAlongVector._vtable_offset - 1
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjectAlongVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjectAlongVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjectAlongVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorProjectAlongVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorProjectAlongVector.__dict__ and type(IVectorGeometryToolVectorProjectAlongVector.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorProjectAlongVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorProjectAlongVector.")
    
    @property
    def SourceVector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IVectorGeometryToolVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def AlongVector(self) -> "IVectorGeometryToolVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IVectorGeometryToolVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}", IVectorGeometryToolVectorProjectAlongVector)
agcls.AgTypeNameMap["IVectorGeometryToolVectorProjectAlongVector"] = IVectorGeometryToolVectorProjectAlongVector

class IVectorGeometryToolVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""
    _uuid = "{0886A066-8650-4C8D-B234-14D28A175A78}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorScalarLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorScalarLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorScalarLinearCombination = agcom.GUID(IVectorGeometryToolVectorScalarLinearCombination._uuid)
        vtable_offset_local = IVectorGeometryToolVectorScalarLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarA"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarLinearCombination, vtable_offset_local+24, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorScalarLinearCombination.__dict__ and type(IVectorGeometryToolVectorScalarLinearCombination.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorScalarLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorScalarLinearCombination.")
    
    @property
    def VectorA(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IVectorGeometryToolVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def UseScaleFromScalarA(self) -> bool:
        """Whether to use a scale from scalar A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarA.setter
    def UseScaleFromScalarA(self, useScaleFromScalarA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarA) as arg_useScaleFromScalarA:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarA"](arg_useScaleFromScalarA.COM_val))

    @property
    def UseScaleFromScalarB(self) -> bool:
        """Whether to use a scale from scalar B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarB.setter
    def UseScaleFromScalarB(self, useScaleFromScalarB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarB) as arg_useScaleFromScalarB:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarB"](arg_useScaleFromScalarB.COM_val))

    @property
    def ScalarA(self) -> "ICalculationToolScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarA.setter
    def ScalarA(self, scalarA:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarA, ICalculationToolScalar) as arg_scalarA:
            agcls.evaluate_hresult(self.__dict__["_SetScalarA"](arg_scalarA.COM_val))

    @property
    def ScalarB(self) -> "ICalculationToolScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarB.setter
    def ScalarB(self, scalarB:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarB, ICalculationToolScalar) as arg_scalarB:
            agcls.evaluate_hresult(self.__dict__["_SetScalarB"](arg_scalarB.COM_val))

    @property
    def VectorB(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IVectorGeometryToolVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0886A066-8650-4C8D-B234-14D28A175A78}", IVectorGeometryToolVectorScalarLinearCombination)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScalarLinearCombination"] = IVectorGeometryToolVectorScalarLinearCombination

class IVectorGeometryToolVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""
    _uuid = "{306C3852-C3E9-43EB-9371-1B9540B52097}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        self.__dict__["_GetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorScalarScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorScalarScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorScalarScaled = agcom.GUID(IVectorGeometryToolVectorScalarScaled._uuid)
        vtable_offset_local = IVectorGeometryToolVectorScalarScaled._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorScalarScaled, vtable_offset_local+12, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorScalarScaled.__dict__ and type(IVectorGeometryToolVectorScalarScaled.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorScalarScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorScalarScaled.")
    
    @property
    def InputVector(self) -> "IVectorGeometryToolVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IVectorGeometryToolVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IVectorGeometryToolVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def InputScalar(self) -> "ICalculationToolScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICalculationToolScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICalculationToolScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """A constant scale applied to the input vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))

    @property
    def Normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Normalize.setter
    def Normalize(self, normalize:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalize) as arg_normalize:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_normalize.COM_val))

    @property
    def DimensionInheritance(self) -> "AgECrdnVectorScaledDimensionInheritance":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DimensionInheritance.setter
    def DimensionInheritance(self, dimensionInheritance:"AgECrdnVectorScaledDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance, dimensionInheritance) as arg_dimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetDimensionInheritance"](arg_dimensionInheritance.COM_val))

    @property
    def Dimension(self) -> str:
        """A dimension assigned to the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{306C3852-C3E9-43EB-9371-1B9540B52097}", IVectorGeometryToolVectorScalarScaled)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScalarScaled"] = IVectorGeometryToolVectorScalarScaled

class IVectorGeometryToolVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""
    _uuid = "{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorVelocityAcceleration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorVelocityAcceleration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorVelocityAcceleration = agcom.GUID(IVectorGeometryToolVectorVelocityAcceleration._uuid)
        vtable_offset_local = IVectorGeometryToolVectorVelocityAcceleration._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorVelocityAcceleration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorVelocityAcceleration.__dict__ and type(IVectorGeometryToolVectorVelocityAcceleration.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorVelocityAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorVelocityAcceleration.")
    
    @property
    def ReferenceSystem(self) -> "IVectorGeometryToolSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IVectorGeometryToolSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def Point(self) -> "IVectorGeometryToolPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IVectorGeometryToolPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}", IVectorGeometryToolVectorVelocityAcceleration)
agcls.AgTypeNameMap["IVectorGeometryToolVectorVelocityAcceleration"] = IVectorGeometryToolVectorVelocityAcceleration

class IVectorGeometryToolVectorPlugin(object):
    """A VGT vector plugin."""
    _uuid = "{F889F617-059E-4BC9-9000-206091889FEB}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorPlugin = agcom.GUID(IVectorGeometryToolVectorPlugin._uuid)
        vtable_offset_local = IVectorGeometryToolVectorPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorPlugin.__dict__ and type(IVectorGeometryToolVectorPlugin.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F889F617-059E-4BC9-9000-206091889FEB}", IVectorGeometryToolVectorPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolVectorPlugin"] = IVectorGeometryToolVectorPlugin

class IVectorGeometryToolVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    _uuid = "{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_SetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorDispSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorDispSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorDispSurface = agcom.GUID(IVectorGeometryToolVectorDispSurface._uuid)
        vtable_offset_local = IVectorGeometryToolVectorDispSurface._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorDispSurface, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorDispSurface.__dict__ and type(IVectorGeometryToolVectorDispSurface.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorDispSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorDispSurface.")
    
    @property
    def OriginPoint(self) -> "IVectorGeometryToolPoint":
        """An origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginPoint.setter
    def OriginPoint(self, originPoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(originPoint, IVectorGeometryToolPoint) as arg_originPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOriginPoint"](arg_originPoint.COM_val))

    @property
    def DestinationPoint(self) -> "IVectorGeometryToolPoint":
        """Destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestinationPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DestinationPoint.setter
    def DestinationPoint(self, destinationPoint:"IVectorGeometryToolPoint") -> None:
        with agmarshall.AgInterface_in_arg(destinationPoint, IVectorGeometryToolPoint) as arg_destinationPoint:
            agcls.evaluate_hresult(self.__dict__["_SetDestinationPoint"](arg_destinationPoint.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """surface central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}", IVectorGeometryToolVectorDispSurface)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDispSurface"] = IVectorGeometryToolVectorDispSurface

class IVectorGeometryToolVectorFactory(object):
    """A Factory object to create vectors."""
    _uuid = "{09F7F253-392A-44D9-9701-51CC0110C033}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateDisplacementVector"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateVectorPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreateCrossProductVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFactory = agcom.GUID(IVectorGeometryToolVectorFactory._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateDisplacementVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+3, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateVectorPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCrossProductVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFactory, vtable_offset_local+6, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFactory.__dict__ and type(IVectorGeometryToolVectorFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFactory.")
    
    def Create(self, vectorName:str, description:str, vectorType:"AgECrdnVectorType") -> "IVectorGeometryToolVector":
        """Creates a VGT vector using specified name, description and type."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVectorType, vectorType) as arg_vectorType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_vectorName.COM_val, arg_description.COM_val, arg_vectorType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnVectorType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateDisplacementVector(self, vectorName:str, originPoint:"IVectorGeometryToolPoint", destPoint:"IVectorGeometryToolPoint") -> "IVectorGeometryToolVectorDisplacement":
        """Creates a displacement vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(originPoint, IVectorGeometryToolPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(destPoint, IVectorGeometryToolPoint) as arg_destPoint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateDisplacementVector"](arg_vectorName.COM_val, arg_originPoint.COM_val, arg_destPoint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AvailableVectorPluginDisplayNames(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableVectorPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVectorPluginFromDisplayName(self, vectorName:str, description:str, displayName:str) -> "IVectorGeometryToolVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVectorPluginFromDisplayName"](arg_vectorName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCrossProductVector(self, vectorName:str, vectorA:"IVectorGeometryToolVector", vectorB:"IVectorGeometryToolVector") -> "IVectorGeometryToolVectorCross":
        """Creates a cross product C = A x B."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(vectorA, IVectorGeometryToolVector) as arg_vectorA, \
             agmarshall.AgInterface_in_arg(vectorB, IVectorGeometryToolVector) as arg_vectorB, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCrossProductVector"](arg_vectorName.COM_val, arg_vectorA.COM_val, arg_vectorB.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{09F7F253-392A-44D9-9701-51CC0110C033}", IVectorGeometryToolVectorFactory)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFactory"] = IVectorGeometryToolVectorFactory

class IVectorGeometryToolAxesFactory(object):
    """A Factory object to create axes."""
    _uuid = "{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateAxesPluginFromDisplayName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesFactory = agcom.GUID(IVectorGeometryToolAxesFactory._uuid)
        vtable_offset_local = IVectorGeometryToolAxesFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateAxesPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesFactory.__dict__ and type(IVectorGeometryToolAxesFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesFactory.")
    
    def Create(self, axesName:str, description:str, axesType:"AgECrdnAxesType") -> "IVectorGeometryToolAxes":
        """Creates a VGT axes using specified name, description and type."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAxesType, axesType) as arg_axesType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_axesName.COM_val, arg_description.COM_val, arg_axesType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAxesType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableAxesPluginDisplayNames(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableAxesPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAxesPluginFromDisplayName(self, axesName:str, description:str, displayName:str) -> "IVectorGeometryToolAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAxesPluginFromDisplayName"](arg_axesName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}", IVectorGeometryToolAxesFactory)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFactory"] = IVectorGeometryToolAxesFactory

class IVectorGeometryToolSystemFactory(object):
    """A Factory interface to create VGT systems."""
    _uuid = "{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemFactory = agcom.GUID(IVectorGeometryToolSystemFactory._uuid)
        vtable_offset_local = IVectorGeometryToolSystemFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemFactory.__dict__ and type(IVectorGeometryToolSystemFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemFactory.")
    
    def Create(self, systemName:str, description:str, systemType:"AgECrdnSystemType") -> "IVectorGeometryToolSystem":
        """Creates a VGT system using the specified name, description and type."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnSystemType, systemType) as arg_systemType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_systemName.COM_val, arg_description.COM_val, arg_systemType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnSystemType") -> bool:
        """Returns true if the specified system type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}", IVectorGeometryToolSystemFactory)
agcls.AgTypeNameMap["IVectorGeometryToolSystemFactory"] = IVectorGeometryToolSystemFactory

class IVectorGeometryToolPointFactory(object):
    """A Factory object to create points."""
    _uuid = "{18FA11DA-BC93-4467-B53F-4D894739C3A3}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreatePointPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreatePointFixedOnCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointFactory = agcom.GUID(IVectorGeometryToolPointFactory._uuid)
        vtable_offset_local = IVectorGeometryToolPointFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreatePointPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreatePointFixedOnCentralBody"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointFactory.__dict__ and type(IVectorGeometryToolPointFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointFactory.")
    
    def Create(self, pointName:str, description:str, pointType:"AgECrdnPointType") -> "IVectorGeometryToolPoint":
        """Creates a VGT point using the specified name, description and type."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPointType, pointType) as arg_pointType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_pointName.COM_val, arg_description.COM_val, arg_pointType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPointType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPointType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailablePointPluginDisplayNames(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailablePointPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointPluginFromDisplayName(self, pointName:str, description:str, displayName:str) -> "IVectorGeometryToolPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointPluginFromDisplayName"](arg_pointName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointFixedOnCentralBody(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"AgECrdnReferenceShapeType") -> "IVectorGeometryToolPoint":
        """Creates a point fixed on a central body."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointFixedOnCentralBody"](arg_pointName.COM_val, arg_description.COM_val, arg_longitude.COM_val, arg_latitude.COM_val, arg_altitude.COM_val, arg_referenceShape.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{18FA11DA-BC93-4467-B53F-4D894739C3A3}", IVectorGeometryToolPointFactory)
agcls.AgTypeNameMap["IVectorGeometryToolPointFactory"] = IVectorGeometryToolPointFactory

class IVectorGeometryToolPlaneFactory(object):
    """A Factory object to create VGT planes."""
    _uuid = "{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneFactory = agcom.GUID(IVectorGeometryToolPlaneFactory._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneFactory.__dict__ and type(IVectorGeometryToolPlaneFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneFactory.")
    
    def Create(self, planeName:str, description:str, planeType:"AgECrdnPlaneType") -> "IVectorGeometryToolPlane":
        """Creates a VGT plane using the specified name, description and type."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPlaneType, planeType) as arg_planeType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_planeName.COM_val, arg_description.COM_val, arg_planeType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPlaneType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}", IVectorGeometryToolPlaneFactory)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFactory"] = IVectorGeometryToolPlaneFactory

class IVectorGeometryToolAngleFactory(object):
    """A Factory object to create angles."""
    _uuid = "{703883F3-9716-4D37-8930-184BECDE1461}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleFactory = agcom.GUID(IVectorGeometryToolAngleFactory._uuid)
        vtable_offset_local = IVectorGeometryToolAngleFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleFactory.__dict__ and type(IVectorGeometryToolAngleFactory.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleFactory.")
    
    def Create(self, angleName:str, description:str, angleType:"AgECrdnAngleType") -> "IVectorGeometryToolAngle":
        """Creates a VGT angle using specified name, description and type."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAngleType, angleType) as arg_angleType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_angleName.COM_val, arg_description.COM_val, arg_angleType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAngleType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{703883F3-9716-4D37-8930-184BECDE1461}", IVectorGeometryToolAngleFactory)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFactory"] = IVectorGeometryToolAngleFactory

class IVectorGeometryToolVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""
    _uuid = "{4412F0DD-2138-4653-8D20-9B4A0CA450D4}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorGroup = agcom.GUID(IVectorGeometryToolVectorGroup._uuid)
        vtable_offset_local = IVectorGeometryToolVectorGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorGroup.__dict__ and type(IVectorGeometryToolVectorGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolVector":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, vectorName:str) -> None:
        """Removes a specified vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_vectorName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolVectorFactory":
        """Returns a Factory object used to create custom vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolVector":
        """Returns a vector by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolVector":
        """Retrieves a vector from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolVector":
        """Retrieves a vector from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4412F0DD-2138-4653-8D20-9B4A0CA450D4}", IVectorGeometryToolVectorGroup)
agcls.AgTypeNameMap["IVectorGeometryToolVectorGroup"] = IVectorGeometryToolVectorGroup

class IVectorGeometryToolPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""
    _uuid = "{6FB1415A-EC77-476F-B650-CC6813BE740C}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointGroup = agcom.GUID(IVectorGeometryToolPointGroup._uuid)
        vtable_offset_local = IVectorGeometryToolPointGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointGroup.__dict__ and type(IVectorGeometryToolPointGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolPointGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPoint":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, pointName:str) -> None:
        """Removes a specified point by name."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_pointName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolPointFactory":
        """Returns a Factory object used to create custom points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPoint":
        """Returns a point by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IVectorGeometryToolPointCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolPoint":
        """Retrieves a point from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolPoint":
        """Retrieves a point from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6FB1415A-EC77-476F-B650-CC6813BE740C}", IVectorGeometryToolPointGroup)
agcls.AgTypeNameMap["IVectorGeometryToolPointGroup"] = IVectorGeometryToolPointGroup

class IVectorGeometryToolAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""
    _uuid = "{C025A1BA-F856-4B26-9134-BBCC785B6C45}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleGroup = agcom.GUID(IVectorGeometryToolAngleGroup._uuid)
        vtable_offset_local = IVectorGeometryToolAngleGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleGroup.__dict__ and type(IVectorGeometryToolAngleGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAngle":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, angleName:str) -> None:
        """Removes a specified Angle."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_angleName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolAngleFactory":
        """Returns a Factory object used to create custom angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAngle":
        """Returns an angle by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolAngle":
        """Retrieves an angle from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolAngle":
        """Retrieves an angle from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C025A1BA-F856-4B26-9134-BBCC785B6C45}", IVectorGeometryToolAngleGroup)
agcls.AgTypeNameMap["IVectorGeometryToolAngleGroup"] = IVectorGeometryToolAngleGroup

class IVectorGeometryToolAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""
    _uuid = "{21C67E72-992F-481F-B77F-1DFC43B4B705}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesGroup = agcom.GUID(IVectorGeometryToolAxesGroup._uuid)
        vtable_offset_local = IVectorGeometryToolAxesGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesGroup.__dict__ and type(IVectorGeometryToolAxesGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAxes":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, axesName:str) -> None:
        """Removes a specified Axes."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_axesName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolAxesFactory":
        """Returns a Factory object used to create custom axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAxes":
        """Returns an axes by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IVectorGeometryToolAxesCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolAxes":
        """Retrieves an axes from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolAxes":
        """Retrieves an axes from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{21C67E72-992F-481F-B77F-1DFC43B4B705}", IVectorGeometryToolAxesGroup)
agcls.AgTypeNameMap["IVectorGeometryToolAxesGroup"] = IVectorGeometryToolAxesGroup

class IVectorGeometryToolPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""
    _uuid = "{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneGroup = agcom.GUID(IVectorGeometryToolPlaneGroup._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneGroup.__dict__ and type(IVectorGeometryToolPlaneGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPlane":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, planeName:str) -> None:
        """Removes a specified Plane."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_planeName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolPlaneFactory":
        """Returns a Factory object used to create custom planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPlane":
        """Returns an Plane by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolPlane":
        """Retrieves a plane from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolPlane":
        """Retrieves a plane from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}", IVectorGeometryToolPlaneGroup)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneGroup"] = IVectorGeometryToolPlaneGroup

class IVectorGeometryToolSystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""
    _uuid = "{05FF6322-1363-4B66-933E-03EA158B7523}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemGroup = agcom.GUID(IVectorGeometryToolSystemGroup._uuid)
        vtable_offset_local = IVectorGeometryToolSystemGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemGroup.__dict__ and type(IVectorGeometryToolSystemGroup.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVectorGeometryToolSystem":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, systemName:str) -> None:
        """Removes a specified System."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_systemName.COM_val))

    @property
    def Context(self) -> "IAnalysisWorkbenchContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IVectorGeometryToolSystemFactory":
        """Returns a Factory object used to create custom VGT systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IVectorGeometryToolSystem":
        """Returns a System by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IVectorGeometryToolSystemCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVectorGeometryToolSystem":
        """Retrieves a system from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IVectorGeometryToolSystem":
        """Retrieves a system from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{05FF6322-1363-4B66-933E-03EA158B7523}", IVectorGeometryToolSystemGroup)
agcls.AgTypeNameMap["IVectorGeometryToolSystemGroup"] = IVectorGeometryToolSystemGroup

class IAnalysisWorkbenchProvider(object):
    """Allows accessing existing Vector Geometry Tool components."""
    _uuid = "{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectors"] = _raise_uninitialized_error
        self.__dict__["_GetPoints"] = _raise_uninitialized_error
        self.__dict__["_GetAngles"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetPlanes"] = _raise_uninitialized_error
        self.__dict__["_GetSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEvents"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetCalcScalars"] = _raise_uninitialized_error
        self.__dict__["_GetEventArrays"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalLists"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalCollections"] = _raise_uninitialized_error
        self.__dict__["_GetParameterSets"] = _raise_uninitialized_error
        self.__dict__["_GetConditions"] = _raise_uninitialized_error
        self.__dict__["_Supports"] = _raise_uninitialized_error
        self.__dict__["_GetConditionSets"] = _raise_uninitialized_error
        self.__dict__["_Import"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrids"] = _raise_uninitialized_error
        self.__dict__["_GetVolumes"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalcs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchProvider._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchProvider from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchProvider = agcom.GUID(IAnalysisWorkbenchProvider._uuid)
        vtable_offset_local = IAnalysisWorkbenchProvider._vtable_offset - 1
        self.__dict__["_GetVectors"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPoints"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAngles"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetPlanes"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetSystems"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetEvents"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervals"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetCalcScalars"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetEventArrays"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalLists"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_GetParameterSets"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetConditions"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_Supports"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetConditionSets"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_Import"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+19, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeGrids"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumes"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeCalcs"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchProvider, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchProvider.__dict__ and type(IAnalysisWorkbenchProvider.__dict__[attrname]) == property:
            return IAnalysisWorkbenchProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchProvider.")
    
    @property
    def Vectors(self) -> "IVectorGeometryToolVectorGroup":
        """Returns a group of vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectors"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Points(self) -> "IVectorGeometryToolPointGroup":
        """Returns a group of points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Angles(self) -> "IVectorGeometryToolAngleGroup":
        """Returns a group of angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngles"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Axes(self) -> "IVectorGeometryToolAxesGroup":
        """Returns a group of axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Planes(self) -> "IVectorGeometryToolPlaneGroup":
        """Returns a group of planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlanes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Systems(self) -> "IVectorGeometryToolSystemGroup":
        """Returns a group of systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IVectorGeometryToolWellKnownSystems":
        """Returns well-known systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IVectorGeometryToolWellKnownAxes":
        """Returns well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Events(self) -> "ITimeToolEventGroup":
        """Returns a group of events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEvents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervals(self) -> "ITimeToolEventIntervalGroup":
        """Returns a group of event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcScalars(self) -> "ICalculationToolScalarGroup":
        """Returns a group of calc scalars."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcScalars"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventArrays(self) -> "ITimeToolEventArrayGroup":
        """Returns a group of event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventArrays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalLists(self) -> "ITimeToolEventIntervalListGroup":
        """Returns a group of event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalLists"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalCollections(self) -> "ITimeToolEventIntervalCollectionGroup":
        """Returns a group of event interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ParameterSets(self) -> "ICalculationToolParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParameterSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Conditions(self) -> "ICalculationToolConditionGroup":
        """Returns a group of condition objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Supports(self, feature:"AgECrdnKind") -> bool:
        """Tests whether the specified VGT feature is supported."""
        with agmarshall.AgEnum_arg(AgECrdnKind, feature) as arg_feature, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Supports"](arg_feature.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ConditionSets(self) -> "ICalculationToolConditionSetGroup":
        """Returns a group of condition set objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Import(self, filename:str) -> "IAnalysisWorkbenchCollection":
        """Imports Analysis Workbench components from a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Import"](arg_filename.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeGrids(self) -> "ISpatialAnalysisToolVolumeGridGroup":
        """Returns a group of volume grid objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrids"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Volumes(self) -> "ISpatialAnalysisToolVolumeGroup":
        """Returns a group of volume objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeCalcs(self) -> "ISpatialAnalysisToolVolumeCalcGroup":
        """Returns a group of volume calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalcs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}", IAnalysisWorkbenchProvider)
agcls.AgTypeNameMap["IAnalysisWorkbenchProvider"] = IAnalysisWorkbenchProvider

class IAnalysisWorkbenchRoot(object):
    """Represents a VGT root object."""
    _uuid = "{FEF8B20D-5EEB-4299-8775-038EE30AA30B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTemplateProvider"] = _raise_uninitialized_error
        self.__dict__["_GetProvider"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchRoot._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchRoot from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchRoot = agcom.GUID(IAnalysisWorkbenchRoot._uuid)
        vtable_offset_local = IAnalysisWorkbenchRoot._vtable_offset - 1
        self.__dict__["_GetTemplateProvider"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchRoot, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvider"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchRoot, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchRoot, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchRoot, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchRoot.__dict__ and type(IAnalysisWorkbenchRoot.__dict__[attrname]) == property:
            return IAnalysisWorkbenchRoot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchRoot.")
    
    def GetTemplateProvider(self, className:str) -> "IAnalysisWorkbenchProvider":
        """Returns a template provider. The method takes a class name (i.e. ``Satellite``, ``Facility``, etc.)"""
        with agmarshall.BSTR_arg(className) as arg_className, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplateProvider"](arg_className.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetProvider(self, instPath:str) -> "IAnalysisWorkbenchProvider":
        """Returns an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. ``Satellite/Satellite1``, ``CentralBody/Earth``, etc.)"""
        with agmarshall.BSTR_arg(instPath) as arg_instPath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvider"](arg_instPath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IVectorGeometryToolWellKnownSystems":
        """Returns the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IVectorGeometryToolWellKnownAxes":
        """Returns the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FEF8B20D-5EEB-4299-8775-038EE30AA30B}", IAnalysisWorkbenchRoot)
agcls.AgTypeNameMap["IAnalysisWorkbenchRoot"] = IAnalysisWorkbenchRoot

class IVectorGeometryToolWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""
    _uuid = "{230A8949-FB8F-415E-A786-5EED50AEB11B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownEarthSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownEarthSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownEarthSystems = agcom.GUID(IVectorGeometryToolWellKnownEarthSystems._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownEarthSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownEarthSystems.__dict__ and type(IVectorGeometryToolWellKnownEarthSystems.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownEarthSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownEarthSystems.")
    
    @property
    def Fixed(self) -> "IVectorGeometryToolSystem":
        """Earth's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IVectorGeometryToolSystem":
        """Earth's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IVectorGeometryToolSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{230A8949-FB8F-415E-A786-5EED50AEB11B}", IVectorGeometryToolWellKnownEarthSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownEarthSystems"] = IVectorGeometryToolWellKnownEarthSystems

class IVectorGeometryToolWellKnownEarthAxes(object):
    """Well-known Earth's axes."""
    _uuid = "{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownEarthAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownEarthAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownEarthAxes = agcom.GUID(IVectorGeometryToolWellKnownEarthAxes._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownEarthAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownEarthAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownEarthAxes.__dict__ and type(IVectorGeometryToolWellKnownEarthAxes.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownEarthAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownEarthAxes.")
    
    @property
    def Fixed(self) -> "IVectorGeometryToolAxes":
        """Earth's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IVectorGeometryToolAxes":
        """Earth's ICRF axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IVectorGeometryToolAxes":
        """Earth's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IVectorGeometryToolAxes":
        """The Earth's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}", IVectorGeometryToolWellKnownEarthAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownEarthAxes"] = IVectorGeometryToolWellKnownEarthAxes

class IVectorGeometryToolWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""
    _uuid = "{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        self.__dict__["_GetBarycenter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownSunSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownSunSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownSunSystems = agcom.GUID(IVectorGeometryToolWellKnownSunSystems._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownSunSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunSystems, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetBarycenter"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunSystems, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownSunSystems.__dict__ and type(IVectorGeometryToolWellKnownSunSystems.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownSunSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownSunSystems.")
    
    @property
    def Fixed(self) -> "IVectorGeometryToolSystem":
        """The Sun's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IVectorGeometryToolSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IVectorGeometryToolSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IVectorGeometryToolSystem":
        """The Sun's J2000 coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Barycenter(self) -> "IVectorGeometryToolSystem":
        """The Inertial system at the Sun's barycenter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBarycenter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}", IVectorGeometryToolWellKnownSunSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSunSystems"] = IVectorGeometryToolWellKnownSunSystems

class IVectorGeometryToolWellKnownSunAxes(object):
    """Well-known Sun's axes."""
    _uuid = "{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownSunAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownSunAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownSunAxes = agcom.GUID(IVectorGeometryToolWellKnownSunAxes._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownSunAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSunAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownSunAxes.__dict__ and type(IVectorGeometryToolWellKnownSunAxes.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownSunAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownSunAxes.")
    
    @property
    def Fixed(self) -> "IVectorGeometryToolAxes":
        """Sun's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IVectorGeometryToolAxes":
        """Sun's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IVectorGeometryToolAxes":
        """Sun's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IVectorGeometryToolAxes":
        """The Sun's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}", IVectorGeometryToolWellKnownSunAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSunAxes"] = IVectorGeometryToolWellKnownSunAxes

class IVectorGeometryToolWellKnownSystems(object):
    """Well-known coordinate reference systems."""
    _uuid = "{D93C6B6F-D457-4D20-BA7B-960773E3652B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownSystems = agcom.GUID(IVectorGeometryToolWellKnownSystems._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownSystems._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownSystems.__dict__ and type(IVectorGeometryToolWellKnownSystems.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownSystems.")
    
    @property
    def Earth(self) -> "IVectorGeometryToolWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IVectorGeometryToolWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D93C6B6F-D457-4D20-BA7B-960773E3652B}", IVectorGeometryToolWellKnownSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSystems"] = IVectorGeometryToolWellKnownSystems

class IVectorGeometryToolWellKnownAxes(object):
    """Well-known Axes."""
    _uuid = "{B2546963-CC14-4F18-91DE-7091EBEA34C5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolWellKnownAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolWellKnownAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolWellKnownAxes = agcom.GUID(IVectorGeometryToolWellKnownAxes._uuid)
        vtable_offset_local = IVectorGeometryToolWellKnownAxes._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolWellKnownAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolWellKnownAxes.__dict__ and type(IVectorGeometryToolWellKnownAxes.__dict__[attrname]) == property:
            return IVectorGeometryToolWellKnownAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolWellKnownAxes.")
    
    @property
    def Earth(self) -> "IVectorGeometryToolWellKnownEarthAxes":
        """Earth's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IVectorGeometryToolWellKnownSunAxes":
        """The Sun's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B2546963-CC14-4F18-91DE-7091EBEA34C5}", IVectorGeometryToolWellKnownAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownAxes"] = IVectorGeometryToolWellKnownAxes

class IVectorGeometryToolAngleFindAngleResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    _uuid = "{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleFindAngleResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleFindAngleResult = agcom.GUID(IVectorGeometryToolAngleFindAngleResult._uuid)
        vtable_offset_local = IVectorGeometryToolAngleFindAngleResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindAngleResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindAngleResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleFindAngleResult.__dict__ and type(IVectorGeometryToolAngleFindAngleResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleFindAngleResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleFindAngleResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}", IVectorGeometryToolAngleFindAngleResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleResult"] = IVectorGeometryToolAngleFindAngleResult

class IVectorGeometryToolAngleFindAngleWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    _uuid = "{E46570BA-661C-4974-A780-32DFEAFB9630}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleFindAngleWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleFindAngleWithRateResult = agcom.GUID(IVectorGeometryToolAngleFindAngleWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolAngleFindAngleWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindAngleWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindAngleWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindAngleWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleFindAngleWithRateResult.__dict__ and type(IVectorGeometryToolAngleFindAngleWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleFindAngleWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleFindAngleWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E46570BA-661C-4974-A780-32DFEAFB9630}", IVectorGeometryToolAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleWithRateResult"] = IVectorGeometryToolAngleFindAngleWithRateResult

class IVectorGeometryToolAngleFindWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    _uuid = "{C4E80CE7-2E38-4364-96D5-004EE425471D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleFindWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleFindWithRateResult = agcom.GUID(IVectorGeometryToolAngleFindWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolAngleFindWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleFindWithRateResult.__dict__ and type(IVectorGeometryToolAngleFindWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleFindWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleFindWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4E80CE7-2E38-4364-96D5-004EE425471D}", IVectorGeometryToolAngleFindWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindWithRateResult"] = IVectorGeometryToolAngleFindWithRateResult

class IVectorGeometryToolAngleFindResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinates method."""
    _uuid = "{36DD880D-214E-4987-A70A-EA31E7E26B84}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAngleFindResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAngleFindResult = agcom.GUID(IVectorGeometryToolAngleFindResult._uuid)
        vtable_offset_local = IVectorGeometryToolAngleFindResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAngleFindResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAngleFindResult.__dict__ and type(IVectorGeometryToolAngleFindResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAngleFindResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAngleFindResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{36DD880D-214E-4987-A70A-EA31E7E26B84}", IVectorGeometryToolAngleFindResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindResult"] = IVectorGeometryToolAngleFindResult

class IVectorGeometryToolAxesTransformResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    _uuid = "{D4EC98BE-0D20-4284-96D0-3C40A3100A06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesTransformResult = agcom.GUID(IVectorGeometryToolAxesTransformResult._uuid)
        vtable_offset_local = IVectorGeometryToolAxesTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesTransformResult.__dict__ and type(IVectorGeometryToolAxesTransformResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D4EC98BE-0D20-4284-96D0-3C40A3100A06}", IVectorGeometryToolAxesTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformResult"] = IVectorGeometryToolAxesTransformResult

class IVectorGeometryToolAxesTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    _uuid = "{6434061B-3584-49FF-99C5-2C2D6B385CF1}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesTransformWithRateResult = agcom.GUID(IVectorGeometryToolAxesTransformWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolAxesTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesTransformWithRateResult.__dict__ and type(IVectorGeometryToolAxesTransformWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6434061B-3584-49FF-99C5-2C2D6B385CF1}", IVectorGeometryToolAxesTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformWithRateResult"] = IVectorGeometryToolAxesTransformWithRateResult

class IVectorGeometryToolPlaneFindInAxesResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    _uuid = "{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneFindInAxesResult = agcom.GUID(IVectorGeometryToolPlaneFindInAxesResult._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneFindInAxesResult.__dict__ and type(IVectorGeometryToolPlaneFindInAxesResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}", IVectorGeometryToolPlaneFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesResult"] = IVectorGeometryToolPlaneFindInAxesResult

class IVectorGeometryToolPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    _uuid = "{CD4424A8-28CF-4AE5-8242-480B6625F0EB}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneFindInAxesWithRateResult = agcom.GUID(IVectorGeometryToolPlaneFindInAxesWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInAxesWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CD4424A8-28CF-4AE5-8242-480B6625F0EB}", IVectorGeometryToolPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesWithRateResult"] = IVectorGeometryToolPlaneFindInAxesWithRateResult

class IVectorGeometryToolPlaneFindInSystemResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    _uuid = "{85D16885-3BEB-4590-963B-F1CC8D016097}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneFindInSystemResult = agcom.GUID(IVectorGeometryToolPlaneFindInSystemResult._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneFindInSystemResult.__dict__ and type(IVectorGeometryToolPlaneFindInSystemResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{85D16885-3BEB-4590-963B-F1CC8D016097}", IVectorGeometryToolPlaneFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemResult"] = IVectorGeometryToolPlaneFindInSystemResult

class IVectorGeometryToolPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    _uuid = "{888499CB-4BF7-46A6-A11B-3FFC05EA6804}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetOriginVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPlaneFindInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPlaneFindInSystemWithRateResult = agcom.GUID(IVectorGeometryToolPlaneFindInSystemWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolPlaneFindInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPlaneFindInSystemWithRateResult, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__ and type(IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPlaneFindInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginVelocity(self) -> "ICartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{888499CB-4BF7-46A6-A11B-3FFC05EA6804}", IVectorGeometryToolPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemWithRateResult"] = IVectorGeometryToolPlaneFindInSystemWithRateResult

class IVectorGeometryToolAxesFindInAxesResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    _uuid = "{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesFindInAxesResult = agcom.GUID(IVectorGeometryToolAxesFindInAxesResult._uuid)
        vtable_offset_local = IVectorGeometryToolAxesFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesFindInAxesResult.__dict__ and type(IVectorGeometryToolAxesFindInAxesResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}", IVectorGeometryToolAxesFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesResult"] = IVectorGeometryToolAxesFindInAxesResult

class IVectorGeometryToolAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    _uuid = "{72644DD0-D129-4D7A-8A81-586E86E639BD}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngularVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolAxesFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolAxesFindInAxesWithRateResult = agcom.GUID(IVectorGeometryToolAxesFindInAxesWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolAxesFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngularVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolAxesFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolAxesFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngularVelocity(self) -> "ICartesian3Vector":
        """Axes' angular velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngularVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{72644DD0-D129-4D7A-8A81-586E86E639BD}", IVectorGeometryToolAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesWithRateResult"] = IVectorGeometryToolAxesFindInAxesWithRateResult

class IVectorGeometryToolPointLocateInSystemResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystem method."""
    _uuid = "{84453DEC-5D01-4D47-A177-F8A737F0496D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointLocateInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointLocateInSystemResult = agcom.GUID(IVectorGeometryToolPointLocateInSystemResult._uuid)
        vtable_offset_local = IVectorGeometryToolPointLocateInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLocateInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLocateInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointLocateInSystemResult.__dict__ and type(IVectorGeometryToolPointLocateInSystemResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPointLocateInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointLocateInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{84453DEC-5D01-4D47-A177-F8A737F0496D}", IVectorGeometryToolPointLocateInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemResult"] = IVectorGeometryToolPointLocateInSystemResult

class IVectorGeometryToolPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    _uuid = "{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolPointLocateInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolPointLocateInSystemWithRateResult = agcom.GUID(IVectorGeometryToolPointLocateInSystemWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolPointLocateInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLocateInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLocateInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolPointLocateInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__ and type(IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolPointLocateInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The point velocity in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}", IVectorGeometryToolPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemWithRateResult"] = IVectorGeometryToolPointLocateInSystemWithRateResult

class IVectorGeometryToolSystemTransformResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    _uuid = "{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemTransformResult = agcom.GUID(IVectorGeometryToolSystemTransformResult._uuid)
        vtable_offset_local = IVectorGeometryToolSystemTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemTransformResult.__dict__ and type(IVectorGeometryToolSystemTransformResult.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}", IVectorGeometryToolSystemTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformResult"] = IVectorGeometryToolSystemTransformResult

class IVectorGeometryToolSystemTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    _uuid = "{A9E92350-230F-45C7-A617-DB684FF89C78}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemTransformWithRateResult = agcom.GUID(IVectorGeometryToolSystemTransformWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolSystemTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemTransformWithRateResult.__dict__ and type(IVectorGeometryToolSystemTransformWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector's velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A9E92350-230F-45C7-A617-DB684FF89C78}", IVectorGeometryToolSystemTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformWithRateResult"] = IVectorGeometryToolSystemTransformWithRateResult

class IVectorGeometryToolSystemFindInSystemResult(object):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    _uuid = "{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolSystemFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolSystemFindInSystemResult = agcom.GUID(IVectorGeometryToolSystemFindInSystemResult._uuid)
        vtable_offset_local = IVectorGeometryToolSystemFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolSystemFindInSystemResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolSystemFindInSystemResult.__dict__ and type(IVectorGeometryToolSystemFindInSystemResult.__dict__[attrname]) == property:
            return IVectorGeometryToolSystemFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolSystemFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """A position vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """A velocity vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """Rate of change."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """Orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}", IVectorGeometryToolSystemFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemFindInSystemResult"] = IVectorGeometryToolSystemFindInSystemResult

class IVectorGeometryToolVectorFindInAxesResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    _uuid = "{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFindInAxesResult = agcom.GUID(IVectorGeometryToolVectorFindInAxesResult._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFindInAxesResult.__dict__ and type(IVectorGeometryToolVectorFindInAxesResult.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}", IVectorGeometryToolVectorFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesResult"] = IVectorGeometryToolVectorFindInAxesResult

class IVectorGeometryToolVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    _uuid = "{A5EB9B7C-559C-4ABB-839E-47109CDC8446}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVectorGeometryToolVectorFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVectorGeometryToolVectorFindInAxesWithRateResult = agcom.GUID(IVectorGeometryToolVectorFindInAxesWithRateResult._uuid)
        vtable_offset_local = IVectorGeometryToolVectorFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_IVectorGeometryToolVectorFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVectorGeometryToolVectorFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """The vector rate in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5EB9B7C-559C-4ABB-839E-47109CDC8446}", IVectorGeometryToolVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesWithRateResult"] = IVectorGeometryToolVectorFindInAxesWithRateResult

class IAnalysisWorkbenchMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""
    _uuid = "{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchMethodCallResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchMethodCallResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchMethodCallResult = agcom.GUID(IAnalysisWorkbenchMethodCallResult._uuid)
        vtable_offset_local = IAnalysisWorkbenchMethodCallResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchMethodCallResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchMethodCallResult.__dict__ and type(IAnalysisWorkbenchMethodCallResult.__dict__[attrname]) == property:
            return IAnalysisWorkbenchMethodCallResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchMethodCallResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}", IAnalysisWorkbenchMethodCallResult)
agcls.AgTypeNameMap["IAnalysisWorkbenchMethodCallResult"] = IAnalysisWorkbenchMethodCallResult

class IAnalysisWorkbenchCentralBody(object):
    """The interface represents a central body."""
    _uuid = "{8742150E-1663-4DCC-A442-278479FF93DC}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchCentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchCentralBody from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchCentralBody = agcom.GUID(IAnalysisWorkbenchCentralBody._uuid)
        vtable_offset_local = IAnalysisWorkbenchCentralBody._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBody, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchCentralBody.__dict__ and type(IAnalysisWorkbenchCentralBody.__dict__[attrname]) == property:
            return IAnalysisWorkbenchCentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchCentralBody.")
    
    @property
    def Name(self) -> str:
        """A name of the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8742150E-1663-4DCC-A442-278479FF93DC}", IAnalysisWorkbenchCentralBody)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBody"] = IAnalysisWorkbenchCentralBody

class IAnalysisWorkbenchCentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""
    _uuid = "{40596A74-4E5F-4406-85FF-70FA79893BFC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchCentralBodyRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchCentralBodyRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchCentralBodyRefTo = agcom.GUID(IAnalysisWorkbenchCentralBodyRefTo._uuid)
        vtable_offset_local = IAnalysisWorkbenchCentralBodyRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchCentralBodyRefTo.__dict__ and type(IAnalysisWorkbenchCentralBodyRefTo.__dict__[attrname]) == property:
            return IAnalysisWorkbenchCentralBodyRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchCentralBodyRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new central body using specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetCentralBody(self, centralBody:"IAnalysisWorkbenchCentralBody") -> None:
        """Sets a new central body."""
        with agmarshall.AgInterface_in_arg(centralBody, IAnalysisWorkbenchCentralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    def GetCentralBody(self) -> "IAnalysisWorkbenchCentralBody":
        """Returns a central body or null if the central body is invalid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{40596A74-4E5F-4406-85FF-70FA79893BFC}", IAnalysisWorkbenchCentralBodyRefTo)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBodyRefTo"] = IAnalysisWorkbenchCentralBodyRefTo

class IAnalysisWorkbenchCentralBodyCollection(object):
    """A collection of central body names."""
    _uuid = "{FB32C9FA-327D-4AF9-9330-7DE8854F827E}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchCentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchCentralBodyCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchCentralBodyCollection = agcom.GUID(IAnalysisWorkbenchCentralBodyCollection._uuid)
        vtable_offset_local = IAnalysisWorkbenchCentralBodyCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCentralBodyCollection, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchCentralBodyCollection.__dict__ and type(IAnalysisWorkbenchCentralBodyCollection.__dict__[attrname]) == property:
            return IAnalysisWorkbenchCentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchCentralBodyCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> str:
        """Returns a central body name at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, centralBodyName:str) -> bool:
        """Adds a central body to the collection of central bodies. True indicates success."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_centralBodyName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Remove(self, centralBodyName:str) -> None:
        """Removes a central body with the specified name from the collection of the central bodies."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_centralBodyName.COM_val))

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FB32C9FA-327D-4AF9-9330-7DE8854F827E}", IAnalysisWorkbenchCentralBodyCollection)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBodyCollection"] = IAnalysisWorkbenchCentralBodyCollection

class IAnalysisWorkbenchCollection(object):
    """A collection of VGT objects."""
    _uuid = "{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAnalysisWorkbenchCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAnalysisWorkbenchCollection = agcom.GUID(IAnalysisWorkbenchCollection._uuid)
        vtable_offset_local = IAnalysisWorkbenchCollection._vtable_offset - 1
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+5, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IAnalysisWorkbenchCollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAnalysisWorkbenchCollection.__dict__ and type(IAnalysisWorkbenchCollection.__dict__[attrname]) == property:
            return IAnalysisWorkbenchCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAnalysisWorkbenchCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAnalysisWorkbenchComponent":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAnalysisWorkbenchComponent":
        """Retrieves an element of the collection using the name of the element or a position in the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IAnalysisWorkbenchComponent":
        """Retrieves an item from the crdn collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "IAnalysisWorkbenchComponent":
        """Retrieves an item from the crdn collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}", IAnalysisWorkbenchCollection)
agcls.AgTypeNameMap["IAnalysisWorkbenchCollection"] = IAnalysisWorkbenchCollection

class ITimeToolPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    _uuid = "{5131DB47-EFEA-4021-BEC5-DD13A73D9917}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolPointSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolPointSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolPointSamplingResult = agcom.GUID(ITimeToolPointSamplingResult._uuid)
        vtable_offset_local = ITimeToolPointSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolPointSamplingResult.__dict__ and type(ITimeToolPointSamplingResult.__dict__[attrname]) == property:
            return ITimeToolPointSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolPointSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ITimeToolPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5131DB47-EFEA-4021-BEC5-DD13A73D9917}", ITimeToolPointSamplingResult)
agcls.AgTypeNameMap["ITimeToolPointSamplingResult"] = ITimeToolPointSamplingResult

class ITimeToolPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""
    _uuid = "{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetPositions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolPointSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolPointSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolPointSamplingInterval = agcom.GUID(ITimeToolPointSamplingInterval._uuid)
        vtable_offset_local = ITimeToolPointSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetPositions"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolPointSamplingInterval.__dict__ and type(ITimeToolPointSamplingInterval.__dict__[attrname]) == property:
            return ITimeToolPointSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolPointSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPositions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}", ITimeToolPointSamplingInterval)
agcls.AgTypeNameMap["ITimeToolPointSamplingInterval"] = ITimeToolPointSamplingInterval

class ITimeToolPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    _uuid = "{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolPointSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolPointSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolPointSamplingIntervalCollection = agcom.GUID(ITimeToolPointSamplingIntervalCollection._uuid)
        vtable_offset_local = ITimeToolPointSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolPointSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolPointSamplingIntervalCollection.__dict__ and type(ITimeToolPointSamplingIntervalCollection.__dict__[attrname]) == property:
            return ITimeToolPointSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolPointSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolPointSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ITimeToolPointSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}", ITimeToolPointSamplingIntervalCollection)
agcls.AgTypeNameMap["ITimeToolPointSamplingIntervalCollection"] = ITimeToolPointSamplingIntervalCollection

class ITimeToolAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    _uuid = "{F01C2A06-2998-406C-9898-CB60F5711EF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolAxesSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolAxesSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolAxesSamplingResult = agcom.GUID(ITimeToolAxesSamplingResult._uuid)
        vtable_offset_local = ITimeToolAxesSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolAxesSamplingResult.__dict__ and type(ITimeToolAxesSamplingResult.__dict__[attrname]) == property:
            return ITimeToolAxesSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolAxesSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ITimeToolAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F01C2A06-2998-406C-9898-CB60F5711EF1}", ITimeToolAxesSamplingResult)
agcls.AgTypeNameMap["ITimeToolAxesSamplingResult"] = ITimeToolAxesSamplingResult

class ITimeToolAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    _uuid = "{5BF49282-A56A-48F1-85C9-92CF71C803D0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetQuaternions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolAxesSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolAxesSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolAxesSamplingInterval = agcom.GUID(ITimeToolAxesSamplingInterval._uuid)
        vtable_offset_local = ITimeToolAxesSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetQuaternions"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolAxesSamplingInterval.__dict__ and type(ITimeToolAxesSamplingInterval.__dict__[attrname]) == property:
            return ITimeToolAxesSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolAxesSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuaternions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of angular velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BF49282-A56A-48F1-85C9-92CF71C803D0}", ITimeToolAxesSamplingInterval)
agcls.AgTypeNameMap["ITimeToolAxesSamplingInterval"] = ITimeToolAxesSamplingInterval

class ITimeToolAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    _uuid = "{F593657B-35A4-4F40-B697-4D14E66195AC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITimeToolAxesSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITimeToolAxesSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITimeToolAxesSamplingIntervalCollection = agcom.GUID(ITimeToolAxesSamplingIntervalCollection._uuid)
        vtable_offset_local = ITimeToolAxesSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITimeToolAxesSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITimeToolAxesSamplingIntervalCollection.__dict__ and type(ITimeToolAxesSamplingIntervalCollection.__dict__[attrname]) == property:
            return ITimeToolAxesSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITimeToolAxesSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITimeToolAxesSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ITimeToolAxesSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F593657B-35A4-4F40-B697-4D14E66195AC}", ITimeToolAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["ITimeToolAxesSamplingIntervalCollection"] = ITimeToolAxesSamplingIntervalCollection



class CalculationToolEvaluateResult(ICalculationToolEvaluateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        ICalculationToolEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolEvaluateResult._get_property(self, attrname) is not None: found_prop = ICalculationToolEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolEvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}", CalculationToolEvaluateResult)


class CalculationToolEvaluateWithRateResult(ICalculationToolEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        ICalculationToolEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = ICalculationToolEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolEvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}", CalculationToolEvaluateWithRateResult)


class TimeToolEventIntervalResult(ITimeToolEventIntervalResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalResult._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{ACE6C28C-4664-4B7F-8736-91F55C7962A6}", TimeToolEventIntervalResult)


class TimeToolEventFindOccurrenceResult(ITimeToolEventFindOccurrenceResult):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    def __init__(self, sourceObject=None):
        ITimeToolEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventFindOccurrenceResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventFindOccurrenceResult._get_property(self, attrname) is not None: found_prop = ITimeToolEventFindOccurrenceResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventFindOccurrenceResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}", TimeToolEventFindOccurrenceResult)


class TimeToolFindTimesResult(ITimeToolFindTimesResult):
    """Returns a collection of intervals and an array of times."""
    def __init__(self, sourceObject=None):
        ITimeToolFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolFindTimesResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolFindTimesResult._get_property(self, attrname) is not None: found_prop = ITimeToolFindTimesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolFindTimesResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}", TimeToolFindTimesResult)


class TimeToolIntervalsVectorResult(ITimeToolIntervalsVectorResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    def __init__(self, sourceObject=None):
        ITimeToolIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolIntervalsVectorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolIntervalsVectorResult._get_property(self, attrname) is not None: found_prop = ITimeToolIntervalsVectorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolIntervalsVectorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{233B8EB4-0B6A-485F-BACB-C678798FDA21}", TimeToolIntervalsVectorResult)


class TimeToolEventIntervalCollectionOccurredResult(ITimeToolEventIntervalCollectionOccurredResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionOccurredResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionOccurredResult._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionOccurredResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionOccurredResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}", TimeToolEventIntervalCollectionOccurredResult)


class TimeToolIntervalListResult(ITimeToolIntervalListResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        ITimeToolIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolIntervalListResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolIntervalListResult._get_property(self, attrname) is not None: found_prop = ITimeToolIntervalListResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolIntervalListResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}", TimeToolIntervalListResult)


class TimeToolIntervalVectorCollection(ITimeToolIntervalVectorCollection):
    """A collection of interval collections."""
    def __init__(self, sourceObject=None):
        ITimeToolIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolIntervalVectorCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolIntervalVectorCollection._get_property(self, attrname) is not None: found_prop = ITimeToolIntervalVectorCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolIntervalVectorCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}", TimeToolIntervalVectorCollection)


class TimeToolEventGroup(ITimeToolEventGroup):
    """Access or create VGT events associated with an object."""
    def __init__(self, sourceObject=None):
        ITimeToolEventGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventGroup._get_property(self, attrname) is not None: found_prop = ITimeToolEventGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D83181-A954-4FA9-886E-A917F135C974}", TimeToolEventGroup)


class TimeToolEventIntervalGroup(ITimeToolEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalGroup._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}", TimeToolEventIntervalGroup)


class TimeToolEventIntervalListGroup(ITimeToolEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListGroup._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B2FDEBA-A2B9-4568-8F48-469F604DB966}", TimeToolEventIntervalListGroup)


class TimeToolEventArrayGroup(ITimeToolEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayGroup._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{365C4A6E-9C2B-4883-96C6-CF689BCC2943}", TimeToolEventArrayGroup)


class CalculationToolScalarGroup(ICalculationToolScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarGroup._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{DFAD8468-4480-460F-993D-74FFADB567B3}", CalculationToolScalarGroup)


class TimeToolEventIntervalCollectionGroup(ITimeToolEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionGroup._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{16E277E2-E306-40E7-B698-B725BDED5739}", TimeToolEventIntervalCollectionGroup)


class CalculationToolParameterSetGroup(ICalculationToolParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetGroup._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}", CalculationToolParameterSetGroup)


class CalculationToolConditionGroup(ICalculationToolConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionGroup._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}", CalculationToolConditionGroup)


class CalculationToolConditionSetGroup(ICalculationToolConditionSetGroup):
    """Allows accessing and creating condition set components."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSetGroup._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D82D5C71-102E-4154-9FF6-153C4EDB5A94}", CalculationToolConditionSetGroup)


class CalculationToolConditionSetEvaluateResult(ICalculationToolConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSetEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSetEvaluateResult._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSetEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSetEvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{13F4EB53-F5AB-487A-BC09-AA186C884744}", CalculationToolConditionSetEvaluateResult)


class CalculationToolConditionSetEvaluateWithRateResult(ICalculationToolConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSetEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSetEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSetEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSetEvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{53051D77-87D0-432C-9044-A2AB1E2104BA}", CalculationToolConditionSetEvaluateWithRateResult)


class SpatialAnalysisToolVolumeGridGroup(ISpatialAnalysisToolVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridGroup._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}", SpatialAnalysisToolVolumeGridGroup)


class SpatialAnalysisToolVolumeGroup(ISpatialAnalysisToolVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGroup._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0055B726-654F-446B-82D7-BCDD744F1D8F}", SpatialAnalysisToolVolumeGroup)


class SpatialAnalysisToolVolumeCalcGroup(ISpatialAnalysisToolVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcGroup._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{b10331b7-f8c3-4a59-9e9b-b05dd6599167}", SpatialAnalysisToolVolumeCalcGroup)


class CalculationToolScalar(ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{440E178B-1B34-4896-A25F-2A4F3AD4848E}", CalculationToolScalar)


class CalculationToolScalarAngle(ICalculationToolScalarAngle, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarAngle.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarAngle._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarAngle._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarAngle._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E2A940D-2656-4410-86B4-D7314B788E47}", CalculationToolScalarAngle)


class CalculationToolScalarConstant(ICalculationToolScalarConstant, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Constant scalar value of specified dimension."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarConstant.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarConstant._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarConstant._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarConstant._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{0725A767-6788-4FF4-B848-EF3D526BD7B0}", CalculationToolScalarConstant)


class CalculationToolScalarCustom(ICalculationToolScalarCustom, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarCustom.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarCustom._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarCustom._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarCustom._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}", CalculationToolScalarCustom)


class CalculationToolScalarDataElement(ICalculationToolScalarDataElement, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarDataElement.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarDataElement._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarDataElement._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarDataElement._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarDataElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{260D686F-07E2-49DB-8E88-467EF79EFA54}", CalculationToolScalarDataElement)


class CalculationToolScalarDerivative(ICalculationToolScalarDerivative, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Derivative of an input scalar calculation."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarDerivative.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarDerivative._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarDerivative._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarDerivative._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}", CalculationToolScalarDerivative)


class CalculationToolScalarDotProduct(ICalculationToolScalarDotProduct, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Dot product between two vectors."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarDotProduct.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarDotProduct._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarDotProduct._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarDotProduct._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarDotProduct.")
        
agcls.AgClassCatalog.add_catalog_entry("{703f009e-faab-4281-8d07-733b1344d42b}", CalculationToolScalarDotProduct)


class CalculationToolScalarElapsedTime(ICalculationToolScalarElapsedTime, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Time elapsed since the reference time instant. Negative if in the past."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarElapsedTime.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarElapsedTime._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarElapsedTime._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarElapsedTime._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarElapsedTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}", CalculationToolScalarElapsedTime)


class CalculationToolScalarFactory(ICalculationToolScalarFactory):
    """The factory creates scalar calculation components."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarFactory._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{47235112-821F-4DC2-9A70-57AB9F1F17E8}", CalculationToolScalarFactory)


class CalculationToolScalarFile(ICalculationToolScalarFile, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarFile.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarFile._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarFile._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarFile._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{75F0039F-B789-4771-BD50-9AEF30F6038E}", CalculationToolScalarFile)


class CalculationToolScalarFixedAtTimeInstant(ICalculationToolScalarFixedAtTimeInstant, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarFixedAtTimeInstant.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarFixedAtTimeInstant._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarFixedAtTimeInstant._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}", CalculationToolScalarFixedAtTimeInstant)


class CalculationToolScalarFunction(ICalculationToolScalarFunction, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Defined by performing the specified function on the input scalar or time instant."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarFunction.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarFunction._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarFunction._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarFunction._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{40158F99-3146-4167-8BB0-A0046BB08EEB}", CalculationToolScalarFunction)


class CalculationToolScalarFunction2Var(ICalculationToolScalarFunction2Var, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Defined by performing a function(x,y) on two scalar arguments."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarFunction2Var.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarFunction2Var._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarFunction2Var._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarFunction2Var._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarFunction2Var.")
        
agcls.AgClassCatalog.add_catalog_entry("{05CA07A4-A36F-44EF-99C4-5E0999E79200}", CalculationToolScalarFunction2Var)


class CalculationToolScalarIntegral(ICalculationToolScalarIntegral, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarIntegral.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarIntegral._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarIntegral._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarIntegral._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarIntegral.")
        
agcls.AgClassCatalog.add_catalog_entry("{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}", CalculationToolScalarIntegral)


class CalculationToolScalarPlugin(ICalculationToolScalarPlugin, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Use a scalar calculation plugin."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarPlugin.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarPlugin._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarPlugin._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarPlugin._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E435E30B-EA9B-4EFB-852A-C20427B71484}", CalculationToolScalarPlugin)


class CalculationToolScalarSurfaceDistanceBetweenPoints(ICalculationToolScalarSurfaceDistanceBetweenPoints, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarSurfaceDistanceBetweenPoints._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarSurfaceDistanceBetweenPoints._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarSurfaceDistanceBetweenPoints._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarSurfaceDistanceBetweenPoints.")
        
agcls.AgClassCatalog.add_catalog_entry("{DEDCB488-6C70-4BC0-A719-68832FB6D30E}", CalculationToolScalarSurfaceDistanceBetweenPoints)


class CalculationToolScalarVectorComponent(ICalculationToolScalarVectorComponent, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """The specified component of a vector when resolved in the specified axes."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarVectorComponent.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarVectorComponent._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarVectorComponent._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarVectorComponent._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarVectorComponent.")
        
agcls.AgClassCatalog.add_catalog_entry("{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}", CalculationToolScalarVectorComponent)


class CalculationToolScalarVectorMagnitude(ICalculationToolScalarVectorMagnitude, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Scalar equal to the magnitude of a specified vector."""
    def __init__(self, sourceObject=None):
        ICalculationToolScalarVectorMagnitude.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolScalarVectorMagnitude._private_init(self, pUnk)
        ICalculationToolScalar._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolScalarVectorMagnitude._get_property(self, attrname) is not None: found_prop = ICalculationToolScalarVectorMagnitude._get_property(self, attrname)
        if ICalculationToolScalar._get_property(self, attrname) is not None: found_prop = ICalculationToolScalar._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolScalarVectorMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}", CalculationToolScalarVectorMagnitude)


class CalculationToolCondition(ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolCondition._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolCondition._get_property(self, attrname) is not None: found_prop = ICalculationToolCondition._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1BED244-FFB2-4038-AE76-A9B3194B2E49}", CalculationToolCondition)


class CalculationToolConditionCombined(ICalculationToolConditionCombined, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Defines a condition which combines multiple conditions."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionCombined.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionCombined._private_init(self, pUnk)
        ICalculationToolCondition._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionCombined._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionCombined._get_property(self, attrname)
        if ICalculationToolCondition._get_property(self, attrname) is not None: found_prop = ICalculationToolCondition._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{92F4488B-3543-4229-B1FB-447D282199B9}", CalculationToolConditionCombined)


class CalculationToolConditionFactory(ICalculationToolConditionFactory):
    """The factory creates condition components."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionFactory._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{06C627F8-87EA-4552-86E8-7E5049914CDE}", CalculationToolConditionFactory)


class CalculationToolConditionPointInVolume(ICalculationToolConditionPointInVolume, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionPointInVolume.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionPointInVolume._private_init(self, pUnk)
        ICalculationToolCondition._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionPointInVolume._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionPointInVolume._get_property(self, attrname)
        if ICalculationToolCondition._get_property(self, attrname) is not None: found_prop = ICalculationToolCondition._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionPointInVolume.")
        
agcls.AgClassCatalog.add_catalog_entry("{41532AD9-B30C-44AE-8581-CE74C24846A8}", CalculationToolConditionPointInVolume)


class CalculationToolConditionScalarBounds(ICalculationToolConditionScalarBounds, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionScalarBounds.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionScalarBounds._private_init(self, pUnk)
        ICalculationToolCondition._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionScalarBounds._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionScalarBounds._get_property(self, attrname)
        if ICalculationToolCondition._get_property(self, attrname) is not None: found_prop = ICalculationToolCondition._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionScalarBounds.")
        
agcls.AgClassCatalog.add_catalog_entry("{452E2178-AFB0-4E61-8187-9C6CB4A704A0}", CalculationToolConditionScalarBounds)


class CalculationToolConditionSet(ICalculationToolConditionSet, IAnalysisWorkbenchComponent):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSet._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6407B1B-6858-49FC-845A-F8A6239162C2}", CalculationToolConditionSet)


class CalculationToolConditionSetFactory(ICalculationToolConditionSetFactory):
    """The factory creates condition set components."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSetFactory._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D2445C98-9EA1-458F-9B6A-607249BF399A}", CalculationToolConditionSetFactory)


class CalculationToolConditionSetScalarThresholds(ICalculationToolConditionSetScalarThresholds, ICalculationToolConditionSet, IAnalysisWorkbenchComponent):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetScalarThresholds.__init__(self, sourceObject)
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConditionSetScalarThresholds._private_init(self, pUnk)
        ICalculationToolConditionSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConditionSetScalarThresholds._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSetScalarThresholds._get_property(self, attrname)
        if ICalculationToolConditionSet._get_property(self, attrname) is not None: found_prop = ICalculationToolConditionSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConditionSetScalarThresholds.")
        
agcls.AgClassCatalog.add_catalog_entry("{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}", CalculationToolConditionSetScalarThresholds)


class AnalysisWorkbenchConverge(IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchConverge._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchConverge._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchConverge._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchConverge.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A13D679-1970-43C2-8D4F-174B08AB04DC}", AnalysisWorkbenchConverge)


class CalculationToolConvergeBasic(ICalculationToolConvergeBasic, IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    def __init__(self, sourceObject=None):
        ICalculationToolConvergeBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolConvergeBasic._private_init(self, pUnk)
        IAnalysisWorkbenchConverge._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolConvergeBasic._get_property(self, attrname) is not None: found_prop = ICalculationToolConvergeBasic._get_property(self, attrname)
        if IAnalysisWorkbenchConverge._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchConverge._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolConvergeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{808F19C3-0E31-4C89-94C8-BBE01E067DFF}", CalculationToolConvergeBasic)


class AnalysisWorkbenchDerivative(IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchDerivative._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchDerivative._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchDerivative._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}", AnalysisWorkbenchDerivative)


class CalculationToolDerivativeBasic(ICalculationToolDerivativeBasic, IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    def __init__(self, sourceObject=None):
        ICalculationToolDerivativeBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolDerivativeBasic._private_init(self, pUnk)
        IAnalysisWorkbenchDerivative._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolDerivativeBasic._get_property(self, attrname) is not None: found_prop = ICalculationToolDerivativeBasic._get_property(self, attrname)
        if IAnalysisWorkbenchDerivative._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchDerivative._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolDerivativeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{3CD084C3-0045-4452-9793-AE8DF4073433}", CalculationToolDerivativeBasic)


class TimeToolEvent(ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Defines an event (time instant)."""
    def __init__(self, sourceObject=None):
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEvent.")
        
agcls.AgClassCatalog.add_catalog_entry("{A4B75B25-5DAE-4AEC-86EF-512F5E031766}", TimeToolEvent)


class TimeToolEventArray(ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArray.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5C87B1A-D519-4A01-8649-AA7560CD503A}", TimeToolEventArray)


class TimeToolEventArrayConditionCrossings(ITimeToolEventArrayConditionCrossings, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayConditionCrossings.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayConditionCrossings._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayConditionCrossings._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayConditionCrossings._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayConditionCrossings.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6FBC501-3521-4AE3-AFD8-4971F089D14F}", TimeToolEventArrayConditionCrossings)


class TimeToolEventArrayExtrema(ITimeToolEventArrayExtrema, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayExtrema.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayExtrema._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayExtrema._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayExtrema._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayExtrema.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}", TimeToolEventArrayExtrema)


class TimeToolEventArrayFactory(ITimeToolEventArrayFactory):
    """The factory creates event arrays."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayFactory._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}", TimeToolEventArrayFactory)


class TimeToolEventArrayFiltered(ITimeToolEventArrayFiltered, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by filtering times from original time array according to specified filtering method."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFiltered.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayFiltered._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayFiltered._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayFiltered._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}", TimeToolEventArrayFiltered)


class TimeToolEventArrayFixedStep(ITimeToolEventArrayFixedStep, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFixedStep.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayFixedStep._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayFixedStep._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayFixedStep._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{CDA379CC-7511-496E-874E-14E10F3E2B1A}", TimeToolEventArrayFixedStep)


class TimeToolEventArrayFixedTimes(ITimeToolEventArrayFixedTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Array defined by time ordered instants each explicitly specified."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFixedTimes.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayFixedTimes._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayFixedTimes._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayFixedTimes._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayFixedTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{EA73AECA-23AB-4DA1-B297-E80E19C55C15}", TimeToolEventArrayFixedTimes)


class TimeToolEventArrayMerged(ITimeToolEventArrayMerged, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayMerged.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayMerged._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayMerged._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayMerged._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{44FBC83E-D466-425F-ADF5-2003D754F935}", TimeToolEventArrayMerged)


class TimeToolEventArraySignaled(ITimeToolEventArraySignaled, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArraySignaled.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArraySignaled._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArraySignaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventArraySignaled._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArraySignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}", TimeToolEventArraySignaled)


class TimeToolEventArrayStartStopTimes(ITimeToolEventArrayStartStopTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    def __init__(self, sourceObject=None):
        ITimeToolEventArrayStartStopTimes.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventArrayStartStopTimes._private_init(self, pUnk)
        ITimeToolEventArray._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventArrayStartStopTimes._get_property(self, attrname) is not None: found_prop = ITimeToolEventArrayStartStopTimes._get_property(self, attrname)
        if ITimeToolEventArray._get_property(self, attrname) is not None: found_prop = ITimeToolEventArray._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventArrayStartStopTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}", TimeToolEventArrayStartStopTimes)


class TimeToolEventEpoch(ITimeToolEventEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event set at specified date/time."""
    def __init__(self, sourceObject=None):
        ITimeToolEventEpoch.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventEpoch._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventEpoch._get_property(self, attrname) is not None: found_prop = ITimeToolEventEpoch._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{230426D4-438A-4B6E-A9D2-5393F7F87238}", TimeToolEventEpoch)


class TimeToolEventExtremum(ITimeToolEventExtremum, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ITimeToolEventExtremum.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventExtremum._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventExtremum._get_property(self, attrname) is not None: found_prop = ITimeToolEventExtremum._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventExtremum.")
        
agcls.AgClassCatalog.add_catalog_entry("{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}", TimeToolEventExtremum)


class TimeToolEventFactory(ITimeToolEventFactory):
    """The factory creates events."""
    def __init__(self, sourceObject=None):
        ITimeToolEventFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventFactory._get_property(self, attrname) is not None: found_prop = ITimeToolEventFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}", TimeToolEventFactory)


class TimeToolEventInterval(ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{2CDA6DDC-7412-441A-8F94-0671FD57D16A}", TimeToolEventInterval)


class TimeToolEventIntervalBetweenTimeInstants(ITimeToolEventIntervalBetweenTimeInstants, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalBetweenTimeInstants._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalBetweenTimeInstants._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalBetweenTimeInstants._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalBetweenTimeInstants.")
        
agcls.AgClassCatalog.add_catalog_entry("{E84D9CAE-E919-4B84-99D7-553CCB97739C}", TimeToolEventIntervalBetweenTimeInstants)


class TimeToolEventIntervalCollection(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollection._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollection._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{892BFFEB-D366-49D5-8220-50AC5E4529A1}", TimeToolEventIntervalCollection)


class TimeToolEventIntervalCollectionCondition(ITimeToolEventIntervalCollectionCondition, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionCondition.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionCondition._private_init(self, pUnk)
        ITimeToolEventIntervalCollection._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionCondition._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionCondition._get_property(self, attrname)
        if ITimeToolEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollection._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}", TimeToolEventIntervalCollectionCondition)


class TimeToolEventIntervalCollectionFactory(ITimeToolEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionFactory._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C76F8390-6619-47D5-9D33-DD1FBBF19B63}", TimeToolEventIntervalCollectionFactory)


class TimeToolEventIntervalCollectionLighting(ITimeToolEventIntervalCollectionLighting, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionLighting.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionLighting._private_init(self, pUnk)
        ITimeToolEventIntervalCollection._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionLighting._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionLighting._get_property(self, attrname)
        if ITimeToolEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollection._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{5457BFBA-3076-4250-B0E0-81FA79D58F19}", TimeToolEventIntervalCollectionLighting)


class TimeToolEventIntervalCollectionSignaled(ITimeToolEventIntervalCollectionSignaled, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionSignaled.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalCollectionSignaled._private_init(self, pUnk)
        ITimeToolEventIntervalCollection._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalCollectionSignaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollectionSignaled._get_property(self, attrname)
        if ITimeToolEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalCollection._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalCollectionSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1ED3869-B0E3-40F6-967A-C539C5D5D630}", TimeToolEventIntervalCollectionSignaled)


class TimeToolEventIntervalFactory(ITimeToolEventIntervalFactory):
    """The factory creates event intervals."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalFactory._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D195D8-DE6D-4926-B743-556B08A827C8}", TimeToolEventIntervalFactory)


class TimeToolEventIntervalFixed(ITimeToolEventIntervalFixed, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFixed.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalFixed._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalFixed._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalFixed._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}", TimeToolEventIntervalFixed)


class TimeToolEventIntervalFixedDuration(ITimeToolEventIntervalFixedDuration, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFixedDuration.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalFixedDuration._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalFixedDuration._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalFixedDuration._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalFixedDuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{84316F31-A3DB-4DF3-B8E3-352673D4E251}", TimeToolEventIntervalFixedDuration)


class TimeToolEventIntervalFromIntervalList(ITimeToolEventIntervalFromIntervalList, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval created from specified interval list by using one of several selection methods."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFromIntervalList.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalFromIntervalList._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalFromIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalFromIntervalList._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalFromIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}", TimeToolEventIntervalFromIntervalList)


class TimeToolEventIntervalList(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{050E0A6D-9960-4470-9803-AF58B43FD747}", TimeToolEventIntervalList)


class TimeToolEventIntervalListCondition(ITimeToolEventIntervalListCondition, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListCondition.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListCondition._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListCondition._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListCondition._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}", TimeToolEventIntervalListCondition)


class TimeToolEventIntervalListFactory(ITimeToolEventIntervalListFactory):
    """The factory creates event interval lists."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListFactory._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}", TimeToolEventIntervalListFactory)


class TimeToolEventIntervalListFile(ITimeToolEventIntervalListFile, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFile.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListFile._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListFile._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListFile._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{5A3BC6C1-559F-448D-946E-3D608C0C59B4}", TimeToolEventIntervalListFile)


class TimeToolEventIntervalListFiltered(ITimeToolEventIntervalListFiltered, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFiltered.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListFiltered._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListFiltered._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListFiltered._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{7123DA29-BECE-4032-9A81-77CDA69C5B13}", TimeToolEventIntervalListFiltered)


class TimeToolEventIntervalListFixed(ITimeToolEventIntervalListFixed, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFixed.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListFixed._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListFixed._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListFixed._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}", TimeToolEventIntervalListFixed)


class TimeToolEventIntervalListMerged(ITimeToolEventIntervalListMerged, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListMerged.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListMerged._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListMerged._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListMerged._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{115C7064-1624-4928-B401-2C2B8DA2A2DC}", TimeToolEventIntervalListMerged)


class TimeToolEventIntervalListScaled(ITimeToolEventIntervalListScaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListScaled.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListScaled._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListScaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListScaled._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}", TimeToolEventIntervalListScaled)


class TimeToolEventIntervalListSignaled(ITimeToolEventIntervalListSignaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListSignaled.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListSignaled._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListSignaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListSignaled._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}", TimeToolEventIntervalListSignaled)


class TimeToolEventIntervalListTimeOffset(ITimeToolEventIntervalListTimeOffset, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListTimeOffset.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalListTimeOffset._private_init(self, pUnk)
        ITimeToolEventIntervalList._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalListTimeOffset._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalListTimeOffset._get_property(self, attrname)
        if ITimeToolEventIntervalList._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalList._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalListTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA2C1495-B20E-477A-A995-8B5B879DE84C}", TimeToolEventIntervalListTimeOffset)


class TimeToolEventIntervalScaled(ITimeToolEventIntervalScaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalScaled.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalScaled._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalScaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalScaled._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}", TimeToolEventIntervalScaled)


class TimeToolEventIntervalSignaled(ITimeToolEventIntervalSignaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalSignaled.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalSignaled._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalSignaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalSignaled._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}", TimeToolEventIntervalSignaled)


class TimeToolEventIntervalSmartInterval(ITimeToolEventIntervalSmartInterval, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """A smart interval."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalSmartInterval.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalSmartInterval._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalSmartInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalSmartInterval._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalSmartInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3D4E2AC-3845-4719-AD57-EE0C715A584D}", TimeToolEventIntervalSmartInterval)


class TimeToolEventIntervalTimeOffset(ITimeToolEventIntervalTimeOffset, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalTimeOffset.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventIntervalTimeOffset._private_init(self, pUnk)
        ITimeToolEventInterval._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventIntervalTimeOffset._get_property(self, attrname) is not None: found_prop = ITimeToolEventIntervalTimeOffset._get_property(self, attrname)
        if ITimeToolEventInterval._get_property(self, attrname) is not None: found_prop = ITimeToolEventInterval._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventIntervalTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{DE89BB00-5A89-4DA4-8730-CA2C3495A867}", TimeToolEventIntervalTimeOffset)


class TimeToolEventSignaled(ITimeToolEventSignaled, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    def __init__(self, sourceObject=None):
        ITimeToolEventSignaled.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventSignaled._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventSignaled._get_property(self, attrname) is not None: found_prop = ITimeToolEventSignaled._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}", TimeToolEventSignaled)


class TimeToolEventSmartEpoch(ITimeToolEventSmartEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """A smart epoch."""
    def __init__(self, sourceObject=None):
        ITimeToolEventSmartEpoch.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventSmartEpoch._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventSmartEpoch._get_property(self, attrname) is not None: found_prop = ITimeToolEventSmartEpoch._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventSmartEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{F722C253-92DA-4956-983B-B80AB469F192}", TimeToolEventSmartEpoch)


class TimeToolEventStartStopTime(ITimeToolEventStartStopTime, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event is either start or stop time selected from a reference interval."""
    def __init__(self, sourceObject=None):
        ITimeToolEventStartStopTime.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventStartStopTime._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventStartStopTime._get_property(self, attrname) is not None: found_prop = ITimeToolEventStartStopTime._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventStartStopTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F0429607-A51C-495C-9902-585429D40D10}", TimeToolEventStartStopTime)


class TimeToolEventTimeOffset(ITimeToolEventTimeOffset, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event at fixed offset from specified reference event."""
    def __init__(self, sourceObject=None):
        ITimeToolEventTimeOffset.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolEventTimeOffset._private_init(self, pUnk)
        ITimeToolEvent._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolEventTimeOffset._get_property(self, attrname) is not None: found_prop = ITimeToolEventTimeOffset._get_property(self, attrname)
        if ITimeToolEvent._get_property(self, attrname) is not None: found_prop = ITimeToolEvent._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolEventTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{EE2C89C8-C148-4044-B0BE-BF137D4B876B}", TimeToolEventTimeOffset)


class TimeToolFirstIntervalsFilter(ITimeToolFirstIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects a portion of first intervals."""
    def __init__(self, sourceObject=None):
        ITimeToolFirstIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolFirstIntervalsFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolFirstIntervalsFilter._get_property(self, attrname) is not None: found_prop = ITimeToolFirstIntervalsFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolFirstIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A044590-5063-4331-9FC2-621221CF7EA9}", TimeToolFirstIntervalsFilter)


class TimeToolGapsFilter(ITimeToolGapsFilter, ITimeToolPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ITimeToolGapsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolGapsFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolGapsFilter._get_property(self, attrname) is not None: found_prop = ITimeToolGapsFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolGapsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{C54D3817-6B48-4436-8E1D-323A38DC2BC0}", TimeToolGapsFilter)


class AnalysisWorkbenchIntegral(IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchIntegral._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchIntegral._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchIntegral._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchIntegral.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C6B1D39-FC48-475A-A888-DA9D459C1906}", AnalysisWorkbenchIntegral)


class CalculationToolIntegralBasic(ICalculationToolIntegralBasic, IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent):
    """Integral definition determines how scalar calculation is numerically integrated."""
    def __init__(self, sourceObject=None):
        ICalculationToolIntegralBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolIntegralBasic._private_init(self, pUnk)
        IAnalysisWorkbenchIntegral._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolIntegralBasic._get_property(self, attrname) is not None: found_prop = ICalculationToolIntegralBasic._get_property(self, attrname)
        if IAnalysisWorkbenchIntegral._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchIntegral._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolIntegralBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}", CalculationToolIntegralBasic)


class AnalysisWorkbenchInterp(IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchInterp._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchInterp._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchInterp._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchInterp.")
        
agcls.AgClassCatalog.add_catalog_entry("{F73B3675-6FD4-4050-9566-797DCD695107}", AnalysisWorkbenchInterp)


class CalculationToolInterpBasic(ICalculationToolInterpBasic, IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    def __init__(self, sourceObject=None):
        ICalculationToolInterpBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolInterpBasic._private_init(self, pUnk)
        IAnalysisWorkbenchInterp._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolInterpBasic._get_property(self, attrname) is not None: found_prop = ICalculationToolInterpBasic._get_property(self, attrname)
        if IAnalysisWorkbenchInterp._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchInterp._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolInterpBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{AB05143F-6997-4F40-BE86-DCF4D723F31E}", CalculationToolInterpBasic)


class TimeToolIntervalsFilter(ITimeToolIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects intervals of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ITimeToolIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolIntervalsFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolIntervalsFilter._get_property(self, attrname) is not None: found_prop = ITimeToolIntervalsFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}", TimeToolIntervalsFilter)


class TimeToolLastIntervalsFilter(ITimeToolLastIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects a portion of last intervals."""
    def __init__(self, sourceObject=None):
        ITimeToolLastIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolLastIntervalsFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolLastIntervalsFilter._get_property(self, attrname) is not None: found_prop = ITimeToolLastIntervalsFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolLastIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}", TimeToolLastIntervalsFilter)


class CalculationToolParameterSet(ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{CD1D82FC-08BF-4854-9295-F90AC87FAE68}", CalculationToolParameterSet)


class CalculationToolParameterSetAttitude(ICalculationToolParameterSetAttitude, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetAttitude.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetAttitude._private_init(self, pUnk)
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetAttitude._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetAttitude._get_property(self, attrname)
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{7082CB04-052B-46A2-A051-4FF52D0260B0}", CalculationToolParameterSetAttitude)


class CalculationToolParameterSetFactory(ICalculationToolParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetFactory._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{FF399336-197C-480B-98AC-3F07E76FF3BC}", CalculationToolParameterSetFactory)


class CalculationToolParameterSetGroundTrajectory(ICalculationToolParameterSetGroundTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetGroundTrajectory.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetGroundTrajectory._private_init(self, pUnk)
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetGroundTrajectory._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetGroundTrajectory._get_property(self, attrname)
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetGroundTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1972E17-F000-4BFF-80A3-216A91D0E2B1}", CalculationToolParameterSetGroundTrajectory)


class CalculationToolParameterSetOrbit(ICalculationToolParameterSetOrbit, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetOrbit.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetOrbit._private_init(self, pUnk)
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetOrbit._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetOrbit._get_property(self, attrname)
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetOrbit.")
        
agcls.AgClassCatalog.add_catalog_entry("{BF4A60A0-68E5-4000-8843-DD7FD76813A9}", CalculationToolParameterSetOrbit)


class CalculationToolParameterSetTrajectory(ICalculationToolParameterSetTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetTrajectory.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetTrajectory._private_init(self, pUnk)
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetTrajectory._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetTrajectory._get_property(self, attrname)
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{542072ED-4073-4F91-8EC8-45F7CC401ED7}", CalculationToolParameterSetTrajectory)


class CalculationToolParameterSetVector(ICalculationToolParameterSetVector, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetVector.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolParameterSetVector._private_init(self, pUnk)
        ICalculationToolParameterSet._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolParameterSetVector._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSetVector._get_property(self, attrname)
        if ICalculationToolParameterSet._get_property(self, attrname) is not None: found_prop = ICalculationToolParameterSet._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolParameterSetVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC7B40D5-7091-4A24-A698-436D2A274DC8}", CalculationToolParameterSetVector)


class TimeToolPruneFilter(ITimeToolPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolPruneFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{E08D63E9-CC8E-41F8-B3C5-0D062425C025}", TimeToolPruneFilter)


class TimeToolPruneFilterFactory(ITimeToolPruneFilterFactory):
    """The factory creates pruning filters."""
    def __init__(self, sourceObject=None):
        ITimeToolPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolPruneFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolPruneFilterFactory._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolPruneFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{954284C2-3544-4888-9A56-759AA8C7E1F7}", TimeToolPruneFilterFactory)


class TimeToolRelativeSatisfactionConditionFilter(ITimeToolRelativeSatisfactionConditionFilter, ITimeToolPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    def __init__(self, sourceObject=None):
        ITimeToolRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolRelativeSatisfactionConditionFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolRelativeSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = ITimeToolRelativeSatisfactionConditionFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolRelativeSatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{93A5C2C0-AABA-4DB3-9359-100604D0BA02}", TimeToolRelativeSatisfactionConditionFilter)


class AnalysisWorkbenchSampling(IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchSampling._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchSampling._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchSampling._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchSampling.")
        
agcls.AgClassCatalog.add_catalog_entry("{17FC40E9-EF68-4FFD-8A16-071054486F6A}", AnalysisWorkbenchSampling)


class CalculationToolSamplingBasic(ICalculationToolSamplingBasic, IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingBasic._private_init(self, pUnk)
        IAnalysisWorkbenchSampling._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingBasic._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingBasic._get_property(self, attrname)
        if IAnalysisWorkbenchSampling._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchSampling._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB786C50-8D9C-4333-A985-FFD2ADD20206}", CalculationToolSamplingBasic)


class CalculationToolSamplingCurvatureTolerance(ICalculationToolSamplingCurvatureTolerance, ICalculationToolSamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingCurvatureTolerance.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingCurvatureTolerance._private_init(self, pUnk)
        ICalculationToolSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingCurvatureTolerance._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingCurvatureTolerance._get_property(self, attrname)
        if ICalculationToolSamplingMethod._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingCurvatureTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{EF49B404-27D2-4AC5-BB5E-EA223A237922}", CalculationToolSamplingCurvatureTolerance)


class CalculationToolSamplingFixedStep(ICalculationToolSamplingFixedStep, ICalculationToolSamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingFixedStep.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingFixedStep._private_init(self, pUnk)
        ICalculationToolSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingFixedStep._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingFixedStep._get_property(self, attrname)
        if ICalculationToolSamplingMethod._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B7D520F-7835-4E84-BCA4-D748C73CB609}", CalculationToolSamplingFixedStep)


class CalculationToolSamplingMethod(ICalculationToolSamplingMethod):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingMethod._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}", CalculationToolSamplingMethod)


class CalculationToolSamplingMethodFactory(ICalculationToolSamplingMethodFactory):
    """The factory creates sampling method components."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingMethodFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingMethodFactory._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingMethodFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingMethodFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}", CalculationToolSamplingMethodFactory)


class CalculationToolSamplingRelativeTolerance(ICalculationToolSamplingRelativeTolerance, ICalculationToolSamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    def __init__(self, sourceObject=None):
        ICalculationToolSamplingRelativeTolerance.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationToolSamplingRelativeTolerance._private_init(self, pUnk)
        ICalculationToolSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationToolSamplingRelativeTolerance._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingRelativeTolerance._get_property(self, attrname)
        if ICalculationToolSamplingMethod._get_property(self, attrname) is not None: found_prop = ICalculationToolSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationToolSamplingRelativeTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}", CalculationToolSamplingRelativeTolerance)


class TimeToolSatisfactionConditionFilter(ITimeToolSatisfactionConditionFilter, ITimeToolPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ITimeToolSatisfactionConditionFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolSatisfactionConditionFilter._private_init(self, pUnk)
        ITimeToolPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = ITimeToolSatisfactionConditionFilter._get_property(self, attrname)
        if ITimeToolPruneFilter._get_property(self, attrname) is not None: found_prop = ITimeToolPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolSatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}", TimeToolSatisfactionConditionFilter)


class AnalysisWorkbenchSignalDelay(IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchSignalDelay._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchSignalDelay._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchSignalDelay._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchSignalDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{71744841-D938-44BE-8336-2B54F06CF443}", AnalysisWorkbenchSignalDelay)


class TimeToolSignalDelayBasic(ITimeToolSignalDelayBasic, IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        ITimeToolSignalDelayBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolSignalDelayBasic._private_init(self, pUnk)
        IAnalysisWorkbenchSignalDelay._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolSignalDelayBasic._get_property(self, attrname) is not None: found_prop = ITimeToolSignalDelayBasic._get_property(self, attrname)
        if IAnalysisWorkbenchSignalDelay._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchSignalDelay._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolSignalDelayBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{0763A330-475A-4E4E-AB26-8943A8CC1C92}", TimeToolSignalDelayBasic)


class SpatialAnalysisToolVolumeCalcFactory(ISpatialAnalysisToolVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcFactory._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{80956ae5-fb8c-4ce4-930f-56b362d07cec}", SpatialAnalysisToolVolumeCalcFactory)


class SpatialAnalysisToolVolumeFactory(ISpatialAnalysisToolVolumeFactory):
    """The factory is used to create instances of volumes."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeFactory._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9497BD8-A985-4054-8ADE-9042DE66125F}", SpatialAnalysisToolVolumeFactory)


class SpatialAnalysisToolVolumeGridFactory(ISpatialAnalysisToolVolumeGridFactory):
    """The factory is used to create instances of volume grids."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridFactory._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6359611-FB48-4B00-9017-01A4BE2B76E5}", SpatialAnalysisToolVolumeGridFactory)


class SpatialAnalysisToolGridCoordinateDefinition(ISpatialAnalysisToolGridCoordinateDefinition):
    """Defines a set of coordinate values."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolGridCoordinateDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolGridCoordinateDefinition._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridCoordinateDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolGridCoordinateDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}", SpatialAnalysisToolGridCoordinateDefinition)


class SpatialAnalysisToolGridValuesCustom(ISpatialAnalysisToolGridValuesCustom, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesCustom.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolGridValuesCustom._private_init(self, pUnk)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolGridValuesCustom._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesCustom._get_property(self, attrname)
        if ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolGridValuesCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}", SpatialAnalysisToolGridValuesCustom)


class SpatialAnalysisToolGridValuesFixedNumberOfSteps(ISpatialAnalysisToolGridValuesFixedNumberOfSteps, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolGridValuesFixedNumberOfSteps._private_init(self, pUnk)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_property(self, attrname)
        if ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolGridValuesFixedNumberOfSteps.")
        
agcls.AgClassCatalog.add_catalog_entry("{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}", SpatialAnalysisToolGridValuesFixedNumberOfSteps)


class SpatialAnalysisToolGridValuesFixedStep(ISpatialAnalysisToolGridValuesFixedStep, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesFixedStep.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolGridValuesFixedStep._private_init(self, pUnk)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolGridValuesFixedStep._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesFixedStep._get_property(self, attrname)
        if ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolGridValuesFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{0942EA2D-33DE-41B5-98BE-E53E659EC81D}", SpatialAnalysisToolGridValuesFixedStep)


class SpatialAnalysisToolGridValuesMethod(ISpatialAnalysisToolGridValuesMethod):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolGridValuesMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1D242BF-73F3-443A-AB46-64EAA02C5F37}", SpatialAnalysisToolGridValuesMethod)


class TimeToolLightTimeDelay(ITimeToolLightTimeDelay):
    """Manage Light Time Delay options.."""
    def __init__(self, sourceObject=None):
        ITimeToolLightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolLightTimeDelay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolLightTimeDelay._get_property(self, attrname) is not None: found_prop = ITimeToolLightTimeDelay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolLightTimeDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{085E2242-4392-4F35-857E-A46A72EADE70}", TimeToolLightTimeDelay)


class SpatialAnalysisToolVolume(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolume.")
        
agcls.AgClassCatalog.add_catalog_entry("{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}", SpatialAnalysisToolVolume)


class SpatialAnalysisToolVolumeCalc(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{d014bfd1-130d-4dc4-a841-76c75bc08f9c}", SpatialAnalysisToolVolumeCalc)


class SpatialAnalysisToolVolumeCalcAltitude(ISpatialAnalysisToolVolumeCalcAltitude, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc altitude interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcAltitude.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcAltitude._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcAltitude._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcAltitude._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcAltitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{4e3c369c-c189-48ce-8e93-f0c6478f0abe}", SpatialAnalysisToolVolumeCalcAltitude)


class SpatialAnalysisToolVolumeCalcAngleOffVector(ISpatialAnalysisToolVolumeCalcAngleOffVector, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc angle off vector interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcAngleOffVector.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcAngleOffVector._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcAngleOffVector._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcAngleOffVector._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcAngleOffVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}", SpatialAnalysisToolVolumeCalcAngleOffVector)


class SpatialAnalysisToolVolumeCalcConditionSatMetric(ISpatialAnalysisToolVolumeCalcConditionSatMetric, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc condition satisfaction interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcConditionSatMetric._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcConditionSatMetric.")
        
agcls.AgClassCatalog.add_catalog_entry("{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}", SpatialAnalysisToolVolumeCalcConditionSatMetric)


class SpatialAnalysisToolVolumeCalcDelayRange(ISpatialAnalysisToolVolumeCalcDelayRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc propagation delay to location interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcDelayRange.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcDelayRange._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcDelayRange._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcDelayRange._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcDelayRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}", SpatialAnalysisToolVolumeCalcDelayRange)


class SpatialAnalysisToolVolumeCalcFile(ISpatialAnalysisToolVolumeCalcFile, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFile.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcFile._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcFile._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcFile._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{188f96c6-9568-4609-9944-dfc5fb7247c5}", SpatialAnalysisToolVolumeCalcFile)


class SpatialAnalysisToolVolumeCalcFromScalar(ISpatialAnalysisToolVolumeCalcFromScalar, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc scalar to location interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFromScalar.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcFromScalar._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcFromScalar._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcFromScalar._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcFromScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{73219623-93c0-4c6e-961a-7fae5dfe9234}", SpatialAnalysisToolVolumeCalcFromScalar)


class SpatialAnalysisToolVolumeCalcRange(ISpatialAnalysisToolVolumeCalcRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc distance to location interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcRange.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcRange._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcRange._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcRange._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{7f1aa95f-e8d6-4faf-925b-98785243ba67}", SpatialAnalysisToolVolumeCalcRange)


class SpatialAnalysisToolVolumeCalcSolarIntensity(ISpatialAnalysisToolVolumeCalcSolarIntensity, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc solar intensityn interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcSolarIntensity.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCalcSolarIntensity._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeCalc._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCalcSolarIntensity._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalcSolarIntensity._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCalc._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCalcSolarIntensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{7796e871-d645-4f65-a3dc-de687b6fbcd5}", SpatialAnalysisToolVolumeCalcSolarIntensity)


class SpatialAnalysisToolVolumeCombined(ISpatialAnalysisToolVolumeCombined, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A combined volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCombined.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeCombined._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeCombined._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeCombined._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{7ECD2E89-B432-47C3-A80F-AF6429E66746}", SpatialAnalysisToolVolumeCombined)


class SpatialAnalysisToolVolumeFromCalc(ISpatialAnalysisToolVolumeFromCalc, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An volume from calc volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromCalc.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeFromCalc._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeFromCalc._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeFromCalc._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeFromCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F2AC0BF-4645-4C7F-9660-A894E267FD59}", SpatialAnalysisToolVolumeFromCalc)


class SpatialAnalysisToolVolumeFromCondition(ISpatialAnalysisToolVolumeFromCondition, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A volume from conditioninterface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromCondition.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeFromCondition._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeFromCondition._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeFromCondition._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeFromCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{A2546B12-78BF-4F8F-87C2-31BC73DA265B}", SpatialAnalysisToolVolumeFromCondition)


class SpatialAnalysisToolVolumeFromGrid(ISpatialAnalysisToolVolumeFromGrid, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromGrid.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeFromGrid._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeFromGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeFromGrid._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeFromGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{D49FE282-4C05-4097-970C-1282997378E9}", SpatialAnalysisToolVolumeFromGrid)


class SpatialAnalysisToolVolumeFromTimeSatisfaction(ISpatialAnalysisToolVolumeFromTimeSatisfaction, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An volume from time satisfaction volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeFromTimeSatisfaction._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeFromTimeSatisfaction._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeFromTimeSatisfaction._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeFromTimeSatisfaction.")
        
agcls.AgClassCatalog.add_catalog_entry("{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}", SpatialAnalysisToolVolumeFromTimeSatisfaction)


class SpatialAnalysisToolVolumeGrid(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}", SpatialAnalysisToolVolumeGrid)


class SpatialAnalysisToolVolumeGridBearingAlt(ISpatialAnalysisToolVolumeGridBearingAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid bearing alt (Surface Bearing) interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridBearingAlt.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridBearingAlt._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridBearingAlt._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridBearingAlt._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridBearingAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}", SpatialAnalysisToolVolumeGridBearingAlt)


class SpatialAnalysisToolVolumeGridCartesian(ISpatialAnalysisToolVolumeGridCartesian, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid Cartesian interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridCartesian.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridCartesian._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridCartesian._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridCartesian._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF15D0A4-BB42-4762-A761-9BD11DC948D0}", SpatialAnalysisToolVolumeGridCartesian)


class SpatialAnalysisToolVolumeGridConstrained(ISpatialAnalysisToolVolumeGridConstrained, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid constrained interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridConstrained.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridConstrained._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridConstrained._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridConstrained._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{253FC52C-5554-4A53-AE3D-624316ECFFFD}", SpatialAnalysisToolVolumeGridConstrained)


class SpatialAnalysisToolVolumeGridCylindrical(ISpatialAnalysisToolVolumeGridCylindrical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid cylindrical interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridCylindrical.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridCylindrical._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridCylindrical._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridCylindrical._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridCylindrical.")
        
agcls.AgClassCatalog.add_catalog_entry("{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}", SpatialAnalysisToolVolumeGridCylindrical)


class SpatialAnalysisToolVolumeGridLatLonAlt(ISpatialAnalysisToolVolumeGridLatLonAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridLatLonAlt.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridLatLonAlt._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridLatLonAlt._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridLatLonAlt._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridLatLonAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{89C10FC4-4031-4B63-9C55-E092DDF3839D}", SpatialAnalysisToolVolumeGridLatLonAlt)


class SpatialAnalysisToolVolumeGridResult(ISpatialAnalysisToolVolumeGridResult):
    """An interface that generates Volume Grid results."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridResult._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}", SpatialAnalysisToolVolumeGridResult)


class SpatialAnalysisToolVolumeGridSpherical(ISpatialAnalysisToolVolumeGridSpherical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid spherical interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridSpherical.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeGridSpherical._private_init(self, pUnk)
        ISpatialAnalysisToolVolumeGrid._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeGridSpherical._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGridSpherical._get_property(self, attrname)
        if ISpatialAnalysisToolVolumeGrid._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeGrid._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeGridSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{0DFD2937-3181-4895-AB05-A45FFD744964}", SpatialAnalysisToolVolumeGridSpherical)


class SpatialAnalysisToolVolumeInview(ISpatialAnalysisToolVolumeInview, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An Inview volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeInview.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeInview._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeInview._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeInview._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeInview.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}", SpatialAnalysisToolVolumeInview)


class SpatialAnalysisToolVolumeLighting(ISpatialAnalysisToolVolumeLighting, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A lighting volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeLighting.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeLighting._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeLighting._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeLighting._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}", SpatialAnalysisToolVolumeLighting)


class SpatialAnalysisToolVolumeOverTime(ISpatialAnalysisToolVolumeOverTime, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeOverTime.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpatialAnalysisToolVolumeOverTime._private_init(self, pUnk)
        ISpatialAnalysisToolVolume._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpatialAnalysisToolVolumeOverTime._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolumeOverTime._get_property(self, attrname)
        if ISpatialAnalysisToolVolume._get_property(self, attrname) is not None: found_prop = ISpatialAnalysisToolVolume._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpatialAnalysisToolVolumeOverTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}", SpatialAnalysisToolVolumeOverTime)


class AnalysisWorkbenchGeneric(IAnalysisWorkbenchComponent):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchGeneric.")
        
agcls.AgClassCatalog.add_catalog_entry("{2909EDFB-9BE2-4BD2-A678-186C9D136937}", AnalysisWorkbenchGeneric)


class AnalysisWorkbenchTypeInfo(IAnalysisWorkbenchTypeInfo):
    """VGT component info."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchTypeInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchTypeInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchTypeInfo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchTypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchTypeInfo.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA26887C-6DFE-4F18-96D8-5694296568D2}", AnalysisWorkbenchTypeInfo)


class AnalysisWorkbenchInstance(IAnalysisWorkbenchContext, IAnalysisWorkbenchInstance):
    """Enables to obtain information about the parent object that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
        IAnalysisWorkbenchInstance.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchContext._private_init(self, pUnk)
        IAnalysisWorkbenchInstance._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchContext._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchContext._get_property(self, attrname)
        if IAnalysisWorkbenchInstance._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchInstance._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchInstance.")
        
agcls.AgClassCatalog.add_catalog_entry("{28241775-2044-4AD1-BC1D-D5B345437415}", AnalysisWorkbenchInstance)


class AnalysisWorkbenchTemplate(IAnalysisWorkbenchContext, IAnalysisWorkbenchTemplate):
    """Enables to obtain information about the STK class that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
        IAnalysisWorkbenchTemplate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchContext._private_init(self, pUnk)
        IAnalysisWorkbenchTemplate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchContext._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchContext._get_property(self, attrname)
        if IAnalysisWorkbenchTemplate._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchTemplate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchTemplate.")
        
agcls.AgClassCatalog.add_catalog_entry("{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}", AnalysisWorkbenchTemplate)


class VectorGeometryToolPointRefTo(IVectorGeometryToolPointRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}", VectorGeometryToolPointRefTo)


class VectorGeometryToolVectorRefTo(IVectorGeometryToolVectorRefTo, IAnalysisWorkbenchRefTo):
    """Represents a vector reference."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}", VectorGeometryToolVectorRefTo)


class VectorGeometryToolAxesRefTo(IVectorGeometryToolAxesRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{ABAD0C95-5570-461A-9DA0-FD800B10DB20}", VectorGeometryToolAxesRefTo)


class VectorGeometryToolAngleRefTo(IVectorGeometryToolAngleRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT angle."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1C8DFF6-65AA-4A6B-B160-7315BD795133}", VectorGeometryToolAngleRefTo)


class VectorGeometryToolSystemRefTo(IVectorGeometryToolSystemRefTo, IAnalysisWorkbenchRefTo):
    """Represents a System reference."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}", VectorGeometryToolSystemRefTo)


class VectorGeometryToolPlaneRefTo(IVectorGeometryToolPlaneRefTo, IAnalysisWorkbenchRefTo):
    """Represents a Plane reference."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneRefTo._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}", VectorGeometryToolPlaneRefTo)


class VectorGeometryToolVector(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{64392436-52D5-4274-9483-E10C56BBD037}", VectorGeometryToolVector)


class VectorGeometryToolAxesLabels(IVectorGeometryToolAxesLabels):
    """Allows configuring the VGT axes labels."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesLabels._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{AC9F13AD-1E42-4695-AC74-6259D2013E4F}", VectorGeometryToolAxesLabels)


class VectorGeometryToolAxes(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{50F5DD10-4D83-4603-94ED-BF7514C26282}", VectorGeometryToolAxes)


class VectorGeometryToolPoint(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{0092C129-467E-4B36-B971-C53F65481DA9}", VectorGeometryToolPoint)


class VectorGeometryToolSystem(IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystem._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystem._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystem._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystem.")
        
agcls.AgClassCatalog.add_catalog_entry("{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}", VectorGeometryToolSystem)


class VectorGeometryToolAngle(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{C3F96DA3-00EC-4E20-A66C-B3506100496B}", VectorGeometryToolAngle)


class VectorGeometryToolPlaneLabels(IVectorGeometryToolPlaneLabels):
    """Allows configuring the X and Y axes labels."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneLabels._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}", VectorGeometryToolPlaneLabels)


class VectorGeometryToolPlane(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E6EAA85-8440-4C4E-97FE-76491E05098A}", VectorGeometryToolPlane)


class VectorGeometryToolAxesAlignedAndConstrained(IVectorGeometryToolAxesAlignedAndConstrained, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAlignedAndConstrained.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesAlignedAndConstrained._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesAlignedAndConstrained._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesAlignedAndConstrained._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesAlignedAndConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{46BB7D5B-6593-434F-B288-BF1445920A2C}", VectorGeometryToolAxesAlignedAndConstrained)


class VectorGeometryToolAxesAngularOffset(IVectorGeometryToolAxesAngularOffset, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAngularOffset.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesAngularOffset._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesAngularOffset._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesAngularOffset._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesAngularOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{64503F8B-96E7-455B-B589-2578ADE1214B}", VectorGeometryToolAxesAngularOffset)


class VectorGeometryToolAxesFixedAtEpoch(IVectorGeometryToolAxesFixedAtEpoch, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes based on another set fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFixedAtEpoch.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesFixedAtEpoch._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesFixedAtEpoch._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}", VectorGeometryToolAxesFixedAtEpoch)


class VectorGeometryToolAxesBPlane(IVectorGeometryToolAxesBPlane, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """B-Plane axes using the selected target body and reference vector."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesBPlane.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesBPlane._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesBPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesBPlane._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0F714EA-31E4-4F92-876F-BDD3183C29B5}", VectorGeometryToolAxesBPlane)


class VectorGeometryToolAxesCustomScript(IVectorGeometryToolAxesCustomScript, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Customized axes offset with respect to a set of reference Axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesCustomScript.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesCustomScript._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesCustomScript._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesCustomScript._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC7A87DC-118E-46ED-8657-90DF42B7B101}", VectorGeometryToolAxesCustomScript)


class VectorGeometryToolAxesAttitudeFile(IVectorGeometryToolAxesAttitudeFile, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes specified by data from a file."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAttitudeFile.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesAttitudeFile._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesAttitudeFile._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesAttitudeFile._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesAttitudeFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{3505D063-9E1B-4964-9865-FFE41F64C8CF}", VectorGeometryToolAxesAttitudeFile)


class VectorGeometryToolAxesFixed(IVectorGeometryToolAxesFixed, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFixed.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesFixed._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesFixed._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesFixed._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}", VectorGeometryToolAxesFixed)


class VectorGeometryToolAxesModelAttach(IVectorGeometryToolAxesModelAttach, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesModelAttach._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesModelAttach._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesModelAttach._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{816C612A-13DD-4812-BFDE-E3861F8C39FD}", VectorGeometryToolAxesModelAttach)


class VectorGeometryToolAxesSpinning(IVectorGeometryToolAxesSpinning, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesSpinning.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesSpinning._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesSpinning._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesSpinning._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesSpinning.")
        
agcls.AgClassCatalog.add_catalog_entry("{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}", VectorGeometryToolAxesSpinning)


class VectorGeometryToolAxesOnSurface(IVectorGeometryToolAxesOnSurface, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Topocentric axes located at the reference point's projection on the central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesOnSurface._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesOnSurface._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesOnSurface._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE8C301A-A846-44FD-8871-5AB4CAACEF11}", VectorGeometryToolAxesOnSurface)


class VectorGeometryToolAxesTrajectory(IVectorGeometryToolAxesTrajectory, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesTrajectory.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesTrajectory._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesTrajectory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesTrajectory._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4038771E-73C1-4989-A9AB-4DC37025FACC}", VectorGeometryToolAxesTrajectory)


class VectorGeometryToolAxesLagrangeLibration(IVectorGeometryToolAxesLagrangeLibration, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesLagrangeLibration.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesLagrangeLibration._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesLagrangeLibration._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesLagrangeLibration._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{16315085-7C87-4A20-865C-0F419A5CDA2F}", VectorGeometryToolAxesLagrangeLibration)


class VectorGeometryToolAxesCommonTasks(IVectorGeometryToolAxesCommonTasks):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesCommonTasks._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{07D4865C-78F1-4B3A-9756-D70050613D4A}", VectorGeometryToolAxesCommonTasks)


class VectorGeometryToolAxesAtTimeInstant(IVectorGeometryToolAxesAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesAtTimeInstant._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesAtTimeInstant._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesAtTimeInstant._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{3845C20A-A6E2-45A0-A748-10E9B565C48D}", VectorGeometryToolAxesAtTimeInstant)


class VectorGeometryToolAxesPlugin(IVectorGeometryToolAxesPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes):
    """A VGT axes plugin."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesPlugin._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesPlugin._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesPlugin._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}", VectorGeometryToolAxesPlugin)


class VectorGeometryToolAngleBetweenVectors(IVectorGeometryToolAngleBetweenVectors, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two vectors."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleBetweenVectors.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleBetweenVectors._private_init(self, pUnk)
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleBetweenVectors._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleBetweenVectors._get_property(self, attrname)
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleBetweenVectors.")
        
agcls.AgClassCatalog.add_catalog_entry("{2F0AA430-85D0-4479-9540-B1B64EB3B530}", VectorGeometryToolAngleBetweenVectors)


class VectorGeometryToolAngleBetweenPlanes(IVectorGeometryToolAngleBetweenPlanes, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two planes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleBetweenPlanes.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleBetweenPlanes._private_init(self, pUnk)
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleBetweenPlanes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleBetweenPlanes._get_property(self, attrname)
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleBetweenPlanes.")
        
agcls.AgClassCatalog.add_catalog_entry("{30C2886F-8792-475D-9E42-975308B1B94E}", VectorGeometryToolAngleBetweenPlanes)


class VectorGeometryToolAngleDihedral(IVectorGeometryToolAngleDihedral, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two vectors about an axis."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleDihedral.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleDihedral._private_init(self, pUnk)
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleDihedral._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleDihedral._get_property(self, attrname)
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleDihedral.")
        
agcls.AgClassCatalog.add_catalog_entry("{550855BB-E8F1-440B-BA5C-024ACE2E2A17}", VectorGeometryToolAngleDihedral)


class VectorGeometryToolAngleRotation(IVectorGeometryToolAngleRotation, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleRotation.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleRotation._private_init(self, pUnk)
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleRotation._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleRotation._get_property(self, attrname)
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleRotation.")
        
agcls.AgClassCatalog.add_catalog_entry("{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}", VectorGeometryToolAngleRotation)


class VectorGeometryToolAngleToPlane(IVectorGeometryToolAngleToPlane, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between a vector and a plane."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleToPlane.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleToPlane._private_init(self, pUnk)
        IVectorGeometryToolAngle._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleToPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleToPlane._get_property(self, attrname)
        if IVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngle._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleToPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}", VectorGeometryToolAngleToPlane)


class VectorGeometryToolPlaneNormal(IVectorGeometryToolPlaneNormal, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneNormal.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneNormal._private_init(self, pUnk)
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneNormal._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneNormal._get_property(self, attrname)
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{0AED319D-7B6C-462B-882B-D363F7A2A86C}", VectorGeometryToolPlaneNormal)


class VectorGeometryToolPlaneQuadrant(IVectorGeometryToolPlaneQuadrant, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane based on a selected Quadrant of a reference system."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneQuadrant.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneQuadrant._private_init(self, pUnk)
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneQuadrant._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneQuadrant._get_property(self, attrname)
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneQuadrant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}", VectorGeometryToolPlaneQuadrant)


class VectorGeometryToolPlaneTrajectory(IVectorGeometryToolPlaneTrajectory, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTrajectory.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneTrajectory._private_init(self, pUnk)
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneTrajectory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneTrajectory._get_property(self, attrname)
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7BD18F79-6788-48B1-AFB5-243D62C01177}", VectorGeometryToolPlaneTrajectory)


class VectorGeometryToolPlaneTriad(IVectorGeometryToolPlaneTriad, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTriad.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneTriad._private_init(self, pUnk)
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneTriad._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneTriad._get_property(self, attrname)
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneTriad.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}", VectorGeometryToolPlaneTriad)


class VectorGeometryToolPlaneTwoVector(IVectorGeometryToolPlaneTwoVector, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTwoVector.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneTwoVector._private_init(self, pUnk)
        IVectorGeometryToolPlane._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneTwoVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneTwoVector._get_property(self, attrname)
        if IVectorGeometryToolPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlane._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneTwoVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{49a61e7a-baba-48fd-9d9d-61f91c520291}", VectorGeometryToolPlaneTwoVector)


class VectorGeometryToolPointBPlane(IVectorGeometryToolPointBPlane, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """B-Plane point using the selected target body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointBPlane.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointBPlane._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointBPlane._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointBPlane._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E62329EB-83D1-47CE-8B5B-B795995A2270}", VectorGeometryToolPointBPlane)


class VectorGeometryToolPointFile(IVectorGeometryToolPointFile, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point specified by data from a file."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFile.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointFile._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointFile._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointFile._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E71C927-09CA-4A90-95F0-CB87E244CE72}", VectorGeometryToolPointFile)


class VectorGeometryToolPointFixedInSystem(IVectorGeometryToolPointFixedInSystem, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFixedInSystem.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointFixedInSystem._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointFixedInSystem._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointFixedInSystem._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointFixedInSystem.")
        
agcls.AgClassCatalog.add_catalog_entry("{9FA10E06-094A-446C-BE9A-5BA397776778}", VectorGeometryToolPointFixedInSystem)


class VectorGeometryToolPointGrazing(IVectorGeometryToolPointGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGrazing.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointGrazing._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointGrazing._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointGrazing._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}", VectorGeometryToolPointGrazing)


class VectorGeometryToolPointGlint(IVectorGeometryToolPointGlint, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point on central body surface that reflects from source to observer."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGlint.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointGlint._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointGlint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointGlint._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointGlint.")
        
agcls.AgClassCatalog.add_catalog_entry("{68F85553-0FA2-459D-93AC-BD4D68A01F6F}", VectorGeometryToolPointGlint)


class VectorGeometryToolPointCovarianceGrazing(IVectorGeometryToolPointCovarianceGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCovarianceGrazing.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointCovarianceGrazing._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointCovarianceGrazing._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointCovarianceGrazing._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointCovarianceGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{84D91807-716E-46F4-AB70-53C73FA21C20}", VectorGeometryToolPointCovarianceGrazing)


class VectorGeometryToolPointPlaneIntersection(IVectorGeometryToolPointPlaneIntersection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point on a plane located along a given direction looking from a given origin."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlaneIntersection.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointPlaneIntersection._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointPlaneIntersection._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointPlaneIntersection._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointPlaneIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}", VectorGeometryToolPointPlaneIntersection)


class VectorGeometryToolPointOnSurface(IVectorGeometryToolPointOnSurface, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The detic subpoint of the reference point as projected onto the central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointOnSurface._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointOnSurface._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointOnSurface._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{03ECCFD1-B058-4817-826F-EDE2A6880757}", VectorGeometryToolPointOnSurface)


class VectorGeometryToolPointModelAttach(IVectorGeometryToolPointModelAttach, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointModelAttach._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointModelAttach._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointModelAttach._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{15958616-F779-4772-9E54-9B134B69BE89}", VectorGeometryToolPointModelAttach)


class VectorGeometryToolPointSatelliteCollectionEntry(IVectorGeometryToolPointSatelliteCollectionEntry, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointSatelliteCollectionEntry.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointSatelliteCollectionEntry._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointSatelliteCollectionEntry._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointSatelliteCollectionEntry._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointSatelliteCollectionEntry.")
        
agcls.AgClassCatalog.add_catalog_entry("{d0dacbed-0c16-4de5-b32a-9c7624297014}", VectorGeometryToolPointSatelliteCollectionEntry)


class VectorGeometryToolPointPlaneProjection(IVectorGeometryToolPointPlaneProjection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlaneProjection.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointPlaneProjection._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointPlaneProjection._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointPlaneProjection._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointPlaneProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}", VectorGeometryToolPointPlaneProjection)


class VectorGeometryToolPointLagrangeLibration(IVectorGeometryToolPointLagrangeLibration, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointLagrangeLibration.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointLagrangeLibration._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointLagrangeLibration._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointLagrangeLibration._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{6BF6D976-775A-445D-AD2B-899892F3127E}", VectorGeometryToolPointLagrangeLibration)


class VectorGeometryToolPointCommonTasks(IVectorGeometryToolPointCommonTasks):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointCommonTasks._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{9866644C-E731-465E-A7AA-3F4667C1729E}", VectorGeometryToolPointCommonTasks)


class VectorGeometryToolPointCentBodyIntersect(IVectorGeometryToolPointCentBodyIntersect, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point on central body surface along direction vector originating at source point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCentBodyIntersect.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointCentBodyIntersect._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointCentBodyIntersect._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointCentBodyIntersect._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointCentBodyIntersect.")
        
agcls.AgClassCatalog.add_catalog_entry("{882047E8-7CB3-489B-B029-33163CBBA583}", VectorGeometryToolPointCentBodyIntersect)


class VectorGeometryToolPointAtTimeInstant(IVectorGeometryToolPointAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointAtTimeInstant._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointAtTimeInstant._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointAtTimeInstant._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}", VectorGeometryToolPointAtTimeInstant)


class VectorGeometryToolPointPlugin(IVectorGeometryToolPointPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """A VGT point plugin."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointPlugin._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointPlugin._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointPlugin._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}", VectorGeometryToolPointPlugin)


class VectorGeometryToolPointCBFixedOffset(IVectorGeometryToolPointCBFixedOffset, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point specified by fixed components with respect to central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCBFixedOffset.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointCBFixedOffset._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointCBFixedOffset._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointCBFixedOffset._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolPoint._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointCBFixedOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}", VectorGeometryToolPointCBFixedOffset)


class VectorGeometryToolSystemAssembled(IVectorGeometryToolSystemAssembled, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A system assembled from an origin point and a set of reference axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemAssembled.__init__(self, sourceObject)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemAssembled._private_init(self, pUnk)
        IVectorGeometryToolSystem._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemAssembled._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemAssembled._get_property(self, attrname)
        if IVectorGeometryToolSystem._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystem._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemAssembled.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE4E84B1-8CCF-467A-A3ED-274D0943407F}", VectorGeometryToolSystemAssembled)


class VectorGeometryToolSystemOnSurface(IVectorGeometryToolSystemOnSurface, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemOnSurface._private_init(self, pUnk)
        IVectorGeometryToolSystem._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemOnSurface._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemOnSurface._get_property(self, attrname)
        if IVectorGeometryToolSystem._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystem._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{073423F9-A59D-4313-B499-C86A45C63513}", VectorGeometryToolSystemOnSurface)


class AnalysisWorkbenchLLAPosition(IAnalysisWorkbenchLLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchLLAPosition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchLLAPosition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchLLAPosition._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchLLAPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchLLAPosition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB962F51-978A-43F9-A88B-AAB62117F93C}", AnalysisWorkbenchLLAPosition)


class VectorGeometryToolSystemCommonTasks(IVectorGeometryToolSystemCommonTasks):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemCommonTasks._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}", VectorGeometryToolSystemCommonTasks)


class VectorGeometryToolVectorAngleRate(IVectorGeometryToolVectorAngleRate, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorAngleRate.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorAngleRate._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorAngleRate._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorAngleRate._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorAngleRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{5769E079-8E9B-40B2-B2EF-14F202AF5666}", VectorGeometryToolVectorAngleRate)


class VectorGeometryToolVectorApoapsis(IVectorGeometryToolVectorApoapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorApoapsis.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorApoapsis._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorApoapsis._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorApoapsis._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{22E4138C-29C6-4401-91E0-DF0C00422302}", VectorGeometryToolVectorApoapsis)


class VectorGeometryToolVectorFixedAtEpoch(IVectorGeometryToolVectorFixedAtEpoch, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Based on another vector fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedAtEpoch.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorFixedAtEpoch._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorFixedAtEpoch._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{FA8DB5F5-1F28-40E6-9B86-489E06D61523}", VectorGeometryToolVectorFixedAtEpoch)


class VectorGeometryToolVectorAngularVelocity(IVectorGeometryToolVectorAngularVelocity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorAngularVelocity.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorAngularVelocity._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorAngularVelocity._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorAngularVelocity._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorAngularVelocity.")
        
agcls.AgClassCatalog.add_catalog_entry("{2ABC83DB-6F6C-4A91-8597-21BD2715D411}", VectorGeometryToolVectorAngularVelocity)


class VectorGeometryToolVectorConing(IVectorGeometryToolVectorConing, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorConing.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorConing._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorConing._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorConing._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorConing.")
        
agcls.AgClassCatalog.add_catalog_entry("{74E6F986-E292-4115-84E4-9E9953C163B8}", VectorGeometryToolVectorConing)


class VectorGeometryToolVectorCross(IVectorGeometryToolVectorCross, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The vector cross product of two vectors."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorCross.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorCross._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorCross._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorCross._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorCross.")
        
agcls.AgClassCatalog.add_catalog_entry("{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}", VectorGeometryToolVectorCross)


class VectorGeometryToolVectorCustomScript(IVectorGeometryToolVectorCustomScript, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Customized vector components defined with respect to reference axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorCustomScript.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorCustomScript._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorCustomScript._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorCustomScript._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{D65CDDC6-21DA-419F-BF72-79C2376648E8}", VectorGeometryToolVectorCustomScript)


class VectorGeometryToolVectorDerivative(IVectorGeometryToolVectorDerivative, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A vector derivative of a vector computed with respect to specified axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDerivative.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorDerivative._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorDerivative._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorDerivative._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}", VectorGeometryToolVectorDerivative)


class VectorGeometryToolVectorDisplacement(IVectorGeometryToolVectorDisplacement, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector defined by its start and end points."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDisplacement.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorDisplacement._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorDisplacement._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorDisplacement._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorDisplacement.")
        
agcls.AgClassCatalog.add_catalog_entry("{6CAADA67-7238-4705-9F74-95596344DED0}", VectorGeometryToolVectorDisplacement)


class VectorGeometryToolVectorTwoPlanesIntersection(IVectorGeometryToolVectorTwoPlanesIntersection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Defined along the intersection of two planes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorTwoPlanesIntersection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorTwoPlanesIntersection._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorTwoPlanesIntersection._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorTwoPlanesIntersection._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorTwoPlanesIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1145553-76CD-4C1E-AE08-E63E29CF4E46}", VectorGeometryToolVectorTwoPlanesIntersection)


class VectorGeometryToolVectorModelAttach(IVectorGeometryToolVectorModelAttach, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorModelAttach._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorModelAttach._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorModelAttach._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{E95BEEB8-C544-4852-9C82-20080343E585}", VectorGeometryToolVectorModelAttach)


class VectorGeometryToolVectorProjection(IVectorGeometryToolVectorProjection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A projection of a vector computed with respect to a reference plane."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorProjection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorProjection._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorProjection._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorProjection._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{7306544A-A8B0-477B-B89D-BA711C9ED600}", VectorGeometryToolVectorProjection)


class VectorGeometryToolVectorScaled(IVectorGeometryToolVectorScaled, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScaled.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorScaled._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorScaled._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorScaled._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{92D80C29-251B-436B-9DA0-D5BA4B262185}", VectorGeometryToolVectorScaled)


class VectorGeometryToolVectorEccentricity(IVectorGeometryToolVectorEccentricity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorEccentricity.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorEccentricity._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorEccentricity._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorEccentricity._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7F157D7-11EB-4779-955F-98530B9C2608}", VectorGeometryToolVectorEccentricity)


class VectorGeometryToolVectorFixedInAxes(IVectorGeometryToolVectorFixedInAxes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedInAxes.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorFixedInAxes._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorFixedInAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorFixedInAxes._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorFixedInAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{61E9F963-8CFC-4B24-B583-716A64BAE54C}", VectorGeometryToolVectorFixedInAxes)


class VectorGeometryToolVectorLineOfNodes(IVectorGeometryToolVectorLineOfNodes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorLineOfNodes.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorLineOfNodes._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorLineOfNodes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorLineOfNodes._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorLineOfNodes.")
        
agcls.AgClassCatalog.add_catalog_entry("{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}", VectorGeometryToolVectorLineOfNodes)


class VectorGeometryToolVectorOrbitAngularMomentum(IVectorGeometryToolVectorOrbitAngularMomentum, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorOrbitAngularMomentum.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorOrbitAngularMomentum._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorOrbitAngularMomentum._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorOrbitAngularMomentum._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorOrbitAngularMomentum.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}", VectorGeometryToolVectorOrbitAngularMomentum)


class VectorGeometryToolVectorOrbitNormal(IVectorGeometryToolVectorOrbitNormal, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorOrbitNormal.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorOrbitNormal._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorOrbitNormal._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorOrbitNormal._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorOrbitNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}", VectorGeometryToolVectorOrbitNormal)


class VectorGeometryToolVectorPeriapsis(IVectorGeometryToolVectorPeriapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorPeriapsis.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorPeriapsis._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorPeriapsis._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorPeriapsis._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA81B380-6D7C-48F4-8E7F-472035958B44}", VectorGeometryToolVectorPeriapsis)


class VectorGeometryToolVectorReflection(IVectorGeometryToolVectorReflection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorReflection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorReflection._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorReflection._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorReflection._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorReflection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}", VectorGeometryToolVectorReflection)


class VectorGeometryToolVectorRotationVector(IVectorGeometryToolVectorRotationVector, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorRotationVector.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorRotationVector._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorRotationVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorRotationVector._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorRotationVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}", VectorGeometryToolVectorRotationVector)


class VectorGeometryToolVectorDirectionToStar(IVectorGeometryToolVectorDirectionToStar, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDirectionToStar.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorDirectionToStar._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorDirectionToStar._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorDirectionToStar._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorDirectionToStar.")
        
agcls.AgClassCatalog.add_catalog_entry("{147FDFCC-767A-460C-9833-02A582AFCA9C}", VectorGeometryToolVectorDirectionToStar)


class VectorGeometryToolVectorFixedAtTimeInstant(IVectorGeometryToolVectorFixedAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorFixedAtTimeInstant._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorFixedAtTimeInstant._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC8737B3-A94E-4B68-857F-81E780C874FD}", VectorGeometryToolVectorFixedAtTimeInstant)


class VectorGeometryToolVectorLinearCombination(IVectorGeometryToolVectorLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Linear combination of two input vectors."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorLinearCombination.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorLinearCombination._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorLinearCombination._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorLinearCombination._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{59E2764C-7920-4CDC-B5FF-2590154E1ABE}", VectorGeometryToolVectorLinearCombination)


class VectorGeometryToolVectorProjectAlongVector(IVectorGeometryToolVectorProjectAlongVector, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """A projection of a source vector in the direction of another vector."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorProjectAlongVector.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorProjectAlongVector._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorProjectAlongVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorProjectAlongVector._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorProjectAlongVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B76B999-135B-4AAF-ADEA-444FD759417D}", VectorGeometryToolVectorProjectAlongVector)


class VectorGeometryToolVectorScalarLinearCombination(IVectorGeometryToolVectorScalarLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Linear combination of two input vectors using scalars."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScalarLinearCombination.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorScalarLinearCombination._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorScalarLinearCombination._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorScalarLinearCombination._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorScalarLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}", VectorGeometryToolVectorScalarLinearCombination)


class VectorGeometryToolVectorScalarScaled(IVectorGeometryToolVectorScalarScaled, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Scaled version of the input vector using scalar."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScalarScaled.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorScalarScaled._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorScalarScaled._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorScalarScaled._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorScalarScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C93B992-687F-4311-B339-DE0DA38409AE}", VectorGeometryToolVectorScalarScaled)


class VectorGeometryToolVectorVelocityAcceleration(IVectorGeometryToolVectorVelocityAcceleration, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Velocity vector of a point in a coordinate system."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorVelocityAcceleration.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorVelocityAcceleration._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorVelocityAcceleration._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorVelocityAcceleration._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorVelocityAcceleration.")
        
agcls.AgClassCatalog.add_catalog_entry("{75A62225-C09F-4F08-B7FE-9216B02DECF2}", VectorGeometryToolVectorVelocityAcceleration)


class VectorGeometryToolVectorPlugin(IVectorGeometryToolVectorPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """A VGT vector plugin."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorPlugin._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorPlugin._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorPlugin._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E105429A-489E-47F6-B827-8E5819FCE917}", VectorGeometryToolVectorPlugin)


class VectorGeometryToolVectorDispSurface(IVectorGeometryToolVectorDispSurface, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDispSurface.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorDispSurface._private_init(self, pUnk)
        IAnalysisWorkbenchComponent._private_init(self, pUnk)
        ITimeToolTimeProperties._private_init(self, pUnk)
        IVectorGeometryToolVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorDispSurface._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorDispSurface._get_property(self, attrname)
        if IAnalysisWorkbenchComponent._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchComponent._get_property(self, attrname)
        if ITimeToolTimeProperties._get_property(self, attrname) is not None: found_prop = ITimeToolTimeProperties._get_property(self, attrname)
        if IVectorGeometryToolVector._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorDispSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{ccd4af03-78af-47ae-902a-90860a17daa4}", VectorGeometryToolVectorDispSurface)


class VectorGeometryToolVectorFactory(IVectorGeometryToolVectorFactory):
    """A Factory object to create vectors."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}", VectorGeometryToolVectorFactory)


class VectorGeometryToolAxesFactory(IVectorGeometryToolAxesFactory):
    """A Factory object to create axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B3E2402-1E15-43DC-BB48-6E98D377B107}", VectorGeometryToolAxesFactory)


class VectorGeometryToolSystemFactory(IVectorGeometryToolSystemFactory):
    """A Factory class to create VGT systems."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{01A37414-BA74-4DF3-A007-6A3395C8A859}", VectorGeometryToolSystemFactory)


class VectorGeometryToolPointFactory(IVectorGeometryToolPointFactory):
    """A Factory object to create points."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6C79F3B2-8AE5-468A-940F-F0988752B309}", VectorGeometryToolPointFactory)


class VectorGeometryToolPlaneFactory(IVectorGeometryToolPlaneFactory):
    """A Factory object to create VGT planes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}", VectorGeometryToolPlaneFactory)


class VectorGeometryToolAngleFactory(IVectorGeometryToolAngleFactory):
    """A Factory object to create angles."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleFactory._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0888F89F-9D77-4FCE-9A08-67FCBE870187}", VectorGeometryToolAngleFactory)


class VectorGeometryToolVectorGroup(IVectorGeometryToolVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolVectorGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolVectorGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolVectorGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolVectorGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}", VectorGeometryToolVectorGroup)


class VectorGeometryToolPointGroup(IVectorGeometryToolPointGroup):
    """Access or create VGT points associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPointGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPointGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPointGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPointGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}", VectorGeometryToolPointGroup)


class VectorGeometryToolAngleGroup(IVectorGeometryToolAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAngleGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAngleGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAngleGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}", VectorGeometryToolAngleGroup)


class VectorGeometryToolAxesGroup(IVectorGeometryToolAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAxesGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolAxesGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolAxesGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolAxesGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D792657-9D6E-4B1E-AEAB-B964839C6F94}", VectorGeometryToolAxesGroup)


class VectorGeometryToolPlaneGroup(IVectorGeometryToolPlaneGroup):
    """Represents a VGT Plane component."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolPlaneGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolPlaneGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolPlaneGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolPlaneGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{15117A82-3EE6-483E-A65E-2A44F60DB355}", VectorGeometryToolPlaneGroup)


class VectorGeometryToolSystemGroup(IVectorGeometryToolSystemGroup):
    """Access or create VGT systems associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolSystemGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolSystemGroup._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolSystemGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolSystemGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}", VectorGeometryToolSystemGroup)


class AnalysisWorkbenchProvider(IAnalysisWorkbenchProvider):
    """Allows accessing existing Vector Geometry Tool components."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchProvider._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchProvider.")
        
agcls.AgClassCatalog.add_catalog_entry("{D9031FE1-81E1-4818-944D-5F00FC3EC97D}", AnalysisWorkbenchProvider)


class AnalysisWorkbenchRoot(IAnalysisWorkbenchRoot):
    """Represents a VGT root."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchRoot.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchRoot._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchRoot._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRoot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchRoot.")
        
agcls.AgClassCatalog.add_catalog_entry("{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}", AnalysisWorkbenchRoot)


class VectorGeometryToolWellKnownEarthSystems(IVectorGeometryToolWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownEarthSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownEarthSystems._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownEarthSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownEarthSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}", VectorGeometryToolWellKnownEarthSystems)


class VectorGeometryToolWellKnownEarthAxes(IVectorGeometryToolWellKnownEarthAxes):
    """Well-known Earth's axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownEarthAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownEarthAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownEarthAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownEarthAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}", VectorGeometryToolWellKnownEarthAxes)


class VectorGeometryToolWellKnownSunSystems(IVectorGeometryToolWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownSunSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownSunSystems._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownSunSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownSunSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{855EB036-E71F-47F9-B27B-57247345282A}", VectorGeometryToolWellKnownSunSystems)


class VectorGeometryToolWellKnownSunAxes(IVectorGeometryToolWellKnownSunAxes):
    """Well-known Sun's axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownSunAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownSunAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownSunAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownSunAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F786A33-8851-4FA4-A0CA-DC353170143E}", VectorGeometryToolWellKnownSunAxes)


class VectorGeometryToolWellKnownSystems(IVectorGeometryToolWellKnownSystems):
    """Well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownSystems._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C5101B3-3FDD-443D-A59F-B1E801873E0A}", VectorGeometryToolWellKnownSystems)


class VectorGeometryToolWellKnownAxes(IVectorGeometryToolWellKnownAxes):
    """Represents well-known VGT Axes."""
    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolWellKnownAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVectorGeometryToolWellKnownAxes._get_property(self, attrname) is not None: found_prop = IVectorGeometryToolWellKnownAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VectorGeometryToolWellKnownAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}", VectorGeometryToolWellKnownAxes)


class AnalysisWorkbenchMethodCallResult(IVectorGeometryToolAngleFindResult, IVectorGeometryToolAngleFindWithRateResult, IVectorGeometryToolAxesTransformResult, IVectorGeometryToolAxesTransformWithRateResult, IVectorGeometryToolAxesFindInAxesResult, IVectorGeometryToolAxesFindInAxesWithRateResult, IVectorGeometryToolPlaneFindInAxesResult, IVectorGeometryToolPlaneFindInAxesWithRateResult, IVectorGeometryToolPlaneFindInSystemResult, IVectorGeometryToolPlaneFindInSystemWithRateResult, IVectorGeometryToolPointLocateInSystemResult, IVectorGeometryToolPointLocateInSystemWithRateResult, IVectorGeometryToolSystemTransformResult, IVectorGeometryToolSystemTransformWithRateResult, IVectorGeometryToolSystemFindInSystemResult, IVectorGeometryToolVectorFindInAxesResult, IVectorGeometryToolVectorFindInAxesWithRateResult, IVectorGeometryToolAngleFindAngleWithRateResult, IVectorGeometryToolAngleFindAngleResult, IAnalysisWorkbenchMethodCallResult):
    """
    Represents a result of a call to a VGT method.

    Some of the inherited interfaces for this class may be disabled at runtime.
    """
    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleFindResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemFindInSystemResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleWithRateResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleResult.__init__(self, sourceObject)
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVectorGeometryToolAngleFindResult._private_init(self, pUnk)
        IVectorGeometryToolAngleFindWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolAxesTransformResult._private_init(self, pUnk)
        IVectorGeometryToolAxesTransformWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolAxesFindInAxesResult._private_init(self, pUnk)
        IVectorGeometryToolAxesFindInAxesWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolPlaneFindInAxesResult._private_init(self, pUnk)
        IVectorGeometryToolPlaneFindInAxesWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolPlaneFindInSystemResult._private_init(self, pUnk)
        IVectorGeometryToolPlaneFindInSystemWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolPointLocateInSystemResult._private_init(self, pUnk)
        IVectorGeometryToolPointLocateInSystemWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolSystemTransformResult._private_init(self, pUnk)
        IVectorGeometryToolSystemTransformWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolSystemFindInSystemResult._private_init(self, pUnk)
        IVectorGeometryToolVectorFindInAxesResult._private_init(self, pUnk)
        IVectorGeometryToolVectorFindInAxesWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolAngleFindAngleWithRateResult._private_init(self, pUnk)
        IVectorGeometryToolAngleFindAngleResult._private_init(self, pUnk)
        IAnalysisWorkbenchMethodCallResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAngleFindResult.__dict__ and type(IVectorGeometryToolAngleFindResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAngleFindResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAngleFindWithRateResult.__dict__ and type(IVectorGeometryToolAngleFindWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAngleFindWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAxesTransformResult.__dict__ and type(IVectorGeometryToolAxesTransformResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAxesTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAxesTransformWithRateResult.__dict__ and type(IVectorGeometryToolAxesTransformWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAxesTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAxesFindInAxesResult.__dict__ and type(IVectorGeometryToolAxesFindInAxesResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAxesFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAxesFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPlaneFindInAxesResult.__dict__ and type(IVectorGeometryToolPlaneFindInAxesResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPlaneFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPlaneFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPlaneFindInSystemResult.__dict__ and type(IVectorGeometryToolPlaneFindInSystemResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPlaneFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__ and type(IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPlaneFindInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPointLocateInSystemResult.__dict__ and type(IVectorGeometryToolPointLocateInSystemResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPointLocateInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__ and type(IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolPointLocateInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolSystemTransformResult.__dict__ and type(IVectorGeometryToolSystemTransformResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolSystemTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolSystemTransformWithRateResult.__dict__ and type(IVectorGeometryToolSystemTransformWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolSystemTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolSystemFindInSystemResult.__dict__ and type(IVectorGeometryToolSystemFindInSystemResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolSystemFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolVectorFindInAxesResult.__dict__ and type(IVectorGeometryToolVectorFindInAxesResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolVectorFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__ and type(IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolVectorFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAngleFindAngleWithRateResult.__dict__ and type(IVectorGeometryToolAngleFindAngleWithRateResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAngleFindAngleWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleResult._uuid))
        if pUnkTest is not None:
            if attrname in IVectorGeometryToolAngleFindAngleResult.__dict__ and type(IVectorGeometryToolAngleFindAngleResult.__dict__[attrname]) == property: found_prop = IVectorGeometryToolAngleFindAngleResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchMethodCallResult._uuid))
        if pUnkTest is not None:
            if attrname in IAnalysisWorkbenchMethodCallResult.__dict__ and type(IAnalysisWorkbenchMethodCallResult.__dict__[attrname]) == property: found_prop = IAnalysisWorkbenchMethodCallResult.__dict__[attrname]
            del(pUnkTest)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchMethodCallResult.")
    def __getattr__(self, attrname):
        found_attr = None
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAngleFindResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAngleFindWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAxesTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAxesTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAxesFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAxesFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAxesFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPlaneFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPlaneFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPlaneFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPlaneFindInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPlaneFindInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPointLocateInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolPointLocateInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolPointLocateInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolSystemTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolSystemTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolSystemFindInSystemResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolSystemFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolVectorFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolVectorFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolVectorFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleWithRateResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAngleFindAngleWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVectorGeometryToolAngleFindAngleResult._uuid))
        if pUnk is not None:
            intf = IVectorGeometryToolAngleFindAngleResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAnalysisWorkbenchMethodCallResult._uuid))
        if pUnk is not None:
            intf = IAnalysisWorkbenchMethodCallResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        if found_attr is not None:
            return found_attr
        else:
            raise STKAttributeError(attrname + " is not a valid attribute in this instance of AnalysisWorkbenchMethodCallResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{03665183-03A3-4ABE-9954-476CD71C8BB3}", AnalysisWorkbenchMethodCallResult)


class TimeToolInterval(ITimeToolInterval):
    """Represents an interval."""
    def __init__(self, sourceObject=None):
        ITimeToolInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolInterval._get_property(self, attrname) is not None: found_prop = ITimeToolInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{7825007C-4D30-46EC-A047-EAF6683C4187}", TimeToolInterval)


class TimeToolIntervalCollection(ITimeToolIntervalCollection):
    """Represents a collection of intervals."""
    def __init__(self, sourceObject=None):
        ITimeToolIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{908714CE-1D69-4F68-875A-9B584CF8F2A7}", TimeToolIntervalCollection)


class AnalysisWorkbenchCentralBody(IAnalysisWorkbenchCentralBody):
    """Represents an central body."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBody.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchCentralBody._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchCentralBody._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchCentralBody._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchCentralBody.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A0248DF-B126-4448-A653-CD5C28DC9229}", AnalysisWorkbenchCentralBody)


class AnalysisWorkbenchCentralBodyRefTo(IAnalysisWorkbenchCentralBodyRefTo, IAnalysisWorkbenchRefTo):
    """Represents a central body reference."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBodyRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchCentralBodyRefTo._private_init(self, pUnk)
        IAnalysisWorkbenchRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchCentralBodyRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchCentralBodyRefTo._get_property(self, attrname)
        if IAnalysisWorkbenchRefTo._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchCentralBodyRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFB22A58-DB60-4A1B-B0D4-44916CACC759}", AnalysisWorkbenchCentralBodyRefTo)


class AnalysisWorkbenchCentralBodyCollection(IAnalysisWorkbenchCentralBodyCollection):
    """A collection of central body names."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchCentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchCentralBodyCollection._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchCentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchCentralBodyCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E8951B8F-E457-4289-9125-5381515552C4}", AnalysisWorkbenchCentralBodyCollection)


class AnalysisWorkbenchCollection(IAnalysisWorkbenchCollection):
    """A collection of VGT objects."""
    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAnalysisWorkbenchCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAnalysisWorkbenchCollection._get_property(self, attrname) is not None: found_prop = IAnalysisWorkbenchCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AnalysisWorkbenchCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}", AnalysisWorkbenchCollection)


class TimeToolPointSamplingResult(ITimeToolPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolPointSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolPointSamplingResult._get_property(self, attrname) is not None: found_prop = ITimeToolPointSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolPointSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}", TimeToolPointSamplingResult)


class TimeToolPointSamplingInterval(ITimeToolPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolPointSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolPointSamplingInterval._get_property(self, attrname) is not None: found_prop = ITimeToolPointSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolPointSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B7546E8-0228-4269-92D1-B3C186AF18EF}", TimeToolPointSamplingInterval)


class TimeToolPointSamplingIntervalCollection(ITimeToolPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolPointSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolPointSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolPointSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolPointSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F6CF6B1-7192-4960-927D-1FC328122E59}", TimeToolPointSamplingIntervalCollection)


class TimeToolAxesSamplingResult(ITimeToolAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolAxesSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolAxesSamplingResult._get_property(self, attrname) is not None: found_prop = ITimeToolAxesSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolAxesSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{54622168-5440-4C86-9539-A0CA336E554B}", TimeToolAxesSamplingResult)


class TimeToolAxesSamplingInterval(ITimeToolAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolAxesSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolAxesSamplingInterval._get_property(self, attrname) is not None: found_prop = ITimeToolAxesSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolAxesSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{069BCA07-B5AB-4A46-A508-AFE218E21B2F}", TimeToolAxesSamplingInterval)


class TimeToolAxesSamplingIntervalCollection(ITimeToolAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITimeToolAxesSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITimeToolAxesSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = ITimeToolAxesSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TimeToolAxesSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AD4C296-E643-4CB6-A34A-D33748117EEF}", TimeToolAxesSamplingIntervalCollection)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
