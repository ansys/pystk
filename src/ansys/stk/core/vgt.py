################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = []

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame
except ModuleNotFoundError:
    pass

import agi.stk12.internal.comutil          as agcom
import agi.stk12.internal.coclassutil      as agcls
import agi.stk12.internal.marshall         as agmarshall
import agi.stk12.internal.dataanalysisutil as agdata
import agi.stk12.utilities.colors          as agcolor
from   agi.stk12.internal.comutil     import IUnknown, IDispatch, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from   agi.stk12.internal.eventutil   import *
from   agi.stk12.utilities.exceptions import *


from agi.stk12.stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError('Valid STK object model classes are returned from STK methods and should not be created independently.')

class AgECrdnCalcScalarType(IntEnum):
    """Defines available calculation scalar types."""
    # Unknown or unsupported calculation scalar types
    eCrdnCalcScalarTypeUnknown = -1,
    # Scalar equal to angular displacement obtained from any angle in VGT.
    eCrdnCalcScalarTypeAngle = 0,
    # Constant scalar created by evaluating input scalar calculation at specified reference time instant.
    eCrdnCalcScalarTypeFixedAtTimeInstant = 1,
    # Constant scalar value of specified dimension.
    eCrdnCalcScalarTypeConstant = 2,
    # Any time-dependent data element from STK data providers available for parent STK object.
    eCrdnCalcScalarTypeDataElement = 3,
    # Derivative of input scalar calculation.
    eCrdnCalcScalarTypeDerivative = 4,
    # Time elapsed since reference time instant.
    eCrdnCalcScalarTypeElapsedTime = 5,
    # Tabulated scalar calculation data loaded from specified file.
    eCrdnCalcScalarTypeFile = 6,
    # Defined by performing one of specified functions on input scalar.
    eCrdnCalcScalarTypeFunction = 7,
    # Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types.
    eCrdnCalcScalarTypeIntegral = 8,
    # Defined by performing one of specified binary operations on two scalar arguments.
    eCrdnCalcScalarTypeFunction2Var = 9,
    # Scalar equal to magnitude of specified vector.
    eCrdnCalcScalarTypeVectorMagnitude = 10,
    # A calc scalar plugin based on a COM object.
    eCrdnCalcScalarTypePlugin = 11,
    # A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate.
    eCrdnCalcScalarTypeCustomScript = 12,
    # Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude).
    eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints = 13,
    # Scalar equal to the dot product between two vectors.
    eCrdnCalcScalarTypeDotProduct = 14,
    # Scalar equal to the specified component of a vector when resolved in the specifed axes.
    eCrdnCalcScalarTypeVectorComponent = 15

agcls.AgTypeNameMap['AgECrdnCalcScalarType'] = AgECrdnCalcScalarType
__all__.append('AgECrdnCalcScalarType')

class AgECrdnConditionCombinedOperationType(IntEnum):
    """Defines scalar condition combined operation types."""
    # Scalar condition combined AND operation.
    eCrdnConditionCombinedOperationTypeAND = 1,
    # Scalar condition combined OR operation.
    eCrdnConditionCombinedOperationTypeOR = 2,
    # Scalar condition combined XOR operation.
    eCrdnConditionCombinedOperationTypeXOR = 3,
    # Scalar condition combined MINUS operation.
    eCrdnConditionCombinedOperationTypeMINUS = 4

agcls.AgTypeNameMap['AgECrdnConditionCombinedOperationType'] = AgECrdnConditionCombinedOperationType
__all__.append('AgECrdnConditionCombinedOperationType')

class AgECrdnConditionSetType(IntEnum):
    """Defines available condition set types."""
    # Unknown or unsupported condition set types.
    eCrdnConditionSetTypeUnknown = -1,
    # Condition set placing multiple thresholds on specified scalar.
    eCrdnConditionSetTypeScalarThresholds = 0

agcls.AgTypeNameMap['AgECrdnConditionSetType'] = AgECrdnConditionSetType
__all__.append('AgECrdnConditionSetType')

class AgECrdnConditionThresholdOption(IntEnum):
    """Operations for Scalar Bounds Condition"""
    # Bound is above a minimum value
    eCrdnConditionThresholdOptionAboveMin = 1,
    # Bound is below a maximum value
    eCrdnConditionThresholdOptionBelowMax = 2,
    # Bound is between a minimum and maximum value
    eCrdnConditionThresholdOptionInsideMinMax = 3,
    # Bound is outside a minimum and maximum value
    eCrdnConditionThresholdOptionOutsideMinMax = 4

agcls.AgTypeNameMap['AgECrdnConditionThresholdOption'] = AgECrdnConditionThresholdOption
__all__.append('AgECrdnConditionThresholdOption')

class AgECrdnConditionType(IntEnum):
    """Defines available condition types."""
    # Unknown or unsupported condition type
    eCrdnConditionTypeUnknown = -1,
    # Condition placing bounds on specified scalar.
    eCrdnConditionTypeScalarBounds = 0,
    # Multiple conditiones on specified scalar.
    eCrdnConditionTypeCombined = 1,
    # Condition placing point in volume.
    eCrdnConditionTypePointInVolume = 2

agcls.AgTypeNameMap['AgECrdnConditionType'] = AgECrdnConditionType
__all__.append('AgECrdnConditionType')

class AgECrdnDimensionInheritance(IntEnum):
    """Defines how dimension is inherited"""
    # Do not inherit dimension.
    eCrdnDimensionInheritanceNone = 0,
    # Inherit dimension from X scalar.
    eCrdnDimensionInheritanceFromX = 1,
    # Inherit dimension from Y scalar.
    eCrdnDimensionInheritanceFromY = 2

agcls.AgTypeNameMap['AgECrdnDimensionInheritance'] = AgECrdnDimensionInheritance
__all__.append('AgECrdnDimensionInheritance')

class AgECrdnEventArrayFilterType(IntEnum):
    """Event array filter types."""
    # Skip time step
    eCrdnEventArrayFilterTypeSkipTimeStep = 0,
    # Skip count
    eCrdnEventArrayFilterTypeSkipCount = 1,
    # Intervals
    eCrdnEventArrayFilterTypeIntervals = 2

agcls.AgTypeNameMap['AgECrdnEventArrayFilterType'] = AgECrdnEventArrayFilterType
__all__.append('AgECrdnEventArrayFilterType')

class AgECrdnEventArrayType(IntEnum):
    """Defines available time array types."""
    # Unknown or unsupported time array types
    eCrdnEventArrayTypeUnknown = -1,
    # Determines time of local minimum and/or maximum of specified scalar calculation.
    eCrdnEventArrayTypeExtrema = 0,
    # Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array.
    eCrdnEventArrayTypeStartStopTimes = 1,
    # Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays.
    eCrdnEventArrayTypeMerged = 2,
    # Defined by filtering times from original time array according to specified filtering method.
    eCrdnEventArrayTypeFiltered = 3,
    # Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list.
    eCrdnEventArrayTypeFixedStep = 4,
    # Time array containing times at which specified condition changes its satisfaction status.
    eCrdnEventArrayTypeConditionCrossings = 5,
    # Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations.
    eCrdnEventArrayTypeSignaled = 6,
    # Time array containing specific times.
    eCrdnEventArrayTypeFixedTimes = 7

agcls.AgTypeNameMap['AgECrdnEventArrayType'] = AgECrdnEventArrayType
__all__.append('AgECrdnEventArrayType')

class AgECrdnEventIntervalCollectionType(IntEnum):
    """Defines available interval collection types."""
    # Unknown or unsupported interval collection types
    eCrdnEventIntervalCollectionTypeUnknown = -1,
    # Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies.
    eCrdnEventIntervalCollectionTypeLighting = 0,
    # Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations.
    eCrdnEventIntervalCollectionTypeSignaled = 1,
    # Interval collection containing intervals during which condition set is satisfied.
    eCrdnEventIntervalCollectionTypeCondition = 2

agcls.AgTypeNameMap['AgECrdnEventIntervalCollectionType'] = AgECrdnEventIntervalCollectionType
__all__.append('AgECrdnEventIntervalCollectionType')

class AgECrdnEventIntervalListType(IntEnum):
    """Defines available interval list types."""
    # Unknown or unsupported interval list types
    eCrdnEventIntervalListTypeUnknown = -1,
    # Interval list created by merging two constituent interval lists using specified logical operation.
    eCrdnEventIntervalListTypeMerged = 1,
    # Defined by filtering intervals from original interval list using specified filtering method.
    eCrdnEventIntervalListTypeFiltered = 2,
    # Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction).
    eCrdnEventIntervalListTypeCondition = 3,
    # Interval List defined by scaling every interval in original interval list using either absolute or relative scale.
    eCrdnEventIntervalListTypeScaled = 4,
    # Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations.
    eCrdnEventIntervalListTypeSignaled = 5,
    # Interval List defined by shifting specified reference interval list by fixed time offset.
    eCrdnEventIntervalListTypeTimeOffset = 6,
    # Interval list loaded from specified interval file
    eCrdnEventIntervalListTypeFile = 0,
    # Interval list with individual intervals defined between explicitly specified start and stop times.
    eCrdnEventIntervalListTypeFixed = 7

agcls.AgTypeNameMap['AgECrdnEventIntervalListType'] = AgECrdnEventIntervalListType
__all__.append('AgECrdnEventIntervalListType')

class AgECrdnEventIntervalType(IntEnum):
    """Defines available interval types."""
    # Unknown or unsupported interval types
    eCrdnEventIntervalTypeUnknown = -1,
    # Interval defined between two explicitly specified start and stop times.
    eCrdnEventIntervalTypeFixed = 0,
    # Interval of fixed duration specified using start and stop offsets relative to specified reference time instant.
    eCrdnEventIntervalTypeFixedDuration = 1,
    # Interval between specified start and stop time instants.
    eCrdnEventIntervalTypeBetweenTimeInstants = 2,
    # Interval created from specified interval list by using one of several selection methods.
    eCrdnEventIntervalTypeFromIntervalList = 3,
    # Interval defined by scaling original interval using either absolute or relative scale.
    eCrdnEventIntervalTypeScaled = 4,
    # Determines an interval recorded at a target clock location by performing signal transmission.
    eCrdnEventIntervalTypeSignaled = 5,
    # Interval defined by shifting specified reference interval by fixed time offset.
    eCrdnEventIntervalTypeTimeOffset = 6,
    # A smart interval.
    eCrdnEventIntervalTypeSmartInterval = 7

agcls.AgTypeNameMap['AgECrdnEventIntervalType'] = AgECrdnEventIntervalType
__all__.append('AgECrdnEventIntervalType')

class AgECrdnEventListMergeOperation(IntEnum):
    """Defines merge operations for interval lists."""
    # Intervals both in A and B
    eCrdnEventListMergeOperationAND = 0,
    # Intervals in A or B
    eCrdnEventListMergeOperationOR = 1,
    # Intervals in A or B but not in both
    eCrdnEventListMergeOperationXOR = 2,
    # Intervals in A and not in B
    eCrdnEventListMergeOperationMINUS = 3

agcls.AgTypeNameMap['AgECrdnEventListMergeOperation'] = AgECrdnEventListMergeOperation
__all__.append('AgECrdnEventListMergeOperation')

class AgECrdnEventType(IntEnum):
    """Defines available time instant types."""
    # Unknown or unsupported time instant types
    eCrdnEventTypeUnknown = -1,
    # Time instant set at specified date/time
    eCrdnEventTypeEpoch = 0,
    # Determines time of global minimum or maximum of specified scalar calculation.
    eCrdnEventTypeExtremum = 1,
    # Start or stop time of selected reference interval
    eCrdnEventTypeFromInterval = 2,
    # Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations.
    eCrdnEventTypeSignaled = 3,
    # Time instant at fixed offset from specified reference time instant
    eCrdnEventTypeTimeOffset = 4,
    # A smart epoch.
    eCrdnEventTypeSmartEpoch = 5

agcls.AgTypeNameMap['AgECrdnEventType'] = AgECrdnEventType
__all__.append('AgECrdnEventType')

class AgECrdnExtremumConstants(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
    # Find the minimum value
    eCrdnExtremumMinimum = 1,
    # Find the maximum value
    eCrdnExtremumMaximum = 2

agcls.AgTypeNameMap['AgECrdnExtremumConstants'] = AgECrdnExtremumConstants
__all__.append('AgECrdnExtremumConstants')

class AgECrdnFileInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnFileInterpolatorInvalid = -1,
    # Lagrange interpolation.
    eCrdnFileInterpolatorTypeLagrange = 1,
    # Hermite interpolation.
    eCrdnFileInterpolatorTypeHermite = 2,
    # Holds the value at the closest previous sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldPrevious = 3,
    # Holds the value at the closest next sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldNext = 4,
    # Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time.
    eCrdnFileInterpolatorTypeHoldNearest = 5

agcls.AgTypeNameMap['AgECrdnFileInterpolatorType'] = AgECrdnFileInterpolatorType
__all__.append('AgECrdnFileInterpolatorType')

class AgECrdnIntegralType(IntEnum):
    """Integral types."""
    # Simpson integral method
    eCrdnIntegralTypeFixedStepSimpson = 2,
    # Trapezoidal integral method
    eCrdnIntegralTypeFixedStepTrapz = 1,
    # Adaptive Lobatto integral method
    eCrdnIntegralTypeAdaptiveStep = 3

agcls.AgTypeNameMap['AgECrdnIntegralType'] = AgECrdnIntegralType
__all__.append('AgECrdnIntegralType')

class AgECrdnIntegrationWindowType(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
    # Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant.
    eCrdnIntegrationWindowTypeTotal = 0,
    # Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time.
    eCrdnIntegrationWindowTypeCumulativeToCurrent = 1,
    # Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time.
    eCrdnIntegrationWindowTypeCumulativeFromCurrent = 2,
    # Defines the integral's window as the interval of times centered around the current time with the specified front and back durations.
    eCrdnIntegrationWindowTypeSlidingWindow = 3

agcls.AgTypeNameMap['AgECrdnIntegrationWindowType'] = AgECrdnIntegrationWindowType
__all__.append('AgECrdnIntegrationWindowType')

class AgECrdnInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnInterpolatorInvalid = -1,
    # Lagrange interpolation.
    eCrdnInterpolatorTypeLagrange = 1,
    # Hermite interpolation.
    eCrdnInterpolatorTypeHermite = 2

agcls.AgTypeNameMap['AgECrdnInterpolatorType'] = AgECrdnInterpolatorType
__all__.append('AgECrdnInterpolatorType')

class AgECrdnIntervalDurationKind(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays"""
    # Filter by at least a specified number of seconds
    eCrdnIntervalDurationKindAtLeast = 0,
    # Filter by at most a specified number of seconds
    eCrdnIntervalDurationKindAtMost = 1

agcls.AgTypeNameMap['AgECrdnIntervalDurationKind'] = AgECrdnIntervalDurationKind
__all__.append('AgECrdnIntervalDurationKind')

class AgECrdnIntervalSelection(IntEnum):
    """Select the method to choose an interval from an interval list"""
    # Select an interval by counting a specified number from the first interval
    eCrdnIntervalSelectionFromStart = 1,
    # Select an interval by counting a specified number back from the last interval
    eCrdnIntervalSelectionFromEnd = 2,
    # Select the interval with the largest duration
    eCrdnIntervalSelectionMaxDuration = 4,
    # Select the interval with the smallest duration
    eCrdnIntervalSelectionMinDuration = 5,
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMaxGap = 9,
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMinGap = 10,
    # Select the interval that is the span of the interval list
    eCrdnIntervalSelectionSpan = 100

agcls.AgTypeNameMap['AgECrdnIntervalSelection'] = AgECrdnIntervalSelection
__all__.append('AgECrdnIntervalSelection')

class AgECrdnParameterSetType(IntEnum):
    """Defines parameter set types."""
    # Unknown or unsupported parameter set
    eCrdnParameterSetTypeUnknown = -1,
    # A parameter set type is defined by identifying one set of axes in reference to another.
    eCrdnParameterSetTypeAttitude = 0,
    # A parameter set type is defined by identifying location in reference central body.
    eCrdnParameterSetTypeGroundTrajectory = 1,
    # A parameter set type is defined by identifying location in reference coordinate system.
    eCrdnParameterSetTypeTrajectory = 2,
    # A parameter set type is defined by identifying orbiting point and its central body.
    eCrdnParameterSetTypeOrbit = 3,
    # A parameter set type is defined by identifying vector in reference axes.
    eCrdnParameterSetTypeVector = 4

agcls.AgTypeNameMap['AgECrdnParameterSetType'] = AgECrdnParameterSetType
__all__.append('AgECrdnParameterSetType')

class AgECrdnPruneFilter(IntEnum):
    """Specify the filter for filtering interval lists or time arrays"""
    # Unknown or unsupported prune filter
    eCrdnPruneFilterUnknown = 0,
    # Selects specified number of first intervals from original list
    eCrdnPruneFilterFirstIntervals = 1,
    # Selects specified number of last intervals from original list
    eCrdnPruneFilterLastIntervals = 2,
    # Selects intervals which satisfy additional duration condition.
    eCrdnPruneFilterIntervals = 3,
    # Selects gaps between intervals which satisfy additional duration condition.
    eCrdnPruneFilterGaps = 4,
    # Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterSatisfactionIntervals = 5,
    # Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterRelativeSatisfactionIntervals = 6

agcls.AgTypeNameMap['AgECrdnPruneFilter'] = AgECrdnPruneFilter
__all__.append('AgECrdnPruneFilter')

class AgECrdnSampledReferenceTime(IntEnum):
    """Event array reference type."""
    # Use a Time Instant as the reference time
    eCrdnSampledReferenceTimeReferenceEvent = 0,
    # Use the start of each interval as the reference time
    eCrdnSampledReferenceTimeStartOfEachInterval = 1,
    # Use the stop of each interval as the reference time
    eCrdnSampledReferenceTimeStopOfEachInterval = 2,
    # Use the start of each interval list as the reference time
    eCrdnSampledReferenceTimeStartOfIntervalList = 3,
    # Use the stop of each interval list as the reference time
    eCrdnSampledReferenceTimeStopOfIntervalList = 4

agcls.AgTypeNameMap['AgECrdnSampledReferenceTime'] = AgECrdnSampledReferenceTime
__all__.append('AgECrdnSampledReferenceTime')

class AgECrdnSamplingMethod(IntEnum):
    """Defines the Sampling Method"""
    # Unknown or unsupported sampling method
    eCrdnSamplingMethodUnknown = 0,
    # Fixed step sampling method
    eCrdnSamplingMethodFixedStep = 1,
    # Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples.
    eCrdnSamplingMethodRelativeTolerance = 2,
    # Curvature tolerance also uses changes in slope between samples
    eCrdnSamplingMethodCurvatureTolerance = 3

agcls.AgTypeNameMap['AgECrdnSamplingMethod'] = AgECrdnSamplingMethod
__all__.append('AgECrdnSamplingMethod')

class AgECrdnSatisfactionCrossing(IntEnum):
    """Direction crossing flags."""
    # Use either off-to-on or on-to-off condition to determine satisfaction
    eCrdnSatisfactionCrossingNone = 0,
    # Satisfaction occurs when crossing from off to on condition
    eCrdnSatisfactionCrossingIn = 1,
    # Satisfaction occurs when crossing from on to off condition
    eCrdnSatisfactionCrossingOut = 2

agcls.AgTypeNameMap['AgECrdnSatisfactionCrossing'] = AgECrdnSatisfactionCrossing
__all__.append('AgECrdnSatisfactionCrossing')

class AgECrdnSaveDataOption(IntEnum):
    """Method for saving computed data"""
    # Use the application setting to determine whether computed data should be saved/loaded.
    eCrdnSaveDataOptionApplicationSettings = -1,
    # Save/load computed data.
    eCrdnSaveDataOptionYes = 100,
    # Don't save computed data, recompute data on load.
    eCrdnSaveDataOptionNo = 10

agcls.AgTypeNameMap['AgECrdnSaveDataOption'] = AgECrdnSaveDataOption
__all__.append('AgECrdnSaveDataOption')

class AgECrdnSignalPathReferenceSystem(IntEnum):
    """Signal path reference system types."""
    # Use Access default system
    eCrdnSignalPathReferenceSystemUseAccessDefault = -1,
    # Use central body inertial system
    eCrdnSignalPathReferenceSystemCentralBodyInertial = 0,
    # Use solar sysyem barycenter system
    eCrdnSignalPathReferenceSystemSolarSystemBarycenter = 1,
    # User will specify a system
    eCrdnSignalPathReferenceSystemCustom = 2

agcls.AgTypeNameMap['AgECrdnSignalPathReferenceSystem'] = AgECrdnSignalPathReferenceSystem
__all__.append('AgECrdnSignalPathReferenceSystem')

class AgECrdnSmartEpochState(IntEnum):
    """Smart epoch states."""
    # Smart epoch is specified explicitly using a time.
    eCrdnSmartEpochStateExplicit = 0,
    # Smart epoch is specified implicitly.
    eCrdnSmartEpochStateImplicit = 3

agcls.AgTypeNameMap['AgECrdnSmartEpochState'] = AgECrdnSmartEpochState
__all__.append('AgECrdnSmartEpochState')

class AgECrdnSmartIntervalState(IntEnum):
    """Smart interval states."""
    # Smart interval is specified explicitly using start/stop times.
    eCrdnSmartIntervalStateExplicit = 0,
    # Smart interval is specified implicitly using start/stop times.
    eCrdnSmartIntervalStateImplicit = 1,
    # Smart interval is specified using smart epochs.
    eCrdnSmartIntervalStateStartStop = 2,
    # Smart interval is specified using a start epoch and duration.
    eCrdnSmartIntervalStateStartDuration = 4,
    # Smart interval is specified using a start time and explicit duration.
    eCrdnSmartIntervalStateExplicitDuration = 3

agcls.AgTypeNameMap['AgECrdnSmartIntervalState'] = AgECrdnSmartIntervalState
__all__.append('AgECrdnSmartIntervalState')

class AgECrdnSpeedOptions(IntEnum):
    """Defines various speed options."""
    # Light transmission speed.
    eCrdnLightTransmissionSpeed = 1,
    # Custom transmission speed.
    eCrdnCustomTransmissionSpeed = 2

agcls.AgTypeNameMap['AgECrdnSpeedOptions'] = AgECrdnSpeedOptions
__all__.append('AgECrdnSpeedOptions')

class AgECrdnStartStopOption(IntEnum):
    """Start/stop options."""
    # Use the start time of the interval
    eCrdnStartStopOptionCountStartOnly = 1,
    # Use the stop time of the interval
    eCrdnStartStopOptionCountStopOnly = 2,
    # Use the start time and stop time of the interval
    eCrdnStartStopOptionCountStartStop = 3

agcls.AgTypeNameMap['AgECrdnStartStopOption'] = AgECrdnStartStopOption
__all__.append('AgECrdnStartStopOption')

class AgECrdnThreshConvergeSense(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
    # Just converge within tolerance.
    eCrdnThreshConvergeSenseSimple = 0,
    # Result above or at threshold.
    eCrdnThreshConvergeSenseAbove = 1,
    # Result below or at threshold.
    eCrdnThreshConvergeSenseBelow = 2

agcls.AgTypeNameMap['AgECrdnThreshConvergeSense'] = AgECrdnThreshConvergeSense
__all__.append('AgECrdnThreshConvergeSense')

class AgECrdnVectorComponentType(IntEnum):
    """Defines component directions for a vector."""
    # X component.
    eCrdnVectorComponentX = 0,
    # Y component.
    eCrdnVectorComponentY = 1,
    # Z component.
    eCrdnVectorComponentZ = 2,
    # -X component.
    eCrdnVectorComponentMinusX = 3,
    # -Y component.
    eCrdnVectorComponentMinusY = 4,
    # -Z component.
    eCrdnVectorComponentMinusZ = 5

agcls.AgTypeNameMap['AgECrdnVectorComponentType'] = AgECrdnVectorComponentType
__all__.append('AgECrdnVectorComponentType')

class AgECrdnVolumeCalcAltitudeReferenceType(IntEnum):
    """Defines volume calc altitude reference types."""
    # Volume calc altitude above reference ellipsoid.
    eCrdnVolumeCalcAltitudeReferenceEllipsoid = 0,
    # Volume calc altitude reference above terrain.
    eCrdnVolumeCalcAltitudeReferenceTerrain = 1,
    # Volume calc altitude reference above mean sea level.
    eCrdnVolumeCalcAltitudeReferenceMSL = 2

agcls.AgTypeNameMap['AgECrdnVolumeCalcAltitudeReferenceType'] = AgECrdnVolumeCalcAltitudeReferenceType
__all__.append('AgECrdnVolumeCalcAltitudeReferenceType')

class AgECrdnVolumeCalcAngleOffVectorType(IntEnum):
    """Defines volume calc angle off vector reference types."""
    # Volume calc angle off plane signed.
    eCrdnVolumeCalcAngleOffPlaneSigned = 1,
    # Volume calc angle off plane unsigned.
    eCrdnVolumeCalcAngleOffPlaneUnsigned = 2,
    # Volume calc angle about vector signed.
    eCrdnVolumeCalcAngleAboutVectorSigned = 4,
    # Volume calc angle about vector unsigned.
    eCrdnVolumeCalcAngleAboutVectorUnsigned = 8,
    # Volume calc angle off vector.
    eCrdnVolumeCalcAngleOffVector = 16

agcls.AgTypeNameMap['AgECrdnVolumeCalcAngleOffVectorType'] = AgECrdnVolumeCalcAngleOffVectorType
__all__.append('AgECrdnVolumeCalcAngleOffVectorType')

class AgECrdnVolumeCalcRangeDistanceType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceFromPoint = 0,
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceAlongVectorSigned = 1,
    # Volume calc range distance type along vector unsigned
    eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned = 2,
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneSigned = 4,
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneUnsigned = 8

agcls.AgTypeNameMap['AgECrdnVolumeCalcRangeDistanceType'] = AgECrdnVolumeCalcRangeDistanceType
__all__.append('AgECrdnVolumeCalcRangeDistanceType')

class AgECrdnVolumeCalcRangeSpeedType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedLight = 1,
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedCustom = 2

agcls.AgTypeNameMap['AgECrdnVolumeCalcRangeSpeedType'] = AgECrdnVolumeCalcRangeSpeedType
__all__.append('AgECrdnVolumeCalcRangeSpeedType')

class AgECrdnVolumeCalcType(IntEnum):
    """Defines volume calc types."""
    # Unknown or unsupported volume calc.
    eCrdnVolumeCalcTypeUnknown = -1,
    # volume calc type altitude to location.
    eCrdnVolumeCalcTypeAltitude = 0,
    # volume calc type angle to location.
    eCrdnVolumeCalcTypeAngleOffVector = 1,
    # volume calc type File.
    eCrdnVolumeCalcTypeFile = 2,
    # volume calc type scalar at location.
    eCrdnVolumeCalcTypeFromScalar = 3,
    # volume calc type Solar Intensity.
    eCrdnVolumeCalcTypeSolarIntensity = 4,
    # volume calc type Spatial Condition Satisfaction Metric.
    eCrdnVolumeCalcTypeVolumeSatisfactionMetric = 5,
    # volume calc type Distance to Location.
    eCrdnVolumeCalcTypeRange = 6,
    # volume calc type Propagation Delay to Location.
    eCrdnVolumeCalcTypeDelayRange = 7

agcls.AgTypeNameMap['AgECrdnVolumeCalcType'] = AgECrdnVolumeCalcType
__all__.append('AgECrdnVolumeCalcType')

class AgECrdnVolumeCalcVolumeSatisfactionAccumulationType(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
    # Volume calc spatial condition satisfaction accumulation type up to current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime = -1,
    # Volume calc spatial condition satisfaction accumulation type current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime = 0,
    # Volume calc spatial condition satisfaction accumulation type from current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime = 1,
    # Volume calc spatial condition satisfaction accumulation type total.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal = 10

agcls.AgTypeNameMap['AgECrdnVolumeCalcVolumeSatisfactionAccumulationType'] = AgECrdnVolumeCalcVolumeSatisfactionAccumulationType
__all__.append('AgECrdnVolumeCalcVolumeSatisfactionAccumulationType')

class AgECrdnVolumeCalcVolumeSatisfactionDurationType(IntEnum):
    """Defines volume calc spatial condition duration types."""
    # Volume calc spatial condition satisfaction duration type minimum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMin = -1,
    # Volume calc spatial condition satisfaction duration type sum.
    eCrdnVolumeCalcVolumeSatisfactionDurationSum = 0,
    # Volume calc spatial condition satisfaction duration type maximum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMax = 1

agcls.AgTypeNameMap['AgECrdnVolumeCalcVolumeSatisfactionDurationType'] = AgECrdnVolumeCalcVolumeSatisfactionDurationType
__all__.append('AgECrdnVolumeCalcVolumeSatisfactionDurationType')

class AgECrdnVolumeCalcVolumeSatisfactionFilterType(IntEnum):
    """Defines volume calc spatial condition filter types."""
    # Volume calc spatial condition satisfaction filter type first intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals = -10,
    # Volume calc spatial condition satisfaction filter type last intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals = -20,
    # Volume calc spatial condition satisfaction filter type none.
    eCrdnVolumeCalcVolumeSatisfactionFilterNone = 0,
    # Volume calc spatial condition satisfaction filter type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration = 1,
    # Volume calc spatial condition satisfaction filter type interval duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration = 2

agcls.AgTypeNameMap['AgECrdnVolumeCalcVolumeSatisfactionFilterType'] = AgECrdnVolumeCalcVolumeSatisfactionFilterType
__all__.append('AgECrdnVolumeCalcVolumeSatisfactionFilterType')

class AgECrdnVolumeCalcVolumeSatisfactionMetricType(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
    # Volume calc spatial condition satisfaction metric type number of gaps.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps = -2,
    # Volume calc spatial condition satisfaction metric type number of intervals.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals = -1,
    # Volume calc spatial condition satisfaction metric type time since last satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction = 1,
    # Volume calc spatial condition satisfaction metric type time until next satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction = 2,
    # Volume calc spatial condition satisfaction metric type interbnal duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration = 10,
    # Volume calc spatial condition satisfaction metric type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration = 20

agcls.AgTypeNameMap['AgECrdnVolumeCalcVolumeSatisfactionMetricType'] = AgECrdnVolumeCalcVolumeSatisfactionMetricType
__all__.append('AgECrdnVolumeCalcVolumeSatisfactionMetricType')

class AgECrdnVolumeGridType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume grid.
    eCrdnVolumeGridTypeUnknown = -1,
    # volume grid type cartesian.
    eCrdnVolumeGridTypeCartesian = 0,
    # volume grid type Cylindrical.
    eCrdnVolumeGridTypeCylindrical = 1,
    # volume grid type Spherical.
    eCrdnVolumeGridTypeSpherical = 2,
    # volume grid type Constrained.
    eCrdnVolumeGridTypeConstrained = 3,
    # volume grid type LatLonAlt (Cartographic).
    eCrdnVolumeGridTypeLatLonAlt = 4,
    # volume grid type BearingAlt (Surface Bearing).
    eCrdnVolumeGridTypeBearingAlt = 5

agcls.AgTypeNameMap['AgECrdnVolumeGridType'] = AgECrdnVolumeGridType
__all__.append('AgECrdnVolumeGridType')

class AgECrdnVolumeResultVectorRequest(IntEnum):
    """Defines volume result vector request types."""
    # volume result vector request pos type
    eCrdnVolumeResultVectorRequestPos = 1,
    # volume result vector request native pos type
    eCrdnVolumeResultVectorRequestNativePos = 2,
    # volume result vector request metric type
    eCrdnVolumeResultVectorRequestMetric = 16,
    # volume result vector request satisfaction type
    eCrdnVolumeResultVectorRequestSatisfaction = 32,
    # volume result vector request gradient type
    eCrdnVolumeResultVectorRequestGradient = 256

agcls.AgTypeNameMap['AgECrdnVolumeResultVectorRequest'] = AgECrdnVolumeResultVectorRequest
__all__.append('AgECrdnVolumeResultVectorRequest')

class AgECrdnVolumeType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume.
    eCrdnVolumeTypeUnknown = -1,
    # volume type combined.
    eCrdnVolumeTypeCombined = 0,
    # volume type lighting.
    eCrdnVolumeTypeLighting = 1,
    # volume type over time.
    eCrdnVolumeTypeOverTime = 2,
    # volume type from grid (Grid Bounding Volume).
    eCrdnVolumeTypeFromGrid = 3,
    # volume type from calc (Spatial Calculation Bounds).
    eCrdnVolumeTypeFromCalc = 4,
    # volume type from time satisfaction (Valid Time At Location).
    eCrdnVolumeTypeFromTimeSatisfaction = 5,
    # volume type from condition (Condition At Location).
    eCrdnVolumeTypeFromCondition = 6,
    # volume type Inview (Access To Location).
    eCrdnVolumeTypeInview = 7

agcls.AgTypeNameMap['AgECrdnVolumeType'] = AgECrdnVolumeType
__all__.append('AgECrdnVolumeType')

class AgECrdnVolumeAberrationType(IntEnum):
    """Defines the model of aberration to use."""
    # Aberration type unknown.
    eCrdnVolumeAberrationUnknown = -1,
    # Aberration type total.
    eCrdnVolumeAberrationTotal = 0,
    # SAberration type annual.
    eCrdnVolumeAberrationAnnual = 1,
    # Aberration type none.
    eCrdnVolumeAberrationNone = 2

agcls.AgTypeNameMap['AgECrdnVolumeAberrationType'] = AgECrdnVolumeAberrationType
__all__.append('AgECrdnVolumeAberrationType')

class AgECrdnVolumeClockHostType(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
    # Unknown
    eCrdnVolumeClockHostUnknown = -1,
    # Base object holds time instance.
    eCrdnVolumeClockHostBase = 0,
    # Target object holds time instance.
    eCrdnVolumeClockHostTarget = 1

agcls.AgTypeNameMap['AgECrdnVolumeClockHostType'] = AgECrdnVolumeClockHostType
__all__.append('AgECrdnVolumeClockHostType')

class AgECrdnVolumeCombinedOperationType(IntEnum):
    """Defines spatial condition combined operation types."""
    # Spatial condition combined AND operation.
    eCrdnVolumeCombinedOperationTypeAND = 1,
    # Spatial condition combined OR operation.
    eCrdnVolumeCombinedOperationTypeOR = 2,
    # Spatial condition combined XOR operation.
    eCrdnVolumeCombinedOperationTypeXOR = 3,
    # Spatial condition combined MINUS operation.
    eCrdnVolumeCombinedOperationTypeMINUS = 4

agcls.AgTypeNameMap['AgECrdnVolumeCombinedOperationType'] = AgECrdnVolumeCombinedOperationType
__all__.append('AgECrdnVolumeCombinedOperationType')

class AgECrdnVolumeFromGridEdgeType(IntEnum):
    """Defines spatial condition from grid edge type."""
    # Spatial condition over time from grid edge type mask points.
    eCrdnVolumeFromGridEdgeTypeMaskPoints = 16,
    # Spatial condition over time from grid edge type mask voxels.
    eCrdnVolumeFromGridEdgeTypeMaskVoxels = 32

agcls.AgTypeNameMap['AgECrdnVolumeFromGridEdgeType'] = AgECrdnVolumeFromGridEdgeType
__all__.append('AgECrdnVolumeFromGridEdgeType')

class AgECrdnVolumeLightingConditionsType(IntFlag):
    """Defines spatial condition lighting conditions types."""
    # Spatial condition lighting undefined.
    eCrdnVolumeLightingConditionTypeUndefined = 0,
    # Spatial condition lighting sun light.
    eCrdnVolumeLightingConditionTypeSunlight = 1,
    # Spatial condition lighting penumbra.
    eCrdnVolumeLightingConditionTypePenumbra = 2,
    # Spatial condition lighting umbra.
    eCrdnVolumeLightingConditionTypeUmbra = 4

agcls.AgTypeNameMap['AgECrdnVolumeLightingConditionsType'] = AgECrdnVolumeLightingConditionsType
__all__.append('AgECrdnVolumeLightingConditionsType')

class AgECrdnVolumeOverTimeDurationType(IntEnum):
    """Defines spatial condition over time duration type."""
    # Spatial condition over time duration type Static.
    eCrdnVolumeOverTimeDurationTypeStatic = 0,
    # Spatial condition over time duration type CumulativeToCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent = 1,
    # Spatial condition over time duration type CumulativeFromCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent = 2,
    # Spatial condition over time duration type SlidingWindow.
    eCrdnVolumeOverTimeDurationTypeSlidingWindow = 3

agcls.AgTypeNameMap['AgECrdnVolumeOverTimeDurationType'] = AgECrdnVolumeOverTimeDurationType
__all__.append('AgECrdnVolumeOverTimeDurationType')

class AgECrdnVolumeTimeSenseType(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
    # Unklnown
    eCrdnVolumeTimeSenseUnknown = -1,
    # Position is computed in Time Sense
    eCrdnVolumeTimeSenseTransmit = 0,
    # Position is computed in Receive Sense
    eCrdnVolumeTimeSenseReceive = 1

agcls.AgTypeNameMap['AgECrdnVolumeTimeSenseType'] = AgECrdnVolumeTimeSenseType
__all__.append('AgECrdnVolumeTimeSenseType')

class AgECrdnVolumetricGridValuesMethodType(IntEnum):
    """Defines volumetric grid values method types."""
    # Unknown or unsupportedgrid values method.
    eCrdnVolumetricGridValuesMethodMethodUnknown = -1,
    # Fixed number steps grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedNumSteps = 0,
    # Fixed step size grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedStepSize = 1,
    # Custom grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodCustomValues = 2

agcls.AgTypeNameMap['AgECrdnVolumetricGridValuesMethodType'] = AgECrdnVolumetricGridValuesMethodType
__all__.append('AgECrdnVolumetricGridValuesMethodType')

class AgECrdnKind(IntEnum):
    """Represents kinds of vectory geometry components."""
    # Unsupported component kind.
    eCrdnKindUnknown = -1,
    # Invalid component.
    eCrdnKindInvalid = 0,
    # Axes component.
    eCrdnKindAxes = 1,
    # Angle component.
    eCrdnKindAngle = 2,
    # Vector component.
    eCrdnKindVector = 3,
    # Point component.
    eCrdnKindPoint = 4,
    # Plane component.
    eCrdnKindPlane = 5,
    # System component.
    eCrdnKindSystem = 6,
    # An event.
    eCrdnKindEvent = 7,
    # An event array.
    eCrdnKindEventArray = 8,
    # An event interval.
    eCrdnKindEventInterval = 9,
    # An event interval collection.
    eCrdnKindEventIntervalCollection = 10,
    # A list of event intervals.
    eCrdnKindEventIntervalList = 11,
    # A parameter set.
    eCrdnKindParameterSet = 12,
    # A scalar.
    eCrdnKindCalcScalar = 13,
    # A condition.
    eCrdnKindCondition = 14,
    # A condition set.
    eCrdnKindConditionSet = 15,
    # A volume grid.
    eCrdnKindVolumeGrid = 16,
    # A volume.
    eCrdnKindVolume = 17,
    # A volume calc.
    eCrdnKindVolumeCalc = 18

agcls.AgTypeNameMap['AgECrdnKind'] = AgECrdnKind
__all__.append('AgECrdnKind')

class AgECrdnAngleType(IntEnum):
    """Represents angle types."""
    # Unknown or unsupported type.
    eCrdnAngleTypeUnknown = -1,
    # An angle between two vectors.
    eCrdnAngleTypeBetweenVectors = 0,
    # An angle between two planes.
    eCrdnAngleTypeBetweenPlanes = 1,
    # An angle between two vectors about an axis.
    eCrdnAngleTypeDihedralAngle = 2,
    # Angle of the shortest rotation between the two specified axes.
    eCrdnAngleTypeRotation = 3,
    # An angle between a vector and a plane.
    eCrdnAngleTypeToPlane = 4,
    # Represents a VGT angle created from a template. This type of angle is not creatable.
    eCrdnAngleTypeTemplate = 5

agcls.AgTypeNameMap['AgECrdnAngleType'] = AgECrdnAngleType
__all__.append('AgECrdnAngleType')

class AgECrdnAxesType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported type.
    eCrdnAxesTypeUnknown = -1,
    # Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type.
    eCrdnAxesTypeLagrangeLibration = 0,
    # Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset.
    eCrdnAxesTypeAngularOffset = 1,
    # Axes based on another set fixed at a specified epoch.
    eCrdnAxesTypeFixedAtEpoch = 2,
    # B-Plane axes using the selected target body and reference vector.
    eCrdnAxesTypeBPlane = 3,
    # Customized axes offset with respect to a set of reference Axes.
    eCrdnAxesTypeCustomScript = 4,
    # Axes fixed in reference axes.
    eCrdnAxesTypeFixed = 6,
    # Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference.
    eCrdnAxesTypeAlignedAndConstrained = 7,
    # Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element.
    eCrdnAxesTypeModelAttachment = 8,
    # Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset.
    eCrdnAxesTypeSpinning = 9,
    # Projection of the reference point onto the central body.
    eCrdnAxesTypeOnSurface = 10,
    # Axes based on trajectory of the point relative to the reference coordinate system.
    eCrdnAxesTypeTrajectory = 11,
    # Represents a VGT axes created from a template. This type of axes is not creatable.
    eCrdnAxesTypeTemplate = 12,
    # Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant.
    eCrdnAxesTypeAtTimeInstant = 13,
    # An axes plugin point.
    eCrdnAxesTypePlugin = 14,
    # Axes specified by data from a file.
    eCrdnAxesTypeFile = 5

agcls.AgTypeNameMap['AgECrdnAxesType'] = AgECrdnAxesType
__all__.append('AgECrdnAxesType')

class AgECrdnPlaneType(IntEnum):
    """Represents plane types."""
    # Unknown or unsupported type.
    eCrdnPlaneTypeUnknown = -1,
    # A plane normal to a vector at a given point.
    eCrdnPlaneTypeNormal = 0,
    # A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system.
    eCrdnPlaneTypeQuadrant = 1,
    # A plane is defined on the basis of a trajectory of a selected point with respect to a reference point.
    eCrdnPlaneTypeTrajectory = 2,
    # A plane is defined by the three points.
    eCrdnPlaneTypeTriad = 3,
    # Represents a VGT plane created from a template. This type of plane is not creatable.
    eCrdnPlaneTypeTemplate = 4,
    # A plane passing through point and containing two given vectors.
    eCrdnPlaneTypeTwoVector = 5

agcls.AgTypeNameMap['AgECrdnPlaneType'] = AgECrdnPlaneType
__all__.append('AgECrdnPlaneType')

class AgECrdnPointType(IntEnum):
    """Represents point types."""
    # Unknown or unsupported type.
    eCrdnPointTypeUnknown = -1,
    # B-Plane point using the selected target body.
    eCrdnPointTypeBPlane = 0,
    # The grazing point is the point of closest approach to the surface of the selected central body along a defined direction.
    eCrdnPointTypeGrazing = 1,
    # The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option.
    eCrdnPointTypeCovarianceGrazing = 2,
    # Point fixed in a reference coordinate system.
    eCrdnPointTypeFixedInSystem = 4,
    # Point on central body surface that reflects from source to observer.
    eCrdnPointTypeGlint = 5,
    # Point on a plane located along a given direction looking from a given origin.
    eCrdnPointTypePlaneIntersection = 6,
    # Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point.
    eCrdnPointTypeModelAttachment = 7,
    # The projection of a point onto a reference plane.
    eCrdnPointTypePlaneProjection = 8,
    # The detic subpoint of the reference point as projected onto the central body.
    eCrdnPointTypeOnSurface = 9,
    # Libration point using one primary and multiple secondary central bodies.
    eCrdnPointTypeLagrangeLibration = 10,
    # Represents a VGT point created from a template. This type of point is not creatable.
    eCrdnPointTypeTemplate = 11,
    # Point on central body surface along direction vector originating at source point.
    eCrdnPointTypeCentralBodyIntersect = 12,
    # Point fixed relative to reference system based on another point evaluated at specified time instant.
    eCrdnPointTypeAtTimeInstant = 13,
    # A point plugin point.
    eCrdnPointTypePlugin = 14,
    # Point specified by data from a file.
    eCrdnPointTypeFile = 3,
    # Point fixed on a central body.
    eCrdnPointTypeFixedOnCentralBody = 15,
    # A point placed at the center of mass of a specified satellite of the satellite collection.
    eCrdnPointTypeSatelliteCollectionEntry = 16

agcls.AgTypeNameMap['AgECrdnPointType'] = AgECrdnPointType
__all__.append('AgECrdnPointType')

class AgECrdnSystemType(IntEnum):
    """Represents system types."""
    # Unknown or unsupported system type.
    eCrdnSystemTypeUnknown = -1,
    # A system assembled from an origin point and a set of reference axes.
    eCrdnSystemTypeAssembled = 0,
    # A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle.
    eCrdnSystemTypeOnSurface = 1,
    # Represents a VGT system created from a template. This type of system is not creatable.
    eCrdnSystemTypeTemplate = 2

agcls.AgTypeNameMap['AgECrdnSystemType'] = AgECrdnSystemType
__all__.append('AgECrdnSystemType')

class AgECrdnVectorType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported vector type.
    eCrdnVectorTypeUnknown = -1,
    # Vector defined by its start and end points.
    eCrdnVectorTypeDisplacement = 0,
    # Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeApoapsis = 1,
    # Based on another vector fixed at a specified epoch.
    eCrdnVectorTypeFixedAtEpoch = 2,
    # Angular velocity vector of one set of axes computed with respect to the reference set.
    eCrdnVectorTypeAngularVelocity = 3,
    # Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode.
    eCrdnVectorTypeConing = 4,
    # The vector cross product of two vectors.
    eCrdnVectorTypeCrossProduct = 5,
    # Customized vector components defined with respect to reference axes.
    eCrdnVectorTypeCustomScript = 6,
    # Derivative of a vector computed with respect to specified axes.
    eCrdnVectorTypeDerivative = 7,
    # Angle rate vector perpendicular to the plane in which the angle is defined.
    eCrdnVectorTypeAngleRate = 8,
    # Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeEccentricity = 9,
    # Vector fixed in reference axes.
    eCrdnVectorTypeFixedInAxes = 10,
    # Defined along the intersection of two planes.
    eCrdnVectorTypeTwoPlanesIntersection = 12,
    # Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body.
    eCrdnVectorTypeLineOfNodes = 13,
    # Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element.
    eCrdnVectorTypeModelAttachment = 14,
    # Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitAngularMomentum = 15,
    # Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitNormal = 16,
    # Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypePeriapsis = 17,
    # A projection of a vector computed with respect to a reference plane.
    eCrdnVectorTypeProjection = 18,
    # Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane.
    eCrdnVectorTypeReflection = 19,
    # Scaled version of the input vector.
    eCrdnVectorTypeScaled = 20,
    # Defined with respect to a star object.
    eCrdnVectorTypeDirectionToStar = 21,
    # Represents a VGT vector created from a template. This type of vector is not creatable.
    eCrdnVectorTypeTemplate = 22,
    # Vector fixed relative to reference axes based on another vector evaluated at specified time instant.
    eCrdnVectorTypeAtTimeInstant = 23,
    # Linear combination of two input vectors.
    eCrdnVectorTypeLinearCombination = 24,
    # A projection of a source vector in the direction of another vector.
    eCrdnVectorTypeProjectAlong = 25,
    # Linear combination of two input vectors using scalars.
    eCrdnVectorTypeScalarLinearCombination = 26,
    # Scaled version of the input vector using scalar.
    eCrdnVectorTypeScalarScaled = 27,
    # Velocity vector of a point in a coordinate system.
    eCrdnVectorTypeVelocity = 28,
    # A vector plugin point.
    eCrdnVectorTypePlugin = 29,
    # Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis.
    eCrdnVectorTypeRotationVector = 30,
    # Displacement between origin and destination points using surface distance and altitude difference.
    eCrdnVectorTypeDisplacementOnSurface = 31

agcls.AgTypeNameMap['AgECrdnVectorType'] = AgECrdnVectorType
__all__.append('AgECrdnVectorType')

class AgECrdnMeanElementTheory(IntEnum):
    """Mean element theory types for approximating motion."""
    # Osculating elements (six standard Keplerian orbital elements).
    eCrdnMeanElementTheoryOsculating = 1,
    # The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377.
    eCrdnMeanElementTheoryKozai = 2,
    # Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eCrdnMeanElementTheoryBrouwerLyddane_Long = 3,
    # Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eCrdnMeanElementTheoryBrouwerLyddane_Short = 4

agcls.AgTypeNameMap['AgECrdnMeanElementTheory'] = AgECrdnMeanElementTheory
__all__.append('AgECrdnMeanElementTheory')

class AgECrdnDirectionType(IntEnum):
    """Direction options."""
    # Incoming direction.
    eCrdnDirectionIncomingAsymptote = 1,
    # Outgoing direction.
    eCrdnDirectionOutgoingAsymptote = 2

agcls.AgTypeNameMap['AgECrdnDirectionType'] = AgECrdnDirectionType
__all__.append('AgECrdnDirectionType')

class AgECrdnLagrangeLibrationPointType(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
    # A point between the Sun and Earth.
    eCrdnLagrangeLibrationPointTypeL1 = 1,
    # Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth.
    eCrdnLagrangeLibrationPointTypeL2 = 2,
    # L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times.
    eCrdnLagrangeLibrationPointTypeL3 = 3,
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL4 = 4,
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL5 = 5

agcls.AgTypeNameMap['AgECrdnLagrangeLibrationPointType'] = AgECrdnLagrangeLibrationPointType
__all__.append('AgECrdnLagrangeLibrationPointType')

class AgECrdnQuadrantType(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY),"""
    # XY quadrant.
    eCrdnQuadrantXY = 1,
    # YX quadrant.
    eCrdnQuadrantYX = 2,
    # XZ quadrant.
    eCrdnQuadrantXZ = 3,
    # ZX quadrant.
    eCrdnQuadrantZX = 4,
    # YZ quadrant.
    eCrdnQuadrantYZ = 5,
    # ZY quadrant.
    eCrdnQuadrantZY = 6

agcls.AgTypeNameMap['AgECrdnQuadrantType'] = AgECrdnQuadrantType
__all__.append('AgECrdnQuadrantType')

class AgECrdnTrajectoryAxesType(IntEnum):
    """Trajectory axes coordinate types."""
    # Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack).
    eCrdnTrajectoryAxesICR = 0,
    # Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal).
    eCrdnTrajectoryAxesVNC = 1,
    # Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack).
    eCrdnTrajectoryAxesRIC = 2,
    # Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal).
    eCrdnTrajectoryAxesLVLH = 3,
    # Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity).
    eCrdnTrajectoryAxesVVLH = 4,
    # Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesBBR = 5,
    # Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesEquinoctial = 6,
    # Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal).
    eCrdnTrajectoryAxesNTC = 7

agcls.AgTypeNameMap['AgECrdnTrajectoryAxesType'] = AgECrdnTrajectoryAxesType
__all__.append('AgECrdnTrajectoryAxesType')

class AgECrdnDisplayAxisSelector(IntEnum):
    """Rotation directions."""
    # Rotate about Axis X.
    eCrdnDisplayAxisX = 0,
    # Rotate about Axis Y.
    eCrdnDisplayAxisY = 1,
    # Rotate about Axis Z.
    eCrdnDisplayAxisZ = 2

agcls.AgTypeNameMap['AgECrdnDisplayAxisSelector'] = AgECrdnDisplayAxisSelector
__all__.append('AgECrdnDisplayAxisSelector')

class AgECrdnSignedAngleType(IntEnum):
    """Defines options for computing an angle."""
    # Choose the option to use unsigned angle.
    eCrdnSignedAngleNone = 0,
    # Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAnglePositive = 1,
    # Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAngleNegative = 2

agcls.AgTypeNameMap['AgECrdnSignedAngleType'] = AgECrdnSignedAngleType
__all__.append('AgECrdnSignedAngleType')

class AgECrdnPointBPlaneType(IntEnum):
    """B-Plane point types."""
    # Asymptote.
    eCrdnPointBPlaneAsymptote = 1,
    # Two body.
    eCrdnPointBPlaneATwoBody = 2

agcls.AgTypeNameMap['AgECrdnPointBPlaneType'] = AgECrdnPointBPlaneType
__all__.append('AgECrdnPointBPlaneType')

class AgECrdnReferenceShapeType(IntEnum):
    """Surface shape types."""
    # An ellipsoid reference shape as defined by the central body (by default, it is WSG84).
    eCrdnReferenceShapeEllipsoid = 1,
    # Terrain as the terrain reference.
    eCrdnReferenceShapeTerrain = 2,
    # Mean Sea Level as the terrain reference.
    eCrdnReferenceShapeMSL = 3

agcls.AgTypeNameMap['AgECrdnReferenceShapeType'] = AgECrdnReferenceShapeType
__all__.append('AgECrdnReferenceShapeType')

class AgECrdnSurfaceType(IntEnum):
    """Surface types."""
    # Detic surface model.
    eCrdnSurfaceDetic = 1,
    # Centric surface model.
    eCrdnSurfaceCentric = 2

agcls.AgTypeNameMap['AgECrdnSurfaceType'] = AgECrdnSurfaceType
__all__.append('AgECrdnSurfaceType')

class AgECrdnSweepMode(IntEnum):
    """The rotation sweeping modes."""
    # Bidirectional sweeping mode.
    eCrdnSweepModeBidirectional = 1,
    # Unidirectional sweeping mode.
    eCrdnSweepModeUnidirectional = 2

agcls.AgTypeNameMap['AgECrdnSweepMode'] = AgECrdnSweepMode
__all__.append('AgECrdnSweepMode')

class AgECrdnSignalSense(IntEnum):
    """Signal sense transmission options."""
    # Signal receive.
    eCrdnSignalSenseReceive = 1,
    # Signal transmit.
    eCrdnSignalSenseTransmit = 2

agcls.AgTypeNameMap['AgECrdnSignalSense'] = AgECrdnSignalSense
__all__.append('AgECrdnSignalSense')

class AgECrdnIntersectionSurface(IntEnum):
    """Intersection surface flags."""
    # Intersection with central body ellipsoid.
    eCrdnIntersectionSurfaceAtCentralBodyEllipsoid = 0,
    # Intersection at altitude.
    eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid = 1,
    # Use terrain as intersection surface.
    eCrdnIntersectionSurfaceAtTerrain = 2

agcls.AgTypeNameMap['AgECrdnIntersectionSurface'] = AgECrdnIntersectionSurface
__all__.append('AgECrdnIntersectionSurface')

class AgECrdnVectorScaledDimensionInheritance(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
    # Do not inherit dimension.
    eCrdnVectorScaledDimensionInheritanceNone = 0,
    # Inherit dimension from scalar.
    eCrdnVectorScaledDimensionInheritanceFromScalar = 1,
    # Inherit dimension from vector.
    eCrdnVectorScaledDimensionInheritanceFromVector = 2

agcls.AgTypeNameMap['AgECrdnVectorScaledDimensionInheritance'] = AgECrdnVectorScaledDimensionInheritance
__all__.append('AgECrdnVectorScaledDimensionInheritance')


class IAgCrdnIntervalCollection(object):
    """The interface represents a collection of intervals."""
    _uuid = '{DAE5D702-43F1-4544-8039-97E746D019AB}'
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntervalCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntervalCollection = agcom.GUID(IAgCrdnIntervalCollection._uuid)
        vtable_offset_local = IAgCrdnIntervalCollection._vtable_offset - 1
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalCollection.__dict__ and type(IAgCrdnIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntervalCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnInterval":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Return a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IAgCrdnInterval":
        """Returns an interval at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{DAE5D702-43F1-4544-8039-97E746D019AB}', IAgCrdnIntervalCollection)
agcls.AgTypeNameMap['IAgCrdnIntervalCollection'] = IAgCrdnIntervalCollection
__all__.append('IAgCrdnIntervalCollection')

class IAgCrdnInterval(object):
    """The interface represents an interval."""
    _uuid = '{4A5031BC-45C0-4E75-9190-31F1802C173D}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetStart'] = _raise_uninitialized_error
        self.__dict__['_GetStop'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnInterval from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnInterval = agcom.GUID(IAgCrdnInterval._uuid)
        vtable_offset_local = IAgCrdnInterval._vtable_offset - 1
        self.__dict__['_GetStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterval, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_GetStop'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterval, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterval.__dict__ and type(IAgCrdnInterval.__dict__[attrname]) == property:
            return IAgCrdnInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnInterval.')
    
    @property
    def Start(self) -> typing.Any:
        """The interval's start time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The interval's stop time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStop'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{4A5031BC-45C0-4E75-9190-31F1802C173D}', IAgCrdnInterval)
agcls.AgTypeNameMap['IAgCrdnInterval'] = IAgCrdnInterval
__all__.append('IAgCrdnInterval')

class IAgCrdnPoint(object):
    """The interface defines methods and properties common to all points."""
    _uuid = '{086D1AA7-D85D-402D-9347-0B51EB552537}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_LocateInSystemWithRate'] = _raise_uninitialized_error
        self.__dict__['_LocateInSystem'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPoint from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPoint = agcom.GUID(IAgCrdnPoint._uuid)
        vtable_offset_local = IAgCrdnPoint._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPoint, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_LocateInSystemWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPoint, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_LocateInSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPoint, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPoint.__dict__ and type(IAgCrdnPoint.__dict__[attrname]) == property:
            return IAgCrdnPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPoint.')
    
    @property
    def Type(self) -> "AgECrdnPointType":
        """Returns a type of the point object."""
        with agmarshall.AgEnum_arg(AgECrdnPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def LocateInSystemWithRate(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_LocateInSystemWithRate'](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def LocateInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_LocateInSystem'](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{086D1AA7-D85D-402D-9347-0B51EB552537}', IAgCrdnPoint)
agcls.AgTypeNameMap['IAgCrdnPoint'] = IAgCrdnPoint
__all__.append('IAgCrdnPoint')

class IAgCrdnVector(object):
    """The interface defines methods and properties common to all vectors."""
    _uuid = '{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindInAxes'] = _raise_uninitialized_error
        self.__dict__['_FindInAxesWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVector = agcom.GUID(IAgCrdnVector._uuid)
        vtable_offset_local = IAgCrdnVector._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindInAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVector, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindInAxesWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVector, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVector.__dict__ and type(IAgCrdnVector.__dict__[attrname]) == property:
            return IAgCrdnVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVector.')
    
    @property
    def Type(self) -> "AgECrdnVectorType":
        """Returns a type of the vector object."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnVectorFindInAxesResult":
        """Computes the vector in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxes'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnVectorFindInAxesWithRateResult":
        """Computes the vector and its rate in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxesWithRate'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}', IAgCrdnVector)
agcls.AgTypeNameMap['IAgCrdnVector'] = IAgCrdnVector
__all__.append('IAgCrdnVector')

class IAgCrdnSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""
    _uuid = '{14687421-5E90-4275-9DE5-21295EC14F65}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindInSystem'] = _raise_uninitialized_error
        self.__dict__['_Transform'] = _raise_uninitialized_error
        self.__dict__['_TransformWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystem from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystem = agcom.GUID(IAgCrdnSystem._uuid)
        vtable_offset_local = IAgCrdnSystem._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystem, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindInSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystem, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_Transform'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystem, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_TransformWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystem, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystem.__dict__ and type(IAgCrdnSystem.__dict__[attrname]) == property:
            return IAgCrdnSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystem.')
    
    @property
    def Type(self) -> "AgECrdnSystemType":
        """Returns a type of the system object."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInSystem'](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputSystem:"IAgCrdnSystem", positionInMySystem:"IAgCartesian3Vector") -> "IAgCrdnSystemTransformResult":
        """Translates the position vector from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, IAgCrdnSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, IAgCartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Transform'](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputSystem:"IAgCrdnSystem", positionInMySystem:"IAgCartesian3Vector", velocityInMySystem:"IAgCartesian3Vector") -> "IAgCrdnSystemTransformWithRateResult":
        """Translates the position and rate vectors from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, IAgCrdnSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, IAgCartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_in_arg(velocityInMySystem, IAgCartesian3Vector) as arg_velocityInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_TransformWithRate'](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, arg_velocityInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{14687421-5E90-4275-9DE5-21295EC14F65}', IAgCrdnSystem)
agcls.AgTypeNameMap['IAgCrdnSystem'] = IAgCrdnSystem
__all__.append('IAgCrdnSystem')

class IAgCrdnAxes(object):
    """The interface defines methods and properties common to all axes."""
    _uuid = '{EE2FCF98-9315-406A-835C-40C56428C888}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindInAxesWithRate'] = _raise_uninitialized_error
        self.__dict__['_FindInAxes'] = _raise_uninitialized_error
        self.__dict__['_GetLabels'] = _raise_uninitialized_error
        self.__dict__['_GetX'] = _raise_uninitialized_error
        self.__dict__['_GetY'] = _raise_uninitialized_error
        self.__dict__['_GetZ'] = _raise_uninitialized_error
        self.__dict__['_Transform'] = _raise_uninitialized_error
        self.__dict__['_TransformWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxes = agcom.GUID(IAgCrdnAxes._uuid)
        vtable_offset_local = IAgCrdnAxes._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindInAxesWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindInAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_GetLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_GetZ'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_Transform'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+8, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_TransformWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxes, vtable_offset_local+9, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxes.__dict__ and type(IAgCrdnAxes.__dict__[attrname]) == property:
            return IAgCrdnAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxes.')
    
    @property
    def Type(self) -> "AgECrdnAxesType":
        """Returns a type of the axes object."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxesWithRate'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxes'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IAgCrdnAxesLabels":
        """Returns an object that allows modifying the axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def X(self) -> "IAgCrdnVector":
        """Returns the X axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetX'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Y(self) -> "IAgCrdnVector":
        """Returns the Y axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetY'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Z(self) -> "IAgCrdnVector":
        """Returns the Z axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetZ'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputAxes:"IAgCrdnAxes", vectorInMyAxes:"IAgCartesian3Vector") -> "IAgCrdnAxesTransformResult":
        """Transforms the input vector from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IAgCrdnAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, IAgCartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Transform'](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputAxes:"IAgCrdnAxes", vectorInMyAxes:"IAgCartesian3Vector", rateInMyAxes:"IAgCartesian3Vector") -> "IAgCrdnAxesTransformWithRateResult":
        """Transforms the input vector and vector's rate from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, IAgCrdnAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, IAgCartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_in_arg(rateInMyAxes, IAgCartesian3Vector) as arg_rateInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_TransformWithRate'](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, arg_rateInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EE2FCF98-9315-406A-835C-40C56428C888}', IAgCrdnAxes)
agcls.AgTypeNameMap['IAgCrdnAxes'] = IAgCrdnAxes
__all__.append('IAgCrdnAxes')

class IAgCrdnAngle(object):
    """The interface defines methods and properties common to all angles."""
    _uuid = '{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindAngle'] = _raise_uninitialized_error
        self.__dict__['_FindAngleWithRate'] = _raise_uninitialized_error
        self.__dict__['_FindCoordinates'] = _raise_uninitialized_error
        self.__dict__['_FindCoordinatesWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngle from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngle = agcom.GUID(IAgCrdnAngle._uuid)
        vtable_offset_local = IAgCrdnAngle._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngle, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngle, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_FindAngleWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngle, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_FindCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngle, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindCoordinatesWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngle, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngle.__dict__ and type(IAgCrdnAngle.__dict__[attrname]) == property:
            return IAgCrdnAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngle.')
    
    @property
    def Type(self) -> "AgECrdnAngleType":
        """Returns a type of the angle object."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindAngle(self, epoch:typing.Any) -> "IAgCrdnAngleFindAngleResult":
        """Finds an angle at the specified epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindAngle'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindAngleWithRate(self, epoch:typing.Any) -> "IAgCrdnAngleFindAngleWithRateResult":
        """Finds an angle and angle rate."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindAngleWithRate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinates(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAngleFindResult":
        """Finds the angle value and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindCoordinates'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinatesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnAngleFindWithRateResult":
        """Finds the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindCoordinatesWithRate'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}', IAgCrdnAngle)
agcls.AgTypeNameMap['IAgCrdnAngle'] = IAgCrdnAngle
__all__.append('IAgCrdnAngle')

class IAgCrdnPlane(object):
    """The interface defines methods and properties common to all VGT planes."""
    _uuid = '{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindInAxes'] = _raise_uninitialized_error
        self.__dict__['_FindInAxesWithRate'] = _raise_uninitialized_error
        self.__dict__['_FindInSystem'] = _raise_uninitialized_error
        self.__dict__['_FindInSystemWithRate'] = _raise_uninitialized_error
        self.__dict__['_GetLabels'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlane from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlane = agcom.GUID(IAgCrdnPlane._uuid)
        vtable_offset_local = IAgCrdnPlane._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindInAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindInAxesWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindInSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_FindInSystemWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_GetLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlane, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlane.__dict__ and type(IAgCrdnPlane.__dict__[attrname]) == property:
            return IAgCrdnPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlane.')
    
    @property
    def Type(self) -> "AgECrdnPlaneType":
        """Returns a type of the plane object."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnPlaneFindInAxesResult":
        """Computes the plane's axes vectors in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxes'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"IAgCrdnAxes") -> "IAgCrdnPlaneFindInAxesWithRateResult":
        """Computes the plane's axes vectors and their rates in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInAxesWithRate'](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPlaneFindInSystemResult":
        """Computes the position and X and Y axes in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInSystem'](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystemWithRate(self, epoch:typing.Any, system:"IAgCrdnSystem") -> "IAgCrdnPlaneFindInSystemWithRateResult":
        """Computes the position, X and Y axes and their rates of change in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInSystemWithRate'](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "IAgCrdnPlaneLabels":
        """Allows configuring the plane's X and Y axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}', IAgCrdnPlane)
agcls.AgTypeNameMap['IAgCrdnPlane'] = IAgCrdnPlane
__all__.append('IAgCrdnPlane')

class IAgCrdnContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""
    _uuid = '{1003D700-A64E-438C-954A-AD3AA9EA9773}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsTemplate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnContext._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnContext from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnContext = agcom.GUID(IAgCrdnContext._uuid)
        vtable_offset_local = IAgCrdnContext._vtable_offset - 1
        self.__dict__['_GetIsTemplate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnContext, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnContext.__dict__ and type(IAgCrdnContext.__dict__[attrname]) == property:
            return IAgCrdnContext.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnContext.')
    
    @property
    def IsTemplate(self) -> bool:
        """Returns whether the current instance is a VGT template."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsTemplate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1003D700-A64E-438C-954A-AD3AA9EA9773}', IAgCrdnContext)
agcls.AgTypeNameMap['IAgCrdnContext'] = IAgCrdnContext
__all__.append('IAgCrdnContext')

class IAgCrdn(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""
    _uuid = '{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}'
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetKind'] = _raise_uninitialized_error
        self.__dict__['_GetCategory'] = _raise_uninitialized_error
        self.__dict__['_SetCategory'] = _raise_uninitialized_error
        self.__dict__['_GetName'] = _raise_uninitialized_error
        self.__dict__['_GetDescription'] = _raise_uninitialized_error
        self.__dict__['_GetPath'] = _raise_uninitialized_error
        self.__dict__['_GetIsDuplicable'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_GetTypeInfo'] = _raise_uninitialized_error
        self.__dict__['_GetQualifiedPath'] = _raise_uninitialized_error
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIsReady'] = _raise_uninitialized_error
        self.__dict__['_GetIsReadOnly'] = _raise_uninitialized_error
        self.__dict__['_Duplicate'] = _raise_uninitialized_error
        self.__dict__['_AnonymousDuplicate'] = _raise_uninitialized_error
        self.__dict__['_DependsOn'] = _raise_uninitialized_error
        self.__dict__['_GetEmbeddedComponents'] = _raise_uninitialized_error
        self.__dict__['_Export'] = _raise_uninitialized_error
        self.__dict__['_Rename'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdn from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdn = agcom.GUID(IAgCrdn._uuid)
        vtable_offset_local = IAgCrdn._vtable_offset - 1
        self.__dict__['_GetKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetCategory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_SetCategory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+3, agcom.BSTR)
        self.__dict__['_GetName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__['_GetDescription'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_GetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__['_GetIsDuplicable'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__['_GetTypeInfo'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_GetQualifiedPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIsReady'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIsReadOnly'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_Duplicate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_AnonymousDuplicate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__['_DependsOn'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+16, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetEmbeddedComponents'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__['_Export'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+18, agcom.BSTR, agcom.BSTR)
        self.__dict__['_Rename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdn, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdn.__dict__ and type(IAgCrdn.__dict__[attrname]) == property:
            return IAgCrdn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdn.')
    
    @property
    def Kind(self) -> "AgECrdnKind":
        """Returns the component kind."""
        with agmarshall.AgEnum_arg(AgECrdnKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetKind'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Category(self) -> str:
        """Allows the user to access or change the component category (Folder)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCategory'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Category.setter
    def Category(self, category:str) -> None:
        with agmarshall.BSTR_arg(category) as arg_category:
            agcls.evaluate_hresult(self.__dict__['_SetCategory'](arg_category.COM_val))

    @property
    def Name(self) -> str:
        """Returns the component name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Description(self) -> str:
        """Returns the component description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDescription'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Path(self) -> str:
        """Returns the component's fully qualified path (ie. \"CentralBody/Earth Body\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPath'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsDuplicable(self) -> bool:
        """Returns whether the VGT component can be duplicated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsDuplicable'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns the context object associated with the instance. The returned object is either an instance of IAgCrdnInstance or IAgCrdnTemplate interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TypeInfo(self) -> "IAgCrdnTypeInfo":
        """Returns the component type information."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTypeInfo'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def QualifiedPath(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. \"CentralBody/Earth Body Vector\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetQualifiedPath'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsValid(self) -> bool:
        """Returns whether the component is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReady(self) -> bool:
        """Returns whether the component is ready. The component is ready if it's been fully initialized."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsReady'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReadOnly(self) -> bool:
        """Returns whether the component is modifiable."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsReadOnly'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Duplicate(self, newName:str, description:str) -> "IAgCrdn":
        """Creates a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        with agmarshall.BSTR_arg(newName) as arg_newName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Duplicate'](arg_newName.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def AnonymousDuplicate(self) -> "IAgCrdn":
        """Creates an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_AnonymousDuplicate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def DependsOn(self, component:"IAgCrdn") -> bool:
        """Tests if the instance depends on another component."""
        with agmarshall.AgInterface_in_arg(component, IAgCrdn) as arg_component, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_DependsOn'](arg_component.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def EmbeddedComponents(self) -> "IAgCrdnCollection":
        """Returns a collection of embedded components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEmbeddedComponents'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Export(self, filename:str, comments:str) -> None:
        """Exports the component to a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.BSTR_arg(comments) as arg_comments:
            agcls.evaluate_hresult(self.__dict__['_Export'](arg_filename.COM_val, arg_comments.COM_val))

    def Rename(self, newName:str) -> None:
        """Renames the component."""
        with agmarshall.BSTR_arg(newName) as arg_newName:
            agcls.evaluate_hresult(self.__dict__['_Rename'](arg_newName.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}', IAgCrdn)
agcls.AgTypeNameMap['IAgCrdn'] = IAgCrdn
__all__.append('IAgCrdn')

class IAgCrdnEvaluateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = '{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetValue'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEvaluateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEvaluateResult = agcom.GUID(IAgCrdnEvaluateResult._uuid)
        vtable_offset_local = IAgCrdnEvaluateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvaluateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvaluateResult.__dict__ and type(IAgCrdnEvaluateResult.__dict__[attrname]) == property:
            return IAgCrdnEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEvaluateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """The scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValue'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}', IAgCrdnEvaluateResult)
agcls.AgTypeNameMap['IAgCrdnEvaluateResult'] = IAgCrdnEvaluateResult
__all__.append('IAgCrdnEvaluateResult')

class IAgCrdnEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = '{E9B2DA30-1317-43E2-8D47-9D675A28F748}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetValue'] = _raise_uninitialized_error
        self.__dict__['_GetRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEvaluateWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEvaluateWithRateResult = agcom.GUID(IAgCrdnEvaluateWithRateResult._uuid)
        vtable_offset_local = IAgCrdnEvaluateWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__['_GetRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvaluateWithRateResult.__dict__ and type(IAgCrdnEvaluateWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEvaluateWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """Computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValue'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Rate(self) -> float:
        """A rate of change of the computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E9B2DA30-1317-43E2-8D47-9D675A28F748}', IAgCrdnEvaluateWithRateResult)
agcls.AgTypeNameMap['IAgCrdnEvaluateWithRateResult'] = IAgCrdnEvaluateWithRateResult
__all__.append('IAgCrdnEvaluateWithRateResult')

class IAgCrdnEventIntervalResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = '{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetInterval'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalResult = agcom.GUID(IAgCrdnEventIntervalResult._uuid)
        vtable_offset_local = IAgCrdnEventIntervalResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalResult.__dict__ and type(IAgCrdnEventIntervalResult.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interval(self) -> "IAgCrdnInterval":
        """An interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}', IAgCrdnEventIntervalResult)
agcls.AgTypeNameMap['IAgCrdnEventIntervalResult'] = IAgCrdnEventIntervalResult
__all__.append('IAgCrdnEventIntervalResult')

class IAgCrdnEventFindOccurrenceResult(object):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    _uuid = '{20F964F0-8466-415E-9344-D6FBA53AF8B0}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventFindOccurrenceResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventFindOccurrenceResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventFindOccurrenceResult = agcom.GUID(IAgCrdnEventFindOccurrenceResult._uuid)
        vtable_offset_local = IAgCrdnEventFindOccurrenceResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFindOccurrenceResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFindOccurrenceResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventFindOccurrenceResult.__dict__ and type(IAgCrdnEventFindOccurrenceResult.__dict__[attrname]) == property:
            return IAgCrdnEventFindOccurrenceResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventFindOccurrenceResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{20F964F0-8466-415E-9344-D6FBA53AF8B0}', IAgCrdnEventFindOccurrenceResult)
agcls.AgTypeNameMap['IAgCrdnEventFindOccurrenceResult'] = IAgCrdnEventFindOccurrenceResult
__all__.append('IAgCrdnEventFindOccurrenceResult')

class IAgCrdnFindTimesResult(object):
    """Returns a collection of intervals and an array of times."""
    _uuid = '{F7B644F0-0728-434D-8C86-C6267B625860}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetStart'] = _raise_uninitialized_error
        self.__dict__['_GetStop'] = _raise_uninitialized_error
        self.__dict__['_GetTimes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnFindTimesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnFindTimesResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnFindTimesResult = agcom.GUID(IAgCrdnFindTimesResult._uuid)
        vtable_offset_local = IAgCrdnFindTimesResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFindTimesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFindTimesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFindTimesResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__['_GetStop'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFindTimesResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__['_GetTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFindTimesResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnFindTimesResult.__dict__ and type(IAgCrdnFindTimesResult.__dict__[attrname]) == property:
            return IAgCrdnFindTimesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnFindTimesResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IAgCrdnIntervalCollection":
        """A collection of found intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStop'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Times(self) -> list:
        """An array of found times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F7B644F0-0728-434D-8C86-C6267B625860}', IAgCrdnFindTimesResult)
agcls.AgTypeNameMap['IAgCrdnFindTimesResult'] = IAgCrdnFindTimesResult
__all__.append('IAgCrdnFindTimesResult')

class IAgCrdnIntervalsVectorResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    _uuid = '{87F76F41-61FB-4DFF-A76E-25270023BE34}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalCollections'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntervalsVectorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntervalsVectorResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntervalsVectorResult = agcom.GUID(IAgCrdnIntervalsVectorResult._uuid)
        vtable_offset_local = IAgCrdnIntervalsVectorResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsVectorResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIntervalCollections'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsVectorResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalsVectorResult.__dict__ and type(IAgCrdnIntervalsVectorResult.__dict__[attrname]) == property:
            return IAgCrdnIntervalsVectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntervalsVectorResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IntervalCollections(self) -> "IAgCrdnIntervalVectorCollection":
        """A collection of interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalCollections'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{87F76F41-61FB-4DFF-A76E-25270023BE34}', IAgCrdnIntervalsVectorResult)
agcls.AgTypeNameMap['IAgCrdnIntervalsVectorResult'] = IAgCrdnIntervalsVectorResult
__all__.append('IAgCrdnIntervalsVectorResult')

class IAgCrdnEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    _uuid = '{A829181E-A9CD-452D-AC81-19C2DA96C490}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIndex'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionOccurredResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionOccurredResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionOccurredResult = agcom.GUID(IAgCrdnEventIntervalCollectionOccurredResult._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionOccurredResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionOccurredResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIndex'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionOccurredResult, vtable_offset_local+2, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionOccurredResult.__dict__ and type(IAgCrdnEventIntervalCollectionOccurredResult.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionOccurredResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionOccurredResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Index(self) -> int:
        """Index of an interval in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIndex'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A829181E-A9CD-452D-AC81-19C2DA96C490}', IAgCrdnEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionOccurredResult'] = IAgCrdnEventIntervalCollectionOccurredResult
__all__.append('IAgCrdnEventIntervalCollectionOccurredResult')

class IAgCrdnIntervalListResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = '{D0FDA46F-8B86-4052-8EC7-1448284EABCF}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntervalListResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntervalListResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntervalListResult = agcom.GUID(IAgCrdnIntervalListResult._uuid)
        vtable_offset_local = IAgCrdnIntervalListResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalListResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalListResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalListResult.__dict__ and type(IAgCrdnIntervalListResult.__dict__[attrname]) == property:
            return IAgCrdnIntervalListResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntervalListResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IAgCrdnIntervalCollection":
        """A list of intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{D0FDA46F-8B86-4052-8EC7-1448284EABCF}', IAgCrdnIntervalListResult)
agcls.AgTypeNameMap['IAgCrdnIntervalListResult'] = IAgCrdnIntervalListResult
__all__.append('IAgCrdnIntervalListResult')

class IAgCrdnIntervalVectorCollection(object):
    """A collection of interval collections."""
    _uuid = '{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}'
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntervalVectorCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntervalVectorCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntervalVectorCollection = agcom.GUID(IAgCrdnIntervalVectorCollection._uuid)
        vtable_offset_local = IAgCrdnIntervalVectorCollection._vtable_offset - 1
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalVectorCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalVectorCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalVectorCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalVectorCollection.__dict__ and type(IAgCrdnIntervalVectorCollection.__dict__[attrname]) == property:
            return IAgCrdnIntervalVectorCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntervalVectorCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnIntervalCollection":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IAgCrdnIntervalCollection":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}', IAgCrdnIntervalVectorCollection)
agcls.AgTypeNameMap['IAgCrdnIntervalVectorCollection'] = IAgCrdnIntervalVectorCollection
__all__.append('IAgCrdnIntervalVectorCollection')

class IAgCrdnEventGroup(object):
    """Access or create VGT events associated with an object."""
    _uuid = '{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventGroup = agcom.GUID(IAgCrdnEventGroup._uuid)
        vtable_offset_local = IAgCrdnEventGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventGroup.__dict__ and type(IAgCrdnEventGroup.__dict__[attrname]) == property:
            return IAgCrdnEventGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnEvent":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnEventFactory":
        """Returns a Factory object used to create custom events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEvent":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}', IAgCrdnEventGroup)
agcls.AgTypeNameMap['IAgCrdnEventGroup'] = IAgCrdnEventGroup
__all__.append('IAgCrdnEventGroup')

class IAgCrdnEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""
    _uuid = '{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalGroup = agcom.GUID(IAgCrdnEventIntervalGroup._uuid)
        vtable_offset_local = IAgCrdnEventIntervalGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalGroup.__dict__ and type(IAgCrdnEventIntervalGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnEventInterval":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventIntervalName:str) -> None:
        """Removes an element by name."""
        with agmarshall.BSTR_arg(eventIntervalName) as arg_eventIntervalName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventIntervalName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnEventIntervalFactory":
        """Returns a Factory object used to create custom event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventInterval":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}', IAgCrdnEventIntervalGroup)
agcls.AgTypeNameMap['IAgCrdnEventIntervalGroup'] = IAgCrdnEventIntervalGroup
__all__.append('IAgCrdnEventIntervalGroup')

class IAgCrdnEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""
    _uuid = '{E5721039-AE57-448A-9891-048ECB8BDC63}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListGroup = agcom.GUID(IAgCrdnEventIntervalListGroup._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListGroup.__dict__ and type(IAgCrdnEventIntervalListGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnEventIntervalList":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnEventIntervalListFactory":
        """Returns a factory object used to create custom event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventIntervalList":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{E5721039-AE57-448A-9891-048ECB8BDC63}', IAgCrdnEventIntervalListGroup)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListGroup'] = IAgCrdnEventIntervalListGroup
__all__.append('IAgCrdnEventIntervalListGroup')

class IAgCrdnEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""
    _uuid = '{37A14DB3-3A49-4A6B-B238-922B59737548}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayGroup = agcom.GUID(IAgCrdnEventArrayGroup._uuid)
        vtable_offset_local = IAgCrdnEventArrayGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayGroup.__dict__ and type(IAgCrdnEventArrayGroup.__dict__[attrname]) == property:
            return IAgCrdnEventArrayGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnEventArray":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnEventArrayFactory":
        """Returns a Factory object used to create event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventArray":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{37A14DB3-3A49-4A6B-B238-922B59737548}', IAgCrdnEventArrayGroup)
agcls.AgTypeNameMap['IAgCrdnEventArrayGroup'] = IAgCrdnEventArrayGroup
__all__.append('IAgCrdnEventArrayGroup')

class IAgCrdnCalcScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    _uuid = '{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarGroup = agcom.GUID(IAgCrdnCalcScalarGroup._uuid)
        vtable_offset_local = IAgCrdnCalcScalarGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarGroup.__dict__ and type(IAgCrdnCalcScalarGroup.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnCalcScalar":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnCalcScalarFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnCalcScalar":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}', IAgCrdnCalcScalarGroup)
agcls.AgTypeNameMap['IAgCrdnCalcScalarGroup'] = IAgCrdnCalcScalarGroup
__all__.append('IAgCrdnCalcScalarGroup')

class IAgCrdnEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""
    _uuid = '{0166467D-9328-4E1B-A982-D9B1396A025E}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionGroup = agcom.GUID(IAgCrdnEventIntervalCollectionGroup._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionGroup.__dict__ and type(IAgCrdnEventIntervalCollectionGroup.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnEventIntervalCollection":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnEventIntervalCollectionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnEventIntervalCollection":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{0166467D-9328-4E1B-A982-D9B1396A025E}', IAgCrdnEventIntervalCollectionGroup)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionGroup'] = IAgCrdnEventIntervalCollectionGroup
__all__.append('IAgCrdnEventIntervalCollectionGroup')

class IAgCrdnParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""
    _uuid = '{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetGroup = agcom.GUID(IAgCrdnParameterSetGroup._uuid)
        vtable_offset_local = IAgCrdnParameterSetGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetGroup.__dict__ and type(IAgCrdnParameterSetGroup.__dict__[attrname]) == property:
            return IAgCrdnParameterSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnParameterSet":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnParameterSetFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnParameterSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}', IAgCrdnParameterSetGroup)
agcls.AgTypeNameMap['IAgCrdnParameterSetGroup'] = IAgCrdnParameterSetGroup
__all__.append('IAgCrdnParameterSetGroup')

class IAgCrdnConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""
    _uuid = '{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionGroup = agcom.GUID(IAgCrdnConditionGroup._uuid)
        vtable_offset_local = IAgCrdnConditionGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionGroup.__dict__ and type(IAgCrdnConditionGroup.__dict__[attrname]) == property:
            return IAgCrdnConditionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnCondition":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnConditionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnCondition":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}', IAgCrdnConditionGroup)
agcls.AgTypeNameMap['IAgCrdnConditionGroup'] = IAgCrdnConditionGroup
__all__.append('IAgCrdnConditionGroup')

class IAgCrdnConditionSetGroup(object):
    """Allows accessing and creating condition set components."""
    _uuid = '{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSetGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSetGroup = agcom.GUID(IAgCrdnConditionSetGroup._uuid)
        vtable_offset_local = IAgCrdnConditionSetGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetGroup.__dict__ and type(IAgCrdnConditionSetGroup.__dict__[attrname]) == property:
            return IAgCrdnConditionSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSetGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnConditionSet":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnConditionSetFactory":
        """Returns a factory object used to create condition set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnConditionSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}', IAgCrdnConditionSetGroup)
agcls.AgTypeNameMap['IAgCrdnConditionSetGroup'] = IAgCrdnConditionSetGroup
__all__.append('IAgCrdnConditionSetGroup')

class IAgCrdnConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""
    _uuid = '{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetValues'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSetEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSetEvaluateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSetEvaluateResult = agcom.GUID(IAgCrdnConditionSetEvaluateResult._uuid)
        vtable_offset_local = IAgCrdnConditionSetEvaluateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetValues'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetEvaluateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetEvaluateResult.__dict__ and type(IAgCrdnConditionSetEvaluateResult.__dict__[attrname]) == property:
            return IAgCrdnConditionSetEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSetEvaluateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValues'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}', IAgCrdnConditionSetEvaluateResult)
agcls.AgTypeNameMap['IAgCrdnConditionSetEvaluateResult'] = IAgCrdnConditionSetEvaluateResult
__all__.append('IAgCrdnConditionSetEvaluateResult')

class IAgCrdnConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    _uuid = '{39814D49-3CF5-42B0-A46C-766781F45AB7}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetValues'] = _raise_uninitialized_error
        self.__dict__['_GetRates'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSetEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSetEvaluateWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSetEvaluateWithRateResult = agcom.GUID(IAgCrdnConditionSetEvaluateWithRateResult._uuid)
        vtable_offset_local = IAgCrdnConditionSetEvaluateWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetValues'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetRates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetEvaluateWithRateResult.__dict__ and type(IAgCrdnConditionSetEvaluateWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnConditionSetEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSetEvaluateWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValues'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rates(self) -> list:
        """Computed rates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{39814D49-3CF5-42B0-A46C-766781F45AB7}', IAgCrdnConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap['IAgCrdnConditionSetEvaluateWithRateResult'] = IAgCrdnConditionSetEvaluateWithRateResult
__all__.append('IAgCrdnConditionSetEvaluateWithRateResult')

class IAgCrdnVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""
    _uuid = '{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridGroup = agcom.GUID(IAgCrdnVolumeGridGroup._uuid)
        vtable_offset_local = IAgCrdnVolumeGridGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridGroup.__dict__ and type(IAgCrdnVolumeGridGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnVolumeGrid":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnVolumeGridFactory":
        """Returns a factory object used to create volume grid components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolumeGrid":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}', IAgCrdnVolumeGridGroup)
agcls.AgTypeNameMap['IAgCrdnVolumeGridGroup'] = IAgCrdnVolumeGridGroup
__all__.append('IAgCrdnVolumeGridGroup')

class IAgCrdnVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""
    _uuid = '{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGroup = agcom.GUID(IAgCrdnVolumeGroup._uuid)
        vtable_offset_local = IAgCrdnVolumeGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGroup.__dict__ and type(IAgCrdnVolumeGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnVolume":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnVolumeFactory":
        """Returns a factory object used to create spatial condition components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolume":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}', IAgCrdnVolumeGroup)
agcls.AgTypeNameMap['IAgCrdnVolumeGroup'] = IAgCrdnVolumeGroup
__all__.append('IAgCrdnVolumeGroup')

class IAgCrdnVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""
    _uuid = '{02991465-35ec-486a-913d-bf204afc9fb6}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcGroup = agcom.GUID(IAgCrdnVolumeCalcGroup._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcGroup.__dict__ and type(IAgCrdnVolumeCalcGroup.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnVolumeCalc":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_eventName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnVolumeCalcFactory":
        """Returns a factory object used to create volume calc components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVolumeCalc":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{02991465-35ec-486a-913d-bf204afc9fb6}', IAgCrdnVolumeCalcGroup)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcGroup'] = IAgCrdnVolumeCalcGroup
__all__.append('IAgCrdnVolumeCalcGroup')

class IAgCrdnCalcScalar(object):
    """Any scalar calculation that is not constant by construction."""
    _uuid = '{55A75307-E283-4146-A456-732D08E47070}'
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_Evaluate'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluate'] = _raise_uninitialized_error
        self.__dict__['_EvaluateWithRate'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluateWithRate'] = _raise_uninitialized_error
        self.__dict__['_GetAvailability'] = _raise_uninitialized_error
        self.__dict__['_GetUnitOfMeasure'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluateArray'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluateWithRateArray'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluateEventArray'] = _raise_uninitialized_error
        self.__dict__['_QuickEvaluateWithRateEventArray'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalar from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalar = agcom.GUID(IAgCrdnCalcScalar._uuid)
        vtable_offset_local = IAgCrdnCalcScalar._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Evaluate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_QuickEvaluate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__['_EvaluateWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_QuickEvaluateWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetAvailability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_GetUnitOfMeasure'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__['_QuickEvaluateArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+8, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__['_QuickEvaluateWithRateArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__['_QuickEvaluateEventArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__['_QuickEvaluateWithRateEventArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalar, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalar.__dict__ and type(IAgCrdnCalcScalar.__dict__[attrname]) == property:
            return IAgCrdnCalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalar.')
    
    @property
    def Type(self) -> "AgECrdnCalcScalarType":
        """Returns the scalar calculation type."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnEvaluateResult":
        """Evaluates the scalar calculation at the specified time instant."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Evaluate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnEvaluateWithRateResult":
        """Evaluates the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_EvaluateWithRate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluateWithRate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetAvailability(self) -> "IAgCrdnIntervalCollection":
        """Returns a list of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailability'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UnitOfMeasure(self) -> str:
        """Returns calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUnitOfMeasure'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def QuickEvaluateArray(self, times:list) -> list:
        """Evaluates the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluateArray'](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateArray(self, times:list) -> list:
        """Evaluates the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluateWithRateArray'](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateEventArray(self, refArray:"IAgCrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, IAgCrdnEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluateEventArray'](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateEventArray(self, refArray:"IAgCrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, IAgCrdnEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_QuickEvaluateWithRateEventArray'](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{55A75307-E283-4146-A456-732D08E47070}', IAgCrdnCalcScalar)
agcls.AgTypeNameMap['IAgCrdnCalcScalar'] = IAgCrdnCalcScalar
__all__.append('IAgCrdnCalcScalar')

class IAgCrdnCalcScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    _uuid = '{52FB9533-9332-44D2-92B2-8AA2D8633112}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputAngle'] = _raise_uninitialized_error
        self.__dict__['_SetInputAngle'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarAngle from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarAngle = agcom.GUID(IAgCrdnCalcScalarAngle._uuid)
        vtable_offset_local = IAgCrdnCalcScalarAngle._vtable_offset - 1
        self.__dict__['_GetInputAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarAngle, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarAngle.__dict__ and type(IAgCrdnCalcScalarAngle.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarAngle.')
    
    @property
    def InputAngle(self) -> "IAgCrdnAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputAngle'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputAngle.setter
    def InputAngle(self, inputAngle:"IAgCrdnAngle") -> None:
        with agmarshall.AgInterface_in_arg(inputAngle, IAgCrdnAngle) as arg_inputAngle:
            agcls.evaluate_hresult(self.__dict__['_SetInputAngle'](arg_inputAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{52FB9533-9332-44D2-92B2-8AA2D8633112}', IAgCrdnCalcScalarAngle)
agcls.AgTypeNameMap['IAgCrdnCalcScalarAngle'] = IAgCrdnCalcScalarAngle
__all__.append('IAgCrdnCalcScalarAngle')

class IAgCrdnCalcScalarConstant(object):
    """Constant scalar value of specified dimension."""
    _uuid = '{96A1ABA9-663C-4CCC-A066-0166E285C3C2}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetValue'] = _raise_uninitialized_error
        self.__dict__['_SetValue'] = _raise_uninitialized_error
        self.__dict__['_GetDimension'] = _raise_uninitialized_error
        self.__dict__['_SetDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarConstant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarConstant = agcom.GUID(IAgCrdnCalcScalarConstant._uuid)
        vtable_offset_local = IAgCrdnCalcScalarConstant._vtable_offset - 1
        self.__dict__['_GetValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarConstant, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarConstant, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarConstant.__dict__ and type(IAgCrdnCalcScalarConstant.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarConstant.')
    
    @property
    def Value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValue'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Value.setter
    def Value(self, value:float) -> None:
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetValue'](arg_value.COM_val))

    @property
    def Dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__['_SetDimension'](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{96A1ABA9-663C-4CCC-A066-0166E285C3C2}', IAgCrdnCalcScalarConstant)
agcls.AgTypeNameMap['IAgCrdnCalcScalarConstant'] = IAgCrdnCalcScalarConstant
__all__.append('IAgCrdnCalcScalarConstant')

class IAgCrdnCalcScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    _uuid = '{6267B685-4486-4B11-A2CA-056D6A9B558C}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        self.__dict__['_Reload'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarCustom from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarCustom = agcom.GUID(IAgCrdnCalcScalarCustom._uuid)
        vtable_offset_local = IAgCrdnCalcScalarCustom._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarCustom, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarCustom, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_Reload'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarCustom, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarCustom.__dict__ and type(IAgCrdnCalcScalarCustom.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarCustom.')
    
    @property
    def Filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__['_Reload']())


agcls.AgClassCatalog.add_catalog_entry('{6267B685-4486-4B11-A2CA-056D6A9B558C}', IAgCrdnCalcScalarCustom)
agcls.AgTypeNameMap['IAgCrdnCalcScalarCustom'] = IAgCrdnCalcScalarCustom
__all__.append('IAgCrdnCalcScalarCustom')

class IAgCrdnCalcScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    _uuid = '{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}'
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDataProvider'] = _raise_uninitialized_error
        self.__dict__['_GetElementName'] = _raise_uninitialized_error
        self.__dict__['_GetGroup'] = _raise_uninitialized_error
        self.__dict__['_GetInterpolation'] = _raise_uninitialized_error
        self.__dict__['_SetInterpolation'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetUseSamples'] = _raise_uninitialized_error
        self.__dict__['_SetUseSamples'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_Set'] = _raise_uninitialized_error
        self.__dict__['_SetWithGroup'] = _raise_uninitialized_error
        self.__dict__['_GetInvalidDataIndicator'] = _raise_uninitialized_error
        self.__dict__['_SetInvalidDataIndicator'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarDataElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarDataElement from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarDataElement = agcom.GUID(IAgCrdnCalcScalarDataElement._uuid)
        vtable_offset_local = IAgCrdnCalcScalarDataElement._vtable_offset - 1
        self.__dict__['_GetDataProvider'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetGroup'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_GetInterpolation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_SetInterpolation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+5, agcom.PVOID)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+7, agcom.PVOID)
        self.__dict__['_GetUseSamples'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseSamples'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+11, agcom.LONG)
        self.__dict__['_Set'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+12, agcom.BSTR, agcom.BSTR)
        self.__dict__['_SetWithGroup'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, agcom.BSTR)
        self.__dict__['_GetInvalidDataIndicator'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__['_SetInvalidDataIndicator'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDataElement, vtable_offset_local+15, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDataElement.__dict__ and type(IAgCrdnCalcScalarDataElement.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDataElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarDataElement.')
    
    @property
    def DataProvider(self) -> str:
        """The name of the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDataProvider'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ElementName(self) -> str:
        """The name of the data element within the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetElementName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetGroup'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interpolation(self) -> "IAgCrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInterpolation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IAgCrdnInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IAgCrdnInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__['_SetInterpolation'](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def UseSamples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseSamples'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseSamples.setter
    def UseSamples(self, useSamples:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useSamples) as arg_useSamples:
            agcls.evaluate_hresult(self.__dict__['_SetUseSamples'](arg_useSamples.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    def Set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__['_Set'](arg_dataProvider.COM_val, arg_elementName.COM_val))

    def SetWithGroup(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(typeName) as arg_typeName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__['_SetWithGroup'](arg_dataProvider.COM_val, arg_typeName.COM_val, arg_elementName.COM_val))

    @property
    def InvalidDataIndicator(self) -> float:
        """Sets the value to display in a report or graph when the actual value is not a valid real number"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInvalidDataIndicator'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InvalidDataIndicator.setter
    def InvalidDataIndicator(self, invalidDataIndicator:float) -> None:
        with agmarshall.DOUBLE_arg(invalidDataIndicator) as arg_invalidDataIndicator:
            agcls.evaluate_hresult(self.__dict__['_SetInvalidDataIndicator'](arg_invalidDataIndicator.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}', IAgCrdnCalcScalarDataElement)
agcls.AgTypeNameMap['IAgCrdnCalcScalarDataElement'] = IAgCrdnCalcScalarDataElement
__all__.append('IAgCrdnCalcScalarDataElement')

class IAgCrdnCalcScalarDerivative(object):
    """Derivative of an input scalar calculation."""
    _uuid = '{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetScalar'] = _raise_uninitialized_error
        self.__dict__['_SetScalar'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetForceUseOfNumericalDifferences'] = _raise_uninitialized_error
        self.__dict__['_SetForceUseOfNumericalDifferences'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarDerivative from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarDerivative = agcom.GUID(IAgCrdnCalcScalarDerivative._uuid)
        vtable_offset_local = IAgCrdnCalcScalarDerivative._vtable_offset - 1
        self.__dict__['_GetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetForceUseOfNumericalDifferences'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetForceUseOfNumericalDifferences'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDerivative.__dict__ and type(IAgCrdnCalcScalarDerivative.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarDerivative.')
    
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar component used to compute the derivative."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, IAgCrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__['_SetScalar'](arg_scalar.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetForceUseOfNumericalDifferences'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__['_SetForceUseOfNumericalDifferences'](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}', IAgCrdnCalcScalarDerivative)
agcls.AgTypeNameMap['IAgCrdnCalcScalarDerivative'] = IAgCrdnCalcScalarDerivative
__all__.append('IAgCrdnCalcScalarDerivative')

class IAgCrdnCalcScalarDotProduct(object):
    """Dot product between two vectors."""
    _uuid = '{ffb69fa2-d123-413e-bb34-db750b7775ea}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetDimension'] = _raise_uninitialized_error
        self.__dict__['_SetDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarDotProduct from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarDotProduct = agcom.GUID(IAgCrdnCalcScalarDotProduct._uuid)
        vtable_offset_local = IAgCrdnCalcScalarDotProduct._vtable_offset - 1
        self.__dict__['_GetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_GetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__['_SetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarDotProduct, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarDotProduct.__dict__ and type(IAgCrdnCalcScalarDotProduct.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarDotProduct.')
    
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """First vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IAgCrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__['_SetVectorA'](arg_vectorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorA'](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Second vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IAgCrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__['_SetVectorB'](arg_vectorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorB'](arg_normalizeVectorB.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'Angle', 'Distance', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__['_SetDimension'](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{ffb69fa2-d123-413e-bb34-db750b7775ea}', IAgCrdnCalcScalarDotProduct)
agcls.AgTypeNameMap['IAgCrdnCalcScalarDotProduct'] = IAgCrdnCalcScalarDotProduct
__all__.append('IAgCrdnCalcScalarDotProduct')

class IAgCrdnCalcScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""
    _uuid = '{81238610-6A1B-499A-8C43-12337F64BC42}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarElapsedTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarElapsedTime from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarElapsedTime = agcom.GUID(IAgCrdnCalcScalarElapsedTime._uuid)
        vtable_offset_local = IAgCrdnCalcScalarElapsedTime._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarElapsedTime, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarElapsedTime, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarElapsedTime.__dict__ and type(IAgCrdnCalcScalarElapsedTime.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarElapsedTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarElapsedTime.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{81238610-6A1B-499A-8C43-12337F64BC42}', IAgCrdnCalcScalarElapsedTime)
agcls.AgTypeNameMap['IAgCrdnCalcScalarElapsedTime'] = IAgCrdnCalcScalarElapsedTime
__all__.append('IAgCrdnCalcScalarElapsedTime')

class IAgCrdnCalcScalarFactory(object):
    """The factory creates scalar calculation components."""
    _uuid = '{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}'
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAvailableCalcScalarPluginDisplayNames'] = _raise_uninitialized_error
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarAngle'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarFixedAtTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarConstant'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarDataElement'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarDataElementWithGroup'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarDerivative'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarElapsedTime'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarFile'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarFunction'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarIntegral'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarFunction2Var'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarVectorMagnitude'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarPluginFromDisplayName'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarFromCustomScript'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarSurfaceDistanceBetweenPoints'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarDotProduct'] = _raise_uninitialized_error
        self.__dict__['_CreateCalcScalarVectorComponent'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarFactory = agcom.GUID(IAgCrdnCalcScalarFactory._uuid)
        vtable_offset_local = IAgCrdnCalcScalarFactory._vtable_offset - 1
        self.__dict__['_GetAvailableCalcScalarPluginDisplayNames'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarFixedAtTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarConstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarDataElement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarDataElementWithGroup'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarDerivative'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarElapsedTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarFunction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+11, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarIntegral'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+12, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarFunction2Var'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarVectorMagnitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarPluginFromDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+15, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+16, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateCalcScalarFromCustomScript'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+17, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarSurfaceDistanceBetweenPoints'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+18, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarDotProduct'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+19, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCalcScalarVectorComponent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFactory, vtable_offset_local+20, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFactory.__dict__ and type(IAgCrdnCalcScalarFactory.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarFactory.')
    
    @property
    def AvailableCalcScalarPluginDisplayNames(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableCalcScalarPluginDisplayNames'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnCalcScalarType") -> "IAgCrdnCalcScalar":
        """Creates and registers a scalar calculation using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnCalcScalarType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarAngle(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarAngle'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFixedAtTimeInstant(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarFixedAtTimeInstant'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarConstant(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarConstant'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElement(self, name:str, description:str, dataProvider:str, elementName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarDataElement'](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElementWithGroup(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(groupName) as arg_groupName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarDataElementWithGroup'](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_groupName.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDerivative(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarDerivative'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarElapsedTime(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarElapsedTime'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFile(self, name:str, description:str, filepath:str) -> "IAgCrdnCalcScalar":
        """Create scalar calculation specified by external data file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarFile'](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarFunction'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarIntegral(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarIntegral'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction2Var(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarFunction2Var'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorMagnitude(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarVectorMagnitude'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarPluginFromDisplayName(self, name:str, description:str, displayName:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarPluginFromDisplayName'](arg_name.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnCalcScalarType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateCalcScalarFromCustomScript(self, name:str, description:str, filepath:str) -> "IAgCrdnCalcScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarFromCustomScript'](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarSurfaceDistanceBetweenPoints(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarSurfaceDistanceBetweenPoints'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDotProduct(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarDotProduct'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorComponent(self, name:str, description:str) -> "IAgCrdnCalcScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCalcScalarVectorComponent'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}', IAgCrdnCalcScalarFactory)
agcls.AgTypeNameMap['IAgCrdnCalcScalarFactory'] = IAgCrdnCalcScalarFactory
__all__.append('IAgCrdnCalcScalarFactory')

class IAgCrdnCalcScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    _uuid = '{98BC97CE-DA0B-4783-BB98-A988CA16447A}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        self.__dict__['_Reload'] = _raise_uninitialized_error
        self.__dict__['_GetFileSpan'] = _raise_uninitialized_error
        self.__dict__['_GetFileInterpolationType'] = _raise_uninitialized_error
        self.__dict__['_SetFileInterpolationType'] = _raise_uninitialized_error
        self.__dict__['_GetFileInterpolationOrder'] = _raise_uninitialized_error
        self.__dict__['_SetFileInterpolationOrder'] = _raise_uninitialized_error
        self.__dict__['_GetUseNativeFileInterpolationSettings'] = _raise_uninitialized_error
        self.__dict__['_SetUseNativeFileInterpolationSettings'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarFile from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarFile = agcom.GUID(IAgCrdnCalcScalarFile._uuid)
        vtable_offset_local = IAgCrdnCalcScalarFile._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_Reload'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+3, )
        self.__dict__['_GetFileSpan'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetFileInterpolationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetFileInterpolationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+6, agcom.LONG)
        self.__dict__['_GetFileInterpolationOrder'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__['_SetFileInterpolationOrder'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+8, agcom.INT)
        self.__dict__['_GetUseNativeFileInterpolationSettings'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseNativeFileInterpolationSettings'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFile, vtable_offset_local+10, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFile.__dict__ and type(IAgCrdnCalcScalarFile.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarFile.')
    
    @property
    def Filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__['_Reload']())

    def GetFileSpan(self) -> "IAgCrdnEventIntervalResult":
        """Computes the interval time span of the file."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFileSpan'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FileInterpolationType(self) -> "AgECrdnFileInterpolatorType":
        """The interpolation method used with the data."""
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFileInterpolationType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationType.setter
    def FileInterpolationType(self, fileInterpolationType:"AgECrdnFileInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType, fileInterpolationType) as arg_fileInterpolationType:
            agcls.evaluate_hresult(self.__dict__['_SetFileInterpolationType'](arg_fileInterpolationType.COM_val))

    @property
    def FileInterpolationOrder(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFileInterpolationOrder'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationOrder.setter
    def FileInterpolationOrder(self, fileInterpolationOrder:int) -> None:
        with agmarshall.INT_arg(fileInterpolationOrder) as arg_fileInterpolationOrder:
            agcls.evaluate_hresult(self.__dict__['_SetFileInterpolationOrder'](arg_fileInterpolationOrder.COM_val))

    @property
    def UseNativeFileInterpolationSettings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseNativeFileInterpolationSettings'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseNativeFileInterpolationSettings.setter
    def UseNativeFileInterpolationSettings(self, useNativeFileInterpolationSettings:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useNativeFileInterpolationSettings) as arg_useNativeFileInterpolationSettings:
            agcls.evaluate_hresult(self.__dict__['_SetUseNativeFileInterpolationSettings'](arg_useNativeFileInterpolationSettings.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{98BC97CE-DA0B-4783-BB98-A988CA16447A}', IAgCrdnCalcScalarFile)
agcls.AgTypeNameMap['IAgCrdnCalcScalarFile'] = IAgCrdnCalcScalarFile
__all__.append('IAgCrdnCalcScalarFile')

class IAgCrdnCalcScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    _uuid = '{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_SetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarFixedAtTimeInstant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarFixedAtTimeInstant = agcom.GUID(IAgCrdnCalcScalarFixedAtTimeInstant._uuid)
        vtable_offset_local = IAgCrdnCalcScalarFixedAtTimeInstant._vtable_offset - 1
        self.__dict__['_GetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFixedAtTimeInstant.__dict__ and type(IAgCrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarFixedAtTimeInstant.')
    
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, IAgCrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__['_SetInputScalar'](arg_inputScalar.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}', IAgCrdnCalcScalarFixedAtTimeInstant)
agcls.AgTypeNameMap['IAgCrdnCalcScalarFixedAtTimeInstant'] = IAgCrdnCalcScalarFixedAtTimeInstant
__all__.append('IAgCrdnCalcScalarFixedAtTimeInstant')

class IAgCrdnCalcScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""
    _uuid = '{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}'
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetUseScalar'] = _raise_uninitialized_error
        self.__dict__['_SetUseScalar'] = _raise_uninitialized_error
        self.__dict__['_GetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_SetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_GetInputTime'] = _raise_uninitialized_error
        self.__dict__['_SetInputTime'] = _raise_uninitialized_error
        self.__dict__['_GetInputUnit'] = _raise_uninitialized_error
        self.__dict__['_SetInputUnit'] = _raise_uninitialized_error
        self.__dict__['_GetA'] = _raise_uninitialized_error
        self.__dict__['_SetA'] = _raise_uninitialized_error
        self.__dict__['_GetB'] = _raise_uninitialized_error
        self.__dict__['_SetB'] = _raise_uninitialized_error
        self.__dict__['_GetC'] = _raise_uninitialized_error
        self.__dict__['_SetC'] = _raise_uninitialized_error
        self.__dict__['_GetD'] = _raise_uninitialized_error
        self.__dict__['_SetD'] = _raise_uninitialized_error
        self.__dict__['_GetCoefficients'] = _raise_uninitialized_error
        self.__dict__['_SetCoefficients'] = _raise_uninitialized_error
        self.__dict__['_GetSelectedFunction'] = _raise_uninitialized_error
        self.__dict__['_SetSelectedFunction'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableFunctions'] = _raise_uninitialized_error
        self.__dict__['_GetInheritDimensionFromInput'] = _raise_uninitialized_error
        self.__dict__['_SetInheritDimensionFromInput'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_GetOutputUnit'] = _raise_uninitialized_error
        self.__dict__['_SetOutputUnit'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarFunction from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarFunction = agcom.GUID(IAgCrdnCalcScalarFunction._uuid)
        vtable_offset_local = IAgCrdnCalcScalarFunction._vtable_offset - 1
        self.__dict__['_GetUseScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__['_GetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetInputTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetInputTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetInputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__['_SetInputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+8, agcom.BSTR)
        self.__dict__['_GetA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__['_SetB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__['_GetC'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__['_SetC'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__['_GetD'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__['_SetD'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__['_GetCoefficients'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetCoefficients'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+18, agcom.SAFEARRAY)
        self.__dict__['_GetSelectedFunction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__['_SetSelectedFunction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+20, agcom.BSTR)
        self.__dict__['_GetAvailableFunctions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetInheritDimensionFromInput'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetInheritDimensionFromInput'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+23, agcom.VARIANT_BOOL)
        self.__dict__['_GetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+25, agcom.BSTR)
        self.__dict__['_GetOutputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+27, agcom.BSTR)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+29, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction, vtable_offset_local+31, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFunction.__dict__ and type(IAgCrdnCalcScalarFunction.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarFunction.')
    
    @property
    def UseScalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseScalar'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScalar.setter
    def UseScalar(self, useScalar:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScalar) as arg_useScalar:
            agcls.evaluate_hresult(self.__dict__['_SetUseScalar'](arg_useScalar.COM_val))

    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, IAgCrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__['_SetInputScalar'](arg_inputScalar.COM_val))

    @property
    def InputTime(self) -> "IAgCrdnEvent":
        """The input time instant (used if UseScalar is false)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputTime'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputTime.setter
    def InputTime(self, inputTime:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(inputTime, IAgCrdnEvent) as arg_inputTime:
            agcls.evaluate_hresult(self.__dict__['_SetInputTime'](arg_inputTime.COM_val))

    @property
    def InputUnit(self) -> str:
        """The input time unit to interpret input time."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputUnit'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InputUnit.setter
    def InputUnit(self, inputUnit:str) -> None:
        with agmarshall.BSTR_arg(inputUnit) as arg_inputUnit:
            agcls.evaluate_hresult(self.__dict__['_SetInputUnit'](arg_inputUnit.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__['_SetA'](arg_a.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__['_SetB'](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetC'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__['_SetC'](arg_c.COM_val))

    @property
    def D(self) -> float:
        """The constant coefficient D."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetD'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @D.setter
    def D(self, d:float) -> None:
        with agmarshall.DOUBLE_arg(d) as arg_d:
            agcls.evaluate_hresult(self.__dict__['_SetD'](arg_d.COM_val))

    @property
    def Coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCoefficients'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Coefficients.setter
    def Coefficients(self, coefficients:list) -> None:
        with agmarshall.SAFEARRAY_arg(coefficients) as arg_coefficients:
            agcls.evaluate_hresult(self.__dict__['_SetCoefficients'](arg_coefficients.COM_val))

    @property
    def SelectedFunction(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSelectedFunction'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__['_SetSelectedFunction'](arg_selectedFunction.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """Get the available function names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableFunctions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def InheritDimensionFromInput(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInheritDimensionFromInput'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InheritDimensionFromInput.setter
    def InheritDimensionFromInput(self, inheritDimensionFromInput:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inheritDimensionFromInput) as arg_inheritDimensionFromInput:
            agcls.evaluate_hresult(self.__dict__['_SetInheritDimensionFromInput'](arg_inheritDimensionFromInput.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimension'](arg_outputDimension.COM_val))

    @property
    def OutputUnit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputUnit'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__['_SetOutputUnit'](arg_outputUnit.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}', IAgCrdnCalcScalarFunction)
agcls.AgTypeNameMap['IAgCrdnCalcScalarFunction'] = IAgCrdnCalcScalarFunction
__all__.append('IAgCrdnCalcScalarFunction')

class IAgCrdnCalcScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""
    _uuid = '{E56D021E-AD96-4ABE-857E-708CDCC4FF14}'
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetX'] = _raise_uninitialized_error
        self.__dict__['_SetX'] = _raise_uninitialized_error
        self.__dict__['_GetUnitX'] = _raise_uninitialized_error
        self.__dict__['_SetUnitX'] = _raise_uninitialized_error
        self.__dict__['_GetA'] = _raise_uninitialized_error
        self.__dict__['_SetA'] = _raise_uninitialized_error
        self.__dict__['_GetY'] = _raise_uninitialized_error
        self.__dict__['_SetY'] = _raise_uninitialized_error
        self.__dict__['_GetUnitY'] = _raise_uninitialized_error
        self.__dict__['_SetUnitY'] = _raise_uninitialized_error
        self.__dict__['_GetB'] = _raise_uninitialized_error
        self.__dict__['_SetB'] = _raise_uninitialized_error
        self.__dict__['_GetC'] = _raise_uninitialized_error
        self.__dict__['_SetC'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableFunctions'] = _raise_uninitialized_error
        self.__dict__['_GetSelectedFunction'] = _raise_uninitialized_error
        self.__dict__['_SetSelectedFunction'] = _raise_uninitialized_error
        self.__dict__['_GetOutputUnit'] = _raise_uninitialized_error
        self.__dict__['_SetOutputUnit'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarFunction2Var._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarFunction2Var from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarFunction2Var = agcom.GUID(IAgCrdnCalcScalarFunction2Var._uuid)
        vtable_offset_local = IAgCrdnCalcScalarFunction2Var._vtable_offset - 1
        self.__dict__['_GetX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetUnitX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetUnitX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+4, agcom.BSTR)
        self.__dict__['_GetA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetUnitY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__['_SetUnitY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+10, agcom.BSTR)
        self.__dict__['_GetB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__['_SetB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__['_GetC'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__['_SetC'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__['_GetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__['_SetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+16, agcom.LONG)
        self.__dict__['_GetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+18, agcom.BSTR)
        self.__dict__['_GetAvailableFunctions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+19, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetSelectedFunction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__['_SetSelectedFunction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+21, agcom.BSTR)
        self.__dict__['_GetOutputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+22, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputUnit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarFunction2Var, vtable_offset_local+23, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarFunction2Var.__dict__ and type(IAgCrdnCalcScalarFunction2Var.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarFunction2Var.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarFunction2Var.')
    
    @property
    def X(self) -> "IAgCrdnCalcScalar":
        """The scalar argument X."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetX'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @X.setter
    def X(self, x:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(x, IAgCrdnCalcScalar) as arg_x:
            agcls.evaluate_hresult(self.__dict__['_SetX'](arg_x.COM_val))

    @property
    def UnitX(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUnitX'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitX.setter
    def UnitX(self, unitX:str) -> None:
        with agmarshall.BSTR_arg(unitX) as arg_unitX:
            agcls.evaluate_hresult(self.__dict__['_SetUnitX'](arg_unitX.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__['_SetA'](arg_a.COM_val))

    @property
    def Y(self) -> "IAgCrdnCalcScalar":
        """The scalar argument Y."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetY'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Y.setter
    def Y(self, y:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(y, IAgCrdnCalcScalar) as arg_y:
            agcls.evaluate_hresult(self.__dict__['_SetY'](arg_y.COM_val))

    @property
    def UnitY(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUnitY'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitY.setter
    def UnitY(self, unitY:str) -> None:
        with agmarshall.BSTR_arg(unitY) as arg_unitY:
            agcls.evaluate_hresult(self.__dict__['_SetUnitY'](arg_unitY.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__['_SetB'](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetC'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__['_SetC'](arg_c.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Specifies whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimensionInheritance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimensionInheritance'](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimension'](arg_outputDimension.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableFunctions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SelectedFunction(self) -> str:
        """The selected function."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSelectedFunction'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__['_SetSelectedFunction'](arg_selectedFunction.COM_val))

    @property
    def OutputUnit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputUnit'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__['_SetOutputUnit'](arg_outputUnit.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{E56D021E-AD96-4ABE-857E-708CDCC4FF14}', IAgCrdnCalcScalarFunction2Var)
agcls.AgTypeNameMap['IAgCrdnCalcScalarFunction2Var'] = IAgCrdnCalcScalarFunction2Var
__all__.append('IAgCrdnCalcScalarFunction2Var')

class IAgCrdnCalcScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    _uuid = '{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}'
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_SetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_GetComputeAsAverage'] = _raise_uninitialized_error
        self.__dict__['_SetComputeAsAverage'] = _raise_uninitialized_error
        self.__dict__['_GetIntegrationWindowType'] = _raise_uninitialized_error
        self.__dict__['_SetIntegrationWindowType'] = _raise_uninitialized_error
        self.__dict__['_GetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_GetStopOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStopOffset'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetInterpolation'] = _raise_uninitialized_error
        self.__dict__['_SetInterpolation'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetIntegral'] = _raise_uninitialized_error
        self.__dict__['_SetIntegral'] = _raise_uninitialized_error
        self.__dict__['_GetKeepConstantOutsideTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetKeepConstantOutsideTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetOffsets'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarIntegral from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarIntegral = agcom.GUID(IAgCrdnCalcScalarIntegral._uuid)
        vtable_offset_local = IAgCrdnCalcScalarIntegral._vtable_offset - 1
        self.__dict__['_GetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetComputeAsAverage'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetComputeAsAverage'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetIntegrationWindowType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetIntegrationWindowType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+6, agcom.LONG)
        self.__dict__['_GetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+14, agcom.PVOID)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+16, agcom.LONG)
        self.__dict__['_GetInterpolation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__['_SetInterpolation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+18, agcom.PVOID)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+20, agcom.PVOID)
        self.__dict__['_GetIntegral'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__['_SetIntegral'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+22, agcom.PVOID)
        self.__dict__['_GetKeepConstantOutsideTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetKeepConstantOutsideTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__['_SetOffsets'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarIntegral, vtable_offset_local+25, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarIntegral.__dict__ and type(IAgCrdnCalcScalarIntegral.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarIntegral.')
    
    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, IAgCrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__['_SetInputScalar'](arg_inputScalar.COM_val))

    @property
    def ComputeAsAverage(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetComputeAsAverage'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ComputeAsAverage.setter
    def ComputeAsAverage(self, computeAsAverage:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(computeAsAverage) as arg_computeAsAverage:
            agcls.evaluate_hresult(self.__dict__['_SetComputeAsAverage'](arg_computeAsAverage.COM_val))

    @property
    def IntegrationWindowType(self) -> "AgECrdnIntegrationWindowType":
        """The integration window, or accumulation, type."""
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntegrationWindowType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntegrationWindowType.setter
    def IntegrationWindowType(self, integrationWindowType:"AgECrdnIntegrationWindowType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType, integrationWindowType) as arg_integrationWindowType:
            agcls.evaluate_hresult(self.__dict__['_SetIntegrationWindowType'](arg_integrationWindowType.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStartOffset'](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStopOffset'](arg_stopOffset.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Interpolation(self) -> "IAgCrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInterpolation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"IAgCrdnInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, IAgCrdnInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__['_SetInterpolation'](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Integral(self) -> "IAgCrdnIntegral":
        """The numerical integration method."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntegral'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Integral.setter
    def Integral(self, integral:"IAgCrdnIntegral") -> None:
        with agmarshall.AgInterface_in_arg(integral, IAgCrdnIntegral) as arg_integral:
            agcls.evaluate_hresult(self.__dict__['_SetIntegral'](arg_integral.COM_val))

    @property
    def KeepConstantOutsideTimeLimits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetKeepConstantOutsideTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @KeepConstantOutsideTimeLimits.setter
    def KeepConstantOutsideTimeLimits(self, keepConstantOutsideTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(keepConstantOutsideTimeLimits) as arg_keepConstantOutsideTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetKeepConstantOutsideTimeLimits'](arg_keepConstantOutsideTimeLimits.COM_val))

    def SetOffsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset, \
             agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__['_SetOffsets'](arg_startOffset.COM_val, arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}', IAgCrdnCalcScalarIntegral)
agcls.AgTypeNameMap['IAgCrdnCalcScalarIntegral'] = IAgCrdnCalcScalarIntegral
__all__.append('IAgCrdnCalcScalarIntegral')

class IAgCrdnCalcScalarPlugin(object):
    """Use a scalar calculation plugin."""
    _uuid = '{1459313C-59BD-42FF-9F0D-AF4604F13D4C}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetProgID'] = _raise_uninitialized_error
        self.__dict__['_GetDisplayName'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableProperties'] = _raise_uninitialized_error
        self.__dict__['_Reset'] = _raise_uninitialized_error
        self.__dict__['_SetProperty'] = _raise_uninitialized_error
        self.__dict__['_GetProperty'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarPlugin from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarPlugin = agcom.GUID(IAgCrdnCalcScalarPlugin._uuid)
        vtable_offset_local = IAgCrdnCalcScalarPlugin._vtable_offset - 1
        self.__dict__['_GetProgID'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetAvailableProperties'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Reset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+4, )
        self.__dict__['_SetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__['_GetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarPlugin.__dict__ and type(IAgCrdnCalcScalarPlugin.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarPlugin.')
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProgID'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDisplayName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableProperties'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__['_Reset']())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetProperty'](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProperty'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1459313C-59BD-42FF-9F0D-AF4604F13D4C}', IAgCrdnCalcScalarPlugin)
agcls.AgTypeNameMap['IAgCrdnCalcScalarPlugin'] = IAgCrdnCalcScalarPlugin
__all__.append('IAgCrdnCalcScalarPlugin')

class IAgCrdnCalcScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    _uuid = '{DC5C0166-111F-4E8A-9650-012CE6A57911}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPoint1'] = _raise_uninitialized_error
        self.__dict__['_SetPoint1'] = _raise_uninitialized_error
        self.__dict__['_GetPoint2'] = _raise_uninitialized_error
        self.__dict__['_SetPoint2'] = _raise_uninitialized_error
        self.__dict__['_GetSurfaceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetSurfaceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarSurfaceDistanceBetweenPoints from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints = agcom.GUID(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._uuid)
        vtable_offset_local = IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._vtable_offset - 1
        self.__dict__['_GetPoint1'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetPoint1'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetPoint2'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetPoint2'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetSurfaceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_SetSurfaceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+6, agcom.BSTR)
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__ and type(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.')
    
    @property
    def Point1(self) -> "IAgCrdnPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint1'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point1.setter
    def Point1(self, point1:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point1, IAgCrdnPoint) as arg_point1:
            agcls.evaluate_hresult(self.__dict__['_SetPoint1'](arg_point1.COM_val))

    @property
    def Point2(self) -> "IAgCrdnPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint2'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point2.setter
    def Point2(self, point2:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point2, IAgCrdnPoint) as arg_point2:
            agcls.evaluate_hresult(self.__dict__['_SetPoint2'](arg_point2.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSurfaceCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__['_SetSurfaceCentralBody'](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{DC5C0166-111F-4E8A-9650-012CE6A57911}', IAgCrdnCalcScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap['IAgCrdnCalcScalarSurfaceDistanceBetweenPoints'] = IAgCrdnCalcScalarSurfaceDistanceBetweenPoints
__all__.append('IAgCrdnCalcScalarSurfaceDistanceBetweenPoints')

class IAgCrdnCalcScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""
    _uuid = '{2adb8ac1-7836-45af-b7f1-77b13a9db586}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputVector'] = _raise_uninitialized_error
        self.__dict__['_SetInputVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetComponent'] = _raise_uninitialized_error
        self.__dict__['_SetComponent'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarVectorComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarVectorComponent from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarVectorComponent = agcom.GUID(IAgCrdnCalcScalarVectorComponent._uuid)
        vtable_offset_local = IAgCrdnCalcScalarVectorComponent._vtable_offset - 1
        self.__dict__['_GetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetComponent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetComponent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorComponent, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarVectorComponent.__dict__ and type(IAgCrdnCalcScalarVectorComponent.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarVectorComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarVectorComponent.')
    
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IAgCrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__['_SetInputVector'](arg_inputVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Axes used to resolve the vector's components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceAxes'](arg_referenceAxes.COM_val))

    @property
    def Component(self) -> "AgECrdnVectorComponentType":
        """The component of the vector to return as the value of the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetComponent'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Component.setter
    def Component(self, component:"AgECrdnVectorComponentType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType, component) as arg_component:
            agcls.evaluate_hresult(self.__dict__['_SetComponent'](arg_component.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2adb8ac1-7836-45af-b7f1-77b13a9db586}', IAgCrdnCalcScalarVectorComponent)
agcls.AgTypeNameMap['IAgCrdnCalcScalarVectorComponent'] = IAgCrdnCalcScalarVectorComponent
__all__.append('IAgCrdnCalcScalarVectorComponent')

class IAgCrdnCalcScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""
    _uuid = '{57FC76A1-A63F-4A25-A3A6-3953275A15E4}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputVector'] = _raise_uninitialized_error
        self.__dict__['_SetInputVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCalcScalarVectorMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCalcScalarVectorMagnitude from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCalcScalarVectorMagnitude = agcom.GUID(IAgCrdnCalcScalarVectorMagnitude._uuid)
        vtable_offset_local = IAgCrdnCalcScalarVectorMagnitude._vtable_offset - 1
        self.__dict__['_GetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorMagnitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCalcScalarVectorMagnitude, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCalcScalarVectorMagnitude.__dict__ and type(IAgCrdnCalcScalarVectorMagnitude.__dict__[attrname]) == property:
            return IAgCrdnCalcScalarVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCalcScalarVectorMagnitude.')
    
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IAgCrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__['_SetInputVector'](arg_inputVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{57FC76A1-A63F-4A25-A3A6-3953275A15E4}', IAgCrdnCalcScalarVectorMagnitude)
agcls.AgTypeNameMap['IAgCrdnCalcScalarVectorMagnitude'] = IAgCrdnCalcScalarVectorMagnitude
__all__.append('IAgCrdnCalcScalarVectorMagnitude')

class IAgCrdnCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    _uuid = '{8CA43B7E-6345-4F97-97B2-A4C4517739C8}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_Evaluate'] = _raise_uninitialized_error
        self.__dict__['_EvaluateWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCondition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCondition = agcom.GUID(IAgCrdnCondition._uuid)
        vtable_offset_local = IAgCrdnCondition._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Evaluate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCondition, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_EvaluateWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCondition, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCondition.__dict__ and type(IAgCrdnCondition.__dict__[attrname]) == property:
            return IAgCrdnCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCondition.')
    
    @property
    def Type(self) -> "AgECrdnConditionType":
        """Returns the type of condition."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnEvaluateResult":
        """Returns result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Evaluate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnEvaluateWithRateResult":
        """Returns result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_EvaluateWithRate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{8CA43B7E-6345-4F97-97B2-A4C4517739C8}', IAgCrdnCondition)
agcls.AgTypeNameMap['IAgCrdnCondition'] = IAgCrdnCondition
__all__.append('IAgCrdnCondition')

class IAgCrdnConditionCombined(object):
    """Defines a condition which combines multiple conditions."""
    _uuid = '{EB19E942-0C28-4AB9-B2C0-D31693564C99}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCombineOperation'] = _raise_uninitialized_error
        self.__dict__['_SetCombineOperation'] = _raise_uninitialized_error
        self.__dict__['_GetConditionCount'] = _raise_uninitialized_error
        self.__dict__['_GetAllConditions'] = _raise_uninitialized_error
        self.__dict__['_SetAllConditions'] = _raise_uninitialized_error
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_RemoveCondition'] = _raise_uninitialized_error
        self.__dict__['_AddCondition'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionCombined from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionCombined = agcom.GUID(IAgCrdnConditionCombined._uuid)
        vtable_offset_local = IAgCrdnConditionCombined._vtable_offset - 1
        self.__dict__['_GetCombineOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetCombineOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetConditionCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__['_GetAllConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetAllConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+7, agcom.PVOID, agcom.INT)
        self.__dict__['_RemoveCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+8, agcom.INT)
        self.__dict__['_AddCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionCombined, vtable_offset_local+9, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionCombined.__dict__ and type(IAgCrdnConditionCombined.__dict__[attrname]) == property:
            return IAgCrdnConditionCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionCombined.')
    
    @property
    def CombineOperation(self) -> "AgECrdnConditionCombinedOperationType":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCombineOperation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnConditionCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__['_SetCombineOperation'](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Gets the number of conditions in the combined condition."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConditionCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all conditions that are being combined."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAllConditions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__['_SetAllConditions'](byref(arg_conditions.COM_val)))

    def GetCondition(self, pos:int) -> "IAgCrdnCondition":
        """Get the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetCondition(self, ref:"IAgCrdnCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        with agmarshall.AgInterface_in_arg(ref, IAgCrdnCondition) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_ref.COM_val, arg_pos.COM_val))

    def RemoveCondition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__['_RemoveCondition'](arg_pos.COM_val))

    def AddCondition(self, ref:"IAgCrdnCondition") -> None:
        """Adds a condition at the end of the list."""
        with agmarshall.AgInterface_in_arg(ref, IAgCrdnCondition) as arg_ref:
            agcls.evaluate_hresult(self.__dict__['_AddCondition'](arg_ref.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EB19E942-0C28-4AB9-B2C0-D31693564C99}', IAgCrdnConditionCombined)
agcls.AgTypeNameMap['IAgCrdnConditionCombined'] = IAgCrdnConditionCombined
__all__.append('IAgCrdnConditionCombined')

class IAgCrdnConditionFactory(object):
    """The factory creates condition components."""
    _uuid = '{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateConditionScalarBounds'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateConditionCombined'] = _raise_uninitialized_error
        self.__dict__['_CreateConditionPointInVolume'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionFactory = agcom.GUID(IAgCrdnConditionFactory._uuid)
        vtable_offset_local = IAgCrdnConditionFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateConditionScalarBounds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateConditionCombined'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateConditionPointInVolume'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionFactory.__dict__ and type(IAgCrdnConditionFactory.__dict__[attrname]) == property:
            return IAgCrdnConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionType") -> "IAgCrdnCondition":
        """Creates and registers a condition using specified name, description and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionScalarBounds(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition placing bounds on specified scalar."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateConditionScalarBounds'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateConditionCombined(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition which combines multiple conditions."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateConditionCombined'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionPointInVolume(self, name:str, description:str) -> "IAgCrdnCondition":
        """Creates a condition for point in volume."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateConditionPointInVolume'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}', IAgCrdnConditionFactory)
agcls.AgTypeNameMap['IAgCrdnConditionFactory'] = IAgCrdnConditionFactory
__all__.append('IAgCrdnConditionFactory')

class IAgCrdnConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    _uuid = '{3C354DF9-E914-4542-9E21-F70A637C4EA4}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPoint'] = _raise_uninitialized_error
        self.__dict__['_SetPoint'] = _raise_uninitialized_error
        self.__dict__['_GetConstraint'] = _raise_uninitialized_error
        self.__dict__['_SetConstraint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionPointInVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionPointInVolume from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionPointInVolume = agcom.GUID(IAgCrdnConditionPointInVolume._uuid)
        vtable_offset_local = IAgCrdnConditionPointInVolume._vtable_offset - 1
        self.__dict__['_GetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionPointInVolume, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionPointInVolume, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionPointInVolume, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionPointInVolume, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionPointInVolume.__dict__ and type(IAgCrdnConditionPointInVolume.__dict__[attrname]) == property:
            return IAgCrdnConditionPointInVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionPointInVolume.')
    
    @property
    def Point(self) -> "IAgCrdnPoint":
        """Get the trajectory point from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__['_SetPoint'](arg_point.COM_val))

    @property
    def Constraint(self) -> "IAgCrdnVolume":
        """Get the volume constraint on trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConstraint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"IAgCrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, IAgCrdnVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__['_SetConstraint'](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{3C354DF9-E914-4542-9E21-F70A637C4EA4}', IAgCrdnConditionPointInVolume)
agcls.AgTypeNameMap['IAgCrdnConditionPointInVolume'] = IAgCrdnConditionPointInVolume
__all__.append('IAgCrdnConditionPointInVolume')

class IAgCrdnConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    _uuid = '{FE3FB52B-9784-4707-8266-28F1E13B79D1}'
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetScalar'] = _raise_uninitialized_error
        self.__dict__['_SetScalar'] = _raise_uninitialized_error
        self.__dict__['_GetOperation'] = _raise_uninitialized_error
        self.__dict__['_SetOperation'] = _raise_uninitialized_error
        self.__dict__['_GetMinimum'] = _raise_uninitialized_error
        self.__dict__['_SetMinimum'] = _raise_uninitialized_error
        self.__dict__['_GetMaximum'] = _raise_uninitialized_error
        self.__dict__['_SetMaximum'] = _raise_uninitialized_error
        self.__dict__['_Set'] = _raise_uninitialized_error
        self.__dict__['_GetMinimumUnitless'] = _raise_uninitialized_error
        self.__dict__['_SetMinimumUnitless'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumUnitless'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumUnitless'] = _raise_uninitialized_error
        self.__dict__['_SetUnitless'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionScalarBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionScalarBounds from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionScalarBounds = agcom.GUID(IAgCrdnConditionScalarBounds._uuid)
        vtable_offset_local = IAgCrdnConditionScalarBounds._vtable_offset - 1
        self.__dict__['_GetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetMinimum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetMinimum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetMaximum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetMaximum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_Set'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
        self.__dict__['_GetMinimumUnitless'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMinimumUnitless'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__['_GetMaximumUnitless'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMaximumUnitless'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__['_SetUnitless'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionScalarBounds, vtable_offset_local+14, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionScalarBounds.__dict__ and type(IAgCrdnConditionScalarBounds.__dict__[attrname]) == property:
            return IAgCrdnConditionScalarBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionScalarBounds.')
    
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """Get the scalar calculation from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, IAgCrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__['_SetScalar'](arg_scalar.COM_val))

    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOperation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__['_SetOperation'](arg_operation.COM_val))

    def GetMinimum(self) -> "IAgQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IAgQuantity") -> None:
        """Set the minimum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IAgQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMinimum'](arg_value.COM_val))

    def GetMaximum(self) -> "IAgQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IAgQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IAgQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMaximum'](arg_value.COM_val))

    def Set(self, min:"IAgQuantity", max:"IAgQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IAgQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IAgQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__['_Set'](arg_min.COM_val, arg_max.COM_val))

    def GetMinimumUnitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimumUnitless'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMinimumUnitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMinimumUnitless'](arg_value.COM_val))

    def GetMaximumUnitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumUnitless'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMaximumUnitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumUnitless'](arg_value.COM_val))

    def SetUnitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__['_SetUnitless'](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{FE3FB52B-9784-4707-8266-28F1E13B79D1}', IAgCrdnConditionScalarBounds)
agcls.AgTypeNameMap['IAgCrdnConditionScalarBounds'] = IAgCrdnConditionScalarBounds
__all__.append('IAgCrdnConditionScalarBounds')

class IAgCrdnConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    _uuid = '{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_Evaluate'] = _raise_uninitialized_error
        self.__dict__['_EvaluateWithRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSet from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSet = agcom.GUID(IAgCrdnConditionSet._uuid)
        vtable_offset_local = IAgCrdnConditionSet._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Evaluate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSet, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_EvaluateWithRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSet, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSet.__dict__ and type(IAgCrdnConditionSet.__dict__[attrname]) == property:
            return IAgCrdnConditionSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSet.')
    
    @property
    def Type(self) -> "AgECrdnConditionSetType":
        """Returns the type of condition set."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "IAgCrdnConditionSetEvaluateResult":
        """Returns an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Evaluate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "IAgCrdnConditionSetEvaluateWithRateResult":
        """Returns an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_EvaluateWithRate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}', IAgCrdnConditionSet)
agcls.AgTypeNameMap['IAgCrdnConditionSet'] = IAgCrdnConditionSet
__all__.append('IAgCrdnConditionSet')

class IAgCrdnConditionSetFactory(object):
    """The factory creates condition set components."""
    _uuid = '{698D592C-B264-426D-8577-AC7087E3EE44}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateScalarThresholds'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSetFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSetFactory = agcom.GUID(IAgCrdnConditionSetFactory._uuid)
        vtable_offset_local = IAgCrdnConditionSetFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateScalarThresholds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetFactory.__dict__ and type(IAgCrdnConditionSetFactory.__dict__[attrname]) == property:
            return IAgCrdnConditionSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSetFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionSetType") -> "IAgCrdnConditionSet":
        """Creates and registers a condition set using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateScalarThresholds(self, name:str, description:str) -> "IAgCrdnConditionSet":
        """Create a scalar thresholds condition set."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateScalarThresholds'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{698D592C-B264-426D-8577-AC7087E3EE44}', IAgCrdnConditionSetFactory)
agcls.AgTypeNameMap['IAgCrdnConditionSetFactory'] = IAgCrdnConditionSetFactory
__all__.append('IAgCrdnConditionSetFactory')

class IAgCrdnConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    _uuid = '{57392078-7821-4910-B734-76B5C70CB6D9}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetScalar'] = _raise_uninitialized_error
        self.__dict__['_SetScalar'] = _raise_uninitialized_error
        self.__dict__['_GetThresholds'] = _raise_uninitialized_error
        self.__dict__['_GetThresholdLabels'] = _raise_uninitialized_error
        self.__dict__['_GetIncludeAboveHighestThreshold'] = _raise_uninitialized_error
        self.__dict__['_SetIncludeAboveHighestThreshold'] = _raise_uninitialized_error
        self.__dict__['_GetIncludeBelowLowestThreshold'] = _raise_uninitialized_error
        self.__dict__['_SetIncludeBelowLowestThreshold'] = _raise_uninitialized_error
        self.__dict__['_SetThresholdsAndLabels'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConditionSetScalarThresholds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConditionSetScalarThresholds from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConditionSetScalarThresholds = agcom.GUID(IAgCrdnConditionSetScalarThresholds._uuid)
        vtable_offset_local = IAgCrdnConditionSetScalarThresholds._vtable_offset - 1
        self.__dict__['_GetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetThresholds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetThresholdLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetIncludeAboveHighestThreshold'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIncludeAboveHighestThreshold'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetIncludeBelowLowestThreshold'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIncludeBelowLowestThreshold'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_SetThresholdsAndLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConditionSetScalarThresholds, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConditionSetScalarThresholds.__dict__ and type(IAgCrdnConditionSetScalarThresholds.__dict__[attrname]) == property:
            return IAgCrdnConditionSetScalarThresholds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConditionSetScalarThresholds.')
    
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, IAgCrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__['_SetScalar'](arg_scalar.COM_val))

    @property
    def Thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetThresholds'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ThresholdLabels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetThresholdLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IncludeAboveHighestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncludeAboveHighestThreshold'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeAboveHighestThreshold.setter
    def IncludeAboveHighestThreshold(self, includeAboveHighestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeAboveHighestThreshold) as arg_includeAboveHighestThreshold:
            agcls.evaluate_hresult(self.__dict__['_SetIncludeAboveHighestThreshold'](arg_includeAboveHighestThreshold.COM_val))

    @property
    def IncludeBelowLowestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncludeBelowLowestThreshold'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeBelowLowestThreshold.setter
    def IncludeBelowLowestThreshold(self, includeBelowLowestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeBelowLowestThreshold) as arg_includeBelowLowestThreshold:
            agcls.evaluate_hresult(self.__dict__['_SetIncludeBelowLowestThreshold'](arg_includeBelowLowestThreshold.COM_val))

    def SetThresholdsAndLabels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        with agmarshall.SAFEARRAY_arg(thresholds) as arg_thresholds, \
             agmarshall.SAFEARRAY_arg(thresholdLabels) as arg_thresholdLabels:
            agcls.evaluate_hresult(self.__dict__['_SetThresholdsAndLabels'](byref(arg_thresholds.COM_val), byref(arg_thresholdLabels.COM_val)))


agcls.AgClassCatalog.add_catalog_entry('{57392078-7821-4910-B734-76B5C70CB6D9}', IAgCrdnConditionSetScalarThresholds)
agcls.AgTypeNameMap['IAgCrdnConditionSetScalarThresholds'] = IAgCrdnConditionSetScalarThresholds
__all__.append('IAgCrdnConditionSetScalarThresholds')

class IAgCrdnConverge(object):
    """Represents a base class for convergence definitions."""
    _uuid = '{28B17124-9BE6-4437-A7ED-0DDC24353430}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConverge._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConverge from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConverge = agcom.GUID(IAgCrdnConverge._uuid)
        vtable_offset_local = IAgCrdnConverge._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConverge.__dict__ and type(IAgCrdnConverge.__dict__[attrname]) == property:
            return IAgCrdnConverge.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConverge.')
    

agcls.AgClassCatalog.add_catalog_entry('{28B17124-9BE6-4437-A7ED-0DDC24353430}', IAgCrdnConverge)
agcls.AgTypeNameMap['IAgCrdnConverge'] = IAgCrdnConverge
__all__.append('IAgCrdnConverge')

class IAgCrdnConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    _uuid = '{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSense'] = _raise_uninitialized_error
        self.__dict__['_SetSense'] = _raise_uninitialized_error
        self.__dict__['_GetTimeTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetTimeTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetAbsoluteTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetAbsoluteTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeTolerance'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnConvergeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnConvergeBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnConvergeBasic = agcom.GUID(IAgCrdnConvergeBasic._uuid)
        vtable_offset_local = IAgCrdnConvergeBasic._vtable_offset - 1
        self.__dict__['_GetSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetTimeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnConvergeBasic, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnConvergeBasic.__dict__ and type(IAgCrdnConvergeBasic.__dict__[attrname]) == property:
            return IAgCrdnConvergeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnConvergeBasic.')
    
    @property
    def Sense(self) -> "AgECrdnThreshConvergeSense":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Sense.setter
    def Sense(self, sense:"AgECrdnThreshConvergeSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense, sense) as arg_sense:
            agcls.evaluate_hresult(self.__dict__['_SetSense'](arg_sense.COM_val))

    @property
    def TimeTolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeTolerance.setter
    def TimeTolerance(self, timeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(timeTolerance) as arg_timeTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetTimeTolerance'](arg_timeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAbsoluteTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetAbsoluteTolerance'](arg_absoluteTolerance.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeTolerance'](arg_relativeTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}', IAgCrdnConvergeBasic)
agcls.AgTypeNameMap['IAgCrdnConvergeBasic'] = IAgCrdnConvergeBasic
__all__.append('IAgCrdnConvergeBasic')

class IAgCrdnDerivative(object):
    """Represents a base class for derivative definitions."""
    _uuid = '{737042BD-D873-4CF6-B5D5-6769849156FD}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnDerivative from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnDerivative = agcom.GUID(IAgCrdnDerivative._uuid)
        vtable_offset_local = IAgCrdnDerivative._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnDerivative.__dict__ and type(IAgCrdnDerivative.__dict__[attrname]) == property:
            return IAgCrdnDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnDerivative.')
    

agcls.AgClassCatalog.add_catalog_entry('{737042BD-D873-4CF6-B5D5-6769849156FD}', IAgCrdnDerivative)
agcls.AgTypeNameMap['IAgCrdnDerivative'] = IAgCrdnDerivative
__all__.append('IAgCrdnDerivative')

class IAgCrdnDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    _uuid = '{CD450BBA-9F54-4F15-B067-C5A80C970FA9}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnDerivativeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnDerivativeBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnDerivativeBasic = agcom.GUID(IAgCrdnDerivativeBasic._uuid)
        vtable_offset_local = IAgCrdnDerivativeBasic._vtable_offset - 1
        self.__dict__['_GetTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnDerivativeBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnDerivativeBasic, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnDerivativeBasic.__dict__ and type(IAgCrdnDerivativeBasic.__dict__[attrname]) == property:
            return IAgCrdnDerivativeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnDerivativeBasic.')
    
    @property
    def TimeStep(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__['_SetTimeStep'](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CD450BBA-9F54-4F15-B067-C5A80C970FA9}', IAgCrdnDerivativeBasic)
agcls.AgTypeNameMap['IAgCrdnDerivativeBasic'] = IAgCrdnDerivativeBasic
__all__.append('IAgCrdnDerivativeBasic')

class IAgCrdnEvent(object):
    """Defines an event (time instant)."""
    _uuid = '{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_GetToday'] = _raise_uninitialized_error
        self.__dict__['_GetTomorrow'] = _raise_uninitialized_error
        self.__dict__['_GetNoonToday'] = _raise_uninitialized_error
        self.__dict__['_GetNoonTomorrow'] = _raise_uninitialized_error
        self.__dict__['_FindOccurrence'] = _raise_uninitialized_error
        self.__dict__['_OccursBefore'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEvent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEvent from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEvent = agcom.GUID(IAgCrdnEvent._uuid)
        vtable_offset_local = IAgCrdnEvent._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetToday'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetTomorrow'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetNoonToday'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetNoonTomorrow'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_FindOccurrence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_OccursBefore'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEvent, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEvent.__dict__ and type(IAgCrdnEvent.__dict__[attrname]) == property:
            return IAgCrdnEvent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEvent.')
    
    @property
    def Type(self) -> "AgECrdnEventType":
        """Return the type of time instant."""
        with agmarshall.AgEnum_arg(AgECrdnEventType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Today(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToday'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTomorrow'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonToday(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to today's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNoonToday'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonTomorrow(self) -> "IAgCrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNoonTomorrow'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindOccurrence(self) -> "IAgCrdnEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindOccurrence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def OccursBefore(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_OccursBefore'](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}', IAgCrdnEvent)
agcls.AgTypeNameMap['IAgCrdnEvent'] = IAgCrdnEvent
__all__.append('IAgCrdnEvent')

class IAgCrdnEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""
    _uuid = '{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_FindTimes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArray from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArray = agcom.GUID(IAgCrdnEventArray._uuid)
        vtable_offset_local = IAgCrdnEventArray._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArray, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_FindTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArray, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArray.__dict__ and type(IAgCrdnEventArray.__dict__[attrname]) == property:
            return IAgCrdnEventArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArray.')
    
    @property
    def Type(self) -> "AgECrdnEventArrayType":
        """Return the type of time array."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindTimes(self) -> "IAgCrdnFindTimesResult":
        """Return computed array of times."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindTimes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}', IAgCrdnEventArray)
agcls.AgTypeNameMap['IAgCrdnEventArray'] = IAgCrdnEventArray
__all__.append('IAgCrdnEventArray')

class IAgCrdnEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    _uuid = '{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}'
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSatisfactionCrossing'] = _raise_uninitialized_error
        self.__dict__['_SetSatisfactionCrossing'] = _raise_uninitialized_error
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayConditionCrossings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayConditionCrossings from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayConditionCrossings = agcom.GUID(IAgCrdnEventArrayConditionCrossings._uuid)
        vtable_offset_local = IAgCrdnEventArrayConditionCrossings._vtable_offset - 1
        self.__dict__['_GetSatisfactionCrossing'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetSatisfactionCrossing'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+10, agcom.LONG)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+12, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayConditionCrossings, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayConditionCrossings.__dict__ and type(IAgCrdnEventArrayConditionCrossings.__dict__[attrname]) == property:
            return IAgCrdnEventArrayConditionCrossings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayConditionCrossings.')
    
    @property
    def SatisfactionCrossing(self) -> "AgECrdnSatisfactionCrossing":
        """The direction of interest for satisfaction crossing."""
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSatisfactionCrossing'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionCrossing.setter
    def SatisfactionCrossing(self, satisfactionCrossing:"AgECrdnSatisfactionCrossing") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing, satisfactionCrossing) as arg_satisfactionCrossing:
            agcls.evaluate_hresult(self.__dict__['_SetSatisfactionCrossing'](arg_satisfactionCrossing.COM_val))

    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, IAgCrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}', IAgCrdnEventArrayConditionCrossings)
agcls.AgTypeNameMap['IAgCrdnEventArrayConditionCrossings'] = IAgCrdnEventArrayConditionCrossings
__all__.append('IAgCrdnEventArrayConditionCrossings')

class IAgCrdnEventArrayExtrema(object):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = '{664C3048-BB87-4841-988A-0580F2976C0D}'
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetExtremumType'] = _raise_uninitialized_error
        self.__dict__['_SetExtremumType'] = _raise_uninitialized_error
        self.__dict__['_GetIsGlobal'] = _raise_uninitialized_error
        self.__dict__['_SetIsGlobal'] = _raise_uninitialized_error
        self.__dict__['_GetCalculation'] = _raise_uninitialized_error
        self.__dict__['_SetCalculation'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayExtrema._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayExtrema from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayExtrema = agcom.GUID(IAgCrdnEventArrayExtrema._uuid)
        vtable_offset_local = IAgCrdnEventArrayExtrema._vtable_offset - 1
        self.__dict__['_GetExtremumType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetExtremumType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetIsGlobal'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIsGlobal'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetCalculation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetCalculation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+12, agcom.LONG)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+14, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayExtrema, vtable_offset_local+16, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayExtrema.__dict__ and type(IAgCrdnEventArrayExtrema.__dict__[attrname]) == property:
            return IAgCrdnEventArrayExtrema.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayExtrema.')
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetExtremumType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__['_SetExtremumType'](arg_extremumType.COM_val))

    @property
    def IsGlobal(self) -> bool:
        """Indicates whether to perform local or global search. The default is false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsGlobal'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsGlobal.setter
    def IsGlobal(self, isGlobal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isGlobal) as arg_isGlobal:
            agcls.evaluate_hresult(self.__dict__['_SetIsGlobal'](arg_isGlobal.COM_val))

    @property
    def Calculation(self) -> "IAgCrdnCalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCalculation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, IAgCrdnCalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__['_SetCalculation'](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{664C3048-BB87-4841-988A-0580F2976C0D}', IAgCrdnEventArrayExtrema)
agcls.AgTypeNameMap['IAgCrdnEventArrayExtrema'] = IAgCrdnEventArrayExtrema
__all__.append('IAgCrdnEventArrayExtrema')

class IAgCrdnEventArrayFactory(object):
    """The factory creates event arrays."""
    _uuid = '{CE43C07E-4626-4CEA-A625-C42052111CDE}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayExtrema'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayStartStopTimes'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayMerged'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayFiltered'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayFixedStep'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayConditionCrossings'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArraySignaled'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateEventArrayFixedTimes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayFactory = agcom.GUID(IAgCrdnEventArrayFactory._uuid)
        vtable_offset_local = IAgCrdnEventArrayFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayExtrema'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayStartStopTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayMerged'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayFiltered'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayFixedStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArrayConditionCrossings'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventArraySignaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateEventArrayFixedTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFactory.__dict__ and type(IAgCrdnEventArrayFactory.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnEventArrayType") -> "IAgCrdnEventArray":
        """Create and register an event array using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventArrayType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayExtrema(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayExtrema'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayStartStopTimes(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayStartStopTimes'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayMerged(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayMerged'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFiltered(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayFiltered'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFixedStep(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayFixedStep'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayConditionCrossings(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayConditionCrossings'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArraySignaled(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArraySignaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventArrayType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventArrayFixedTimes(self, name:str, description:str) -> "IAgCrdnEventArray":
        """Create an event array using specfied times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventArrayFixedTimes'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{CE43C07E-4626-4CEA-A625-C42052111CDE}', IAgCrdnEventArrayFactory)
agcls.AgTypeNameMap['IAgCrdnEventArrayFactory'] = IAgCrdnEventArrayFactory
__all__.append('IAgCrdnEventArrayFactory')

class IAgCrdnEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""
    _uuid = '{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalTimeArray'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalTimeArray'] = _raise_uninitialized_error
        self.__dict__['_GetFilterType'] = _raise_uninitialized_error
        self.__dict__['_SetFilterType'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_SetCount'] = _raise_uninitialized_error
        self.__dict__['_GetStep'] = _raise_uninitialized_error
        self.__dict__['_SetStep'] = _raise_uninitialized_error
        self.__dict__['_GetIncludeIntervalStopTimes'] = _raise_uninitialized_error
        self.__dict__['_SetIncludeIntervalStopTimes'] = _raise_uninitialized_error
        self.__dict__['_GetFilterIntervalList'] = _raise_uninitialized_error
        self.__dict__['_SetFilterIntervalList'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayFiltered from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayFiltered = agcom.GUID(IAgCrdnEventArrayFiltered._uuid)
        vtable_offset_local = IAgCrdnEventArrayFiltered._vtable_offset - 1
        self.__dict__['_GetOriginalTimeArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalTimeArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetFilterType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetFilterType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__['_SetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+6, agcom.INT)
        self.__dict__['_GetStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetIncludeIntervalStopTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIncludeIntervalStopTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__['_GetFilterIntervalList'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetFilterIntervalList'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFiltered, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFiltered.__dict__ and type(IAgCrdnEventArrayFiltered.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayFiltered.')
    
    @property
    def OriginalTimeArray(self) -> "IAgCrdnEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalTimeArray'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IAgCrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, IAgCrdnEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalTimeArray'](arg_originalTimeArray.COM_val))

    @property
    def FilterType(self) -> "AgECrdnEventArrayFilterType":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilterType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FilterType.setter
    def FilterType(self, filterType:"AgECrdnEventArrayFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType, filterType) as arg_filterType:
            agcls.evaluate_hresult(self.__dict__['_SetFilterType'](arg_filterType.COM_val))

    @property
    def Count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Count.setter
    def Count(self, count:int) -> None:
        with agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__['_SetCount'](arg_count.COM_val))

    @property
    def Step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__['_SetStep'](arg_step.COM_val))

    @property
    def IncludeIntervalStopTimes(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncludeIntervalStopTimes'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalStopTimes.setter
    def IncludeIntervalStopTimes(self, includeIntervalStopTimes:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalStopTimes) as arg_includeIntervalStopTimes:
            agcls.evaluate_hresult(self.__dict__['_SetIncludeIntervalStopTimes'](arg_includeIntervalStopTimes.COM_val))

    @property
    def FilterIntervalList(self) -> "IAgCrdnEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilterIntervalList'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @FilterIntervalList.setter
    def FilterIntervalList(self, filterIntervalList:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(filterIntervalList, IAgCrdnEventIntervalList) as arg_filterIntervalList:
            agcls.evaluate_hresult(self.__dict__['_SetFilterIntervalList'](arg_filterIntervalList.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}', IAgCrdnEventArrayFiltered)
agcls.AgTypeNameMap['IAgCrdnEventArrayFiltered'] = IAgCrdnEventArrayFiltered
__all__.append('IAgCrdnEventArrayFiltered')

class IAgCrdnEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    _uuid = '{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetBoundingIntervalList'] = _raise_uninitialized_error
        self.__dict__['_SetBoundingIntervalList'] = _raise_uninitialized_error
        self.__dict__['_GetSamplingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetSamplingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetIncludeIntervalEdges'] = _raise_uninitialized_error
        self.__dict__['_SetIncludeIntervalEdges'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceType'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceType'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayFixedStep from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayFixedStep = agcom.GUID(IAgCrdnEventArrayFixedStep._uuid)
        vtable_offset_local = IAgCrdnEventArrayFixedStep._vtable_offset - 1
        self.__dict__['_GetBoundingIntervalList'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetBoundingIntervalList'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSamplingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetSamplingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetIncludeIntervalEdges'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIncludeIntervalEdges'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetReferenceType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetReferenceType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedStep, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFixedStep.__dict__ and type(IAgCrdnEventArrayFixedStep.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayFixedStep.')
    
    @property
    def BoundingIntervalList(self) -> "IAgCrdnEventIntervalList":
        """The bounding interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBoundingIntervalList'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BoundingIntervalList.setter
    def BoundingIntervalList(self, boundingIntervalList:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(boundingIntervalList, IAgCrdnEventIntervalList) as arg_boundingIntervalList:
            agcls.evaluate_hresult(self.__dict__['_SetBoundingIntervalList'](arg_boundingIntervalList.COM_val))

    @property
    def SamplingTimeStep(self) -> float:
        """The sampling time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSamplingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SamplingTimeStep.setter
    def SamplingTimeStep(self, samplingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(samplingTimeStep) as arg_samplingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetSamplingTimeStep'](arg_samplingTimeStep.COM_val))

    @property
    def IncludeIntervalEdges(self) -> bool:
        """Specify whether to include interval edges."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncludeIntervalEdges'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalEdges.setter
    def IncludeIntervalEdges(self, includeIntervalEdges:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalEdges) as arg_includeIntervalEdges:
            agcls.evaluate_hresult(self.__dict__['_SetIncludeIntervalEdges'](arg_includeIntervalEdges.COM_val))

    @property
    def ReferenceType(self) -> "AgECrdnSampledReferenceTime":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, referenceType:"AgECrdnSampledReferenceTime") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime, referenceType) as arg_referenceType:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceType'](arg_referenceType.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}', IAgCrdnEventArrayFixedStep)
agcls.AgTypeNameMap['IAgCrdnEventArrayFixedStep'] = IAgCrdnEventArrayFixedStep
__all__.append('IAgCrdnEventArrayFixedStep')

class IAgCrdnEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""
    _uuid = '{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetArrayTimes'] = _raise_uninitialized_error
        self.__dict__['_SetArrayTimes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayFixedTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayFixedTimes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayFixedTimes = agcom.GUID(IAgCrdnEventArrayFixedTimes._uuid)
        vtable_offset_local = IAgCrdnEventArrayFixedTimes._vtable_offset - 1
        self.__dict__['_GetArrayTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedTimes, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetArrayTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayFixedTimes, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayFixedTimes.__dict__ and type(IAgCrdnEventArrayFixedTimes.__dict__[attrname]) == property:
            return IAgCrdnEventArrayFixedTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayFixedTimes.')
    
    @property
    def ArrayTimes(self) -> list:
        """The array of times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetArrayTimes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetArrayTimes(self, times:list) -> None:
        """Sets array of times."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times:
            agcls.evaluate_hresult(self.__dict__['_SetArrayTimes'](byref(arg_times.COM_val)))


agcls.AgClassCatalog.add_catalog_entry('{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}', IAgCrdnEventArrayFixedTimes)
agcls.AgTypeNameMap['IAgCrdnEventArrayFixedTimes'] = IAgCrdnEventArrayFixedTimes
__all__.append('IAgCrdnEventArrayFixedTimes')

class IAgCrdnEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    _uuid = '{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimeArrayA'] = _raise_uninitialized_error
        self.__dict__['_SetTimeArrayA'] = _raise_uninitialized_error
        self.__dict__['_GetTimeArrayB'] = _raise_uninitialized_error
        self.__dict__['_SetTimeArrayB'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayMerged from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayMerged = agcom.GUID(IAgCrdnEventArrayMerged._uuid)
        vtable_offset_local = IAgCrdnEventArrayMerged._vtable_offset - 1
        self.__dict__['_GetTimeArrayA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetTimeArrayA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayMerged, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetTimeArrayB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayMerged, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetTimeArrayB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayMerged, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayMerged.__dict__ and type(IAgCrdnEventArrayMerged.__dict__[attrname]) == property:
            return IAgCrdnEventArrayMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayMerged.')
    
    @property
    def TimeArrayA(self) -> "IAgCrdnEventArray":
        """The first time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeArrayA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayA.setter
    def TimeArrayA(self, timeArrayA:"IAgCrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayA, IAgCrdnEventArray) as arg_timeArrayA:
            agcls.evaluate_hresult(self.__dict__['_SetTimeArrayA'](arg_timeArrayA.COM_val))

    @property
    def TimeArrayB(self) -> "IAgCrdnEventArray":
        """The second time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeArrayB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayB.setter
    def TimeArrayB(self, timeArrayB:"IAgCrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayB, IAgCrdnEventArray) as arg_timeArrayB:
            agcls.evaluate_hresult(self.__dict__['_SetTimeArrayB'](arg_timeArrayB.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}', IAgCrdnEventArrayMerged)
agcls.AgTypeNameMap['IAgCrdnEventArrayMerged'] = IAgCrdnEventArrayMerged
__all__.append('IAgCrdnEventArrayMerged')

class IAgCrdnEventArraySignaled(object):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    _uuid = '{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalTimeArray'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalTimeArray'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetSignalDelay'] = _raise_uninitialized_error
        self.__dict__['_SetSignalDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArraySignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArraySignaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArraySignaled = agcom.GUID(IAgCrdnEventArraySignaled._uuid)
        vtable_offset_local = IAgCrdnEventArraySignaled._vtable_offset - 1
        self.__dict__['_GetOriginalTimeArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalTimeArray'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArraySignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArraySignaled.__dict__ and type(IAgCrdnEventArraySignaled.__dict__[attrname]) == property:
            return IAgCrdnEventArraySignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArraySignaled.')
    
    @property
    def OriginalTimeArray(self) -> "IAgCrdnEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalTimeArray'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"IAgCrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, IAgCrdnEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalTimeArray'](arg_originalTimeArray.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBaseClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IAgCrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetBaseClockLocation'](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IAgCrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetTargetClockLocation'](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAgCrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__['_SetSignalDelay'](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}', IAgCrdnEventArraySignaled)
agcls.AgTypeNameMap['IAgCrdnEventArraySignaled'] = IAgCrdnEventArraySignaled
__all__.append('IAgCrdnEventArraySignaled')

class IAgCrdnEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    _uuid = '{1AB79442-7711-4342-B944-81C51D14FBE4}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetStartStopOption'] = _raise_uninitialized_error
        self.__dict__['_SetStartStopOption'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventArrayStartStopTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventArrayStartStopTimes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventArrayStartStopTimes = agcom.GUID(IAgCrdnEventArrayStartStopTimes._uuid)
        vtable_offset_local = IAgCrdnEventArrayStartStopTimes._vtable_offset - 1
        self.__dict__['_GetStartStopOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayStartStopTimes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetStartStopOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayStartStopTimes, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayStartStopTimes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventArrayStartStopTimes, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventArrayStartStopTimes.__dict__ and type(IAgCrdnEventArrayStartStopTimes.__dict__[attrname]) == property:
            return IAgCrdnEventArrayStartStopTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventArrayStartStopTimes.')
    
    @property
    def StartStopOption(self) -> "AgECrdnStartStopOption":
        """The edge type. At least one of the two edge types must be selected."""
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartStopOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartStopOption.setter
    def StartStopOption(self, startStopOption:"AgECrdnStartStopOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption, startStopOption) as arg_startStopOption:
            agcls.evaluate_hresult(self.__dict__['_SetStartStopOption'](arg_startStopOption.COM_val))

    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IAgCrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceIntervals'](arg_referenceIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{1AB79442-7711-4342-B944-81C51D14FBE4}', IAgCrdnEventArrayStartStopTimes)
agcls.AgTypeNameMap['IAgCrdnEventArrayStartStopTimes'] = IAgCrdnEventArrayStartStopTimes
__all__.append('IAgCrdnEventArrayStartStopTimes')

class IAgCrdnEventEpoch(object):
    """Event set at specified date/time."""
    _uuid = '{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetEpoch'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventEpoch from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventEpoch = agcom.GUID(IAgCrdnEventEpoch._uuid)
        vtable_offset_local = IAgCrdnEventEpoch._vtable_offset - 1
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_SetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventEpoch, vtable_offset_local+2, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventEpoch.__dict__ and type(IAgCrdnEventEpoch.__dict__[attrname]) == property:
            return IAgCrdnEventEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventEpoch.')
    
    @property
    def Epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__['_SetEpoch'](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}', IAgCrdnEventEpoch)
agcls.AgTypeNameMap['IAgCrdnEventEpoch'] = IAgCrdnEventEpoch
__all__.append('IAgCrdnEventEpoch')

class IAgCrdnEventExtremum(object):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = '{C588FDD4-2008-4C33-AA63-1C59565AE4F3}'
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetExtremumType'] = _raise_uninitialized_error
        self.__dict__['_SetExtremumType'] = _raise_uninitialized_error
        self.__dict__['_GetCalculation'] = _raise_uninitialized_error
        self.__dict__['_SetCalculation'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventExtremum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventExtremum from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventExtremum = agcom.GUID(IAgCrdnEventExtremum._uuid)
        vtable_offset_local = IAgCrdnEventExtremum._vtable_offset - 1
        self.__dict__['_GetExtremumType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetExtremumType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetCalculation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetCalculation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+10, agcom.LONG)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+12, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventExtremum, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventExtremum.__dict__ and type(IAgCrdnEventExtremum.__dict__[attrname]) == property:
            return IAgCrdnEventExtremum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventExtremum.')
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetExtremumType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__['_SetExtremumType'](arg_extremumType.COM_val))

    @property
    def Calculation(self) -> "IAgCrdnCalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCalculation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, IAgCrdnCalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__['_SetCalculation'](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{C588FDD4-2008-4C33-AA63-1C59565AE4F3}', IAgCrdnEventExtremum)
agcls.AgTypeNameMap['IAgCrdnEventExtremum'] = IAgCrdnEventExtremum
__all__.append('IAgCrdnEventExtremum')

class IAgCrdnEventFactory(object):
    """The factory creates events."""
    _uuid = '{803DD343-F271-47D9-8D71-2092DD2A3387}'
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetToday'] = _raise_uninitialized_error
        self.__dict__['_GetTomorrow'] = _raise_uninitialized_error
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateEventEpoch'] = _raise_uninitialized_error
        self.__dict__['_CreateEventExtremum'] = _raise_uninitialized_error
        self.__dict__['_CreateEventStartStopTime'] = _raise_uninitialized_error
        self.__dict__['_CreateEventSignaled'] = _raise_uninitialized_error
        self.__dict__['_CreateEventTimeOffset'] = _raise_uninitialized_error
        self.__dict__['_CreateSmartEpochFromTime'] = _raise_uninitialized_error
        self.__dict__['_CreateSmartEpochFromEvent'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventFactory = agcom.GUID(IAgCrdnEventFactory._uuid)
        vtable_offset_local = IAgCrdnEventFactory._vtable_offset - 1
        self.__dict__['_GetToday'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetTomorrow'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventExtremum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventStartStopTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventSignaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateSmartEpochFromTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+9, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_CreateSmartEpochFromEvent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventFactory, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventFactory.__dict__ and type(IAgCrdnEventFactory.__dict__[attrname]) == property:
            return IAgCrdnEventFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventFactory.')
    
    @property
    def Today(self) -> "IAgCrdnEvent":
        """Returns Today time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToday'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "IAgCrdnEvent":
        """Returns Tomorrow time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTomorrow'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnEventType") -> "IAgCrdnEvent":
        """Creates and registers an event using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventEpoch(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event set at a specified date/time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventEpoch'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventExtremum(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event that determines the time of global minimum or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventExtremum'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventStartStopTime(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event that is either the start or stop time selected from a reference interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventStartStopTime'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventSignaled(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventSignaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventTimeOffset(self, name:str, description:str) -> "IAgCrdnEvent":
        """Creates an event at fixed offset from specified reference event."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventTimeOffset'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromTime(self, epoch:typing.Any) -> "IAgCrdnEventSmartEpoch":
        """Creates a smart epoch from STK epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateSmartEpochFromTime'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromEvent(self, refEvent:"IAgCrdnEvent") -> "IAgCrdnEventSmartEpoch":
        """Creates a smart epoch from an event."""
        with agmarshall.AgInterface_in_arg(refEvent, IAgCrdnEvent) as arg_refEvent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateSmartEpochFromEvent'](arg_refEvent.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{803DD343-F271-47D9-8D71-2092DD2A3387}', IAgCrdnEventFactory)
agcls.AgTypeNameMap['IAgCrdnEventFactory'] = IAgCrdnEventFactory
__all__.append('IAgCrdnEventFactory')

class IAgCrdnEventInterval(object):
    """A single time interval."""
    _uuid = '{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_GetLabelStartDescription'] = _raise_uninitialized_error
        self.__dict__['_GetLabelStopDescription'] = _raise_uninitialized_error
        self.__dict__['_GetLabelStart'] = _raise_uninitialized_error
        self.__dict__['_GetLabelStop'] = _raise_uninitialized_error
        self.__dict__['_FindInterval'] = _raise_uninitialized_error
        self.__dict__['_Occurred'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventInterval from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventInterval = agcom.GUID(IAgCrdnEventInterval._uuid)
        vtable_offset_local = IAgCrdnEventInterval._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetLabelStartDescription'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetLabelStopDescription'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_GetLabelStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__['_GetLabelStop'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_FindInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_Occurred'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventInterval, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventInterval.__dict__ and type(IAgCrdnEventInterval.__dict__[attrname]) == property:
            return IAgCrdnEventInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventInterval.')
    
    @property
    def Type(self) -> "AgECrdnEventIntervalType":
        """Return the type of interval."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStartDescription(self) -> str:
        """The start description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelStartDescription'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStopDescription(self) -> str:
        """The stop description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelStopDescription'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStart(self) -> str:
        """A label associated with the interval start."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStop(self) -> str:
        """A label associated with the interval stop."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelStop'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInterval(self) -> "IAgCrdnEventIntervalResult":
        """Return computed interval if it exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Occurred'](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}', IAgCrdnEventInterval)
agcls.AgTypeNameMap['IAgCrdnEventInterval'] = IAgCrdnEventInterval
__all__.append('IAgCrdnEventInterval')

class IAgCrdnEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    _uuid = '{18236EC1-B691-4FFD-995B-FB4896BAFD71}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetStartTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetStartTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetStopTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetStopTimeInstant'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalBetweenTimeInstants._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalBetweenTimeInstants from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalBetweenTimeInstants = agcom.GUID(IAgCrdnEventIntervalBetweenTimeInstants._uuid)
        vtable_offset_local = IAgCrdnEventIntervalBetweenTimeInstants._vtable_offset - 1
        self.__dict__['_GetStartTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalBetweenTimeInstants, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetStartTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalBetweenTimeInstants, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetStopTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalBetweenTimeInstants, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetStopTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalBetweenTimeInstants, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalBetweenTimeInstants.__dict__ and type(IAgCrdnEventIntervalBetweenTimeInstants.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalBetweenTimeInstants.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalBetweenTimeInstants.')
    
    @property
    def StartTimeInstant(self) -> "IAgCrdnEvent":
        """The start time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StartTimeInstant.setter
    def StartTimeInstant(self, startTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(startTimeInstant, IAgCrdnEvent) as arg_startTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetStartTimeInstant'](arg_startTimeInstant.COM_val))

    @property
    def StopTimeInstant(self) -> "IAgCrdnEvent":
        """The stop time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StopTimeInstant.setter
    def StopTimeInstant(self, stopTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(stopTimeInstant, IAgCrdnEvent) as arg_stopTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetStopTimeInstant'](arg_stopTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{18236EC1-B691-4FFD-995B-FB4896BAFD71}', IAgCrdnEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap['IAgCrdnEventIntervalBetweenTimeInstants'] = IAgCrdnEventIntervalBetweenTimeInstants
__all__.append('IAgCrdnEventIntervalBetweenTimeInstants')

class IAgCrdnEventIntervalCollection(object):
    """A collection of related interval lists."""
    _uuid = '{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_GetLabels'] = _raise_uninitialized_error
        self.__dict__['_FindIntervalCollection'] = _raise_uninitialized_error
        self.__dict__['_Occurred'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollection = agcom.GUID(IAgCrdnEventIntervalCollection._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollection._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollection, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_FindIntervalCollection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_Occurred'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollection, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollection.__dict__ and type(IAgCrdnEventIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollection.')
    
    @property
    def Type(self) -> "AgECrdnEventIntervalCollectionType":
        """Return the type of collection of interval lists."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervalCollection(self) -> "IAgCrdnIntervalsVectorResult":
        """Return computed collection of interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindIntervalCollection'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> "IAgCrdnEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Occurred'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}', IAgCrdnEventIntervalCollection)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollection'] = IAgCrdnEventIntervalCollection
__all__.append('IAgCrdnEventIntervalCollection')

class IAgCrdnEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = '{0253FA16-73AA-4F0A-9904-0789EC873ECB}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetConditionSet'] = _raise_uninitialized_error
        self.__dict__['_SetConditionSet'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionCondition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionCondition = agcom.GUID(IAgCrdnEventIntervalCollectionCondition._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionCondition._vtable_offset - 1
        self.__dict__['_GetConditionSet'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetConditionSet'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionCondition.__dict__ and type(IAgCrdnEventIntervalCollectionCondition.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionCondition.')
    
    @property
    def ConditionSet(self) -> "IAgCrdnConditionSet":
        """Get/set the condition set object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConditionSet'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ConditionSet.setter
    def ConditionSet(self, conditionSet:"IAgCrdnConditionSet") -> None:
        with agmarshall.AgInterface_in_arg(conditionSet, IAgCrdnConditionSet) as arg_conditionSet:
            agcls.evaluate_hresult(self.__dict__['_SetConditionSet'](arg_conditionSet.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{0253FA16-73AA-4F0A-9904-0789EC873ECB}', IAgCrdnEventIntervalCollectionCondition)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionCondition'] = IAgCrdnEventIntervalCollectionCondition
__all__.append('IAgCrdnEventIntervalCollectionCondition')

class IAgCrdnEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""
    _uuid = '{15E2D2CF-61F9-4468-A5E1-770149F6B08C}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalCollectionLighting'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalCollectionSignaled'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalCollectionSatisfaction'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionFactory = agcom.GUID(IAgCrdnEventIntervalCollectionFactory._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalCollectionLighting'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalCollectionSignaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionFactory, vtable_offset_local+4, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateEventIntervalCollectionSatisfaction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionFactory.__dict__ and type(IAgCrdnEventIntervalCollectionFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalCollectionType") -> "IAgCrdnEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionLighting(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalCollectionLighting'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionSignaled(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalCollectionSignaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalCollectionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalCollectionSatisfaction(self, name:str, description:str) -> "IAgCrdnEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalCollectionSatisfaction'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{15E2D2CF-61F9-4468-A5E1-770149F6B08C}', IAgCrdnEventIntervalCollectionFactory)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionFactory'] = IAgCrdnEventIntervalCollectionFactory
__all__.append('IAgCrdnEventIntervalCollectionFactory')

class IAgCrdnEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    _uuid = '{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetLocation'] = _raise_uninitialized_error
        self.__dict__['_SetLocation'] = _raise_uninitialized_error
        self.__dict__['_GetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_GetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionLighting from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionLighting = agcom.GUID(IAgCrdnEventIntervalCollectionLighting._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionLighting._vtable_offset - 1
        self.__dict__['_GetLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__['_GetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionLighting, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionLighting.__dict__ and type(IAgCrdnEventIntervalCollectionLighting.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionLighting.')
    
    @property
    def Location(self) -> "IAgCrdnPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IAgCrdnPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__['_SetLocation'](arg_location.COM_val))

    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEclipsingBodies'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetEclipsingBodies'](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseObjectEclipsingBodies'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetUseObjectEclipsingBodies'](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}', IAgCrdnEventIntervalCollectionLighting)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionLighting'] = IAgCrdnEventIntervalCollectionLighting
__all__.append('IAgCrdnEventIntervalCollectionLighting')

class IAgCrdnEventIntervalCollectionSignaled(object):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    _uuid = '{AE464683-EEEC-46CF-8886-91F7A30B7859}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalCollection'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalCollection'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetSignalDelay'] = _raise_uninitialized_error
        self.__dict__['_SetSignalDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalCollectionSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalCollectionSignaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalCollectionSignaled = agcom.GUID(IAgCrdnEventIntervalCollectionSignaled._uuid)
        vtable_offset_local = IAgCrdnEventIntervalCollectionSignaled._vtable_offset - 1
        self.__dict__['_GetOriginalCollection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalCollection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalCollectionSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalCollectionSignaled.__dict__ and type(IAgCrdnEventIntervalCollectionSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalCollectionSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalCollectionSignaled.')
    
    @property
    def OriginalCollection(self) -> "IAgCrdnEventIntervalCollection":
        """The original interval list collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalCollection'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalCollection.setter
    def OriginalCollection(self, originalCollection:"IAgCrdnEventIntervalCollection") -> None:
        with agmarshall.AgInterface_in_arg(originalCollection, IAgCrdnEventIntervalCollection) as arg_originalCollection:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalCollection'](arg_originalCollection.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBaseClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IAgCrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetBaseClockLocation'](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IAgCrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetTargetClockLocation'](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAgCrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__['_SetSignalDelay'](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{AE464683-EEEC-46CF-8886-91F7A30B7859}', IAgCrdnEventIntervalCollectionSignaled)
agcls.AgTypeNameMap['IAgCrdnEventIntervalCollectionSignaled'] = IAgCrdnEventIntervalCollectionSignaled
__all__.append('IAgCrdnEventIntervalCollectionSignaled')

class IAgCrdnEventIntervalFactory(object):
    """The factory creates event intervals."""
    _uuid = '{F87C00CA-725C-425C-941E-6987709D788F}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalFixed'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalFixedDuration'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalBetweenTimeInstants'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalFromIntervalList'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalScaled'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalSignaled'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalTimeOffset'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalFactory = agcom.GUID(IAgCrdnEventIntervalFactory._uuid)
        vtable_offset_local = IAgCrdnEventIntervalFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalFixedDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalBetweenTimeInstants'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalFromIntervalList'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalScaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalSignaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFactory.__dict__ and type(IAgCrdnEventIntervalFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalType") -> "IAgCrdnEventInterval":
        """Create and register an interval using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixed(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalFixed'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixedDuration(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalFixedDuration'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalBetweenTimeInstants(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval using specified start and stop time instants."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalBetweenTimeInstants'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFromIntervalList(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalFromIntervalList'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalScaled(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalScaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalSignaled(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalSignaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalTimeOffset(self, name:str, description:str) -> "IAgCrdnEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalTimeOffset'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F87C00CA-725C-425C-941E-6987709D788F}', IAgCrdnEventIntervalFactory)
agcls.AgTypeNameMap['IAgCrdnEventIntervalFactory'] = IAgCrdnEventIntervalFactory
__all__.append('IAgCrdnEventIntervalFactory')

class IAgCrdnEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    _uuid = '{2DBC4523-FDD0-413B-B933-9F74B9B17BED}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetStartTime'] = _raise_uninitialized_error
        self.__dict__['_GetStopTime'] = _raise_uninitialized_error
        self.__dict__['_SetInterval'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalFixed from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalFixed = agcom.GUID(IAgCrdnEventIntervalFixed._uuid)
        vtable_offset_local = IAgCrdnEventIntervalFixed._vtable_offset - 1
        self.__dict__['_GetStartTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixed, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_GetStopTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixed, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__['_SetInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixed, vtable_offset_local+3, agcom.VARIANT, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFixed.__dict__ and type(IAgCrdnEventIntervalFixed.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalFixed.')
    
    @property
    def StartTime(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def StopTime(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetInterval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch, \
             agmarshall.VARIANT_arg(stopEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetInterval'](arg_startEpoch.COM_val, arg_stopEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2DBC4523-FDD0-413B-B933-9F74B9B17BED}', IAgCrdnEventIntervalFixed)
agcls.AgTypeNameMap['IAgCrdnEventIntervalFixed'] = IAgCrdnEventIntervalFixed
__all__.append('IAgCrdnEventIntervalFixed')

class IAgCrdnEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    _uuid = '{2A20830B-D576-4DF1-9C15-51EB59AEC23F}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_GetStopOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStopOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalFixedDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalFixedDuration from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalFixedDuration = agcom.GUID(IAgCrdnEventIntervalFixedDuration._uuid)
        vtable_offset_local = IAgCrdnEventIntervalFixedDuration._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFixedDuration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFixedDuration.__dict__ and type(IAgCrdnEventIntervalFixedDuration.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFixedDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalFixedDuration.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))

    @property
    def StartOffset(self) -> float:
        """The start time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStartOffset'](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """The stop time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStopOffset'](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2A20830B-D576-4DF1-9C15-51EB59AEC23F}', IAgCrdnEventIntervalFixedDuration)
agcls.AgTypeNameMap['IAgCrdnEventIntervalFixedDuration'] = IAgCrdnEventIntervalFixedDuration
__all__.append('IAgCrdnEventIntervalFixedDuration')

class IAgCrdnEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""
    _uuid = '{DCF8AA30-67A3-4856-956D-C4952BF3818E}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalSelection'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalSelection'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalNumber'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalNumber'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalFromIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalFromIntervalList from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalFromIntervalList = agcom.GUID(IAgCrdnEventIntervalFromIntervalList._uuid)
        vtable_offset_local = IAgCrdnEventIntervalFromIntervalList._vtable_offset - 1
        self.__dict__['_GetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetIntervalSelection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetIntervalSelection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetIntervalNumber'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__['_SetIntervalNumber'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalFromIntervalList, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalFromIntervalList.__dict__ and type(IAgCrdnEventIntervalFromIntervalList.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalFromIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalFromIntervalList.')
    
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IAgCrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceIntervals'](arg_referenceIntervals.COM_val))

    @property
    def IntervalSelection(self) -> "AgECrdnIntervalSelection":
        """The method used to select an interval from the reference interval list."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalSelection'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalSelection.setter
    def IntervalSelection(self, intervalSelection:"AgECrdnIntervalSelection") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection, intervalSelection) as arg_intervalSelection:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalSelection'](arg_intervalSelection.COM_val))

    @property
    def IntervalNumber(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd"""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalNumber'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalNumber.setter
    def IntervalNumber(self, intervalNumber:int) -> None:
        with agmarshall.INT_arg(intervalNumber) as arg_intervalNumber:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalNumber'](arg_intervalNumber.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{DCF8AA30-67A3-4856-956D-C4952BF3818E}', IAgCrdnEventIntervalFromIntervalList)
agcls.AgTypeNameMap['IAgCrdnEventIntervalFromIntervalList'] = IAgCrdnEventIntervalFromIntervalList
__all__.append('IAgCrdnEventIntervalFromIntervalList')

class IAgCrdnEventIntervalList(object):
    """An ordered list of time intervals."""
    _uuid = '{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_GetLabels'] = _raise_uninitialized_error
        self.__dict__['_GetDescriptions'] = _raise_uninitialized_error
        self.__dict__['_FindIntervals'] = _raise_uninitialized_error
        self.__dict__['_Occurred'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalList from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalList = agcom.GUID(IAgCrdnEventIntervalList._uuid)
        vtable_offset_local = IAgCrdnEventIntervalList._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalList, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalList, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetDescriptions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalList, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_FindIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalList, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_Occurred'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalList, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalList.__dict__ and type(IAgCrdnEventIntervalList.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalList.')
    
    @property
    def Type(self) -> "AgECrdnEventIntervalListType":
        """Return the type of interval list."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDescriptions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervals(self) -> "IAgCrdnIntervalListResult":
        """Return computed interval list that can be empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Occurred'](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}', IAgCrdnEventIntervalList)
agcls.AgTypeNameMap['IAgCrdnEventIntervalList'] = IAgCrdnEventIntervalList
__all__.append('IAgCrdnEventIntervalList')

class IAgCrdnEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = '{D073568A-7398-45C2-998A-CD2EC12F06E0}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_SetSaveDataOption'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListCondition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListCondition = agcom.GUID(IAgCrdnEventIntervalListCondition._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListCondition._vtable_offset - 1
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetSaveDataOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListCondition.__dict__ and type(IAgCrdnEventIntervalListCondition.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListCondition.')
    
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, IAgCrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSaveDataOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__['_SetSaveDataOption'](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{D073568A-7398-45C2-998A-CD2EC12F06E0}', IAgCrdnEventIntervalListCondition)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListCondition'] = IAgCrdnEventIntervalListCondition
__all__.append('IAgCrdnEventIntervalListCondition')

class IAgCrdnEventIntervalListFactory(object):
    """The factory creates event interval lists."""
    _uuid = '{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListMerged'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListFiltered'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListCondition'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListScaled'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListSignaled'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListTimeOffset'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListFile'] = _raise_uninitialized_error
        self.__dict__['_CreateEventIntervalListFixed'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListFactory = agcom.GUID(IAgCrdnEventIntervalListFactory._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListMerged'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListFiltered'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListScaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListSignaled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateEventIntervalListFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateEventIntervalListFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFactory.__dict__ and type(IAgCrdnEventIntervalListFactory.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalListType") -> "IAgCrdnEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListMerged(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListMerged'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFiltered(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListFiltered'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListCondition(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListCondition'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListScaled(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListScaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListSignaled(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListSignaled'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListTimeOffset(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListTimeOffset'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalListType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalListFile(self, name:str, description:str, filePath:str) -> "IAgCrdnEventIntervalList":
        """Create an interval list based on specified interval file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filePath) as arg_filePath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListFile'](arg_name.COM_val, arg_description.COM_val, arg_filePath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFixed(self, name:str, description:str) -> "IAgCrdnEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEventIntervalListFixed'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}', IAgCrdnEventIntervalListFactory)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListFactory'] = IAgCrdnEventIntervalListFactory
__all__.append('IAgCrdnEventIntervalListFactory')

class IAgCrdnEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    _uuid = '{A17588F4-C944-44F8-B8D8-275B13D27E3A}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        self.__dict__['_Reload'] = _raise_uninitialized_error
        self.__dict__['_GetFileSpan'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListFile from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListFile = agcom.GUID(IAgCrdnEventIntervalListFile._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListFile._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_Reload'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFile, vtable_offset_local+3, )
        self.__dict__['_GetFileSpan'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFile, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFile.__dict__ and type(IAgCrdnEventIntervalListFile.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListFile.')
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the interval list file."""
        agcls.evaluate_hresult(self.__dict__['_Reload']())

    def GetFileSpan(self) -> "IAgCrdnEventIntervalResult":
        """Computes the interval list file span."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFileSpan'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A17588F4-C944-44F8-B8D8-275B13D27E3A}', IAgCrdnEventIntervalListFile)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListFile'] = IAgCrdnEventIntervalListFile
__all__.append('IAgCrdnEventIntervalListFile')

class IAgCrdnEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    _uuid = '{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetFilterFactory'] = _raise_uninitialized_error
        self.__dict__['_GetFilter'] = _raise_uninitialized_error
        self.__dict__['_SetFilter'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListFiltered from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListFiltered = agcom.GUID(IAgCrdnEventIntervalListFiltered._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListFiltered._vtable_offset - 1
        self.__dict__['_GetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetFilterFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFiltered, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetFilter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFiltered, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_SetFilter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFiltered, vtable_offset_local+5, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFiltered.__dict__ and type(IAgCrdnEventIntervalListFiltered.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListFiltered.')
    
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IAgCrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalIntervals'](arg_originalIntervals.COM_val))

    @property
    def FilterFactory(self) -> "IAgCrdnPruneFilterFactory":
        """Get the prune filter factory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilterFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filter(self) -> "IAgCrdnPruneFilter":
        """The pruning filter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilter'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"IAgCrdnPruneFilter") -> None:
        with agmarshall.AgInterface_in_arg(filter, IAgCrdnPruneFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__['_SetFilter'](arg_filter.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}', IAgCrdnEventIntervalListFiltered)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListFiltered'] = IAgCrdnEventIntervalListFiltered
__all__.append('IAgCrdnEventIntervalListFiltered')

class IAgCrdnEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    _uuid = '{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListFixed from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListFixed = agcom.GUID(IAgCrdnEventIntervalListFixed._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListFixed._vtable_offset - 1
        self.__dict__['_GetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFixed, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListFixed, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListFixed.__dict__ and type(IAgCrdnEventIntervalListFixed.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListFixed.')
    
    def GetIntervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetIntervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg(intervals) as arg_intervals:
            agcls.evaluate_hresult(self.__dict__['_SetIntervals'](byref(arg_intervals.COM_val)))


agcls.AgClassCatalog.add_catalog_entry('{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}', IAgCrdnEventIntervalListFixed)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListFixed'] = IAgCrdnEventIntervalListFixed
__all__.append('IAgCrdnEventIntervalListFixed')

class IAgCrdnEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    _uuid = '{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIntervalListOrIntervalA'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalListOrIntervalB'] = _raise_uninitialized_error
        self.__dict__['_GetMergeOperation'] = _raise_uninitialized_error
        self.__dict__['_SetMergeOperation'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalListA'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalA'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalListB'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalB'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListMerged from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListMerged = agcom.GUID(IAgCrdnEventIntervalListMerged._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListMerged._vtable_offset - 1
        self.__dict__['_GetIntervalListOrIntervalA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetIntervalListOrIntervalB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMergeOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMergeOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_SetIntervalListA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+5, agcom.PVOID)
        self.__dict__['_SetIntervalA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_SetIntervalListB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+7, agcom.PVOID)
        self.__dict__['_SetIntervalB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListMerged, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListMerged.__dict__ and type(IAgCrdnEventIntervalListMerged.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListMerged.')
    
    @property
    def IntervalListOrIntervalA(self) -> "IAgCrdn":
        """The interval list or interval A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalListOrIntervalA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IntervalListOrIntervalB(self) -> "IAgCrdn":
        """The interval list or interval B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalListOrIntervalB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MergeOperation(self) -> "AgECrdnEventListMergeOperation":
        """The merge operation."""
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMergeOperation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MergeOperation.setter
    def MergeOperation(self, mergeOperation:"AgECrdnEventListMergeOperation") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation, mergeOperation) as arg_mergeOperation:
            agcls.evaluate_hresult(self.__dict__['_SetMergeOperation'](arg_mergeOperation.COM_val))

    def SetIntervalListA(self, refIntervals:"IAgCrdnEventIntervalList") -> None:
        """Sets the interval list A."""
        with agmarshall.AgInterface_in_arg(refIntervals, IAgCrdnEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalListA'](arg_refIntervals.COM_val))

    def SetIntervalA(self, refIntervals:"IAgCrdnEventInterval") -> None:
        """Sets the interval A."""
        with agmarshall.AgInterface_in_arg(refIntervals, IAgCrdnEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalA'](arg_refIntervals.COM_val))

    def SetIntervalListB(self, refIntervals:"IAgCrdnEventIntervalList") -> None:
        """Sets the interval list B."""
        with agmarshall.AgInterface_in_arg(refIntervals, IAgCrdnEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalListB'](arg_refIntervals.COM_val))

    def SetIntervalB(self, refIntervals:"IAgCrdnEventInterval") -> None:
        """Sets the interval B."""
        with agmarshall.AgInterface_in_arg(refIntervals, IAgCrdnEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalB'](arg_refIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}', IAgCrdnEventIntervalListMerged)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListMerged'] = IAgCrdnEventIntervalListMerged
__all__.append('IAgCrdnEventIntervalListMerged')

class IAgCrdnEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    _uuid = '{7DDA88F8-A738-464E-9CDC-613E107F57D0}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeIncrement'] = _raise_uninitialized_error
        self.__dict__['_GetUseAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetUseAbsoluteIncrement'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListScaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListScaled = agcom.GUID(IAgCrdnEventIntervalListScaled._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListScaled._vtable_offset - 1
        self.__dict__['_GetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetRelativeIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetUseAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListScaled.__dict__ and type(IAgCrdnEventIntervalListScaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListScaled.')
    
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IAgCrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalIntervals'](arg_originalIntervals.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAbsoluteIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetAbsoluteIncrement'](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeIncrement'](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseAbsoluteIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetUseAbsoluteIncrement'](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7DDA88F8-A738-464E-9CDC-613E107F57D0}', IAgCrdnEventIntervalListScaled)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListScaled'] = IAgCrdnEventIntervalListScaled
__all__.append('IAgCrdnEventIntervalListScaled')

class IAgCrdnEventIntervalListSignaled(object):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    _uuid = '{C40EA24E-E258-4B0E-8A0F-89424F93F837}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetSignalDelay'] = _raise_uninitialized_error
        self.__dict__['_SetSignalDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListSignaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListSignaled = agcom.GUID(IAgCrdnEventIntervalListSignaled._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListSignaled._vtable_offset - 1
        self.__dict__['_GetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListSignaled.__dict__ and type(IAgCrdnEventIntervalListSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListSignaled.')
    
    @property
    def OriginalIntervals(self) -> "IAgCrdnEventIntervalList":
        """The original time interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, IAgCrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalIntervals'](arg_originalIntervals.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBaseClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IAgCrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetBaseClockLocation'](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IAgCrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetTargetClockLocation'](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAgCrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__['_SetSignalDelay'](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{C40EA24E-E258-4B0E-8A0F-89424F93F837}', IAgCrdnEventIntervalListSignaled)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListSignaled'] = IAgCrdnEventIntervalListSignaled
__all__.append('IAgCrdnEventIntervalListSignaled')

class IAgCrdnEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    _uuid = '{EEA120D3-8E9F-419B-B11C-A034007EB2D0}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetTimeOffset'] = _raise_uninitialized_error
        self.__dict__['_SetTimeOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalListTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalListTimeOffset from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalListTimeOffset = agcom.GUID(IAgCrdnEventIntervalListTimeOffset._uuid)
        vtable_offset_local = IAgCrdnEventIntervalListTimeOffset._vtable_offset - 1
        self.__dict__['_GetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalListTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalListTimeOffset.__dict__ and type(IAgCrdnEventIntervalListTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalListTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalListTimeOffset.')
    
    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IAgCrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceIntervals'](arg_referenceIntervals.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__['_SetTimeOffset'](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EEA120D3-8E9F-419B-B11C-A034007EB2D0}', IAgCrdnEventIntervalListTimeOffset)
agcls.AgTypeNameMap['IAgCrdnEventIntervalListTimeOffset'] = IAgCrdnEventIntervalListTimeOffset
__all__.append('IAgCrdnEventIntervalListTimeOffset')

class IAgCrdnEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    _uuid = '{FA9613FB-7341-4785-AD95-51CFA2B605BC}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalInterval'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalInterval'] = _raise_uninitialized_error
        self.__dict__['_GetAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeIncrement'] = _raise_uninitialized_error
        self.__dict__['_GetUseAbsoluteIncrement'] = _raise_uninitialized_error
        self.__dict__['_SetUseAbsoluteIncrement'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalScaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalScaled = agcom.GUID(IAgCrdnEventIntervalScaled._uuid)
        vtable_offset_local = IAgCrdnEventIntervalScaled._vtable_offset - 1
        self.__dict__['_GetOriginalInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetRelativeIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetUseAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseAbsoluteIncrement'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalScaled.__dict__ and type(IAgCrdnEventIntervalScaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalScaled.')
    
    @property
    def OriginalInterval(self) -> "IAgCrdnEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IAgCrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, IAgCrdnEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalInterval'](arg_originalInterval.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAbsoluteIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetAbsoluteIncrement'](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeIncrement'](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseAbsoluteIncrement'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__['_SetUseAbsoluteIncrement'](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{FA9613FB-7341-4785-AD95-51CFA2B605BC}', IAgCrdnEventIntervalScaled)
agcls.AgTypeNameMap['IAgCrdnEventIntervalScaled'] = IAgCrdnEventIntervalScaled
__all__.append('IAgCrdnEventIntervalScaled')

class IAgCrdnEventIntervalSignaled(object):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    _uuid = '{51B9DE87-9220-40B2-AA57-01F7B17BD945}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalInterval'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalInterval'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetSignalDelay'] = _raise_uninitialized_error
        self.__dict__['_SetSignalDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalSignaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalSignaled = agcom.GUID(IAgCrdnEventIntervalSignaled._uuid)
        vtable_offset_local = IAgCrdnEventIntervalSignaled._vtable_offset - 1
        self.__dict__['_GetOriginalInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalSignaled.__dict__ and type(IAgCrdnEventIntervalSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalSignaled.')
    
    @property
    def OriginalInterval(self) -> "IAgCrdnEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"IAgCrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, IAgCrdnEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalInterval'](arg_originalInterval.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBaseClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IAgCrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetBaseClockLocation'](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IAgCrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetTargetClockLocation'](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAgCrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__['_SetSignalDelay'](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{51B9DE87-9220-40B2-AA57-01F7B17BD945}', IAgCrdnEventIntervalSignaled)
agcls.AgTypeNameMap['IAgCrdnEventIntervalSignaled'] = IAgCrdnEventIntervalSignaled
__all__.append('IAgCrdnEventIntervalSignaled')

class IAgCrdnEventIntervalSmartInterval(object):
    """A smart interval."""
    _uuid = '{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}'
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceInterval'] = _raise_uninitialized_error
        self.__dict__['_GetDurationAsString'] = _raise_uninitialized_error
        self.__dict__['_SetDurationAsString'] = _raise_uninitialized_error
        self.__dict__['_GetState'] = _raise_uninitialized_error
        self.__dict__['_SetState'] = _raise_uninitialized_error
        self.__dict__['_SetImplicitInterval'] = _raise_uninitialized_error
        self.__dict__['_FindStartTime'] = _raise_uninitialized_error
        self.__dict__['_FindStopTime'] = _raise_uninitialized_error
        self.__dict__['_GetStartEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetStartEpoch'] = _raise_uninitialized_error
        self.__dict__['_GetStopEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetStopEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetExplicitInterval'] = _raise_uninitialized_error
        self.__dict__['_SetStartAndStopEpochs'] = _raise_uninitialized_error
        self.__dict__['_SetStartAndStopTimes'] = _raise_uninitialized_error
        self.__dict__['_SetStartEpochAndDuration'] = _raise_uninitialized_error
        self.__dict__['_SetStartTimeAndDuration'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalSmartInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalSmartInterval from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalSmartInterval = agcom.GUID(IAgCrdnEventIntervalSmartInterval._uuid)
        vtable_offset_local = IAgCrdnEventIntervalSmartInterval._vtable_offset - 1
        self.__dict__['_GetReferenceInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetDurationAsString'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_SetDurationAsString'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+3, agcom.BSTR)
        self.__dict__['_GetState'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_SetState'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+5, agcom.LONG)
        self.__dict__['_SetImplicitInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_FindStartTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__['_FindStopTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__['_GetStartEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetStartEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+10, agcom.PVOID)
        self.__dict__['_GetStopEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetStopEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+12, agcom.PVOID)
        self.__dict__['_SetExplicitInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+13, agcom.VARIANT, agcom.VARIANT)
        self.__dict__['_SetStartAndStopEpochs'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+14, agcom.PVOID, agcom.PVOID)
        self.__dict__['_SetStartAndStopTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+15, agcom.VARIANT, agcom.VARIANT)
        self.__dict__['_SetStartEpochAndDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+16, agcom.PVOID, agcom.BSTR)
        self.__dict__['_SetStartTimeAndDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalSmartInterval, vtable_offset_local+17, agcom.VARIANT, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalSmartInterval.__dict__ and type(IAgCrdnEventIntervalSmartInterval.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalSmartInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalSmartInterval.')
    
    @property
    def ReferenceInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DurationAsString(self) -> str:
        """The duration of the interval"""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationAsString'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationAsString.setter
    def DurationAsString(self, durationAsString:str) -> None:
        with agmarshall.BSTR_arg(durationAsString) as arg_durationAsString:
            agcls.evaluate_hresult(self.__dict__['_SetDurationAsString'](arg_durationAsString.COM_val))

    @property
    def State(self) -> "AgECrdnSmartIntervalState":
        """A state of the smart interval."""
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetState'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartIntervalState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__['_SetState'](arg_state.COM_val))

    def SetImplicitInterval(self, eventInterval:"IAgCrdnEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventInterval, IAgCrdnEventInterval) as arg_eventInterval:
            agcls.evaluate_hresult(self.__dict__['_SetImplicitInterval'](arg_eventInterval.COM_val))

    def FindStartTime(self) -> typing.Any:
        """Finds a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindStartTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindStopTime(self) -> typing.Any:
        """Finds a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_FindStopTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetStartEpoch(self) -> "IAgCrdnEventSmartEpoch":
        """Returns a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartEpoch'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStartEpoch(self, startEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets a start of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(startEpoch, IAgCrdnEventSmartEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetStartEpoch'](arg_startEpoch.COM_val))

    def GetStopEpoch(self) -> "IAgCrdnEventSmartEpoch":
        """Returns a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopEpoch'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStopEpoch(self, stopEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets a stop of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(stopEpoch, IAgCrdnEventSmartEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetStopEpoch'](arg_stopEpoch.COM_val))

    def SetExplicitInterval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(start) as arg_start, \
             agmarshall.VARIANT_arg(stop) as arg_stop:
            agcls.evaluate_hresult(self.__dict__['_SetExplicitInterval'](arg_start.COM_val, arg_stop.COM_val))

    def SetStartAndStopEpochs(self, refStartEpoch:"IAgCrdnEventSmartEpoch", refStopEpoch:"IAgCrdnEventSmartEpoch") -> None:
        """Sets the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, IAgCrdnEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.AgInterface_in_arg(refStopEpoch, IAgCrdnEventSmartEpoch) as arg_refStopEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetStartAndStopEpochs'](arg_refStartEpoch.COM_val, arg_refStopEpoch.COM_val))

    def SetStartAndStopTimes(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Sets the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(startTime) as arg_startTime, \
             agmarshall.VARIANT_arg(stopTime) as arg_stopTime:
            agcls.evaluate_hresult(self.__dict__['_SetStartAndStopTimes'](arg_startTime.COM_val, arg_stopTime.COM_val))

    def SetStartEpochAndDuration(self, refStartEpoch:"IAgCrdnEventSmartEpoch", durationStr:str) -> None:
        """Sets the interval's start epoch and the interval's duration."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, IAgCrdnEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__['_SetStartEpochAndDuration'](arg_refStartEpoch.COM_val, arg_durationStr.COM_val))

    def SetStartTimeAndDuration(self, epoch:typing.Any, durationStr:str) -> None:
        """Sets the interval's start time and the interval's duration."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__['_SetStartTimeAndDuration'](arg_epoch.COM_val, arg_durationStr.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}', IAgCrdnEventIntervalSmartInterval)
agcls.AgTypeNameMap['IAgCrdnEventIntervalSmartInterval'] = IAgCrdnEventIntervalSmartInterval
__all__.append('IAgCrdnEventIntervalSmartInterval')

class IAgCrdnEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    _uuid = '{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceInterval'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceInterval'] = _raise_uninitialized_error
        self.__dict__['_GetTimeOffset'] = _raise_uninitialized_error
        self.__dict__['_SetTimeOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventIntervalTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventIntervalTimeOffset from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventIntervalTimeOffset = agcom.GUID(IAgCrdnEventIntervalTimeOffset._uuid)
        vtable_offset_local = IAgCrdnEventIntervalTimeOffset._vtable_offset - 1
        self.__dict__['_GetReferenceInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventIntervalTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventIntervalTimeOffset.__dict__ and type(IAgCrdnEventIntervalTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventIntervalTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventIntervalTimeOffset.')
    
    @property
    def ReferenceInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceInterval.setter
    def ReferenceInterval(self, referenceInterval:"IAgCrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceInterval, IAgCrdnEventInterval) as arg_referenceInterval:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceInterval'](arg_referenceInterval.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__['_SetTimeOffset'](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}', IAgCrdnEventIntervalTimeOffset)
agcls.AgTypeNameMap['IAgCrdnEventIntervalTimeOffset'] = IAgCrdnEventIntervalTimeOffset
__all__.append('IAgCrdnEventIntervalTimeOffset')

class IAgCrdnEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    _uuid = '{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginalTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetOriginalTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetBaseClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_SetTargetClockLocation'] = _raise_uninitialized_error
        self.__dict__['_GetSignalDelay'] = _raise_uninitialized_error
        self.__dict__['_SetSignalDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventSignaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventSignaled = agcom.GUID(IAgCrdnEventSignaled._uuid)
        vtable_offset_local = IAgCrdnEventSignaled._vtable_offset - 1
        self.__dict__['_GetOriginalTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginalTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetBaseClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetTargetClockLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetSignalDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventSignaled.__dict__ and type(IAgCrdnEventSignaled.__dict__[attrname]) == property:
            return IAgCrdnEventSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventSignaled.')
    
    @property
    def OriginalTimeInstant(self) -> "IAgCrdnEvent":
        """The original time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginalTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeInstant.setter
    def OriginalTimeInstant(self, originalTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeInstant, IAgCrdnEvent) as arg_originalTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetOriginalTimeInstant'](arg_originalTimeInstant.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "IAgCrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBaseClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, IAgCrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetBaseClockLocation'](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "IAgCrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetClockLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, IAgCrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__['_SetTargetClockLocation'](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "IAgCrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"IAgCrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, IAgCrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__['_SetSignalDelay'](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}', IAgCrdnEventSignaled)
agcls.AgTypeNameMap['IAgCrdnEventSignaled'] = IAgCrdnEventSignaled
__all__.append('IAgCrdnEventSignaled')

class IAgCrdnEventSmartEpoch(object):
    """A smart epoch."""
    _uuid = '{4C5542F5-5B94-498B-90BC-CC7CB7C86629}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceEvent'] = _raise_uninitialized_error
        self.__dict__['_GetState'] = _raise_uninitialized_error
        self.__dict__['_SetState'] = _raise_uninitialized_error
        self.__dict__['_SetExplicitTime'] = _raise_uninitialized_error
        self.__dict__['_SetImplicitTime'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventSmartEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventSmartEpoch from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventSmartEpoch = agcom.GUID(IAgCrdnEventSmartEpoch._uuid)
        vtable_offset_local = IAgCrdnEventSmartEpoch._vtable_offset - 1
        self.__dict__['_GetTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_GetReferenceEvent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetState'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetState'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_SetExplicitTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__['_SetImplicitTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventSmartEpoch, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventSmartEpoch.__dict__ and type(IAgCrdnEventSmartEpoch.__dict__[attrname]) == property:
            return IAgCrdnEventSmartEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventSmartEpoch.')
    
    @property
    def TimeInstant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeInstant'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ReferenceEvent(self) -> "IAgCrdnEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceEvent'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def State(self) -> "AgECrdnSmartEpochState":
        """State of the event."""
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetState'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartEpochState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__['_SetState'](arg_state.COM_val))

    def SetExplicitTime(self, epoch:typing.Any) -> None:
        """Sets explicit time instant and the smart epoch's state to Explicit."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__['_SetExplicitTime'](arg_epoch.COM_val))

    def SetImplicitTime(self, eventEpoch:"IAgCrdnEvent") -> None:
        """Sets the reference event and the smart epoch's state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventEpoch, IAgCrdnEvent) as arg_eventEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetImplicitTime'](arg_eventEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4C5542F5-5B94-498B-90BC-CC7CB7C86629}', IAgCrdnEventSmartEpoch)
agcls.AgTypeNameMap['IAgCrdnEventSmartEpoch'] = IAgCrdnEventSmartEpoch
__all__.append('IAgCrdnEventSmartEpoch')

class IAgCrdnEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""
    _uuid = '{EB96850C-18E7-4269-8D35-67FB7E55BD59}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetUseStart'] = _raise_uninitialized_error
        self.__dict__['_SetUseStart'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceEventInterval'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceEventInterval'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventStartStopTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventStartStopTime from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventStartStopTime = agcom.GUID(IAgCrdnEventStartStopTime._uuid)
        vtable_offset_local = IAgCrdnEventStartStopTime._vtable_offset - 1
        self.__dict__['_GetUseStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventStartStopTime, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventStartStopTime, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__['_GetReferenceEventInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventStartStopTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceEventInterval'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventStartStopTime, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventStartStopTime.__dict__ and type(IAgCrdnEventStartStopTime.__dict__[attrname]) == property:
            return IAgCrdnEventStartStopTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventStartStopTime.')
    
    @property
    def UseStart(self) -> bool:
        """Indicates whether to use start (true) or stop (false)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseStart.setter
    def UseStart(self, useStart:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useStart) as arg_useStart:
            agcls.evaluate_hresult(self.__dict__['_SetUseStart'](arg_useStart.COM_val))

    @property
    def ReferenceEventInterval(self) -> "IAgCrdnEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceEventInterval'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceEventInterval.setter
    def ReferenceEventInterval(self, referenceEventInterval:"IAgCrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceEventInterval, IAgCrdnEventInterval) as arg_referenceEventInterval:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceEventInterval'](arg_referenceEventInterval.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EB96850C-18E7-4269-8D35-67FB7E55BD59}', IAgCrdnEventStartStopTime)
agcls.AgTypeNameMap['IAgCrdnEventStartStopTime'] = IAgCrdnEventStartStopTime
__all__.append('IAgCrdnEventStartStopTime')

class IAgCrdnEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""
    _uuid = '{EB95E24E-6BDF-434C-A278-BF64475E4EB5}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetTimeOffset2'] = _raise_uninitialized_error
        self.__dict__['_SetTimeOffset2'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnEventTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnEventTimeOffset from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnEventTimeOffset = agcom.GUID(IAgCrdnEventTimeOffset._uuid)
        vtable_offset_local = IAgCrdnEventTimeOffset._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetTimeOffset2'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeOffset2'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnEventTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnEventTimeOffset.__dict__ and type(IAgCrdnEventTimeOffset.__dict__[attrname]) == property:
            return IAgCrdnEventTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnEventTimeOffset.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))

    @property
    def TimeOffset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in \'TimeUnit\' dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeOffset2'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset2.setter
    def TimeOffset2(self, timeOffset2:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset2) as arg_timeOffset2:
            agcls.evaluate_hresult(self.__dict__['_SetTimeOffset2'](arg_timeOffset2.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EB95E24E-6BDF-434C-A278-BF64475E4EB5}', IAgCrdnEventTimeOffset)
agcls.AgTypeNameMap['IAgCrdnEventTimeOffset'] = IAgCrdnEventTimeOffset
__all__.append('IAgCrdnEventTimeOffset')

class IAgCrdnFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""
    _uuid = '{032A1F18-16B1-48B3-BB59-AFE83A834880}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnFirstIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnFirstIntervalsFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnFirstIntervalsFilter = agcom.GUID(IAgCrdnFirstIntervalsFilter._uuid)
        vtable_offset_local = IAgCrdnFirstIntervalsFilter._vtable_offset - 1
        self.__dict__['_GetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFirstIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__['_SetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnFirstIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnFirstIntervalsFilter.__dict__ and type(IAgCrdnFirstIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnFirstIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnFirstIntervalsFilter.')
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumNumberOfIntervals'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumNumberOfIntervals'](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{032A1F18-16B1-48B3-BB59-AFE83A834880}', IAgCrdnFirstIntervalsFilter)
agcls.AgTypeNameMap['IAgCrdnFirstIntervalsFilter'] = IAgCrdnFirstIntervalsFilter
__all__.append('IAgCrdnFirstIntervalsFilter')

class IAgCrdnGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    _uuid = '{97B393F6-5E70-4D67-80C1-F85080D818F3}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_SetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_GetGapDuration'] = _raise_uninitialized_error
        self.__dict__['_SetGapDuration'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGapsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGapsFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGapsFilter = agcom.GUID(IAgCrdnGapsFilter._uuid)
        vtable_offset_local = IAgCrdnGapsFilter._vtable_offset - 1
        self.__dict__['_GetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGapsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGapsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetGapDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGapsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetGapDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGapsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGapsFilter.__dict__ and type(IAgCrdnGapsFilter.__dict__[attrname]) == property:
            return IAgCrdnGapsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGapsFilter.')
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationKind'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__['_SetDurationKind'](arg_durationKind.COM_val))

    @property
    def GapDuration(self) -> float:
        """Duration of the gap."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetGapDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GapDuration.setter
    def GapDuration(self, gapDuration:float) -> None:
        with agmarshall.DOUBLE_arg(gapDuration) as arg_gapDuration:
            agcls.evaluate_hresult(self.__dict__['_SetGapDuration'](arg_gapDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{97B393F6-5E70-4D67-80C1-F85080D818F3}', IAgCrdnGapsFilter)
agcls.AgTypeNameMap['IAgCrdnGapsFilter'] = IAgCrdnGapsFilter
__all__.append('IAgCrdnGapsFilter')

class IAgCrdnIntegral(object):
    """Represents a base class for integral definitions."""
    _uuid = '{61D34977-CC2E-43C1-9103-692FF9B3DEF0}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntegral from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntegral = agcom.GUID(IAgCrdnIntegral._uuid)
        vtable_offset_local = IAgCrdnIntegral._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntegral.__dict__ and type(IAgCrdnIntegral.__dict__[attrname]) == property:
            return IAgCrdnIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntegral.')
    

agcls.AgClassCatalog.add_catalog_entry('{61D34977-CC2E-43C1-9103-692FF9B3DEF0}', IAgCrdnIntegral)
agcls.AgTypeNameMap['IAgCrdnIntegral'] = IAgCrdnIntegral
__all__.append('IAgCrdnIntegral')

class IAgCrdnIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""
    _uuid = '{19DEEA25-F655-487B-86FF-429B55093F77}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_SetType'] = _raise_uninitialized_error
        self.__dict__['_GetTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumIterations'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumIterations'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntegralBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntegralBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntegralBasic = agcom.GUID(IAgCrdnIntegralBasic._uuid)
        vtable_offset_local = IAgCrdnIntegralBasic._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetMaximumIterations'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__['_SetMaximumIterations'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntegralBasic, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntegralBasic.__dict__ and type(IAgCrdnIntegralBasic.__dict__[attrname]) == property:
            return IAgCrdnIntegralBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntegralBasic.')
    
    @property
    def Type(self) -> "AgECrdnIntegralType":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        with agmarshall.AgEnum_arg(AgECrdnIntegralType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnIntegralType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegralType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__['_SetType'](arg_type.COM_val))

    @property
    def Tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Tolerance.setter
    def Tolerance(self, tolerance:float) -> None:
        with agmarshall.DOUBLE_arg(tolerance) as arg_tolerance:
            agcls.evaluate_hresult(self.__dict__['_SetTolerance'](arg_tolerance.COM_val))

    @property
    def MaximumIterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumIterations'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumIterations.setter
    def MaximumIterations(self, maximumIterations:int) -> None:
        with agmarshall.INT_arg(maximumIterations) as arg_maximumIterations:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumIterations'](arg_maximumIterations.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{19DEEA25-F655-487B-86FF-429B55093F77}', IAgCrdnIntegralBasic)
agcls.AgTypeNameMap['IAgCrdnIntegralBasic'] = IAgCrdnIntegralBasic
__all__.append('IAgCrdnIntegralBasic')

class IAgCrdnInterp(object):
    """Represents a base class for interpolation definitions."""
    _uuid = '{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnInterp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnInterp from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnInterp = agcom.GUID(IAgCrdnInterp._uuid)
        vtable_offset_local = IAgCrdnInterp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterp.__dict__ and type(IAgCrdnInterp.__dict__[attrname]) == property:
            return IAgCrdnInterp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnInterp.')
    

agcls.AgClassCatalog.add_catalog_entry('{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}', IAgCrdnInterp)
agcls.AgTypeNameMap['IAgCrdnInterp'] = IAgCrdnInterp
__all__.append('IAgCrdnInterp')

class IAgCrdnInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    _uuid = '{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_SetType'] = _raise_uninitialized_error
        self.__dict__['_GetOrder'] = _raise_uninitialized_error
        self.__dict__['_SetOrder'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnInterpBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnInterpBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnInterpBasic = agcom.GUID(IAgCrdnInterpBasic._uuid)
        vtable_offset_local = IAgCrdnInterpBasic._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterpBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterpBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetOrder'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterpBasic, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__['_SetOrder'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInterpBasic, vtable_offset_local+4, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInterpBasic.__dict__ and type(IAgCrdnInterpBasic.__dict__[attrname]) == property:
            return IAgCrdnInterpBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnInterpBasic.')
    
    @property
    def Type(self) -> "AgECrdnInterpolatorType":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__['_SetType'](arg_type.COM_val))

    @property
    def Order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrder'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Order.setter
    def Order(self, order:int) -> None:
        with agmarshall.INT_arg(order) as arg_order:
            agcls.evaluate_hresult(self.__dict__['_SetOrder'](arg_order.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}', IAgCrdnInterpBasic)
agcls.AgTypeNameMap['IAgCrdnInterpBasic'] = IAgCrdnInterpBasic
__all__.append('IAgCrdnInterpBasic')

class IAgCrdnIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""
    _uuid = '{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_SetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalDuration'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalDuration'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnIntervalsFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnIntervalsFilter = agcom.GUID(IAgCrdnIntervalsFilter._uuid)
        vtable_offset_local = IAgCrdnIntervalsFilter._vtable_offset - 1
        self.__dict__['_GetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnIntervalsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnIntervalsFilter.__dict__ and type(IAgCrdnIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnIntervalsFilter.')
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationKind'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__['_SetDurationKind'](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """The interval duration."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalDuration'](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}', IAgCrdnIntervalsFilter)
agcls.AgTypeNameMap['IAgCrdnIntervalsFilter'] = IAgCrdnIntervalsFilter
__all__.append('IAgCrdnIntervalsFilter')

class IAgCrdnLastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""
    _uuid = '{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnLastIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnLastIntervalsFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnLastIntervalsFilter = agcom.GUID(IAgCrdnLastIntervalsFilter._uuid)
        vtable_offset_local = IAgCrdnLastIntervalsFilter._vtable_offset - 1
        self.__dict__['_GetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLastIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__['_SetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLastIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLastIntervalsFilter.__dict__ and type(IAgCrdnLastIntervalsFilter.__dict__[attrname]) == property:
            return IAgCrdnLastIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnLastIntervalsFilter.')
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumNumberOfIntervals'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumNumberOfIntervals'](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}', IAgCrdnLastIntervalsFilter)
agcls.AgTypeNameMap['IAgCrdnLastIntervalsFilter'] = IAgCrdnLastIntervalsFilter
__all__.append('IAgCrdnLastIntervalsFilter')

class IAgCrdnParameterSet(object):
    """Parameter set contains various sets of scalar computations."""
    _uuid = '{285664E8-604B-4C0A-9ED0-5EE27CA1539D}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetType'] = _raise_uninitialized_error
        self.__dict__['_GetLabels'] = _raise_uninitialized_error
        self.__dict__['_GetDimensions'] = _raise_uninitialized_error
        self.__dict__['_GetScalarNames'] = _raise_uninitialized_error
        self.__dict__['_Calculate'] = _raise_uninitialized_error
        self.__dict__['_CalculateWithDerivative'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSet from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSet = agcom.GUID(IAgCrdnParameterSet._uuid)
        vtable_offset_local = IAgCrdnParameterSet._vtable_offset - 1
        self.__dict__['_GetType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetLabels'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetDimensions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetScalarNames'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Calculate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__['_CalculateWithDerivative'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSet, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSet.__dict__ and type(IAgCrdnParameterSet.__dict__[attrname]) == property:
            return IAgCrdnParameterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSet.')
    
    @property
    def Type(self) -> "AgECrdnParameterSetType":
        """Get the type of parameter set."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabels'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimensions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScalarNames(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalarNames'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Calculate'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CalculateWithDerivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CalculateWithDerivative'](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{285664E8-604B-4C0A-9ED0-5EE27CA1539D}', IAgCrdnParameterSet)
agcls.AgTypeNameMap['IAgCrdnParameterSet'] = IAgCrdnParameterSet
__all__.append('IAgCrdnParameterSet')

class IAgCrdnParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    _uuid = '{8B7DCF32-3CA4-4794-8468-81A3627B4043}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAxes'] = _raise_uninitialized_error
        self.__dict__['_SetAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetAttitude from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetAttitude = agcom.GUID(IAgCrdnParameterSetAttitude._uuid)
        vtable_offset_local = IAgCrdnParameterSetAttitude._vtable_offset - 1
        self.__dict__['_GetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetAttitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetAttitude, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetAttitude, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetAttitude, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetAttitude.__dict__ and type(IAgCrdnParameterSetAttitude.__dict__[attrname]) == property:
            return IAgCrdnParameterSetAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetAttitude.')
    
    @property
    def Axes(self) -> "IAgCrdnAxes":
        """Get the axes for which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Axes.setter
    def Axes(self, axes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__['_SetAxes'](arg_axes.COM_val))

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceAxes'](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{8B7DCF32-3CA4-4794-8468-81A3627B4043}', IAgCrdnParameterSetAttitude)
agcls.AgTypeNameMap['IAgCrdnParameterSetAttitude'] = IAgCrdnParameterSetAttitude
__all__.append('IAgCrdnParameterSetAttitude')

class IAgCrdnParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""
    _uuid = '{4D20E85F-1DEA-4963-9114-6B0407E53C5E}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateParameterSetAttitude'] = _raise_uninitialized_error
        self.__dict__['_CreateParameterSetGroundTrajectory'] = _raise_uninitialized_error
        self.__dict__['_CreateParameterSetTrajectory'] = _raise_uninitialized_error
        self.__dict__['_CreateParameterSetOrbit'] = _raise_uninitialized_error
        self.__dict__['_CreateParameterSetVector'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetFactory = agcom.GUID(IAgCrdnParameterSetFactory._uuid)
        vtable_offset_local = IAgCrdnParameterSetFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateParameterSetAttitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateParameterSetGroundTrajectory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateParameterSetTrajectory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateParameterSetOrbit'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateParameterSetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetFactory, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetFactory.__dict__ and type(IAgCrdnParameterSetFactory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnParameterSetType") -> "IAgCrdnParameterSet":
        """Creates and registers a parameter set using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnParameterSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetAttitude(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying one set of axes in reference to another."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateParameterSetAttitude'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetGroundTrajectory(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateParameterSetGroundTrajectory'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetTrajectory(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference coordinate system."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateParameterSetTrajectory'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetOrbit(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying orbiting point and its central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateParameterSetOrbit'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetVector(self, name:str, description:str) -> "IAgCrdnParameterSet":
        """Creates a parameter set defined by identifying vector in reference axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateParameterSetVector'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnParameterSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{4D20E85F-1DEA-4963-9114-6B0407E53C5E}', IAgCrdnParameterSetFactory)
agcls.AgTypeNameMap['IAgCrdnParameterSetFactory'] = IAgCrdnParameterSetFactory
__all__.append('IAgCrdnParameterSetFactory')

class IAgCrdnParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    _uuid = '{53ABEB95-F846-4574-BA87-C76220FDC19F}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetLocation'] = _raise_uninitialized_error
        self.__dict__['_SetLocation'] = _raise_uninitialized_error
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetGroundTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetGroundTrajectory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetGroundTrajectory = agcom.GUID(IAgCrdnParameterSetGroundTrajectory._uuid)
        vtable_offset_local = IAgCrdnParameterSetGroundTrajectory._vtable_offset - 1
        self.__dict__['_GetLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroundTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroundTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroundTrajectory, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetGroundTrajectory, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetGroundTrajectory.__dict__ and type(IAgCrdnParameterSetGroundTrajectory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetGroundTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetGroundTrajectory.')
    
    @property
    def Location(self) -> "IAgCrdnPoint":
        """Get the point for which ground trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, IAgCrdnPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__['_SetLocation'](arg_location.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{53ABEB95-F846-4574-BA87-C76220FDC19F}', IAgCrdnParameterSetGroundTrajectory)
agcls.AgTypeNameMap['IAgCrdnParameterSetGroundTrajectory'] = IAgCrdnParameterSetGroundTrajectory
__all__.append('IAgCrdnParameterSetGroundTrajectory')

class IAgCrdnParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    _uuid = '{141AEAB7-C017-4044-BE2C-EFE4AD724022}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOrbitingPoint'] = _raise_uninitialized_error
        self.__dict__['_SetOrbitingPoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetGravitationalParameter'] = _raise_uninitialized_error
        self.__dict__['_SetGravitationalParameter'] = _raise_uninitialized_error
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetUseCentralBodyGravitationalParameter'] = _raise_uninitialized_error
        self.__dict__['_SetUseCentralBodyGravitationalParameter'] = _raise_uninitialized_error
        self.__dict__['_GetUseCentralBodyInertial'] = _raise_uninitialized_error
        self.__dict__['_SetUseCentralBodyInertial'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetOrbit from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetOrbit = agcom.GUID(IAgCrdnParameterSetOrbit._uuid)
        vtable_offset_local = IAgCrdnParameterSetOrbit._vtable_offset - 1
        self.__dict__['_GetOrbitingPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOrbitingPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetGravitationalParameter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetGravitationalParameter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+8, agcom.BSTR)
        self.__dict__['_GetUseCentralBodyGravitationalParameter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCentralBodyGravitationalParameter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__['_GetUseCentralBodyInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCentralBodyInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetOrbit, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetOrbit.__dict__ and type(IAgCrdnParameterSetOrbit.__dict__[attrname]) == property:
            return IAgCrdnParameterSetOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetOrbit.')
    
    @property
    def OrbitingPoint(self) -> "IAgCrdnPoint":
        """Get the point for which orbital parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrbitingPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OrbitingPoint.setter
    def OrbitingPoint(self, orbitingPoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(orbitingPoint, IAgCrdnPoint) as arg_orbitingPoint:
            agcls.evaluate_hresult(self.__dict__['_SetOrbitingPoint'](arg_orbitingPoint.COM_val))

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def GravitationalParameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetGravitationalParameter'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GravitationalParameter.setter
    def GravitationalParameter(self, gravitationalParameter:float) -> None:
        with agmarshall.DOUBLE_arg(gravitationalParameter) as arg_gravitationalParameter:
            agcls.evaluate_hresult(self.__dict__['_SetGravitationalParameter'](arg_gravitationalParameter.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))

    @property
    def UseCentralBodyGravitationalParameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCentralBodyGravitationalParameter'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyGravitationalParameter.setter
    def UseCentralBodyGravitationalParameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyGravitationalParameter) as arg_useCentralBodyGravitationalParameter:
            agcls.evaluate_hresult(self.__dict__['_SetUseCentralBodyGravitationalParameter'](arg_useCentralBodyGravitationalParameter.COM_val))

    @property
    def UseCentralBodyInertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCentralBodyInertial'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyInertial.setter
    def UseCentralBodyInertial(self, useCentralBodyInertial:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyInertial) as arg_useCentralBodyInertial:
            agcls.evaluate_hresult(self.__dict__['_SetUseCentralBodyInertial'](arg_useCentralBodyInertial.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{141AEAB7-C017-4044-BE2C-EFE4AD724022}', IAgCrdnParameterSetOrbit)
agcls.AgTypeNameMap['IAgCrdnParameterSetOrbit'] = IAgCrdnParameterSetOrbit
__all__.append('IAgCrdnParameterSetOrbit')

class IAgCrdnParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    _uuid = '{0FE9C601-61BB-4579-B91F-B1123A19AFB4}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPoint'] = _raise_uninitialized_error
        self.__dict__['_SetPoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetTrajectory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetTrajectory = agcom.GUID(IAgCrdnParameterSetTrajectory._uuid)
        vtable_offset_local = IAgCrdnParameterSetTrajectory._vtable_offset - 1
        self.__dict__['_GetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetTrajectory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetTrajectory, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetTrajectory.__dict__ and type(IAgCrdnParameterSetTrajectory.__dict__[attrname]) == property:
            return IAgCrdnParameterSetTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetTrajectory.')
    
    @property
    def Point(self) -> "IAgCrdnPoint":
        """Get the point for which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__['_SetPoint'](arg_point.COM_val))

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{0FE9C601-61BB-4579-B91F-B1123A19AFB4}', IAgCrdnParameterSetTrajectory)
agcls.AgTypeNameMap['IAgCrdnParameterSetTrajectory'] = IAgCrdnParameterSetTrajectory
__all__.append('IAgCrdnParameterSetTrajectory')

class IAgCrdnParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    _uuid = '{5B99EEC1-21BD-48B5-96A0-0230894532F1}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_SetVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnParameterSetVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnParameterSetVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnParameterSetVector = agcom.GUID(IAgCrdnParameterSetVector._uuid)
        vtable_offset_local = IAgCrdnParameterSetVector._vtable_offset - 1
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnParameterSetVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnParameterSetVector.__dict__ and type(IAgCrdnParameterSetVector.__dict__[attrname]) == property:
            return IAgCrdnParameterSetVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnParameterSetVector.')
    
    @property
    def Vector(self) -> "IAgCrdnVector":
        """Get the vector for which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Vector.setter
    def Vector(self, vector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vector, IAgCrdnVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__['_SetVector'](arg_vector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """Get the reference axes relative to which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceAxes'](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5B99EEC1-21BD-48B5-96A0-0230894532F1}', IAgCrdnParameterSetVector)
agcls.AgTypeNameMap['IAgCrdnParameterSetVector'] = IAgCrdnParameterSetVector
__all__.append('IAgCrdnParameterSetVector')

class IAgCrdnPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""
    _uuid = '{89E95CD7-CDB2-4B17-9E47-DE17F551F873}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilterType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPruneFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPruneFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPruneFilter = agcom.GUID(IAgCrdnPruneFilter._uuid)
        vtable_offset_local = IAgCrdnPruneFilter._vtable_offset - 1
        self.__dict__['_GetFilterType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPruneFilter, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPruneFilter.__dict__ and type(IAgCrdnPruneFilter.__dict__[attrname]) == property:
            return IAgCrdnPruneFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPruneFilter.')
    
    @property
    def FilterType(self) -> "AgECrdnPruneFilter":
        """Returns a type of the filter."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilterType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{89E95CD7-CDB2-4B17-9E47-DE17F551F873}', IAgCrdnPruneFilter)
agcls.AgTypeNameMap['IAgCrdnPruneFilter'] = IAgCrdnPruneFilter
__all__.append('IAgCrdnPruneFilter')

class IAgCrdnPruneFilterFactory(object):
    """The factory creates pruning filters."""
    _uuid = '{77E7099E-9B41-45FA-B50F-F8DE5964FABD}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPruneFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPruneFilterFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPruneFilterFactory = agcom.GUID(IAgCrdnPruneFilterFactory._uuid)
        vtable_offset_local = IAgCrdnPruneFilterFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPruneFilterFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPruneFilterFactory.__dict__ and type(IAgCrdnPruneFilterFactory.__dict__[attrname]) == property:
            return IAgCrdnPruneFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPruneFilterFactory.')
    
    def Create(self, eFilter:"AgECrdnPruneFilter") -> "IAgCrdnPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter, eFilter) as arg_eFilter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_eFilter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{77E7099E-9B41-45FA-B50F-F8DE5964FABD}', IAgCrdnPruneFilterFactory)
agcls.AgTypeNameMap['IAgCrdnPruneFilterFactory'] = IAgCrdnPruneFilterFactory
__all__.append('IAgCrdnPruneFilterFactory')

class IAgCrdnRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    _uuid = '{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_SetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeIntervalDuration'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeIntervalDuration'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnRelativeSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnRelativeSatisfactionConditionFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnRelativeSatisfactionConditionFilter = agcom.GUID(IAgCrdnRelativeSatisfactionConditionFilter._uuid)
        vtable_offset_local = IAgCrdnRelativeSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetRelativeIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRelativeSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRelativeSatisfactionConditionFilter.__dict__ and type(IAgCrdnRelativeSatisfactionConditionFilter.__dict__[attrname]) == property:
            return IAgCrdnRelativeSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnRelativeSatisfactionConditionFilter.')
    
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, IAgCrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationKind'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__['_SetDurationKind'](arg_durationKind.COM_val))

    @property
    def RelativeIntervalDuration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeIntervalDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIntervalDuration.setter
    def RelativeIntervalDuration(self, relativeIntervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIntervalDuration) as arg_relativeIntervalDuration:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeIntervalDuration'](arg_relativeIntervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}', IAgCrdnRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap['IAgCrdnRelativeSatisfactionConditionFilter'] = IAgCrdnRelativeSatisfactionConditionFilter
__all__.append('IAgCrdnRelativeSatisfactionConditionFilter')

class IAgCrdnSampling(object):
    """Base sampling interface."""
    _uuid = '{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSampling._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSampling from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSampling = agcom.GUID(IAgCrdnSampling._uuid)
        vtable_offset_local = IAgCrdnSampling._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSampling.__dict__ and type(IAgCrdnSampling.__dict__[attrname]) == property:
            return IAgCrdnSampling.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSampling.')
    

agcls.AgClassCatalog.add_catalog_entry('{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}', IAgCrdnSampling)
agcls.AgTypeNameMap['IAgCrdnSampling'] = IAgCrdnSampling
__all__.append('IAgCrdnSampling')

class IAgCrdnSamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    _uuid = '{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSamplingMethod'] = _raise_uninitialized_error
        self.__dict__['_SetSamplingMethod'] = _raise_uninitialized_error
        self.__dict__['_GetMethodFactory'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingBasic = agcom.GUID(IAgCrdnSamplingBasic._uuid)
        vtable_offset_local = IAgCrdnSamplingBasic._vtable_offset - 1
        self.__dict__['_GetSamplingMethod'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingBasic, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetSamplingMethod'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingBasic, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetMethodFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingBasic.__dict__ and type(IAgCrdnSamplingBasic.__dict__[attrname]) == property:
            return IAgCrdnSamplingBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingBasic.')
    
    @property
    def SamplingMethod(self) -> "IAgCrdnSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSamplingMethod'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SamplingMethod.setter
    def SamplingMethod(self, samplingMethod:"IAgCrdnSamplingMethod") -> None:
        with agmarshall.AgInterface_in_arg(samplingMethod, IAgCrdnSamplingMethod) as arg_samplingMethod:
            agcls.evaluate_hresult(self.__dict__['_SetSamplingMethod'](arg_samplingMethod.COM_val))

    @property
    def MethodFactory(self) -> "IAgCrdnSamplingMethodFactory":
        """Creates sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMethodFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}', IAgCrdnSamplingBasic)
agcls.AgTypeNameMap['IAgCrdnSamplingBasic'] = IAgCrdnSamplingBasic
__all__.append('IAgCrdnSamplingBasic')

class IAgCrdnSamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    _uuid = '{618ADA55-9E3D-4CEC-815A-B028995774CB}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMinimumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetMinimumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetStepAtBoundaries'] = _raise_uninitialized_error
        self.__dict__['_SetStepAtBoundaries'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetAbsoluteTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetAbsoluteTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetCurvatureTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetCurvatureTolerance'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingCurvatureTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingCurvatureTolerance from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingCurvatureTolerance = agcom.GUID(IAgCrdnSamplingCurvatureTolerance._uuid)
        vtable_offset_local = IAgCrdnSamplingCurvatureTolerance._vtable_offset - 1
        self.__dict__['_GetMinimumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMinimumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetMaximumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMaximumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetStepAtBoundaries'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStepAtBoundaries'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetCurvatureTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__['_SetCurvatureTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingCurvatureTolerance, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingCurvatureTolerance.__dict__ and type(IAgCrdnSamplingCurvatureTolerance.__dict__[attrname]) == property:
            return IAgCrdnSamplingCurvatureTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingCurvatureTolerance.')
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimumTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetMinimumTimeStep'](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumTimeStep'](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStepAtBoundaries'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__['_SetStepAtBoundaries'](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeTolerance'](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAbsoluteTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetAbsoluteTolerance'](arg_absoluteTolerance.COM_val))

    @property
    def CurvatureTolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCurvatureTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CurvatureTolerance.setter
    def CurvatureTolerance(self, curvatureTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetCurvatureTolerance'](arg_curvatureTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{618ADA55-9E3D-4CEC-815A-B028995774CB}', IAgCrdnSamplingCurvatureTolerance)
agcls.AgTypeNameMap['IAgCrdnSamplingCurvatureTolerance'] = IAgCrdnSamplingCurvatureTolerance
__all__.append('IAgCrdnSamplingCurvatureTolerance')

class IAgCrdnSamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    _uuid = '{68784D1E-776C-4212-B35E-121FFE569627}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingFixedStep from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingFixedStep = agcom.GUID(IAgCrdnSamplingFixedStep._uuid)
        vtable_offset_local = IAgCrdnSamplingFixedStep._vtable_offset - 1
        self.__dict__['_GetTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingFixedStep, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingFixedStep.__dict__ and type(IAgCrdnSamplingFixedStep.__dict__[attrname]) == property:
            return IAgCrdnSamplingFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingFixedStep.')
    
    @property
    def TimeStep(self) -> float:
        """Get the fixed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__['_SetTimeStep'](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{68784D1E-776C-4212-B35E-121FFE569627}', IAgCrdnSamplingFixedStep)
agcls.AgTypeNameMap['IAgCrdnSamplingFixedStep'] = IAgCrdnSamplingFixedStep
__all__.append('IAgCrdnSamplingFixedStep')

class IAgCrdnSamplingMethod(object):
    """A sampling method."""
    _uuid = '{1D14391E-F22F-42FF-B3FA-902F061A6F7B}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMethodType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingMethod from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingMethod = agcom.GUID(IAgCrdnSamplingMethod._uuid)
        vtable_offset_local = IAgCrdnSamplingMethod._vtable_offset - 1
        self.__dict__['_GetMethodType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingMethod.__dict__ and type(IAgCrdnSamplingMethod.__dict__[attrname]) == property:
            return IAgCrdnSamplingMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingMethod.')
    
    @property
    def MethodType(self) -> "AgECrdnSamplingMethod":
        """A sampling method type."""
        with agmarshall.AgEnum_arg(AgECrdnSamplingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMethodType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1D14391E-F22F-42FF-B3FA-902F061A6F7B}', IAgCrdnSamplingMethod)
agcls.AgTypeNameMap['IAgCrdnSamplingMethod'] = IAgCrdnSamplingMethod
__all__.append('IAgCrdnSamplingMethod')

class IAgCrdnSamplingMethodFactory(object):
    """The factory creates sampling method components."""
    _uuid = '{C214929B-45FA-4023-9C40-6DCE747C151B}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_CreateFixedStep'] = _raise_uninitialized_error
        self.__dict__['_CreateCurvatureTolerance'] = _raise_uninitialized_error
        self.__dict__['_CreateRelativeTolerance'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingMethodFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingMethodFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingMethodFactory = agcom.GUID(IAgCrdnSamplingMethodFactory._uuid)
        vtable_offset_local = IAgCrdnSamplingMethodFactory._vtable_offset - 1
        self.__dict__['_CreateFixedStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingMethodFactory, vtable_offset_local+1, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_CreateCurvatureTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingMethodFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_CreateRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingMethodFactory, vtable_offset_local+3, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingMethodFactory.__dict__ and type(IAgCrdnSamplingMethodFactory.__dict__[attrname]) == property:
            return IAgCrdnSamplingMethodFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingMethodFactory.')
    
    def CreateFixedStep(self, fixedStep:float) -> "IAgCrdnSamplingMethod":
        """Create a fixed time step sampling definition."""
        with agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateFixedStep'](arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCurvatureTolerance(self, curvatureTolerance:float) -> "IAgCrdnSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCurvatureTolerance'](arg_curvatureTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateRelativeTolerance(self, relativeTolerance:float) -> "IAgCrdnSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateRelativeTolerance'](arg_relativeTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C214929B-45FA-4023-9C40-6DCE747C151B}', IAgCrdnSamplingMethodFactory)
agcls.AgTypeNameMap['IAgCrdnSamplingMethodFactory'] = IAgCrdnSamplingMethodFactory
__all__.append('IAgCrdnSamplingMethodFactory')

class IAgCrdnSamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    _uuid = '{32BB5026-A93C-41F7-ADE8-0A04A43627BC}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMinimumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetMinimumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetStepAtBoundaries'] = _raise_uninitialized_error
        self.__dict__['_SetStepAtBoundaries'] = _raise_uninitialized_error
        self.__dict__['_GetRelativeTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetRelativeTolerance'] = _raise_uninitialized_error
        self.__dict__['_GetAbsoluteTolerance'] = _raise_uninitialized_error
        self.__dict__['_SetAbsoluteTolerance'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSamplingRelativeTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSamplingRelativeTolerance from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSamplingRelativeTolerance = agcom.GUID(IAgCrdnSamplingRelativeTolerance._uuid)
        vtable_offset_local = IAgCrdnSamplingRelativeTolerance._vtable_offset - 1
        self.__dict__['_GetMinimumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMinimumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetMaximumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMaximumTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetStepAtBoundaries'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStepAtBoundaries'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRelativeTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAbsoluteTolerance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSamplingRelativeTolerance, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSamplingRelativeTolerance.__dict__ and type(IAgCrdnSamplingRelativeTolerance.__dict__[attrname]) == property:
            return IAgCrdnSamplingRelativeTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSamplingRelativeTolerance.')
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimumTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetMinimumTimeStep'](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumTimeStep'](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStepAtBoundaries'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__['_SetStepAtBoundaries'](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRelativeTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetRelativeTolerance'](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAbsoluteTolerance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__['_SetAbsoluteTolerance'](arg_absoluteTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{32BB5026-A93C-41F7-ADE8-0A04A43627BC}', IAgCrdnSamplingRelativeTolerance)
agcls.AgTypeNameMap['IAgCrdnSamplingRelativeTolerance'] = IAgCrdnSamplingRelativeTolerance
__all__.append('IAgCrdnSamplingRelativeTolerance')

class IAgCrdnSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    _uuid = '{84F129C1-1D47-4FE2-B87B-013BEF12269C}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_SetDurationKind'] = _raise_uninitialized_error
        self.__dict__['_GetIntervalDuration'] = _raise_uninitialized_error
        self.__dict__['_SetIntervalDuration'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSatisfactionConditionFilter from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSatisfactionConditionFilter = agcom.GUID(IAgCrdnSatisfactionConditionFilter._uuid)
        vtable_offset_local = IAgCrdnSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetDurationKind'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetIntervalDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSatisfactionConditionFilter.__dict__ and type(IAgCrdnSatisfactionConditionFilter.__dict__[attrname]) == property:
            return IAgCrdnSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSatisfactionConditionFilter.')
    
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, IAgCrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationKind'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__['_SetDurationKind'](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """A duration of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervalDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__['_SetIntervalDuration'](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{84F129C1-1D47-4FE2-B87B-013BEF12269C}', IAgCrdnSatisfactionConditionFilter)
agcls.AgTypeNameMap['IAgCrdnSatisfactionConditionFilter'] = IAgCrdnSatisfactionConditionFilter
__all__.append('IAgCrdnSatisfactionConditionFilter')

class IAgCrdnSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = '{5ED53953-1C55-431D-88AF-1AF23B2FE424}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSignalDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSignalDelay from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSignalDelay = agcom.GUID(IAgCrdnSignalDelay._uuid)
        vtable_offset_local = IAgCrdnSignalDelay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSignalDelay.__dict__ and type(IAgCrdnSignalDelay.__dict__[attrname]) == property:
            return IAgCrdnSignalDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSignalDelay.')
    

agcls.AgClassCatalog.add_catalog_entry('{5ED53953-1C55-431D-88AF-1AF23B2FE424}', IAgCrdnSignalDelay)
agcls.AgTypeNameMap['IAgCrdnSignalDelay'] = IAgCrdnSignalDelay
__all__.append('IAgCrdnSignalDelay')

class IAgCrdnSignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = '{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSignalPathReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetSignalPathReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetSpeedOption'] = _raise_uninitialized_error
        self.__dict__['_SetSpeedOption'] = _raise_uninitialized_error
        self.__dict__['_GetTransferSpeed'] = _raise_uninitialized_error
        self.__dict__['_SetTransferSpeed'] = _raise_uninitialized_error
        self.__dict__['_GetTimeDelayConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetTimeDelayConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSignalDelayBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSignalDelayBasic from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSignalDelayBasic = agcom.GUID(IAgCrdnSignalDelayBasic._uuid)
        vtable_offset_local = IAgCrdnSignalDelayBasic._vtable_offset - 1
        self.__dict__['_GetSignalPathReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetSignalPathReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetSpeedOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetSpeedOption'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+6, agcom.LONG)
        self.__dict__['_GetTransferSpeed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTransferSpeed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetTimeDelayConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeDelayConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSignalDelayBasic, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSignalDelayBasic.__dict__ and type(IAgCrdnSignalDelayBasic.__dict__[attrname]) == property:
            return IAgCrdnSignalDelayBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSignalDelayBasic.')
    
    @property
    def SignalPathReferenceSystem(self) -> "AgECrdnSignalPathReferenceSystem":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalPathReferenceSystem'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalPathReferenceSystem.setter
    def SignalPathReferenceSystem(self, signalPathReferenceSystem:"AgECrdnSignalPathReferenceSystem") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem, signalPathReferenceSystem) as arg_signalPathReferenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetSignalPathReferenceSystem'](arg_signalPathReferenceSystem.COM_val))

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def SpeedOption(self) -> "AgECrdnSpeedOptions":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpeedOption'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedOption.setter
    def SpeedOption(self, speedOption:"AgECrdnSpeedOptions") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions, speedOption) as arg_speedOption:
            agcls.evaluate_hresult(self.__dict__['_SetSpeedOption'](arg_speedOption.COM_val))

    @property
    def TransferSpeed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTransferSpeed'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TransferSpeed.setter
    def TransferSpeed(self, transferSpeed:float) -> None:
        with agmarshall.DOUBLE_arg(transferSpeed) as arg_transferSpeed:
            agcls.evaluate_hresult(self.__dict__['_SetTransferSpeed'](arg_transferSpeed.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeDelayConvergence'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__['_SetTimeDelayConvergence'](arg_timeDelayConvergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}', IAgCrdnSignalDelayBasic)
agcls.AgTypeNameMap['IAgCrdnSignalDelayBasic'] = IAgCrdnSignalDelayBasic
__all__.append('IAgCrdnSignalDelayBasic')

class IAgCrdnVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""
    _uuid = '{42eb6d4a-5cff-471f-997d-3f624cb4a416}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcAltitude'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcAngleOffVector'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcFile'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcFromScalar'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcSolarIntensity'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcVolumeSatisfactionMetric'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcRange'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCalcDelayRange'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcFactory = agcom.GUID(IAgCrdnVolumeCalcFactory._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcFactory._vtable_offset - 1
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcAngleOffVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcFromScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcSolarIntensity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcVolumeSatisfactionMetric'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeCalcDelayRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFactory.__dict__ and type(IAgCrdnVolumeCalcFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcFactory.')
    
    def IsTypeSupported(self, eType:"AgECrdnVolumeCalcType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnVolumeCalcType") -> "IAgCrdnVolumeCalc":
        """Creates and registers a volume calc using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAltitude(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a altitude to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcAltitude'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAngleOffVector(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a angle to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcAngleOffVector'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFile(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a file volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcFile'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFromScalar(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a scalar to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcFromScalar'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcSolarIntensity(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a solar intensity volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcSolarIntensity'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcVolumeSatisfactionMetric(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcVolumeSatisfactionMetric'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcRange(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcRange'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcDelayRange(self, name:str, description:str) -> "IAgCrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCalcDelayRange'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{42eb6d4a-5cff-471f-997d-3f624cb4a416}', IAgCrdnVolumeCalcFactory)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcFactory'] = IAgCrdnVolumeCalcFactory
__all__.append('IAgCrdnVolumeCalcFactory')

class IAgCrdnVolumeFactory(object):
    """The factory is used to create instances of volumes."""
    _uuid = '{FE97990E-A152-417C-883E-64C42AB9B913}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeCombined'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeLighting'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeOverTime'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeFromGrid'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeFromCalc'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeFromTimeSatisfaction'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeFromCondition'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeInview'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeFactory = agcom.GUID(IAgCrdnVolumeFactory._uuid)
        vtable_offset_local = IAgCrdnVolumeFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateVolumeCombined'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeLighting'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeOverTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeFromGrid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeFromCalc'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeFromTimeSatisfaction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeFromCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeInview'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFactory.__dict__ and type(IAgCrdnVolumeFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeType") -> "IAgCrdnVolume":
        """Creates and registers a volume using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeCombined(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type combined."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeCombined'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeLighting(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type lighting."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeLighting'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeOverTime(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type over time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeOverTime'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromGrid(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from grid."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeFromGrid'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCalc(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from calc."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeFromCalc'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromTimeSatisfaction(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type from time satisfaction."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeFromTimeSatisfaction'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCondition(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type condition."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeFromCondition'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeInview(self, name:str, description:str) -> "IAgCrdnVolume":
        """Creates a volume type Inview."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeInview'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{FE97990E-A152-417C-883E-64C42AB9B913}', IAgCrdnVolumeFactory)
agcls.AgTypeNameMap['IAgCrdnVolumeFactory'] = IAgCrdnVolumeFactory
__all__.append('IAgCrdnVolumeFactory')

class IAgCrdnVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""
    _uuid = '{4533DEA1-D754-4579-A79D-B5A639C2CD39}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridCartesian'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridCylindrical'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridSpherical'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridConstrained'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridLatLonAlt'] = _raise_uninitialized_error
        self.__dict__['_CreateVolumeGridBearingAlt'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridFactory = agcom.GUID(IAgCrdnVolumeGridFactory._uuid)
        vtable_offset_local = IAgCrdnVolumeGridFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeGridCartesian'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateVolumeGridCylindrical'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeGridSpherical'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeGridConstrained'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeGridLatLonAlt'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateVolumeGridBearingAlt'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridFactory.__dict__ and type(IAgCrdnVolumeGridFactory.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridFactory.')
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeGridType") -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeGridType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridCartesian(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a cartesian volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridCartesian'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeGridType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeGridType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeGridCylindrical(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a cylindrical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridCylindrical'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridSpherical(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a spherical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridSpherical'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridConstrained(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridConstrained'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridLatLonAlt(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers cartographic volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridLatLonAlt'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridBearingAlt(self, name:str, description:str) -> "IAgCrdnVolumeGrid":
        """Creates and registers a volume grid of type surface bearing using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVolumeGridBearingAlt'](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{4533DEA1-D754-4579-A79D-B5A639C2CD39}', IAgCrdnVolumeGridFactory)
agcls.AgTypeNameMap['IAgCrdnVolumeGridFactory'] = IAgCrdnVolumeGridFactory
__all__.append('IAgCrdnVolumeGridFactory')

class IAgCrdnGridCoordinateDefinition(object):
    """Defines a set of coordinate values."""
    _uuid = '{96875D1C-9CBC-4732-A678-2CB17995C0E9}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMethodType'] = _raise_uninitialized_error
        self.__dict__['_GetGridValuesMethod'] = _raise_uninitialized_error
        self.__dict__['_SetGridValuesFixedStep'] = _raise_uninitialized_error
        self.__dict__['_SetGridValuesFixedNumberOfSteps'] = _raise_uninitialized_error
        self.__dict__['_SetGridValuesCustom'] = _raise_uninitialized_error
        self.__dict__['_SetGridValuesFixedNumberOfStepsEx'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGridCoordinateDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGridCoordinateDefinition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGridCoordinateDefinition = agcom.GUID(IAgCrdnGridCoordinateDefinition._uuid)
        vtable_offset_local = IAgCrdnGridCoordinateDefinition._vtable_offset - 1
        self.__dict__['_GetMethodType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_GetGridValuesMethod'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_SetGridValuesFixedStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+3, agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_SetGridValuesFixedNumberOfSteps'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+4, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__['_SetGridValuesCustom'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+5, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__['_SetGridValuesFixedNumberOfStepsEx'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridCoordinateDefinition, vtable_offset_local+6, agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridCoordinateDefinition.__dict__ and type(IAgCrdnGridCoordinateDefinition.__dict__[attrname]) == property:
            return IAgCrdnGridCoordinateDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGridCoordinateDefinition.')
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMethodType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def GridValuesMethod(self) -> "IAgCrdnGridValuesMethod":
        """Sets/Returns the grid values interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetGridValuesMethod'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedStep(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "IAgCrdnGridValuesFixedStep":
        """Sets grid values type to fixed step."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax, \
             agmarshall.DOUBLE_arg(refValue) as arg_refValue, \
             agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_SetGridValuesFixedStep'](arg_min.COM_val, arg_max.COM_val, arg_includeMinMax.COM_val, arg_refValue.COM_val, arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfSteps(self, min:float, max:float, numSteps:int) -> "IAgCrdnGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_SetGridValuesFixedNumberOfSteps'](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesCustom(self, values:list) -> "IAgCrdnGridValuesCustom":
        """Sets grid values type to custom values."""
        with agmarshall.SAFEARRAY_arg(values) as arg_values, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_SetGridValuesCustom'](byref(arg_values.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfStepsEx(self, min:"IAgQuantity", max:"IAgQuantity", numSteps:int) -> "IAgCrdnGridValuesFixedNumberOfSteps":
        """Sets grid values type to fixed number of steps with min and max as IAgQuantity"""
        with agmarshall.AgInterface_in_arg(min, IAgQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IAgQuantity) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_SetGridValuesFixedNumberOfStepsEx'](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{96875D1C-9CBC-4732-A678-2CB17995C0E9}', IAgCrdnGridCoordinateDefinition)
agcls.AgTypeNameMap['IAgCrdnGridCoordinateDefinition'] = IAgCrdnGridCoordinateDefinition
__all__.append('IAgCrdnGridCoordinateDefinition')

class IAgCrdnGridValuesCustom(object):
    """Fixed step grid values."""
    _uuid = '{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetValues'] = _raise_uninitialized_error
        self.__dict__['_SetValues'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGridValuesCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGridValuesCustom from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGridValuesCustom = agcom.GUID(IAgCrdnGridValuesCustom._uuid)
        vtable_offset_local = IAgCrdnGridValuesCustom._vtable_offset - 1
        self.__dict__['_GetValues'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesCustom, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetValues'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesCustom, vtable_offset_local+2, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesCustom.__dict__ and type(IAgCrdnGridValuesCustom.__dict__[attrname]) == property:
            return IAgCrdnGridValuesCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGridValuesCustom.')
    
    @property
    def Values(self) -> list:
        """Custom set of coordinate values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetValues'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Values.setter
    def Values(self, values:list) -> None:
        with agmarshall.SAFEARRAY_arg(values) as arg_values:
            agcls.evaluate_hresult(self.__dict__['_SetValues'](arg_values.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}', IAgCrdnGridValuesCustom)
agcls.AgTypeNameMap['IAgCrdnGridValuesCustom'] = IAgCrdnGridValuesCustom
__all__.append('IAgCrdnGridValuesCustom')

class IAgCrdnGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""
    _uuid = '{379ACEFA-1B1E-4753-BA9A-87939E5B8893}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMin'] = _raise_uninitialized_error
        self.__dict__['_SetMin'] = _raise_uninitialized_error
        self.__dict__['_GetMax'] = _raise_uninitialized_error
        self.__dict__['_SetMax'] = _raise_uninitialized_error
        self.__dict__['_GetNumberOfSteps'] = _raise_uninitialized_error
        self.__dict__['_SetNumberOfSteps'] = _raise_uninitialized_error
        self.__dict__['_GetMinEx'] = _raise_uninitialized_error
        self.__dict__['_SetMinEx'] = _raise_uninitialized_error
        self.__dict__['_GetMaxEx'] = _raise_uninitialized_error
        self.__dict__['_SetMaxEx'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGridValuesFixedNumberOfSteps._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGridValuesFixedNumberOfSteps from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGridValuesFixedNumberOfSteps = agcom.GUID(IAgCrdnGridValuesFixedNumberOfSteps._uuid)
        vtable_offset_local = IAgCrdnGridValuesFixedNumberOfSteps._vtable_offset - 1
        self.__dict__['_GetMin'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMin'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetNumberOfSteps'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__['_SetNumberOfSteps'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+6, agcom.INT)
        self.__dict__['_GetMinEx'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetMinEx'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetMaxEx'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetMaxEx'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedNumberOfSteps, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesFixedNumberOfSteps.__dict__ and type(IAgCrdnGridValuesFixedNumberOfSteps.__dict__[attrname]) == property:
            return IAgCrdnGridValuesFixedNumberOfSteps.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGridValuesFixedNumberOfSteps.')
    
    @property
    def Min(self) -> float:
        """This property is deprecated. Use MinEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMin'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__['_SetMin'](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMax'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__['_SetMax'](arg_max.COM_val))

    @property
    def NumberOfSteps(self) -> int:
        """The number of steps between coordinate values."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNumberOfSteps'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NumberOfSteps.setter
    def NumberOfSteps(self, numberOfSteps:int) -> None:
        with agmarshall.INT_arg(numberOfSteps) as arg_numberOfSteps:
            agcls.evaluate_hresult(self.__dict__['_SetNumberOfSteps'](arg_numberOfSteps.COM_val))

    @property
    def MinEx(self) -> "IAgQuantity":
        """Minimum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinEx'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MinEx.setter
    def MinEx(self, minEx:"IAgQuantity") -> None:
        with agmarshall.AgInterface_in_arg(minEx, IAgQuantity) as arg_minEx:
            agcls.evaluate_hresult(self.__dict__['_SetMinEx'](arg_minEx.COM_val))

    @property
    def MaxEx(self) -> "IAgQuantity":
        """Maximum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaxEx'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MaxEx.setter
    def MaxEx(self, maxEx:"IAgQuantity") -> None:
        with agmarshall.AgInterface_in_arg(maxEx, IAgQuantity) as arg_maxEx:
            agcls.evaluate_hresult(self.__dict__['_SetMaxEx'](arg_maxEx.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{379ACEFA-1B1E-4753-BA9A-87939E5B8893}', IAgCrdnGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap['IAgCrdnGridValuesFixedNumberOfSteps'] = IAgCrdnGridValuesFixedNumberOfSteps
__all__.append('IAgCrdnGridValuesFixedNumberOfSteps')

class IAgCrdnGridValuesFixedStep(object):
    """Fixed step grid values."""
    _uuid = '{7C18BF81-7E22-4A28-B462-37ED86EC3050}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMin'] = _raise_uninitialized_error
        self.__dict__['_SetMin'] = _raise_uninitialized_error
        self.__dict__['_GetMax'] = _raise_uninitialized_error
        self.__dict__['_SetMax'] = _raise_uninitialized_error
        self.__dict__['_GetIncludeMinMax'] = _raise_uninitialized_error
        self.__dict__['_SetIncludeMinMax'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceValue'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceValue'] = _raise_uninitialized_error
        self.__dict__['_GetStep'] = _raise_uninitialized_error
        self.__dict__['_SetStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGridValuesFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGridValuesFixedStep from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGridValuesFixedStep = agcom.GUID(IAgCrdnGridValuesFixedStep._uuid)
        vtable_offset_local = IAgCrdnGridValuesFixedStep._vtable_offset - 1
        self.__dict__['_GetMin'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMin'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetIncludeMinMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIncludeMinMax'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetReferenceValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetReferenceValue'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesFixedStep, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesFixedStep.__dict__ and type(IAgCrdnGridValuesFixedStep.__dict__[attrname]) == property:
            return IAgCrdnGridValuesFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGridValuesFixedStep.')
    
    @property
    def Min(self) -> float:
        """Minimum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMin'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__['_SetMin'](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """Maximum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMax'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__['_SetMax'](arg_max.COM_val))

    @property
    def IncludeMinMax(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncludeMinMax'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeMinMax.setter
    def IncludeMinMax(self, includeMinMax:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax:
            agcls.evaluate_hresult(self.__dict__['_SetIncludeMinMax'](arg_includeMinMax.COM_val))

    @property
    def ReferenceValue(self) -> float:
        """Reference coordinate value from which steps are taken."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceValue'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceValue.setter
    def ReferenceValue(self, referenceValue:float) -> None:
        with agmarshall.DOUBLE_arg(referenceValue) as arg_referenceValue:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceValue'](arg_referenceValue.COM_val))

    @property
    def Step(self) -> float:
        """Step between subsequent coordinate values."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__['_SetStep'](arg_step.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7C18BF81-7E22-4A28-B462-37ED86EC3050}', IAgCrdnGridValuesFixedStep)
agcls.AgTypeNameMap['IAgCrdnGridValuesFixedStep'] = IAgCrdnGridValuesFixedStep
__all__.append('IAgCrdnGridValuesFixedStep')

class IAgCrdnGridValuesMethod(object):
    """A grid values method."""
    _uuid = '{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetMethodType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnGridValuesMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnGridValuesMethod from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnGridValuesMethod = agcom.GUID(IAgCrdnGridValuesMethod._uuid)
        vtable_offset_local = IAgCrdnGridValuesMethod._vtable_offset - 1
        self.__dict__['_GetMethodType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnGridValuesMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnGridValuesMethod.__dict__ and type(IAgCrdnGridValuesMethod.__dict__[attrname]) == property:
            return IAgCrdnGridValuesMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnGridValuesMethod.')
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMethodType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}', IAgCrdnGridValuesMethod)
agcls.AgTypeNameMap['IAgCrdnGridValuesMethod'] = IAgCrdnGridValuesMethod
__all__.append('IAgCrdnGridValuesMethod')

class IAgCrdnLightTimeDelay(object):
    """Manage Light Time Delay options.."""
    _uuid = '{82765B62-B9AB-4D52-900E-52ADAC0365D0}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetUseLightTimeDelay'] = _raise_uninitialized_error
        self.__dict__['_SetUseLightTimeDelay'] = _raise_uninitialized_error
        self.__dict__['_GetTimeDelayConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetTimeDelayConvergence'] = _raise_uninitialized_error
        self.__dict__['_GetAberrationType'] = _raise_uninitialized_error
        self.__dict__['_SetAberrationType'] = _raise_uninitialized_error
        self.__dict__['_GetClockHost'] = _raise_uninitialized_error
        self.__dict__['_SetClockHost'] = _raise_uninitialized_error
        self.__dict__['_GetTimeSense'] = _raise_uninitialized_error
        self.__dict__['_SetTimeSense'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnLightTimeDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnLightTimeDelay from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnLightTimeDelay = agcom.GUID(IAgCrdnLightTimeDelay._uuid)
        vtable_offset_local = IAgCrdnLightTimeDelay._vtable_offset - 1
        self.__dict__['_GetUseLightTimeDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseLightTimeDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__['_GetTimeDelayConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetTimeDelayConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetAberrationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetAberrationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+6, agcom.LONG)
        self.__dict__['_GetClockHost'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetClockHost'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetTimeSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetTimeSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLightTimeDelay, vtable_offset_local+10, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLightTimeDelay.__dict__ and type(IAgCrdnLightTimeDelay.__dict__[attrname]) == property:
            return IAgCrdnLightTimeDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnLightTimeDelay.')
    
    @property
    def UseLightTimeDelay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseLightTimeDelay'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, useLightTimeDelay:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useLightTimeDelay) as arg_useLightTimeDelay:
            agcls.evaluate_hresult(self.__dict__['_SetUseLightTimeDelay'](arg_useLightTimeDelay.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Set light Time Delay Convergence."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeDelayConvergence'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__['_SetTimeDelayConvergence'](arg_timeDelayConvergence.COM_val))

    @property
    def AberrationType(self) -> "AgECrdnVolumeAberrationType":
        """Method used to Aberration Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAberrationType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AberrationType.setter
    def AberrationType(self, aberrationType:"AgECrdnVolumeAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType, aberrationType) as arg_aberrationType:
            agcls.evaluate_hresult(self.__dict__['_SetAberrationType'](arg_aberrationType.COM_val))

    @property
    def ClockHost(self) -> "AgECrdnVolumeClockHostType":
        """Indicates whether object1 or object2 of an Access instance holds the clock for Access times."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetClockHost'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockHost.setter
    def ClockHost(self, clockHost:"AgECrdnVolumeClockHostType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType, clockHost) as arg_clockHost:
            agcls.evaluate_hresult(self.__dict__['_SetClockHost'](arg_clockHost.COM_val))

    @property
    def TimeSense(self) -> "AgECrdnVolumeTimeSenseType":
        """Indicates whether apparent position is computed in a transmit or receive sense"""
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeSense.setter
    def TimeSense(self, timeSense:"AgECrdnVolumeTimeSenseType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType, timeSense) as arg_timeSense:
            agcls.evaluate_hresult(self.__dict__['_SetTimeSense'](arg_timeSense.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{82765B62-B9AB-4D52-900E-52ADAC0365D0}', IAgCrdnLightTimeDelay)
agcls.AgTypeNameMap['IAgCrdnLightTimeDelay'] = IAgCrdnLightTimeDelay
__all__.append('IAgCrdnLightTimeDelay')

class IAgCrdnVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    _uuid = '{F85958EC-F470-432F-81B1-8517D3952F1E}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolume from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolume = agcom.GUID(IAgCrdnVolume._uuid)
        vtable_offset_local = IAgCrdnVolume._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolume.__dict__ and type(IAgCrdnVolume.__dict__[attrname]) == property:
            return IAgCrdnVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolume.')
    

agcls.AgClassCatalog.add_catalog_entry('{F85958EC-F470-432F-81B1-8517D3952F1E}', IAgCrdnVolume)
agcls.AgTypeNameMap['IAgCrdnVolume'] = IAgCrdnVolume
__all__.append('IAgCrdnVolume')

class IAgCrdnVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    _uuid = '{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalc from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalc = agcom.GUID(IAgCrdnVolumeCalc._uuid)
        vtable_offset_local = IAgCrdnVolumeCalc._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalc.__dict__ and type(IAgCrdnVolumeCalc.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalc.')
    

agcls.AgClassCatalog.add_catalog_entry('{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}', IAgCrdnVolumeCalc)
agcls.AgTypeNameMap['IAgCrdnVolumeCalc'] = IAgCrdnVolumeCalc
__all__.append('IAgCrdnVolumeCalc')

class IAgCrdnVolumeCalcAltitude(object):
    """A volume calc altitude interface."""
    _uuid = '{6039868a-acea-4918-966b-c6f952fd94d3}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetShapeModel'] = _raise_uninitialized_error
        self.__dict__['_SetShapeModel'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomReference'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomReference'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcAltitude from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcAltitude = agcom.GUID(IAgCrdnVolumeCalcAltitude._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcAltitude._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetShapeModel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetShapeModel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetUseCustomReference'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomReference'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAltitude, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcAltitude.__dict__ and type(IAgCrdnVolumeCalcAltitude.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcAltitude.')
    
    @property
    def CentralBody(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))

    @property
    def ShapeModel(self) -> "AgECrdnVolumeCalcAltitudeReferenceType":
        """The Volume Calc Altitude Reference Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetShapeModel'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ShapeModel.setter
    def ShapeModel(self, shapeModel:"AgECrdnVolumeCalcAltitudeReferenceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType, shapeModel) as arg_shapeModel:
            agcls.evaluate_hresult(self.__dict__['_SetShapeModel'](arg_shapeModel.COM_val))

    @property
    def UseCustomReference(self) -> bool:
        """Whether to use custom reference."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomReference'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomReference.setter
    def UseCustomReference(self, useCustomReference:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomReference) as arg_useCustomReference:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomReference'](arg_useCustomReference.COM_val))

    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IAgCrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePoint'](arg_referencePoint.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{6039868a-acea-4918-966b-c6f952fd94d3}', IAgCrdnVolumeCalcAltitude)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcAltitude'] = IAgCrdnVolumeCalcAltitude
__all__.append('IAgCrdnVolumeCalcAltitude')

class IAgCrdnVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""
    _uuid = '{ad6880b4-afc1-47ba-b964-f38916955c7b}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_SetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetAboutVector'] = _raise_uninitialized_error
        self.__dict__['_SetAboutVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcAngleOffVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcAngleOffVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcAngleOffVector = agcom.GUID(IAgCrdnVolumeCalcAngleOffVector._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcAngleOffVector._vtable_offset - 1
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetAboutVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetAboutVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcAngleOffVector, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcAngleOffVector.__dict__ and type(IAgCrdnVolumeCalcAngleOffVector.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcAngleOffVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcAngleOffVector.')
    
    @property
    def Angle(self) -> "AgECrdnVolumeCalcAngleOffVectorType":
        """The Volume Calc Angle Off Vector Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Angle.setter
    def Angle(self, angle:"AgECrdnVolumeCalcAngleOffVectorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType, angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__['_SetAngle'](arg_angle.COM_val))

    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IAgCrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePlane'](arg_referencePlane.COM_val))

    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Angle Off Vector reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IAgCrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePoint'](arg_referencePoint.COM_val))

    @property
    def ReferenceVector(self) -> "IAgCrdnVector":
        """The Volume Calc Angle Off Vector reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVector.setter
    def ReferenceVector(self, referenceVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(referenceVector, IAgCrdnVector) as arg_referenceVector:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceVector'](arg_referenceVector.COM_val))

    @property
    def AboutVector(self) -> "IAgCrdnVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAboutVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AboutVector.setter
    def AboutVector(self, aboutVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(aboutVector, IAgCrdnVector) as arg_aboutVector:
            agcls.evaluate_hresult(self.__dict__['_SetAboutVector'](arg_aboutVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{ad6880b4-afc1-47ba-b964-f38916955c7b}', IAgCrdnVolumeCalcAngleOffVector)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcAngleOffVector'] = IAgCrdnVolumeCalcAngleOffVector
__all__.append('IAgCrdnVolumeCalcAngleOffVector')

class IAgCrdnVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""
    _uuid = '{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}'
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSpatialCondition'] = _raise_uninitialized_error
        self.__dict__['_SetSpatialCondition'] = _raise_uninitialized_error
        self.__dict__['_GetSatisfactionMetric'] = _raise_uninitialized_error
        self.__dict__['_SetSatisfactionMetric'] = _raise_uninitialized_error
        self.__dict__['_GetAccumulationType'] = _raise_uninitialized_error
        self.__dict__['_SetAccumulationType'] = _raise_uninitialized_error
        self.__dict__['_GetDurationType'] = _raise_uninitialized_error
        self.__dict__['_SetDurationType'] = _raise_uninitialized_error
        self.__dict__['_GetFilter'] = _raise_uninitialized_error
        self.__dict__['_SetFilter'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumNumberOfIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetUseMinimumDuration'] = _raise_uninitialized_error
        self.__dict__['_SetUseMinimumDuration'] = _raise_uninitialized_error
        self.__dict__['_GetUseMaximumDuration'] = _raise_uninitialized_error
        self.__dict__['_SetUseMaximumDuration'] = _raise_uninitialized_error
        self.__dict__['_GetMinimumDurationTime'] = _raise_uninitialized_error
        self.__dict__['_SetMinimumDurationTime'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumDurationTime'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumDurationTime'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcConditionSatMetric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcConditionSatMetric from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcConditionSatMetric = agcom.GUID(IAgCrdnVolumeCalcConditionSatMetric._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcConditionSatMetric._vtable_offset - 1
        self.__dict__['_GetSpatialCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetSpatialCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSatisfactionMetric'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSatisfactionMetric'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetAccumulationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetAccumulationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+6, agcom.LONG)
        self.__dict__['_GetDurationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetDurationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetFilter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetFilter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+10, agcom.LONG)
        self.__dict__['_GetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+11, POINTER(agcom.INT))
        self.__dict__['_SetMaximumNumberOfIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+12, agcom.INT)
        self.__dict__['_GetUseMinimumDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMinimumDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__['_GetUseMaximumDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMaximumDuration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__['_GetMinimumDurationTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMinimumDurationTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__['_GetMaximumDurationTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMaximumDurationTime'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcConditionSatMetric, vtable_offset_local+20, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcConditionSatMetric.__dict__ and type(IAgCrdnVolumeCalcConditionSatMetric.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcConditionSatMetric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcConditionSatMetric.')
    
    @property
    def SpatialCondition(self) -> "IAgCrdnVolume":
        """A spatial condition for satisfaction metric."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpatialCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SpatialCondition.setter
    def SpatialCondition(self, spatialCondition:"IAgCrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(spatialCondition, IAgCrdnVolume) as arg_spatialCondition:
            agcls.evaluate_hresult(self.__dict__['_SetSpatialCondition'](arg_spatialCondition.COM_val))

    @property
    def SatisfactionMetric(self) -> "AgECrdnVolumeCalcVolumeSatisfactionMetricType":
        """Sspatial condition satisfaction metric types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSatisfactionMetric'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionMetric.setter
    def SatisfactionMetric(self, satisfactionMetric:"AgECrdnVolumeCalcVolumeSatisfactionMetricType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType, satisfactionMetric) as arg_satisfactionMetric:
            agcls.evaluate_hresult(self.__dict__['_SetSatisfactionMetric'](arg_satisfactionMetric.COM_val))

    @property
    def AccumulationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType":
        """Spatial condition satisfaction accumulation types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAccumulationType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AccumulationType.setter
    def AccumulationType(self, accumulationType:"AgECrdnVolumeCalcVolumeSatisfactionAccumulationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType, accumulationType) as arg_accumulationType:
            agcls.evaluate_hresult(self.__dict__['_SetAccumulationType'](arg_accumulationType.COM_val))

    @property
    def DurationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionDurationType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeCalcVolumeSatisfactionDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__['_SetDurationType'](arg_durationType.COM_val))

    @property
    def Filter(self) -> "AgECrdnVolumeCalcVolumeSatisfactionFilterType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilter'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"AgECrdnVolumeCalcVolumeSatisfactionFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType, filter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__['_SetFilter'](arg_filter.COM_val))

    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumNumberOfIntervals'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumNumberOfIntervals'](arg_maximumNumberOfIntervals.COM_val))

    @property
    def UseMinimumDuration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMinimumDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumDuration.setter
    def UseMinimumDuration(self, useMinimumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumDuration) as arg_useMinimumDuration:
            agcls.evaluate_hresult(self.__dict__['_SetUseMinimumDuration'](arg_useMinimumDuration.COM_val))

    @property
    def UseMaximumDuration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMaximumDuration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumDuration.setter
    def UseMaximumDuration(self, useMaximumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumDuration) as arg_useMaximumDuration:
            agcls.evaluate_hresult(self.__dict__['_SetUseMaximumDuration'](arg_useMaximumDuration.COM_val))

    @property
    def MinimumDurationTime(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimumDurationTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumDurationTime.setter
    def MinimumDurationTime(self, minimumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDurationTime) as arg_minimumDurationTime:
            agcls.evaluate_hresult(self.__dict__['_SetMinimumDurationTime'](arg_minimumDurationTime.COM_val))

    @property
    def MaximumDurationTime(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumDurationTime'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumDurationTime.setter
    def MaximumDurationTime(self, maximumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDurationTime) as arg_maximumDurationTime:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumDurationTime'](arg_maximumDurationTime.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}', IAgCrdnVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcConditionSatMetric'] = IAgCrdnVolumeCalcConditionSatMetric
__all__.append('IAgCrdnVolumeCalcConditionSatMetric')

class IAgCrdnVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""
    _uuid = '{874bf6c9-20d7-486c-918a-a0094093879a}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDistance'] = _raise_uninitialized_error
        self.__dict__['_SetDistance'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_GetAlongVector'] = _raise_uninitialized_error
        self.__dict__['_SetAlongVector'] = _raise_uninitialized_error
        self.__dict__['_GetSpeedType'] = _raise_uninitialized_error
        self.__dict__['_SetSpeedType'] = _raise_uninitialized_error
        self.__dict__['_GetSpeed'] = _raise_uninitialized_error
        self.__dict__['_SetSpeed'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcDelayRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcDelayRange from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcDelayRange = agcom.GUID(IAgCrdnVolumeCalcDelayRange._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcDelayRange._vtable_offset - 1
        self.__dict__['_GetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetSpeedType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetSpeedType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+10, agcom.LONG)
        self.__dict__['_GetSpeed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__['_SetSpeed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcDelayRange, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcDelayRange.__dict__ and type(IAgCrdnVolumeCalcDelayRange.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcDelayRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcDelayRange.')
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDistance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__['_SetDistance'](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IAgCrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePoint'](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IAgCrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePlane'](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlongVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IAgCrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__['_SetAlongVector'](arg_alongVector.COM_val))

    @property
    def SpeedType(self) -> "AgECrdnVolumeCalcRangeSpeedType":
        """The Volume Calc range speed types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpeedType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedType.setter
    def SpeedType(self, speedType:"AgECrdnVolumeCalcRangeSpeedType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType, speedType) as arg_speedType:
            agcls.evaluate_hresult(self.__dict__['_SetSpeedType'](arg_speedType.COM_val))

    @property
    def Speed(self) -> float:
        """The Volume Calc range speed value"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpeed'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Speed.setter
    def Speed(self, speed:float) -> None:
        with agmarshall.DOUBLE_arg(speed) as arg_speed:
            agcls.evaluate_hresult(self.__dict__['_SetSpeed'](arg_speed.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{874bf6c9-20d7-486c-918a-a0094093879a}', IAgCrdnVolumeCalcDelayRange)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcDelayRange'] = IAgCrdnVolumeCalcDelayRange
__all__.append('IAgCrdnVolumeCalcDelayRange')

class IAgCrdnVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    _uuid = '{362b7405-edf6-486c-8fcf-1f9a93b75000}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        self.__dict__['_Reload'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcFile from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcFile = agcom.GUID(IAgCrdnVolumeCalcFile._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcFile._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_Reload'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFile, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFile.__dict__ and type(IAgCrdnVolumeCalcFile.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcFile.')
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the volume calc file."""
        agcls.evaluate_hresult(self.__dict__['_Reload']())


agcls.AgClassCatalog.add_catalog_entry('{362b7405-edf6-486c-8fcf-1f9a93b75000}', IAgCrdnVolumeCalcFile)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcFile'] = IAgCrdnVolumeCalcFile
__all__.append('IAgCrdnVolumeCalcFile')

class IAgCrdnVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""
    _uuid = '{6e537b27-ee55-44c5-89b2-f2c504a44bb6}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetScalar'] = _raise_uninitialized_error
        self.__dict__['_SetScalar'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcFromScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcFromScalar from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcFromScalar = agcom.GUID(IAgCrdnVolumeCalcFromScalar._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcFromScalar._vtable_offset - 1
        self.__dict__['_GetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFromScalar, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcFromScalar, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcFromScalar.__dict__ and type(IAgCrdnVolumeCalcFromScalar.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcFromScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcFromScalar.')
    
    @property
    def Scalar(self) -> "IAgCrdnCalcScalar":
        """The Volume calc scalar to location Type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, IAgCrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__['_SetScalar'](arg_scalar.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{6e537b27-ee55-44c5-89b2-f2c504a44bb6}', IAgCrdnVolumeCalcFromScalar)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcFromScalar'] = IAgCrdnVolumeCalcFromScalar
__all__.append('IAgCrdnVolumeCalcFromScalar')

class IAgCrdnVolumeCalcRange(object):
    """A volume calc distance to location interface."""
    _uuid = '{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDistance'] = _raise_uninitialized_error
        self.__dict__['_SetDistance'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_GetAlongVector'] = _raise_uninitialized_error
        self.__dict__['_SetAlongVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcRange from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcRange = agcom.GUID(IAgCrdnVolumeCalcRange._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcRange._vtable_offset - 1
        self.__dict__['_GetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcRange, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcRange.__dict__ and type(IAgCrdnVolumeCalcRange.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcRange.')
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDistance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__['_SetDistance'](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IAgCrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePoint'](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "IAgCrdnPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"IAgCrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, IAgCrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePlane'](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlongVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IAgCrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__['_SetAlongVector'](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}', IAgCrdnVolumeCalcRange)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcRange'] = IAgCrdnVolumeCalcRange
__all__.append('IAgCrdnVolumeCalcRange')

class IAgCrdnVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""
    _uuid = '{40e35f2b-9a83-449a-9a4e-35bdee832061}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_GetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCalcSolarIntensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCalcSolarIntensity from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCalcSolarIntensity = agcom.GUID(IAgCrdnVolumeCalcSolarIntensity._uuid)
        vtable_offset_local = IAgCrdnVolumeCalcSolarIntensity._vtable_offset - 1
        self.__dict__['_GetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcSolarIntensity, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcSolarIntensity, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__['_GetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcSolarIntensity, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCalcSolarIntensity, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCalcSolarIntensity.__dict__ and type(IAgCrdnVolumeCalcSolarIntensity.__dict__[attrname]) == property:
            return IAgCrdnVolumeCalcSolarIntensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCalcSolarIntensity.')
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEclipsingBodies'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetEclipsingBodies'](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseObjectEclipsingBodies'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetUseObjectEclipsingBodies'](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{40e35f2b-9a83-449a-9a4e-35bdee832061}', IAgCrdnVolumeCalcSolarIntensity)
agcls.AgTypeNameMap['IAgCrdnVolumeCalcSolarIntensity'] = IAgCrdnVolumeCalcSolarIntensity
__all__.append('IAgCrdnVolumeCalcSolarIntensity')

class IAgCrdnVolumeCombined(object):
    """A combined volume interface."""
    _uuid = '{96684FB4-3839-44DB-AD80-B772BF58A39A}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCombineOperation'] = _raise_uninitialized_error
        self.__dict__['_SetCombineOperation'] = _raise_uninitialized_error
        self.__dict__['_GetConditionCount'] = _raise_uninitialized_error
        self.__dict__['_GetAllConditions'] = _raise_uninitialized_error
        self.__dict__['_SetAllConditions'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_RemoveCondition'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeCombined from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeCombined = agcom.GUID(IAgCrdnVolumeCombined._uuid)
        vtable_offset_local = IAgCrdnVolumeCombined._vtable_offset - 1
        self.__dict__['_GetCombineOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetCombineOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetConditionCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__['_GetAllConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetAllConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+6, agcom.PVOID, agcom.INT)
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__['_RemoveCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeCombined, vtable_offset_local+8, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeCombined.__dict__ and type(IAgCrdnVolumeCombined.__dict__[attrname]) == property:
            return IAgCrdnVolumeCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeCombined.')
    
    @property
    def CombineOperation(self) -> "AgECrdnVolumeCombinedOperationType":
        """Sets/Returns volume combined operation."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCombineOperation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnVolumeCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__['_SetCombineOperation'](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Returns the spatial condition vectore size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConditionCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all spatial conditions."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAllConditions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__['_SetAllConditions'](byref(arg_conditions.COM_val)))

    def SetCondition(self, ref:"IAgCrdnVolume", pos:int) -> None:
        """Set spatial conditions at a postion."""
        with agmarshall.AgInterface_in_arg(ref, IAgCrdnVolume) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_ref.COM_val, arg_pos.COM_val))

    def GetCondition(self, pos:int) -> "IAgCrdnVolume":
        """Get spatial conditions at a postion."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def RemoveCondition(self, pos:int) -> None:
        """Remove spatial conditions at a postion."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__['_RemoveCondition'](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{96684FB4-3839-44DB-AD80-B772BF58A39A}', IAgCrdnVolumeCombined)
agcls.AgTypeNameMap['IAgCrdnVolumeCombined'] = IAgCrdnVolumeCombined
__all__.append('IAgCrdnVolumeCombined')

class IAgCrdnVolumeFromCalc(object):
    """An volume from calc volume interface."""
    _uuid = '{018666E1-C0E6-46F6-A682-F91FBF3C74F3}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOperation'] = _raise_uninitialized_error
        self.__dict__['_SetOperation'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeCalc'] = _raise_uninitialized_error
        self.__dict__['_SetVolumeCalc'] = _raise_uninitialized_error
        self.__dict__['_GetMinimum'] = _raise_uninitialized_error
        self.__dict__['_SetMinimum'] = _raise_uninitialized_error
        self.__dict__['_GetMaximum'] = _raise_uninitialized_error
        self.__dict__['_SetMaximum'] = _raise_uninitialized_error
        self.__dict__['_Set'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeFromCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeFromCalc from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeFromCalc = agcom.GUID(IAgCrdnVolumeFromCalc._uuid)
        vtable_offset_local = IAgCrdnVolumeFromCalc._vtable_offset - 1
        self.__dict__['_GetOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetOperation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetVolumeCalc'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetVolumeCalc'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetMinimum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetMinimum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetMaximum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetMaximum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_Set'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCalc, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromCalc.__dict__ and type(IAgCrdnVolumeFromCalc.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeFromCalc.')
    
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOperation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__['_SetOperation'](arg_operation.COM_val))

    @property
    def VolumeCalc(self) -> "IAgCrdnVolumeCalc":
        """Get the volume calc from the bounds."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeCalc'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeCalc.setter
    def VolumeCalc(self, volumeCalc:"IAgCrdnVolumeCalc") -> None:
        with agmarshall.AgInterface_in_arg(volumeCalc, IAgCrdnVolumeCalc) as arg_volumeCalc:
            agcls.evaluate_hresult(self.__dict__['_SetVolumeCalc'](arg_volumeCalc.COM_val))

    def GetMinimum(self) -> "IAgQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IAgQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        with agmarshall.AgInterface_in_arg(value, IAgQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMinimum'](arg_value.COM_val))

    def GetMaximum(self) -> "IAgQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IAgQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IAgQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetMaximum'](arg_value.COM_val))

    def Set(self, min:"IAgQuantity", max:"IAgQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IAgQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IAgQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__['_Set'](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{018666E1-C0E6-46F6-A682-F91FBF3C74F3}', IAgCrdnVolumeFromCalc)
agcls.AgTypeNameMap['IAgCrdnVolumeFromCalc'] = IAgCrdnVolumeFromCalc
__all__.append('IAgCrdnVolumeFromCalc')

class IAgCrdnVolumeFromCondition(object):
    """A volume from conditioninterface."""
    _uuid = '{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCondition'] = _raise_uninitialized_error
        self.__dict__['_SetCondition'] = _raise_uninitialized_error
        self.__dict__['_GetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetUseCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_SetCustomTimeLimits'] = _raise_uninitialized_error
        self.__dict__['_GetSampling'] = _raise_uninitialized_error
        self.__dict__['_SetSampling'] = _raise_uninitialized_error
        self.__dict__['_GetConvergence'] = _raise_uninitialized_error
        self.__dict__['_SetConvergence'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeFromCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeFromCondition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeFromCondition = agcom.GUID(IAgCrdnVolumeFromCondition._uuid)
        vtable_offset_local = IAgCrdnVolumeFromCondition._vtable_offset - 1
        self.__dict__['_GetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetCondition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetCustomTimeLimits'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetSampling'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_SetConvergence'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromCondition, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromCondition.__dict__ and type(IAgCrdnVolumeFromCondition.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeFromCondition.')
    
    @property
    def Condition(self) -> "IAgCrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCondition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"IAgCrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, IAgCrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__['_SetCondition'](arg_condition.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseCustomTimeLimits'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetUseCustomTimeLimits'](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "IAgCrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCustomTimeLimits'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, IAgCrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__['_SetCustomTimeLimits'](arg_customTimeLimits.COM_val))

    @property
    def Sampling(self) -> "IAgCrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSampling'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"IAgCrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, IAgCrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__['_SetSampling'](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "IAgCrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConvergence'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"IAgCrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, IAgCrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__['_SetConvergence'](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}', IAgCrdnVolumeFromCondition)
agcls.AgTypeNameMap['IAgCrdnVolumeFromCondition'] = IAgCrdnVolumeFromCondition
__all__.append('IAgCrdnVolumeFromCondition')

class IAgCrdnVolumeFromGrid(object):
    """An over time volume interface."""
    _uuid = '{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEdgeType'] = _raise_uninitialized_error
        self.__dict__['_SetEdgeType'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeGrid'] = _raise_uninitialized_error
        self.__dict__['_SetVolumeGrid'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeFromGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeFromGrid from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeFromGrid = agcom.GUID(IAgCrdnVolumeFromGrid._uuid)
        vtable_offset_local = IAgCrdnVolumeFromGrid._vtable_offset - 1
        self.__dict__['_GetEdgeType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromGrid, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetEdgeType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromGrid, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetVolumeGrid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromGrid, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetVolumeGrid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromGrid, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromGrid.__dict__ and type(IAgCrdnVolumeFromGrid.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeFromGrid.')
    
    @property
    def EdgeType(self) -> "AgECrdnVolumeFromGridEdgeType":
        """Sets/Returns the edge type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEdgeType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EdgeType.setter
    def EdgeType(self, edgeType:"AgECrdnVolumeFromGridEdgeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType, edgeType) as arg_edgeType:
            agcls.evaluate_hresult(self.__dict__['_SetEdgeType'](arg_edgeType.COM_val))

    @property
    def VolumeGrid(self) -> "IAgCrdnVolumeGrid":
        """Sets/Returns the volume grid for bounding."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeGrid'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeGrid.setter
    def VolumeGrid(self, volumeGrid:"IAgCrdnVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(volumeGrid, IAgCrdnVolumeGrid) as arg_volumeGrid:
            agcls.evaluate_hresult(self.__dict__['_SetVolumeGrid'](arg_volumeGrid.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}', IAgCrdnVolumeFromGrid)
agcls.AgTypeNameMap['IAgCrdnVolumeFromGrid'] = IAgCrdnVolumeFromGrid
__all__.append('IAgCrdnVolumeFromGrid')

class IAgCrdnVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""
    _uuid = '{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimeSatisfaction'] = _raise_uninitialized_error
        self.__dict__['_SetTimeSatisfaction'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeFromTimeSatisfaction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeFromTimeSatisfaction from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeFromTimeSatisfaction = agcom.GUID(IAgCrdnVolumeFromTimeSatisfaction._uuid)
        vtable_offset_local = IAgCrdnVolumeFromTimeSatisfaction._vtable_offset - 1
        self.__dict__['_GetTimeSatisfaction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromTimeSatisfaction, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetTimeSatisfaction'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeFromTimeSatisfaction, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeFromTimeSatisfaction.__dict__ and type(IAgCrdnVolumeFromTimeSatisfaction.__dict__[attrname]) == property:
            return IAgCrdnVolumeFromTimeSatisfaction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeFromTimeSatisfaction.')
    
    @property
    def TimeSatisfaction(self) -> "IAgCrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimeSatisfaction'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeSatisfaction.setter
    def TimeSatisfaction(self, timeSatisfaction:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(timeSatisfaction, IAgCrdnEventIntervalList) as arg_timeSatisfaction:
            agcls.evaluate_hresult(self.__dict__['_SetTimeSatisfaction'](arg_timeSatisfaction.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}', IAgCrdnVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap['IAgCrdnVolumeFromTimeSatisfaction'] = IAgCrdnVolumeFromTimeSatisfaction
__all__.append('IAgCrdnVolumeFromTimeSatisfaction')

class IAgCrdnVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    _uuid = '{88BBE781-85C1-439D-A4F4-58006B9A35EC}'
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGrid from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGrid = agcom.GUID(IAgCrdnVolumeGrid._uuid)
        vtable_offset_local = IAgCrdnVolumeGrid._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGrid.__dict__ and type(IAgCrdnVolumeGrid.__dict__[attrname]) == property:
            return IAgCrdnVolumeGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGrid.')
    

agcls.AgClassCatalog.add_catalog_entry('{88BBE781-85C1-439D-A4F4-58006B9A35EC}', IAgCrdnVolumeGrid)
agcls.AgTypeNameMap['IAgCrdnVolumeGrid'] = IAgCrdnVolumeGrid
__all__.append('IAgCrdnVolumeGrid')

class IAgCrdnVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""
    _uuid = '{2814A890-E858-41A6-B640-19F9D27E5ACB}'
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetAlongBearingCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetCrossBearingCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetAltitudeCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetAutoFitBounds'] = _raise_uninitialized_error
        self.__dict__['_SetAutoFitBounds'] = _raise_uninitialized_error
        self.__dict__['_GetBearingAngle'] = _raise_uninitialized_error
        self.__dict__['_SetBearingAngle'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceLocation'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceLocation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridBearingAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridBearingAlt from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridBearingAlt = agcom.GUID(IAgCrdnVolumeGridBearingAlt._uuid)
        vtable_offset_local = IAgCrdnVolumeGridBearingAlt._vtable_offset - 1
        self.__dict__['_GetReferenceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetReferenceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetAlongBearingCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetCrossBearingCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetAltitudeCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetAutoFitBounds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetAutoFitBounds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__['_GetBearingAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__['_SetBearingAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__['_GetReferenceLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetReferenceLocation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridBearingAlt, vtable_offset_local+11, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridBearingAlt.__dict__ and type(IAgCrdnVolumeGridBearingAlt.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridBearingAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridBearingAlt.')
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceCentralBody'](arg_referenceCentralBody.COM_val))

    @property
    def AlongBearingCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns AlongBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlongBearingCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CrossBearingCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns CrossBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCrossBearingCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns altitude Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAltitudeCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAutoFitBounds'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__['_SetAutoFitBounds'](arg_autoFitBounds.COM_val))

    @property
    def BearingAngle(self) -> float:
        """Specify the Bearing Angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBearingAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @BearingAngle.setter
    def BearingAngle(self, bearingAngle:float) -> None:
        with agmarshall.DOUBLE_arg(bearingAngle) as arg_bearingAngle:
            agcls.evaluate_hresult(self.__dict__['_SetBearingAngle'](arg_bearingAngle.COM_val))

    @property
    def ReferenceLocation(self) -> list:
        """Get lat/lon for reference location"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceLocation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceLocation.setter
    def ReferenceLocation(self, referenceLocation:list) -> None:
        with agmarshall.SAFEARRAY_arg(referenceLocation) as arg_referenceLocation:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceLocation'](arg_referenceLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2814A890-E858-41A6-B640-19F9D27E5ACB}', IAgCrdnVolumeGridBearingAlt)
agcls.AgTypeNameMap['IAgCrdnVolumeGridBearingAlt'] = IAgCrdnVolumeGridBearingAlt
__all__.append('IAgCrdnVolumeGridBearingAlt')

class IAgCrdnVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""
    _uuid = '{E959F851-165E-4201-8C13-81FA4C2D3E2D}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetXCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetYCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetZCoordinates'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridCartesian from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridCartesian = agcom.GUID(IAgCrdnVolumeGridCartesian._uuid)
        vtable_offset_local = IAgCrdnVolumeGridCartesian._vtable_offset - 1
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCartesian, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCartesian, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetXCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCartesian, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetYCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCartesian, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetZCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCartesian, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridCartesian.__dict__ and type(IAgCrdnVolumeGridCartesian.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridCartesian.')
    
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def XCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns X Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns Y Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ZCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns Z Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetZCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E959F851-165E-4201-8C13-81FA4C2D3E2D}', IAgCrdnVolumeGridCartesian)
agcls.AgTypeNameMap['IAgCrdnVolumeGridCartesian'] = IAgCrdnVolumeGridCartesian
__all__.append('IAgCrdnVolumeGridCartesian')

class IAgCrdnVolumeGridConstrained(object):
    """A volume grid constrained interface."""
    _uuid = '{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceGrid'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceGrid'] = _raise_uninitialized_error
        self.__dict__['_GetConstraint'] = _raise_uninitialized_error
        self.__dict__['_SetConstraint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridConstrained from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridConstrained = agcom.GUID(IAgCrdnVolumeGridConstrained._uuid)
        vtable_offset_local = IAgCrdnVolumeGridConstrained._vtable_offset - 1
        self.__dict__['_GetReferenceGrid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceGrid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridConstrained, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridConstrained, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridConstrained.__dict__ and type(IAgCrdnVolumeGridConstrained.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridConstrained.')
    
    @property
    def ReferenceGrid(self) -> "IAgCrdnVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceGrid'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceGrid.setter
    def ReferenceGrid(self, referenceGrid:"IAgCrdnVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(referenceGrid, IAgCrdnVolumeGrid) as arg_referenceGrid:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceGrid'](arg_referenceGrid.COM_val))

    @property
    def Constraint(self) -> "IAgCrdnVolume":
        """Get the volume constraint on the grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConstraint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"IAgCrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, IAgCrdnVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__['_SetConstraint'](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}', IAgCrdnVolumeGridConstrained)
agcls.AgTypeNameMap['IAgCrdnVolumeGridConstrained'] = IAgCrdnVolumeGridConstrained
__all__.append('IAgCrdnVolumeGridConstrained')

class IAgCrdnVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""
    _uuid = '{0CF87427-CC2B-4282-9B41-0A2D86395AD4}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetThetaCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetRadiusCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetHeightCoordinates'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridCylindrical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridCylindrical from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridCylindrical = agcom.GUID(IAgCrdnVolumeGridCylindrical._uuid)
        vtable_offset_local = IAgCrdnVolumeGridCylindrical._vtable_offset - 1
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCylindrical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCylindrical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetThetaCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCylindrical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetRadiusCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCylindrical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetHeightCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridCylindrical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridCylindrical.__dict__ and type(IAgCrdnVolumeGridCylindrical.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridCylindrical.')
    
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def ThetaCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns theta Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetThetaCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RadiusCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns radius Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRadiusCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def HeightCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns height Coordinates parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetHeightCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{0CF87427-CC2B-4282-9B41-0A2D86395AD4}', IAgCrdnVolumeGridCylindrical)
agcls.AgTypeNameMap['IAgCrdnVolumeGridCylindrical'] = IAgCrdnVolumeGridCylindrical
__all__.append('IAgCrdnVolumeGridCylindrical')

class IAgCrdnVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    _uuid = '{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetLatitudeCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetLongitudeCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetAltitudeCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetAutoFitBounds'] = _raise_uninitialized_error
        self.__dict__['_SetAutoFitBounds'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridLatLonAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridLatLonAlt from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridLatLonAlt = agcom.GUID(IAgCrdnVolumeGridLatLonAlt._uuid)
        vtable_offset_local = IAgCrdnVolumeGridLatLonAlt._vtable_offset - 1
        self.__dict__['_GetReferenceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetReferenceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetLatitudeCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetLongitudeCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetAltitudeCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetAutoFitBounds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetAutoFitBounds'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridLatLonAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridLatLonAlt.__dict__ and type(IAgCrdnVolumeGridLatLonAlt.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridLatLonAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridLatLonAlt.')
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceCentralBody'](arg_referenceCentralBody.COM_val))

    @property
    def LatitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns latitute Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLatitudeCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LongitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns longtitude Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLongitudeCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns altitude parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAltitudeCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAutoFitBounds'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__['_SetAutoFitBounds'](arg_autoFitBounds.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}', IAgCrdnVolumeGridLatLonAlt)
agcls.AgTypeNameMap['IAgCrdnVolumeGridLatLonAlt'] = IAgCrdnVolumeGridLatLonAlt
__all__.append('IAgCrdnVolumeGridLatLonAlt')

class IAgCrdnVolumeGridResult(object):
    """An interafcce that genereates Volume Grid results."""
    _uuid = '{1C3B106C-011E-4C51-B321-20389C8EAF76}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        self.__dict__['_GetSizeI'] = _raise_uninitialized_error
        self.__dict__['_GetSizeJ'] = _raise_uninitialized_error
        self.__dict__['_GetSizeK'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeMetricDataVector'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeMetricPositionVector'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeMetricNativePositionVector'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeMetricGradientVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridResult = agcom.GUID(IAgCrdnVolumeGridResult._uuid)
        vtable_offset_local = IAgCrdnVolumeGridResult._vtable_offset - 1
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_GetSizeI'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__['_GetSizeJ'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__['_GetSizeK'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+4, POINTER(agcom.INT))
        self.__dict__['_GetVolumeMetricDataVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetVolumeMetricPositionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+6, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetVolumeMetricNativePositionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetVolumeMetricGradientVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridResult, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridResult.__dict__ and type(IAgCrdnVolumeGridResult.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridResult.')
    
    @property
    def Epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeI(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSizeI'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeJ(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSizeJ'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeK(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSizeK'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VolumeMetricDataVector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeMetricDataVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricPositionVector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeMetricPositionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricNativePositionVector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeMetricNativePositionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricGradientVector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeMetricGradientVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1C3B106C-011E-4C51-B321-20389C8EAF76}', IAgCrdnVolumeGridResult)
agcls.AgTypeNameMap['IAgCrdnVolumeGridResult'] = IAgCrdnVolumeGridResult
__all__.append('IAgCrdnVolumeGridResult')

class IAgCrdnVolumeGridSpherical(object):
    """A volume grid spherical interface."""
    _uuid = '{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetAzimuthCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetElevationCoordinates'] = _raise_uninitialized_error
        self.__dict__['_GetRangeCoordinates'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeGridSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeGridSpherical from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeGridSpherical = agcom.GUID(IAgCrdnVolumeGridSpherical._uuid)
        vtable_offset_local = IAgCrdnVolumeGridSpherical._vtable_offset - 1
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridSpherical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridSpherical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAzimuthCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridSpherical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetElevationCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridSpherical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetRangeCoordinates'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeGridSpherical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeGridSpherical.__dict__ and type(IAgCrdnVolumeGridSpherical.__dict__[attrname]) == property:
            return IAgCrdnVolumeGridSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeGridSpherical.')
    
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def AzimuthCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns azimuth coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAzimuthCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ElevationCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns elevation coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetElevationCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RangeCoordinates(self) -> "IAgCrdnGridCoordinateDefinition":
        """Returns range coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRangeCoordinates'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}', IAgCrdnVolumeGridSpherical)
agcls.AgTypeNameMap['IAgCrdnVolumeGridSpherical'] = IAgCrdnVolumeGridSpherical
__all__.append('IAgCrdnVolumeGridSpherical')

class IAgCrdnVolumeInview(object):
    """An Inview volume interface."""
    _uuid = '{EF724630-CEB6-4818-A5BB-F74CF1B9D931}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetConstraintObject'] = _raise_uninitialized_error
        self.__dict__['_SetConstraintObject'] = _raise_uninitialized_error
        self.__dict__['_GetLightTimeDelay'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeInview._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeInview from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeInview = agcom.GUID(IAgCrdnVolumeInview._uuid)
        vtable_offset_local = IAgCrdnVolumeInview._vtable_offset - 1
        self.__dict__['_GetConstraintObject'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeInview, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_SetConstraintObject'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeInview, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__['_GetLightTimeDelay'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeInview, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeInview.__dict__ and type(IAgCrdnVolumeInview.__dict__[attrname]) == property:
            return IAgCrdnVolumeInview.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeInview.')
    
    @property
    def ConstraintObject(self) -> typing.Any:
        """A constraint object of the access."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConstraintObject'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ConstraintObject.setter
    def ConstraintObject(self, constraintObject:typing.Any) -> None:
        with agmarshall.VARIANT_arg(constraintObject) as arg_constraintObject:
            agcls.evaluate_hresult(self.__dict__['_SetConstraintObject'](arg_constraintObject.COM_val))

    @property
    def LightTimeDelay(self) -> "IAgCrdnLightTimeDelay":
        """Returns Light Time Delay options parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLightTimeDelay'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EF724630-CEB6-4818-A5BB-F74CF1B9D931}', IAgCrdnVolumeInview)
agcls.AgTypeNameMap['IAgCrdnVolumeInview'] = IAgCrdnVolumeInview
__all__.append('IAgCrdnVolumeInview')

class IAgCrdnVolumeLighting(object):
    """A lighting volume interface."""
    _uuid = '{CE134C08-274E-4E29-9337-03E9C73AA8F9}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_GetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_SetUseObjectEclipsingBodies'] = _raise_uninitialized_error
        self.__dict__['_GetLightingConditions'] = _raise_uninitialized_error
        self.__dict__['_SetLightingConditions'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeLighting from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeLighting = agcom.GUID(IAgCrdnVolumeLighting._uuid)
        vtable_offset_local = IAgCrdnVolumeLighting._vtable_offset - 1
        self.__dict__['_GetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_SetEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__['_GetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseObjectEclipsingBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetLightingConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetLightingConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeLighting, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeLighting.__dict__ and type(IAgCrdnVolumeLighting.__dict__[attrname]) == property:
            return IAgCrdnVolumeLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeLighting.')
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEclipsingBodies'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetEclipsingBodies'](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseObjectEclipsingBodies'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__['_SetUseObjectEclipsingBodies'](arg_useObjectEclipsingBodies.COM_val))

    @property
    def LightingConditions(self) -> "AgECrdnVolumeLightingConditionsType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLightingConditions'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LightingConditions.setter
    def LightingConditions(self, lightingConditions:"AgECrdnVolumeLightingConditionsType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType, lightingConditions) as arg_lightingConditions:
            agcls.evaluate_hresult(self.__dict__['_SetLightingConditions'](arg_lightingConditions.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CE134C08-274E-4E29-9337-03E9C73AA8F9}', IAgCrdnVolumeLighting)
agcls.AgTypeNameMap['IAgCrdnVolumeLighting'] = IAgCrdnVolumeLighting
__all__.append('IAgCrdnVolumeLighting')

class IAgCrdnVolumeOverTime(object):
    """An over time volume interface."""
    _uuid = '{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}'
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDurationType'] = _raise_uninitialized_error
        self.__dict__['_SetDurationType'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceVolume'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceVolume'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStartOffset'] = _raise_uninitialized_error
        self.__dict__['_GetStopOffset'] = _raise_uninitialized_error
        self.__dict__['_SetStopOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVolumeOverTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVolumeOverTime from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVolumeOverTime = agcom.GUID(IAgCrdnVolumeOverTime._uuid)
        vtable_offset_local = IAgCrdnVolumeOverTime._vtable_offset - 1
        self.__dict__['_GetDurationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_SetDurationType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+2, agcom.LONG)
        self.__dict__['_GetReferenceVolume'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceVolume'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStartOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStopOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVolumeOverTime, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVolumeOverTime.__dict__ and type(IAgCrdnVolumeOverTime.__dict__[attrname]) == property:
            return IAgCrdnVolumeOverTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVolumeOverTime.')
    
    @property
    def DurationType(self) -> "AgECrdnVolumeOverTimeDurationType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDurationType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeOverTimeDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__['_SetDurationType'](arg_durationType.COM_val))

    @property
    def ReferenceVolume(self) -> "IAgCrdnVolume":
        """Sets/Returns the reference volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVolume'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVolume.setter
    def ReferenceVolume(self, referenceVolume:"IAgCrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(referenceVolume, IAgCrdnVolume) as arg_referenceVolume:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceVolume'](arg_referenceVolume.COM_val))

    @property
    def ReferenceIntervals(self) -> "IAgCrdnEventIntervalList":
        """The reference interval list for the over time volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"IAgCrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, IAgCrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceIntervals'](arg_referenceIntervals.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStartOffset'](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__['_SetStopOffset'](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}', IAgCrdnVolumeOverTime)
agcls.AgTypeNameMap['IAgCrdnVolumeOverTime'] = IAgCrdnVolumeOverTime
__all__.append('IAgCrdnVolumeOverTime')

class IAgCrdnTimeProperties(object):
    """Defines methods to compute time properties such as availability and special times."""
    _uuid = '{E95B72AA-F8DE-4122-AC60-54E46A208E19}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAvailability'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnTimeProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnTimeProperties from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnTimeProperties = agcom.GUID(IAgCrdnTimeProperties._uuid)
        vtable_offset_local = IAgCrdnTimeProperties._vtable_offset - 1
        self.__dict__['_GetAvailability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnTimeProperties, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTimeProperties.__dict__ and type(IAgCrdnTimeProperties.__dict__[attrname]) == property:
            return IAgCrdnTimeProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnTimeProperties.')
    
    def GetAvailability(self) -> "IAgCrdnIntervalCollection":
        """Returns a collection of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailability'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E95B72AA-F8DE-4122-AC60-54E46A208E19}', IAgCrdnTimeProperties)
agcls.AgTypeNameMap['IAgCrdnTimeProperties'] = IAgCrdnTimeProperties
__all__.append('IAgCrdnTimeProperties')

class IAgCrdnTypeInfo(object):
    """Provides information about the type of VGT components."""
    _uuid = '{67E20A46-9550-4A68-9276-697DC821A23A}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTypeDescription'] = _raise_uninitialized_error
        self.__dict__['_GetTypeName'] = _raise_uninitialized_error
        self.__dict__['_GetShortTypeDescription'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnTypeInfo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnTypeInfo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnTypeInfo = agcom.GUID(IAgCrdnTypeInfo._uuid)
        vtable_offset_local = IAgCrdnTypeInfo._vtable_offset - 1
        self.__dict__['_GetTypeDescription'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnTypeInfo, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetTypeName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnTypeInfo, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetShortTypeDescription'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnTypeInfo, vtable_offset_local+3, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTypeInfo.__dict__ and type(IAgCrdnTypeInfo.__dict__[attrname]) == property:
            return IAgCrdnTypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnTypeInfo.')
    
    @property
    def TypeDescription(self) -> str:
        """Return the type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTypeDescription'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def TypeName(self) -> str:
        """Return the type name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTypeName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShortTypeDescription(self) -> str:
        """Return the short type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetShortTypeDescription'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{67E20A46-9550-4A68-9276-697DC821A23A}', IAgCrdnTypeInfo)
agcls.AgTypeNameMap['IAgCrdnTypeInfo'] = IAgCrdnTypeInfo
__all__.append('IAgCrdnTypeInfo')

class IAgCrdnRefTo(object):
    """A base interface for all VGT component references."""
    _uuid = '{2F3A17A6-4304-4565-BC1C-7A064DCFE310}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPath'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnRefTo = agcom.GUID(IAgCrdnRefTo._uuid)
        vtable_offset_local = IAgCrdnRefTo._vtable_offset - 1
        self.__dict__['_GetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRefTo, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRefTo.__dict__ and type(IAgCrdnRefTo.__dict__[attrname]) == property:
            return IAgCrdnRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnRefTo.')
    
    @property
    def Path(self) -> str:
        """Returns a path to the referenced VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPath'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{2F3A17A6-4304-4565-BC1C-7A064DCFE310}', IAgCrdnRefTo)
agcls.AgTypeNameMap['IAgCrdnRefTo'] = IAgCrdnRefTo
__all__.append('IAgCrdnRefTo')

class IAgCrdnTemplate(object):
    """The IAgCrdnTemplate interface enables to obtain information about the STK class that owns the VGT component."""
    _uuid = '{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetClassName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnTemplate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnTemplate from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnTemplate = agcom.GUID(IAgCrdnTemplate._uuid)
        vtable_offset_local = IAgCrdnTemplate._vtable_offset - 1
        self.__dict__['_GetClassName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnTemplate, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnTemplate.__dict__ and type(IAgCrdnTemplate.__dict__[attrname]) == property:
            return IAgCrdnTemplate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnTemplate.')
    
    @property
    def ClassName(self) -> str:
        """Returns a class name (i.e. 'Satellite', 'Facility', etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetClassName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}', IAgCrdnTemplate)
agcls.AgTypeNameMap['IAgCrdnTemplate'] = IAgCrdnTemplate
__all__.append('IAgCrdnTemplate')

class IAgCrdnInstance(object):
    """The IAgCrdnInstance interface enables to obtain information about the parent object that owns the VGT component."""
    _uuid = '{17633665-9601-4FFF-8227-4D5DF0AAEA06}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInstancePath'] = _raise_uninitialized_error
        self.__dict__['_GetTemplate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnInstance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnInstance from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnInstance = agcom.GUID(IAgCrdnInstance._uuid)
        vtable_offset_local = IAgCrdnInstance._vtable_offset - 1
        self.__dict__['_GetInstancePath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInstance, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetTemplate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnInstance, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnInstance.__dict__ and type(IAgCrdnInstance.__dict__[attrname]) == property:
            return IAgCrdnInstance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnInstance.')
    
    @property
    def InstancePath(self) -> str:
        """Returns a path to the parent object that owns the VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInstancePath'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Template(self) -> "IAgCrdn":
        """Returns a template object the VGT component was created from or null if the VGT component was not created from a template."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTemplate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{17633665-9601-4FFF-8227-4D5DF0AAEA06}', IAgCrdnInstance)
agcls.AgTypeNameMap['IAgCrdnInstance'] = IAgCrdnInstance
__all__.append('IAgCrdnInstance')

class IAgCrdnPointRefTo(object):
    """Represents a reference to a VGT point."""
    _uuid = '{B553DE32-05C9-4944-918A-90552E039DBE}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetPoint'] = _raise_uninitialized_error
        self.__dict__['_GetPoint'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointRefTo = agcom.GUID(IAgCrdnPointRefTo._uuid)
        vtable_offset_local = IAgCrdnPointRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointRefTo.__dict__ and type(IAgCrdnPointRefTo.__dict__[attrname]) == property:
            return IAgCrdnPointRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new point."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetPoint(self, point:"IAgCrdnPoint") -> None:
        """Sets a new point."""
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__['_SetPoint'](arg_point.COM_val))

    def GetPoint(self) -> "IAgCrdnPoint":
        """Returns the actual point object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, point:"IAgCrdnPoint") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_point.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B553DE32-05C9-4944-918A-90552E039DBE}', IAgCrdnPointRefTo)
agcls.AgTypeNameMap['IAgCrdnPointRefTo'] = IAgCrdnPointRefTo
__all__.append('IAgCrdnPointRefTo')

class IAgCrdnVectorRefTo(object):
    """Represents a reference to a VGT vector."""
    _uuid = '{EDF2E070-340E-456C-BDA8-BE9B9B40E728}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetVector'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorRefTo = agcom.GUID(IAgCrdnVectorRefTo._uuid)
        vtable_offset_local = IAgCrdnVectorRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorRefTo.__dict__ and type(IAgCrdnVectorRefTo.__dict__[attrname]) == property:
            return IAgCrdnVectorRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new vector."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetVector(self, vector:"IAgCrdnVector") -> None:
        """Sets a new vector."""
        with agmarshall.AgInterface_in_arg(vector, IAgCrdnVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__['_SetVector'](arg_vector.COM_val))

    def GetVector(self) -> "IAgCrdnVector":
        """Returns the actual vector object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, vector:"IAgCrdnVector") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(vector, IAgCrdnVector) as arg_vector, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_vector.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EDF2E070-340E-456C-BDA8-BE9B9B40E728}', IAgCrdnVectorRefTo)
agcls.AgTypeNameMap['IAgCrdnVectorRefTo'] = IAgCrdnVectorRefTo
__all__.append('IAgCrdnVectorRefTo')

class IAgCrdnAxesRefTo(object):
    """Represents a reference to a VGT axes."""
    _uuid = '{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetAxes'] = _raise_uninitialized_error
        self.__dict__['_GetAxes'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesRefTo = agcom.GUID(IAgCrdnAxesRefTo._uuid)
        vtable_offset_local = IAgCrdnAxesRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesRefTo.__dict__ and type(IAgCrdnAxesRefTo.__dict__[attrname]) == property:
            return IAgCrdnAxesRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new axes."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetAxes(self, axes:"IAgCrdnAxes") -> None:
        """Sets a new axes."""
        with agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__['_SetAxes'](arg_axes.COM_val))

    def GetAxes(self) -> "IAgCrdnAxes":
        """Returns the actual axes object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, axes:"IAgCrdnAxes") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_axes.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}', IAgCrdnAxesRefTo)
agcls.AgTypeNameMap['IAgCrdnAxesRefTo'] = IAgCrdnAxesRefTo
__all__.append('IAgCrdnAxesRefTo')

class IAgCrdnAngleRefTo(object):
    """Represents a reference to a VGT angle."""
    _uuid = '{7A9D809F-D819-4458-9855-2DA8507F6E57}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleRefTo = agcom.GUID(IAgCrdnAngleRefTo._uuid)
        vtable_offset_local = IAgCrdnAngleRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleRefTo.__dict__ and type(IAgCrdnAngleRefTo.__dict__[attrname]) == property:
            return IAgCrdnAngleRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new angle."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetAngle(self, angle:"IAgCrdnAngle") -> None:
        """Sets a new angle."""
        with agmarshall.AgInterface_in_arg(angle, IAgCrdnAngle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__['_SetAngle'](arg_angle.COM_val))

    def GetAngle(self) -> "IAgCrdnAngle":
        """Returns the actual angle object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, angle:"IAgCrdnAngle") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(angle, IAgCrdnAngle) as arg_angle, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_angle.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{7A9D809F-D819-4458-9855-2DA8507F6E57}', IAgCrdnAngleRefTo)
agcls.AgTypeNameMap['IAgCrdnAngleRefTo'] = IAgCrdnAngleRefTo
__all__.append('IAgCrdnAngleRefTo')

class IAgCrdnSystemRefTo(object):
    """Represents a reference to a VGT system."""
    _uuid = '{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetSystem'] = _raise_uninitialized_error
        self.__dict__['_GetSystem'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemRefTo = agcom.GUID(IAgCrdnSystemRefTo._uuid)
        vtable_offset_local = IAgCrdnSystemRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemRefTo.__dict__ and type(IAgCrdnSystemRefTo.__dict__[attrname]) == property:
            return IAgCrdnSystemRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new system."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetSystem(self, system:"IAgCrdnSystem") -> None:
        """Sets a new system."""
        with agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system:
            agcls.evaluate_hresult(self.__dict__['_SetSystem'](arg_system.COM_val))

    def GetSystem(self) -> "IAgCrdnSystem":
        """Returns the actual system object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, system:"IAgCrdnSystem") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(system, IAgCrdnSystem) as arg_system, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_system.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}', IAgCrdnSystemRefTo)
agcls.AgTypeNameMap['IAgCrdnSystemRefTo'] = IAgCrdnSystemRefTo
__all__.append('IAgCrdnSystemRefTo')

class IAgCrdnPlaneRefTo(object):
    """Represents a reference to a VGT plane."""
    _uuid = '{CE3D70F2-61E0-4A23-803F-A734005DC36D}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetPlane'] = _raise_uninitialized_error
        self.__dict__['_GetPlane'] = _raise_uninitialized_error
        self.__dict__['_HasCyclicDependency'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneRefTo = agcom.GUID(IAgCrdnPlaneRefTo._uuid)
        vtable_offset_local = IAgCrdnPlaneRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetPlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetPlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_HasCyclicDependency'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneRefTo.__dict__ and type(IAgCrdnPlaneRefTo.__dict__[attrname]) == property:
            return IAgCrdnPlaneRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new plane using a specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetPlane(self, plane:"IAgCrdnPlane") -> None:
        """Sets a new plane."""
        with agmarshall.AgInterface_in_arg(plane, IAgCrdnPlane) as arg_plane:
            agcls.evaluate_hresult(self.__dict__['_SetPlane'](arg_plane.COM_val))

    def GetPlane(self) -> "IAgCrdnPlane":
        """Returns the actual plane object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, plane:"IAgCrdnPlane") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(plane, IAgCrdnPlane) as arg_plane, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_HasCyclicDependency'](arg_plane.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{CE3D70F2-61E0-4A23-803F-A734005DC36D}', IAgCrdnPlaneRefTo)
agcls.AgTypeNameMap['IAgCrdnPlaneRefTo'] = IAgCrdnPlaneRefTo
__all__.append('IAgCrdnPlaneRefTo')

class IAgCrdnAxesLabels(object):
    """Allows configuring the VGT axes labels."""
    _uuid = '{0CD79528-D932-4473-9CC4-0BF5C936A6CD}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetLabelX'] = _raise_uninitialized_error
        self.__dict__['_SetLabelX'] = _raise_uninitialized_error
        self.__dict__['_GetLabelY'] = _raise_uninitialized_error
        self.__dict__['_SetLabelY'] = _raise_uninitialized_error
        self.__dict__['_GetLabelZ'] = _raise_uninitialized_error
        self.__dict__['_SetLabelZ'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesLabels from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesLabels = agcom.GUID(IAgCrdnAxesLabels._uuid)
        vtable_offset_local = IAgCrdnAxesLabels._vtable_offset - 1
        self.__dict__['_GetLabelX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetLabelX'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetLabelY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetLabelY'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+4, agcom.BSTR)
        self.__dict__['_GetLabelZ'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_SetLabelZ'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLabels, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesLabels.__dict__ and type(IAgCrdnAxesLabels.__dict__[attrname]) == property:
            return IAgCrdnAxesLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesLabels.')
    
    @property
    def LabelX(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelX'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelX.setter
    def LabelX(self, labelX:str) -> None:
        with agmarshall.BSTR_arg(labelX) as arg_labelX:
            agcls.evaluate_hresult(self.__dict__['_SetLabelX'](arg_labelX.COM_val))

    @property
    def LabelY(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelY'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelY.setter
    def LabelY(self, labelY:str) -> None:
        with agmarshall.BSTR_arg(labelY) as arg_labelY:
            agcls.evaluate_hresult(self.__dict__['_SetLabelY'](arg_labelY.COM_val))

    @property
    def LabelZ(self) -> str:
        """Specify a Z axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLabelZ'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelZ.setter
    def LabelZ(self, labelZ:str) -> None:
        with agmarshall.BSTR_arg(labelZ) as arg_labelZ:
            agcls.evaluate_hresult(self.__dict__['_SetLabelZ'](arg_labelZ.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{0CD79528-D932-4473-9CC4-0BF5C936A6CD}', IAgCrdnAxesLabels)
agcls.AgTypeNameMap['IAgCrdnAxesLabels'] = IAgCrdnAxesLabels
__all__.append('IAgCrdnAxesLabels')

class IAgCrdnPlaneLabels(object):
    """Allows configuring the X and Y axes labels."""
    _uuid = '{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetXAxisLabel'] = _raise_uninitialized_error
        self.__dict__['_SetXAxisLabel'] = _raise_uninitialized_error
        self.__dict__['_GetYAxisLabel'] = _raise_uninitialized_error
        self.__dict__['_SetYAxisLabel'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneLabels from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneLabels = agcom.GUID(IAgCrdnPlaneLabels._uuid)
        vtable_offset_local = IAgCrdnPlaneLabels._vtable_offset - 1
        self.__dict__['_GetXAxisLabel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetXAxisLabel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetYAxisLabel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetYAxisLabel'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneLabels, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneLabels.__dict__ and type(IAgCrdnPlaneLabels.__dict__[attrname]) == property:
            return IAgCrdnPlaneLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneLabels.')
    
    @property
    def XAxisLabel(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxisLabel'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @XAxisLabel.setter
    def XAxisLabel(self, xAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(xAxisLabel) as arg_xAxisLabel:
            agcls.evaluate_hresult(self.__dict__['_SetXAxisLabel'](arg_xAxisLabel.COM_val))

    @property
    def YAxisLabel(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxisLabel'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxisLabel.setter
    def YAxisLabel(self, yAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(yAxisLabel) as arg_yAxisLabel:
            agcls.evaluate_hresult(self.__dict__['_SetYAxisLabel'](arg_yAxisLabel.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}', IAgCrdnPlaneLabels)
agcls.AgTypeNameMap['IAgCrdnPlaneLabels'] = IAgCrdnPlaneLabels
__all__.append('IAgCrdnPlaneLabels')

class IAgCrdnAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    _uuid = '{19991E4F-F368-41CD-AE27-96CF11EC963F}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAlignmentReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetConstraintReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetAlignmentDirection'] = _raise_uninitialized_error
        self.__dict__['_GetConstraintDirection'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesAlignedAndConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesAlignedAndConstrained from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesAlignedAndConstrained = agcom.GUID(IAgCrdnAxesAlignedAndConstrained._uuid)
        vtable_offset_local = IAgCrdnAxesAlignedAndConstrained._vtable_offset - 1
        self.__dict__['_GetAlignmentReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAlignedAndConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetConstraintReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAlignedAndConstrained, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetAlignmentDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAlignedAndConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetConstraintDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAlignedAndConstrained, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAlignedAndConstrained.__dict__ and type(IAgCrdnAxesAlignedAndConstrained.__dict__[attrname]) == property:
            return IAgCrdnAxesAlignedAndConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesAlignedAndConstrained.')
    
    @property
    def AlignmentReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify an alignment reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlignmentReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a constraint reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConstraintReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AlignmentDirection(self) -> "IAgDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlignmentDirection'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintDirection(self) -> "IAgDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConstraintDirection'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{19991E4F-F368-41CD-AE27-96CF11EC963F}', IAgCrdnAxesAlignedAndConstrained)
agcls.AgTypeNameMap['IAgCrdnAxesAlignedAndConstrained'] = IAgCrdnAxesAlignedAndConstrained
__all__.append('IAgCrdnAxesAlignedAndConstrained')

class IAgCrdnAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    _uuid = '{0096F935-281A-4EC9-92A4-7400BD2DEF60}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSpinVector'] = _raise_uninitialized_error
        self.__dict__['_GetRotationAngle'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetFixedOffsetAngle'] = _raise_uninitialized_error
        self.__dict__['_SetFixedOffsetAngle'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesAngularOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesAngularOffset from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesAngularOffset = agcom.GUID(IAgCrdnAxesAngularOffset._uuid)
        vtable_offset_local = IAgCrdnAxesAngularOffset._vtable_offset - 1
        self.__dict__['_GetSpinVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAngularOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetRotationAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAngularOffset, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAngularOffset, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetFixedOffsetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAngularOffset, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__['_SetFixedOffsetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAngularOffset, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAngularOffset.__dict__ and type(IAgCrdnAxesAngularOffset.__dict__[attrname]) == property:
            return IAgCrdnAxesAngularOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesAngularOffset.')
    
    @property
    def SpinVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpinVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationAngle(self) -> "IAgCrdnAngleRefTo":
        """Specify a rotational angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRotationAngle'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOffsetAngle(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixedOffsetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FixedOffsetAngle.setter
    def FixedOffsetAngle(self, fixedOffsetAngle:float) -> None:
        with agmarshall.DOUBLE_arg(fixedOffsetAngle) as arg_fixedOffsetAngle:
            agcls.evaluate_hresult(self.__dict__['_SetFixedOffsetAngle'](arg_fixedOffsetAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{0096F935-281A-4EC9-92A4-7400BD2DEF60}', IAgCrdnAxesAngularOffset)
agcls.AgTypeNameMap['IAgCrdnAxesAngularOffset'] = IAgCrdnAxesAngularOffset
__all__.append('IAgCrdnAxesAngularOffset')

class IAgCrdnAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""
    _uuid = '{CEB9E066-A9F8-4B74-AF7A-0301BF611843}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSourceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetEpoch'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesFixedAtEpoch from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesFixedAtEpoch = agcom.GUID(IAgCrdnAxesFixedAtEpoch._uuid)
        vtable_offset_local = IAgCrdnAxesFixedAtEpoch._vtable_offset - 1
        self.__dict__['_GetSourceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixedAtEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__['_SetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixedAtEpoch, vtable_offset_local+4, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFixedAtEpoch.__dict__ and type(IAgCrdnAxesFixedAtEpoch.__dict__[attrname]) == property:
            return IAgCrdnAxesFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesFixedAtEpoch.')
    
    @property
    def SourceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a source axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__['_SetEpoch'](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CEB9E066-A9F8-4B74-AF7A-0301BF611843}', IAgCrdnAxesFixedAtEpoch)
agcls.AgTypeNameMap['IAgCrdnAxesFixedAtEpoch'] = IAgCrdnAxesFixedAtEpoch
__all__.append('IAgCrdnAxesFixedAtEpoch')

class IAgCrdnAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""
    _uuid = '{72FD97D1-AE64-45D2-973E-E4F491B474AC}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTrajectory'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetTargetBody'] = _raise_uninitialized_error
        self.__dict__['_GetDirection'] = _raise_uninitialized_error
        self.__dict__['_SetDirection'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesBPlane from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesBPlane = agcom.GUID(IAgCrdnAxesBPlane._uuid)
        vtable_offset_local = IAgCrdnAxesBPlane._vtable_offset - 1
        self.__dict__['_GetTrajectory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetTargetBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesBPlane, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesBPlane, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_SetDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesBPlane, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesBPlane.__dict__ and type(IAgCrdnAxesBPlane.__dict__[attrname]) == property:
            return IAgCrdnAxesBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesBPlane.')
    
    @property
    def Trajectory(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTrajectory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirection'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__['_SetDirection'](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{72FD97D1-AE64-45D2-973E-E4F491B474AC}', IAgCrdnAxesBPlane)
agcls.AgTypeNameMap['IAgCrdnAxesBPlane'] = IAgCrdnAxesBPlane
__all__.append('IAgCrdnAxesBPlane')

class IAgCrdnAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""
    _uuid = '{F5A690E6-0304-49E0-BAB5-229F848B0401}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesCustomScript from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesCustomScript = agcom.GUID(IAgCrdnAxesCustomScript._uuid)
        vtable_offset_local = IAgCrdnAxesCustomScript._vtable_offset - 1
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCustomScript, vtable_offset_local+3, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesCustomScript.__dict__ and type(IAgCrdnAxesCustomScript.__dict__[attrname]) == property:
            return IAgCrdnAxesCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesCustomScript.')
    
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filename(self) -> str:
        """Can be MATLAB (*.m or *.dll), VB Script (*.vbs) or Perl (*.pl) script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{F5A690E6-0304-49E0-BAB5-229F848B0401}', IAgCrdnAxesCustomScript)
agcls.AgTypeNameMap['IAgCrdnAxesCustomScript'] = IAgCrdnAxesCustomScript
__all__.append('IAgCrdnAxesCustomScript')

class IAgCrdnAxesAttitudeFile(object):
    """Axes specified by data from a file."""
    _uuid = '{E4A194BD-44ED-498F-ACB2-9911C19F52E8}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesAttitudeFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesAttitudeFile from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesAttitudeFile = agcom.GUID(IAgCrdnAxesAttitudeFile._uuid)
        vtable_offset_local = IAgCrdnAxesAttitudeFile._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAttitudeFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAttitudeFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAttitudeFile.__dict__ and type(IAgCrdnAxesAttitudeFile.__dict__[attrname]) == property:
            return IAgCrdnAxesAttitudeFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesAttitudeFile.')
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{E4A194BD-44ED-498F-ACB2-9911C19F52E8}', IAgCrdnAxesAttitudeFile)
agcls.AgTypeNameMap['IAgCrdnAxesAttitudeFile'] = IAgCrdnAxesAttitudeFile
__all__.append('IAgCrdnAxesAttitudeFile')

class IAgCrdnAxesFixed(object):
    """Axes fixed in reference axes."""
    _uuid = '{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetFixedOrientation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesFixed from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesFixed = agcom.GUID(IAgCrdnAxesFixed._uuid)
        vtable_offset_local = IAgCrdnAxesFixed._vtable_offset - 1
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixed, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetFixedOrientation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFixed, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFixed.__dict__ and type(IAgCrdnAxesFixed.__dict__[attrname]) == property:
            return IAgCrdnAxesFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesFixed.')
    
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOrientation(self) -> "IAgOrientation":
        """Specify a desired orientation and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixedOrientation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}', IAgCrdnAxesFixed)
agcls.AgTypeNameMap['IAgCrdnAxesFixed'] = IAgCrdnAxesFixed
__all__.append('IAgCrdnAxesFixed')

class IAgCrdnAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    _uuid = '{3A20DEC4-2D89-416C-8B47-D76E859763B0}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPointableElementName'] = _raise_uninitialized_error
        self.__dict__['_SetPointableElementName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesModelAttach from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesModelAttach = agcom.GUID(IAgCrdnAxesModelAttach._uuid)
        vtable_offset_local = IAgCrdnAxesModelAttach._vtable_offset - 1
        self.__dict__['_GetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesModelAttach.__dict__ and type(IAgCrdnAxesModelAttach.__dict__[attrname]) == property:
            return IAgCrdnAxesModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesModelAttach.')
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointableElementName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__['_SetPointableElementName'](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{3A20DEC4-2D89-416C-8B47-D76E859763B0}', IAgCrdnAxesModelAttach)
agcls.AgTypeNameMap['IAgCrdnAxesModelAttach'] = IAgCrdnAxesModelAttach
__all__.append('IAgCrdnAxesModelAttach')

class IAgCrdnAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    _uuid = '{ECB36015-B534-40C6-B50F-298217335C38}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSpinVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetEpoch'] = _raise_uninitialized_error
        self.__dict__['_GetInitialOffset'] = _raise_uninitialized_error
        self.__dict__['_SetInitialOffset'] = _raise_uninitialized_error
        self.__dict__['_GetSpinRate'] = _raise_uninitialized_error
        self.__dict__['_SetSpinRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesSpinning._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesSpinning from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesSpinning = agcom.GUID(IAgCrdnAxesSpinning._uuid)
        vtable_offset_local = IAgCrdnAxesSpinning._vtable_offset - 1
        self.__dict__['_GetSpinVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__['_SetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__['_GetInitialOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetInitialOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetSpinRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetSpinRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSpinning, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSpinning.__dict__ and type(IAgCrdnAxesSpinning.__dict__[attrname]) == property:
            return IAgCrdnAxesSpinning.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesSpinning.')
    
    @property
    def SpinVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpinVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__['_SetEpoch'](arg_epoch.COM_val))

    @property
    def InitialOffset(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInitialOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitialOffset.setter
    def InitialOffset(self, initialOffset:float) -> None:
        with agmarshall.DOUBLE_arg(initialOffset) as arg_initialOffset:
            agcls.evaluate_hresult(self.__dict__['_SetInitialOffset'](arg_initialOffset.COM_val))

    @property
    def SpinRate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSpinRate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpinRate.setter
    def SpinRate(self, spinRate:float) -> None:
        with agmarshall.DOUBLE_arg(spinRate) as arg_spinRate:
            agcls.evaluate_hresult(self.__dict__['_SetSpinRate'](arg_spinRate.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{ECB36015-B534-40C6-B50F-298217335C38}', IAgCrdnAxesSpinning)
agcls.AgTypeNameMap['IAgCrdnAxesSpinning'] = IAgCrdnAxesSpinning
__all__.append('IAgCrdnAxesSpinning')

class IAgCrdnAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""
    _uuid = '{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetUseMSL'] = _raise_uninitialized_error
        self.__dict__['_SetUseMSL'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesOnSurface from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesOnSurface = agcom.GUID(IAgCrdnAxesOnSurface._uuid)
        vtable_offset_local = IAgCrdnAxesOnSurface._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetUseMSL'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesOnSurface, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMSL'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesOnSurface, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesOnSurface.__dict__ and type(IAgCrdnAxesOnSurface.__dict__[attrname]) == property:
            return IAgCrdnAxesOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesOnSurface.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseMSL(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMSL'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__['_SetUseMSL'](arg_useMSL.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}', IAgCrdnAxesOnSurface)
agcls.AgTypeNameMap['IAgCrdnAxesOnSurface'] = IAgCrdnAxesOnSurface
__all__.append('IAgCrdnAxesOnSurface')

class IAgCrdnAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    _uuid = '{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTrajectoryPoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetTrajectoryAxesType'] = _raise_uninitialized_error
        self.__dict__['_SetTrajectoryAxesType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesTrajectory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesTrajectory = agcom.GUID(IAgCrdnAxesTrajectory._uuid)
        vtable_offset_local = IAgCrdnAxesTrajectory._vtable_offset - 1
        self.__dict__['_GetTrajectoryPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetTrajectoryAxesType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTrajectory, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetTrajectoryAxesType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTrajectory, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTrajectory.__dict__ and type(IAgCrdnAxesTrajectory.__dict__[attrname]) == property:
            return IAgCrdnAxesTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesTrajectory.')
    
    @property
    def TrajectoryPoint(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTrajectoryPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TrajectoryAxesType(self) -> "AgECrdnTrajectoryAxesType":
        """Specify a type of the trajectory's coordinate frame."""
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTrajectoryAxesType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TrajectoryAxesType.setter
    def TrajectoryAxesType(self, trajectoryAxesType:"AgECrdnTrajectoryAxesType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType, trajectoryAxesType) as arg_trajectoryAxesType:
            agcls.evaluate_hresult(self.__dict__['_SetTrajectoryAxesType'](arg_trajectoryAxesType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}', IAgCrdnAxesTrajectory)
agcls.AgTypeNameMap['IAgCrdnAxesTrajectory'] = IAgCrdnAxesTrajectory
__all__.append('IAgCrdnAxesTrajectory')

class IAgCrdnAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    _uuid = '{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPrimaryCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetPointType'] = _raise_uninitialized_error
        self.__dict__['_SetPointType'] = _raise_uninitialized_error
        self.__dict__['_GetSecondaryCentralBodies'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesLagrangeLibration from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesLagrangeLibration = agcom.GUID(IAgCrdnAxesLagrangeLibration._uuid)
        vtable_offset_local = IAgCrdnAxesLagrangeLibration._vtable_offset - 1
        self.__dict__['_GetPrimaryCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__['_SetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__['_GetSecondaryCentralBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesLagrangeLibration.__dict__ and type(IAgCrdnAxesLagrangeLibration.__dict__[attrname]) == property:
            return IAgCrdnAxesLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesLagrangeLibration.')
    
    @property
    def PrimaryCentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a primary central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPrimaryCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__['_SetPointType'](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "IAgCrdnCentralBodyCollection":
        """Specify secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSecondaryCentralBodies'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}', IAgCrdnAxesLagrangeLibration)
agcls.AgTypeNameMap['IAgCrdnAxesLagrangeLibration'] = IAgCrdnAxesLagrangeLibration
__all__.append('IAgCrdnAxesLagrangeLibration')

class IAgCrdnAxesCommonTasks(object):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = '{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_CreateTopocentricAxesQuaternion'] = _raise_uninitialized_error
        self.__dict__['_CreateTopocentricAxesEulerAngles'] = _raise_uninitialized_error
        self.__dict__['_CreateFixed'] = _raise_uninitialized_error
        self.__dict__['_Sample'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesCommonTasks from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesCommonTasks = agcom.GUID(IAgCrdnAxesCommonTasks._uuid)
        vtable_offset_local = IAgCrdnAxesCommonTasks._vtable_offset - 1
        self.__dict__['_CreateTopocentricAxesQuaternion'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_CreateTopocentricAxesEulerAngles'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_CreateFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCommonTasks, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_Sample'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesCommonTasks, vtable_offset_local+4, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesCommonTasks.__dict__ and type(IAgCrdnAxesCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnAxesCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesCommonTasks.')
    
    def CreateTopocentricAxesQuaternion(self, originPoint:"IAgCrdnPoint", qx:float, qy:float, qz:float, qs:float) -> "IAgCrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IAgCrdnPoint) as arg_originPoint, \
             agmarshall.DOUBLE_arg(qx) as arg_qx, \
             agmarshall.DOUBLE_arg(qy) as arg_qy, \
             agmarshall.DOUBLE_arg(qz) as arg_qz, \
             agmarshall.DOUBLE_arg(qs) as arg_qs, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateTopocentricAxesQuaternion'](arg_originPoint.COM_val, arg_qx.COM_val, arg_qy.COM_val, arg_qz.COM_val, arg_qs.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateTopocentricAxesEulerAngles(self, originPoint:"IAgCrdnPoint", sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> "IAgCrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, IAgCrdnPoint) as arg_originPoint, \
             agmarshall.AgEnum_arg(AgEEulerOrientationSequence, sequence) as arg_sequence, \
             agmarshall.VARIANT_arg(a) as arg_a, \
             agmarshall.VARIANT_arg(b) as arg_b, \
             agmarshall.VARIANT_arg(c) as arg_c, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateTopocentricAxesEulerAngles'](arg_originPoint.COM_val, arg_sequence.COM_val, arg_a.COM_val, arg_b.COM_val, arg_c.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixed(self, referenceAxes:"IAgCrdnAxes") -> "IAgCrdnAxesFixed":
        """Creates non-persistent fixed axes based on specified axes."""
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateFixed'](arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, axes:"IAgCrdnAxes", referenceAxes:"IAgCrdnAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IAgCrdnAxesSamplingResult":
        """Computes and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(axes, IAgCrdnAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Sample'](arg_axes.COM_val, arg_referenceAxes.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}', IAgCrdnAxesCommonTasks)
agcls.AgTypeNameMap['IAgCrdnAxesCommonTasks'] = IAgCrdnAxesCommonTasks
__all__.append('IAgCrdnAxesCommonTasks')

class IAgCrdnAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    _uuid = '{193F4A55-5E79-43A1-8A2C-3C001F7608A5}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetSourceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetSourceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesAtTimeInstant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesAtTimeInstant = agcom.GUID(IAgCrdnAxesAtTimeInstant._uuid)
        vtable_offset_local = IAgCrdnAxesAtTimeInstant._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSourceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetSourceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesAtTimeInstant.__dict__ and type(IAgCrdnAxesAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnAxesAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesAtTimeInstant.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))

    @property
    def SourceAxes(self) -> "IAgCrdnAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceAxes.setter
    def SourceAxes(self, sourceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(sourceAxes, IAgCrdnAxes) as arg_sourceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetSourceAxes'](arg_sourceAxes.COM_val))

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceAxes'](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{193F4A55-5E79-43A1-8A2C-3C001F7608A5}', IAgCrdnAxesAtTimeInstant)
agcls.AgTypeNameMap['IAgCrdnAxesAtTimeInstant'] = IAgCrdnAxesAtTimeInstant
__all__.append('IAgCrdnAxesAtTimeInstant')

class IAgCrdnAxesPlugin(object):
    """A VGT axes plugin."""
    _uuid = '{E63FD5E1-B844-4893-9E4C-3F02210AE74C}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetProgID'] = _raise_uninitialized_error
        self.__dict__['_GetDisplayName'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableProperties'] = _raise_uninitialized_error
        self.__dict__['_Reset'] = _raise_uninitialized_error
        self.__dict__['_SetProperty'] = _raise_uninitialized_error
        self.__dict__['_GetProperty'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesPlugin from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesPlugin = agcom.GUID(IAgCrdnAxesPlugin._uuid)
        vtable_offset_local = IAgCrdnAxesPlugin._vtable_offset - 1
        self.__dict__['_GetProgID'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetAvailableProperties'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Reset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+4, )
        self.__dict__['_SetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__['_GetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesPlugin.__dict__ and type(IAgCrdnAxesPlugin.__dict__[attrname]) == property:
            return IAgCrdnAxesPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesPlugin.')
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProgID'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDisplayName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableProperties'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__['_Reset']())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetProperty'](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProperty'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E63FD5E1-B844-4893-9E4C-3F02210AE74C}', IAgCrdnAxesPlugin)
agcls.AgTypeNameMap['IAgCrdnAxesPlugin'] = IAgCrdnAxesPlugin
__all__.append('IAgCrdnAxesPlugin')

class IAgCrdnAngleBetweenVectors(object):
    """An angle between two vectors."""
    _uuid = '{B3986E8E-A8CB-414F-8214-71C53ED00740}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFromVector'] = _raise_uninitialized_error
        self.__dict__['_GetToVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleBetweenVectors._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleBetweenVectors from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleBetweenVectors = agcom.GUID(IAgCrdnAngleBetweenVectors._uuid)
        vtable_offset_local = IAgCrdnAngleBetweenVectors._vtable_offset - 1
        self.__dict__['_GetFromVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleBetweenVectors, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetToVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleBetweenVectors, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleBetweenVectors.__dict__ and type(IAgCrdnAngleBetweenVectors.__dict__[attrname]) == property:
            return IAgCrdnAngleBetweenVectors.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleBetweenVectors.')
    
    @property
    def FromVector(self) -> "IAgCrdnVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFromVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IAgCrdnVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B3986E8E-A8CB-414F-8214-71C53ED00740}', IAgCrdnAngleBetweenVectors)
agcls.AgTypeNameMap['IAgCrdnAngleBetweenVectors'] = IAgCrdnAngleBetweenVectors
__all__.append('IAgCrdnAngleBetweenVectors')

class IAgCrdnAngleBetweenPlanes(object):
    """An angle between two planes."""
    _uuid = '{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFromPlane'] = _raise_uninitialized_error
        self.__dict__['_GetToPlane'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleBetweenPlanes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleBetweenPlanes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleBetweenPlanes = agcom.GUID(IAgCrdnAngleBetweenPlanes._uuid)
        vtable_offset_local = IAgCrdnAngleBetweenPlanes._vtable_offset - 1
        self.__dict__['_GetFromPlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleBetweenPlanes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetToPlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleBetweenPlanes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleBetweenPlanes.__dict__ and type(IAgCrdnAngleBetweenPlanes.__dict__[attrname]) == property:
            return IAgCrdnAngleBetweenPlanes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleBetweenPlanes.')
    
    @property
    def FromPlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFromPlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToPlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToPlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}', IAgCrdnAngleBetweenPlanes)
agcls.AgTypeNameMap['IAgCrdnAngleBetweenPlanes'] = IAgCrdnAngleBetweenPlanes
__all__.append('IAgCrdnAngleBetweenPlanes')

class IAgCrdnAngleDihedral(object):
    """An angle between two vectors about an axis."""
    _uuid = '{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFromVector'] = _raise_uninitialized_error
        self.__dict__['_GetToVector'] = _raise_uninitialized_error
        self.__dict__['_GetPoleAbout'] = _raise_uninitialized_error
        self.__dict__['_GetCounterClockwiseRotation'] = _raise_uninitialized_error
        self.__dict__['_SetCounterClockwiseRotation'] = _raise_uninitialized_error
        self.__dict__['_GetSignedAngle'] = _raise_uninitialized_error
        self.__dict__['_SetSignedAngle'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleDihedral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleDihedral from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleDihedral = agcom.GUID(IAgCrdnAngleDihedral._uuid)
        vtable_offset_local = IAgCrdnAngleDihedral._vtable_offset - 1
        self.__dict__['_GetFromVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetToVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetPoleAbout'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetCounterClockwiseRotation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetCounterClockwiseRotation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__['_GetSignedAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetSignedAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleDihedral, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleDihedral.__dict__ and type(IAgCrdnAngleDihedral.__dict__[attrname]) == property:
            return IAgCrdnAngleDihedral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleDihedral.')
    
    @property
    def FromVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a first vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFromVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a second vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PoleAbout(self) -> "IAgCrdnVectorRefTo":
        """Specify a vector about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoleAbout'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CounterClockwiseRotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCounterClockwiseRotation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, counterClockwiseRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(counterClockwiseRotation) as arg_counterClockwiseRotation:
            agcls.evaluate_hresult(self.__dict__['_SetCounterClockwiseRotation'](arg_counterClockwiseRotation.COM_val))

    @property
    def SignedAngle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignedAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignedAngle.setter
    def SignedAngle(self, signedAngle:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(signedAngle) as arg_signedAngle:
            agcls.evaluate_hresult(self.__dict__['_SetSignedAngle'](arg_signedAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}', IAgCrdnAngleDihedral)
agcls.AgTypeNameMap['IAgCrdnAngleDihedral'] = IAgCrdnAngleDihedral
__all__.append('IAgCrdnAngleDihedral')

class IAgCrdnAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    _uuid = '{9E842F77-B3A8-475C-96AA-E692B35E8E05}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFromAxes'] = _raise_uninitialized_error
        self.__dict__['_GetToAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceDirection'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceDirection'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleRotation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleRotation from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleRotation = agcom.GUID(IAgCrdnAngleRotation._uuid)
        vtable_offset_local = IAgCrdnAngleRotation._vtable_offset - 1
        self.__dict__['_GetFromAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRotation, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetToAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRotation, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRotation, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetReferenceDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleRotation, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleRotation.__dict__ and type(IAgCrdnAngleRotation.__dict__[attrname]) == property:
            return IAgCrdnAngleRotation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleRotation.')
    
    @property
    def FromAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify an axes to rotate from."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFromAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify an axes to rotate to."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetToAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceDirection(self) -> "AgECrdnDisplayAxisSelector":
        """Specify a rotation direction."""
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceDirection'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, referenceDirection:"AgECrdnDisplayAxisSelector") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector, referenceDirection) as arg_referenceDirection:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceDirection'](arg_referenceDirection.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{9E842F77-B3A8-475C-96AA-E692B35E8E05}', IAgCrdnAngleRotation)
agcls.AgTypeNameMap['IAgCrdnAngleRotation'] = IAgCrdnAngleRotation
__all__.append('IAgCrdnAngleRotation')

class IAgCrdnAngleToPlane(object):
    """An angle between a vector and a plane."""
    _uuid = '{DDFA25AD-174D-407B-B90C-747B3E43F7C9}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_GetSigned'] = _raise_uninitialized_error
        self.__dict__['_SetSigned'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleToPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleToPlane from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleToPlane = agcom.GUID(IAgCrdnAngleToPlane._uuid)
        vtable_offset_local = IAgCrdnAngleToPlane._vtable_offset - 1
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleToPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleToPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetSigned'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleToPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetSigned'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleToPlane, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleToPlane.__dict__ and type(IAgCrdnAngleToPlane.__dict__[attrname]) == property:
            return IAgCrdnAngleToPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleToPlane.')
    
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Signed(self) -> "AgECrdnSignedAngleType":
        """Controls whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSigned'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Signed.setter
    def Signed(self, signed:"AgECrdnSignedAngleType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType, signed) as arg_signed:
            agcls.evaluate_hresult(self.__dict__['_SetSigned'](arg_signed.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{DDFA25AD-174D-407B-B90C-747B3E43F7C9}', IAgCrdnAngleToPlane)
agcls.AgTypeNameMap['IAgCrdnAngleToPlane'] = IAgCrdnAngleToPlane
__all__.append('IAgCrdnAngleToPlane')

class IAgCrdnPlaneNormal(object):
    """A plane normal to a vector at a given point."""
    _uuid = '{AAF66E5C-B310-4387-BDAE-D45F24F226BC}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetNormalVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneNormal from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneNormal = agcom.GUID(IAgCrdnPlaneNormal._uuid)
        vtable_offset_local = IAgCrdnPlaneNormal._vtable_offset - 1
        self.__dict__['_GetNormalVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneNormal, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneNormal.__dict__ and type(IAgCrdnPlaneNormal.__dict__[attrname]) == property:
            return IAgCrdnPlaneNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneNormal.')
    
    @property
    def NormalVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{AAF66E5C-B310-4387-BDAE-D45F24F226BC}', IAgCrdnPlaneNormal)
agcls.AgTypeNameMap['IAgCrdnPlaneNormal'] = IAgCrdnPlaneNormal
__all__.append('IAgCrdnPlaneNormal')

class IAgCrdnPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""
    _uuid = '{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetQuadrant'] = _raise_uninitialized_error
        self.__dict__['_SetQuadrant'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneQuadrant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneQuadrant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneQuadrant = agcom.GUID(IAgCrdnPlaneQuadrant._uuid)
        vtable_offset_local = IAgCrdnPlaneQuadrant._vtable_offset - 1
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneQuadrant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetQuadrant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneQuadrant, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__['_SetQuadrant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneQuadrant, vtable_offset_local+3, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneQuadrant.__dict__ and type(IAgCrdnPlaneQuadrant.__dict__[attrname]) == property:
            return IAgCrdnPlaneQuadrant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneQuadrant.')
    
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quadrant(self) -> "AgECrdnQuadrantType":
        """Specify a quadrant."""
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetQuadrant'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Quadrant.setter
    def Quadrant(self, quadrant:"AgECrdnQuadrantType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType, quadrant) as arg_quadrant:
            agcls.evaluate_hresult(self.__dict__['_SetQuadrant'](arg_quadrant.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}', IAgCrdnPlaneQuadrant)
agcls.AgTypeNameMap['IAgCrdnPlaneQuadrant'] = IAgCrdnPlaneQuadrant
__all__.append('IAgCrdnPlaneQuadrant')

class IAgCrdnPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    _uuid = '{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetRotationOffset'] = _raise_uninitialized_error
        self.__dict__['_SetRotationOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneTrajectory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneTrajectory = agcom.GUID(IAgCrdnPlaneTrajectory._uuid)
        vtable_offset_local = IAgCrdnPlaneTrajectory._vtable_offset - 1
        self.__dict__['_GetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetRotationOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTrajectory, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRotationOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTrajectory, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTrajectory.__dict__ and type(IAgCrdnPlaneTrajectory.__dict__[attrname]) == property:
            return IAgCrdnPlaneTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneTrajectory.')
    
    @property
    def Point(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRotationOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__['_SetRotationOffset'](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}', IAgCrdnPlaneTrajectory)
agcls.AgTypeNameMap['IAgCrdnPlaneTrajectory'] = IAgCrdnPlaneTrajectory
__all__.append('IAgCrdnPlaneTrajectory')

class IAgCrdnPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""
    _uuid = '{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPointA'] = _raise_uninitialized_error
        self.__dict__['_GetPointB'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetRotationOffset'] = _raise_uninitialized_error
        self.__dict__['_SetRotationOffset'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneTriad._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneTriad from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneTriad = agcom.GUID(IAgCrdnPlaneTriad._uuid)
        vtable_offset_local = IAgCrdnPlaneTriad._vtable_offset - 1
        self.__dict__['_GetPointA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTriad, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetPointB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTriad, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTriad, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetRotationOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTriad, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__['_SetRotationOffset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTriad, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTriad.__dict__ and type(IAgCrdnPlaneTriad.__dict__[attrname]) == property:
            return IAgCrdnPlaneTriad.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneTriad.')
    
    @property
    def PointA(self) -> "IAgCrdnPointRefTo":
        """Specify a point A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointB(self) -> "IAgCrdnPointRefTo":
        """Specify a point B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRotationOffset'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__['_SetRotationOffset'](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}', IAgCrdnPlaneTriad)
agcls.AgTypeNameMap['IAgCrdnPlaneTriad'] = IAgCrdnPlaneTriad
__all__.append('IAgCrdnPlaneTriad')

class IAgCrdnPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""
    _uuid = '{345761f0-0ace-494c-8d9c-0f3e3af9c2da}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetVector2'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneTwoVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneTwoVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneTwoVector = agcom.GUID(IAgCrdnPlaneTwoVector._uuid)
        vtable_offset_local = IAgCrdnPlaneTwoVector._vtable_offset - 1
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTwoVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetVector2'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTwoVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneTwoVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneTwoVector.__dict__ and type(IAgCrdnPlaneTwoVector.__dict__[attrname]) == property:
            return IAgCrdnPlaneTwoVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneTwoVector.')
    
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Vector2(self) -> "IAgCrdnVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector2'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{345761f0-0ace-494c-8d9c-0f3e3af9c2da}', IAgCrdnPlaneTwoVector)
agcls.AgTypeNameMap['IAgCrdnPlaneTwoVector'] = IAgCrdnPlaneTwoVector
__all__.append('IAgCrdnPlaneTwoVector')

class IAgCrdnPointBPlane(object):
    """B-Plane point using the selected target body."""
    _uuid = '{CC3B797F-5327-4D04-911D-8ED499E056AF}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTargetBody'] = _raise_uninitialized_error
        self.__dict__['_GetTrajectory'] = _raise_uninitialized_error
        self.__dict__['_GetPointType'] = _raise_uninitialized_error
        self.__dict__['_SetPointType'] = _raise_uninitialized_error
        self.__dict__['_GetDirection'] = _raise_uninitialized_error
        self.__dict__['_SetDirection'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointBPlane from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointBPlane = agcom.GUID(IAgCrdnPointBPlane._uuid)
        vtable_offset_local = IAgCrdnPointBPlane._vtable_offset - 1
        self.__dict__['_GetTargetBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetTrajectory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointBPlane, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointBPlane.__dict__ and type(IAgCrdnPointBPlane.__dict__[attrname]) == property:
            return IAgCrdnPointBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointBPlane.')
    
    @property
    def TargetBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Trajectory(self) -> "IAgCrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTrajectory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnPointBPlaneType":
        """Specify a point type."""
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnPointBPlaneType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__['_SetPointType'](arg_pointType.COM_val))

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirection'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__['_SetDirection'](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CC3B797F-5327-4D04-911D-8ED499E056AF}', IAgCrdnPointBPlane)
agcls.AgTypeNameMap['IAgCrdnPointBPlane'] = IAgCrdnPointBPlane
__all__.append('IAgCrdnPointBPlane')

class IAgCrdnPointFile(object):
    """Point specified by data from a file."""
    _uuid = '{9612277C-2238-42BD-89D7-E54D7701D8F2}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFilename'] = _raise_uninitialized_error
        self.__dict__['_SetFilename'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointFile from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointFile = agcom.GUID(IAgCrdnPointFile._uuid)
        vtable_offset_local = IAgCrdnPointFile._vtable_offset - 1
        self.__dict__['_GetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetFilename'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFile.__dict__ and type(IAgCrdnPointFile.__dict__[attrname]) == property:
            return IAgCrdnPointFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointFile.')
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFilename'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__['_SetFilename'](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{9612277C-2238-42BD-89D7-E54D7701D8F2}', IAgCrdnPointFile)
agcls.AgTypeNameMap['IAgCrdnPointFile'] = IAgCrdnPointFile
__all__.append('IAgCrdnPointFile')

class IAgCrdnPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    _uuid = '{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReference'] = _raise_uninitialized_error
        self.__dict__['_GetFixedPoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointFixedInSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointFixedInSystem from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointFixedInSystem = agcom.GUID(IAgCrdnPointFixedInSystem._uuid)
        vtable_offset_local = IAgCrdnPointFixedInSystem._vtable_offset - 1
        self.__dict__['_GetReference'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFixedInSystem, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetFixedPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFixedInSystem, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFixedInSystem.__dict__ and type(IAgCrdnPointFixedInSystem.__dict__[attrname]) == property:
            return IAgCrdnPointFixedInSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointFixedInSystem.')
    
    @property
    def Reference(self) -> "IAgCrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReference'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedPoint(self) -> "IAgPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixedPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}', IAgCrdnPointFixedInSystem)
agcls.AgTypeNameMap['IAgCrdnPointFixedInSystem'] = IAgCrdnPointFixedInSystem
__all__.append('IAgCrdnPointFixedInSystem')

class IAgCrdnPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    _uuid = '{7FDF037E-1367-4590-A330-660EF3442DE1}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetDirectionVector'] = _raise_uninitialized_error
        self.__dict__['_GetAltitude'] = _raise_uninitialized_error
        self.__dict__['_SetAltitude'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointGrazing from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointGrazing = agcom.GUID(IAgCrdnPointGrazing._uuid)
        vtable_offset_local = IAgCrdnPointGrazing._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetDirectionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGrazing, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGrazing, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGrazing, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGrazing.__dict__ and type(IAgCrdnPointGrazing.__dict__[attrname]) == property:
            return IAgCrdnPointGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointGrazing.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirectionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAltitude'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__['_SetAltitude'](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7FDF037E-1367-4590-A330-660EF3442DE1}', IAgCrdnPointGrazing)
agcls.AgTypeNameMap['IAgCrdnPointGrazing'] = IAgCrdnPointGrazing
__all__.append('IAgCrdnPointGrazing')

class IAgCrdnPointGlint(object):
    """Point on central body surface that reflects from source to observer."""
    _uuid = '{C4168949-A6F2-42B7-8019-671FF808836D}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetSourcePoint'] = _raise_uninitialized_error
        self.__dict__['_GetObserverPoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointGlint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointGlint from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointGlint = agcom.GUID(IAgCrdnPointGlint._uuid)
        vtable_offset_local = IAgCrdnPointGlint._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGlint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetSourcePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGlint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetObserverPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGlint, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGlint.__dict__ and type(IAgCrdnPointGlint.__dict__[attrname]) == property:
            return IAgCrdnPointGlint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointGlint.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SourcePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourcePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ObserverPoint(self) -> "IAgCrdnPointRefTo":
        """Specify an observer point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetObserverPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C4168949-A6F2-42B7-8019-671FF808836D}', IAgCrdnPointGlint)
agcls.AgTypeNameMap['IAgCrdnPointGlint'] = IAgCrdnPointGlint
__all__.append('IAgCrdnPointGlint')

class IAgCrdnPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    _uuid = '{CC9E8B92-77D8-46A9-BD52-3DABB173913D}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetDirectionVector'] = _raise_uninitialized_error
        self.__dict__['_GetTargetName'] = _raise_uninitialized_error
        self.__dict__['_SetTargetName'] = _raise_uninitialized_error
        self.__dict__['_GetDistance'] = _raise_uninitialized_error
        self.__dict__['_SetDistance'] = _raise_uninitialized_error
        self.__dict__['_GetProbability'] = _raise_uninitialized_error
        self.__dict__['_SetProbability'] = _raise_uninitialized_error
        self.__dict__['_GetScale'] = _raise_uninitialized_error
        self.__dict__['_SetScale'] = _raise_uninitialized_error
        self.__dict__['_GetUseProbability'] = _raise_uninitialized_error
        self.__dict__['_SetUseProbability'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointCovarianceGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointCovarianceGrazing from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointCovarianceGrazing = agcom.GUID(IAgCrdnPointCovarianceGrazing._uuid)
        vtable_offset_local = IAgCrdnPointCovarianceGrazing._vtable_offset - 1
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetDirectionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetTargetName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__['_SetTargetName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+4, agcom.BSTR)
        self.__dict__['_GetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDistance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetProbability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetProbability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__['_GetScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetUseProbability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseProbability'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCovarianceGrazing, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCovarianceGrazing.__dict__ and type(IAgCrdnPointCovarianceGrazing.__dict__[attrname]) == property:
            return IAgCrdnPointCovarianceGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointCovarianceGrazing.')
    
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirectionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetName(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTargetName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TargetName.setter
    def TargetName(self, targetName:str) -> None:
        with agmarshall.BSTR_arg(targetName) as arg_targetName:
            agcls.evaluate_hresult(self.__dict__['_SetTargetName'](arg_targetName.COM_val))

    @property
    def Distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDistance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:float) -> None:
        with agmarshall.DOUBLE_arg(distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__['_SetDistance'](arg_distance.COM_val))

    @property
    def Probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProbability'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Probability.setter
    def Probability(self, probability:float) -> None:
        with agmarshall.DOUBLE_arg(probability) as arg_probability:
            agcls.evaluate_hresult(self.__dict__['_SetProbability'](arg_probability.COM_val))

    @property
    def Scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScale'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__['_SetScale'](arg_scale.COM_val))

    @property
    def UseProbability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseProbability'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseProbability.setter
    def UseProbability(self, useProbability:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useProbability) as arg_useProbability:
            agcls.evaluate_hresult(self.__dict__['_SetUseProbability'](arg_useProbability.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CC9E8B92-77D8-46A9-BD52-3DABB173913D}', IAgCrdnPointCovarianceGrazing)
agcls.AgTypeNameMap['IAgCrdnPointCovarianceGrazing'] = IAgCrdnPointCovarianceGrazing
__all__.append('IAgCrdnPointCovarianceGrazing')

class IAgCrdnPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""
    _uuid = '{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetDirectionVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        self.__dict__['_GetOriginPoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointPlaneIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointPlaneIntersection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointPlaneIntersection = agcom.GUID(IAgCrdnPointPlaneIntersection._uuid)
        vtable_offset_local = IAgCrdnPointPlaneIntersection._vtable_offset - 1
        self.__dict__['_GetDirectionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlaneIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlaneIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetOriginPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlaneIntersection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlaneIntersection.__dict__ and type(IAgCrdnPointPlaneIntersection.__dict__[attrname]) == property:
            return IAgCrdnPointPlaneIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointPlaneIntersection.')
    
    @property
    def DirectionVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a direction vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirectionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginPoint(self) -> "IAgCrdnPointRefTo":
        """Specify the origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}', IAgCrdnPointPlaneIntersection)
agcls.AgTypeNameMap['IAgCrdnPointPlaneIntersection'] = IAgCrdnPointPlaneIntersection
__all__.append('IAgCrdnPointPlaneIntersection')

class IAgCrdnPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""
    _uuid = '{AED0D41F-BB69-4672-A513-17A43B12873D}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceShape'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceShape'] = _raise_uninitialized_error
        self.__dict__['_GetSurfaceType'] = _raise_uninitialized_error
        self.__dict__['_SetSurfaceType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointOnSurface from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointOnSurface = agcom.GUID(IAgCrdnPointOnSurface._uuid)
        vtable_offset_local = IAgCrdnPointOnSurface._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceShape'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetReferenceShape'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetSurfaceType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__['_SetSurfaceType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointOnSurface, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointOnSurface.__dict__ and type(IAgCrdnPointOnSurface.__dict__[attrname]) == property:
            return IAgCrdnPointOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointOnSurface.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Specify a reference shape."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceShape'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceShape'](arg_referenceShape.COM_val))

    @property
    def SurfaceType(self) -> "AgECrdnSurfaceType":
        """Specify a surface type."""
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSurfaceType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceType.setter
    def SurfaceType(self, surfaceType:"AgECrdnSurfaceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType, surfaceType) as arg_surfaceType:
            agcls.evaluate_hresult(self.__dict__['_SetSurfaceType'](arg_surfaceType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{AED0D41F-BB69-4672-A513-17A43B12873D}', IAgCrdnPointOnSurface)
agcls.AgTypeNameMap['IAgCrdnPointOnSurface'] = IAgCrdnPointOnSurface
__all__.append('IAgCrdnPointOnSurface')

class IAgCrdnPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    _uuid = '{CFEB5448-9053-44F6-BCB5-35280361131F}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPointableElementName'] = _raise_uninitialized_error
        self.__dict__['_SetPointableElementName'] = _raise_uninitialized_error
        self.__dict__['_GetUseScale'] = _raise_uninitialized_error
        self.__dict__['_SetUseScale'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointModelAttach from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointModelAttach = agcom.GUID(IAgCrdnPointModelAttach._uuid)
        vtable_offset_local = IAgCrdnPointModelAttach._vtable_offset - 1
        self.__dict__['_GetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointModelAttach, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetUseScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointModelAttach, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointModelAttach, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointModelAttach.__dict__ and type(IAgCrdnPointModelAttach.__dict__[attrname]) == property:
            return IAgCrdnPointModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointModelAttach.')
    
    @property
    def PointableElementName(self) -> str:
        """Specify a model attachment point."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointableElementName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__['_SetPointableElementName'](arg_pointableElementName.COM_val))

    @property
    def UseScale(self) -> bool:
        """Specify whether to use the model scale."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseScale'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScale.setter
    def UseScale(self, useScale:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScale) as arg_useScale:
            agcls.evaluate_hresult(self.__dict__['_SetUseScale'](arg_useScale.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CFEB5448-9053-44F6-BCB5-35280361131F}', IAgCrdnPointModelAttach)
agcls.AgTypeNameMap['IAgCrdnPointModelAttach'] = IAgCrdnPointModelAttach
__all__.append('IAgCrdnPointModelAttach')

class IAgCrdnPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    _uuid = '{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEntryName'] = _raise_uninitialized_error
        self.__dict__['_SetEntryName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointSatelliteCollectionEntry._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointSatelliteCollectionEntry from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointSatelliteCollectionEntry = agcom.GUID(IAgCrdnPointSatelliteCollectionEntry._uuid)
        vtable_offset_local = IAgCrdnPointSatelliteCollectionEntry._vtable_offset - 1
        self.__dict__['_GetEntryName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSatelliteCollectionEntry, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetEntryName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSatelliteCollectionEntry, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSatelliteCollectionEntry.__dict__ and type(IAgCrdnPointSatelliteCollectionEntry.__dict__[attrname]) == property:
            return IAgCrdnPointSatelliteCollectionEntry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointSatelliteCollectionEntry.')
    
    @property
    def EntryName(self) -> str:
        """Specify a satellite collection entry name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEntryName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EntryName.setter
    def EntryName(self, entryName:str) -> None:
        with agmarshall.BSTR_arg(entryName) as arg_entryName:
            agcls.evaluate_hresult(self.__dict__['_SetEntryName'](arg_entryName.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}', IAgCrdnPointSatelliteCollectionEntry)
agcls.AgTypeNameMap['IAgCrdnPointSatelliteCollectionEntry'] = IAgCrdnPointSatelliteCollectionEntry
__all__.append('IAgCrdnPointSatelliteCollectionEntry')

class IAgCrdnPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    _uuid = '{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSourcePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointPlaneProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointPlaneProjection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointPlaneProjection = agcom.GUID(IAgCrdnPointPlaneProjection._uuid)
        vtable_offset_local = IAgCrdnPointPlaneProjection._vtable_offset - 1
        self.__dict__['_GetSourcePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlaneProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlaneProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlaneProjection.__dict__ and type(IAgCrdnPointPlaneProjection.__dict__[attrname]) == property:
            return IAgCrdnPointPlaneProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointPlaneProjection.')
    
    @property
    def SourcePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourcePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}', IAgCrdnPointPlaneProjection)
agcls.AgTypeNameMap['IAgCrdnPointPlaneProjection'] = IAgCrdnPointPlaneProjection
__all__.append('IAgCrdnPointPlaneProjection')

class IAgCrdnPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    _uuid = '{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetPointType'] = _raise_uninitialized_error
        self.__dict__['_SetPointType'] = _raise_uninitialized_error
        self.__dict__['_GetSecondaryCentralBodies'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointLagrangeLibration from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointLagrangeLibration = agcom.GUID(IAgCrdnPointLagrangeLibration._uuid)
        vtable_offset_local = IAgCrdnPointLagrangeLibration._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__['_SetPointType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__['_GetSecondaryCentralBodies'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLagrangeLibration.__dict__ and type(IAgCrdnPointLagrangeLibration.__dict__[attrname]) == property:
            return IAgCrdnPointLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointLagrangeLibration.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__['_SetPointType'](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "IAgCrdnCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSecondaryCentralBodies'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}', IAgCrdnPointLagrangeLibration)
agcls.AgTypeNameMap['IAgCrdnPointLagrangeLibration'] = IAgCrdnPointLagrangeLibration
__all__.append('IAgCrdnPointLagrangeLibration')

class IAgCrdnPointCommonTasks(object):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = '{C357C0A5-3F2A-499C-83F3-6824532C969E}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_CreateFixedInSystemCartographic'] = _raise_uninitialized_error
        self.__dict__['_CreateFixedInSystemCartesian'] = _raise_uninitialized_error
        self.__dict__['_Sample'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointCommonTasks from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointCommonTasks = agcom.GUID(IAgCrdnPointCommonTasks._uuid)
        vtable_offset_local = IAgCrdnPointCommonTasks._vtable_offset - 1
        self.__dict__['_CreateFixedInSystemCartographic'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_CreateFixedInSystemCartesian'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_Sample'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCommonTasks, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCommonTasks.__dict__ and type(IAgCrdnPointCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnPointCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointCommonTasks.')
    
    def CreateFixedInSystemCartographic(self, referenceSystem:"IAgCrdnSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IAgCrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateFixedInSystemCartographic'](arg_referenceSystem.COM_val, arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixedInSystemCartesian(self, referenceSystem:"IAgCrdnSystem", x:float, y:float, z:float) -> "IAgCrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem, \
             agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateFixedInSystemCartesian'](arg_referenceSystem.COM_val, arg_x.COM_val, arg_y.COM_val, arg_z.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, point:"IAgCrdnPoint", referenceSystem:"IAgCrdnSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "IAgCrdnPointSamplingResult":
        """Computes and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point, \
             agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Sample'](arg_point.COM_val, arg_referenceSystem.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C357C0A5-3F2A-499C-83F3-6824532C969E}', IAgCrdnPointCommonTasks)
agcls.AgTypeNameMap['IAgCrdnPointCommonTasks'] = IAgCrdnPointCommonTasks
__all__.append('IAgCrdnPointCommonTasks')

class IAgCrdnPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""
    _uuid = '{C0F5946B-9467-44AC-B16A-9276CE4EA141}'
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_SetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetDirectionVector'] = _raise_uninitialized_error
        self.__dict__['_SetDirectionVector'] = _raise_uninitialized_error
        self.__dict__['_GetIntersectionSurface'] = _raise_uninitialized_error
        self.__dict__['_SetIntersectionSurface'] = _raise_uninitialized_error
        self.__dict__['_GetAltitude'] = _raise_uninitialized_error
        self.__dict__['_SetAltitude'] = _raise_uninitialized_error
        self.__dict__['_GetUseRangeConstraint'] = _raise_uninitialized_error
        self.__dict__['_SetUseRangeConstraint'] = _raise_uninitialized_error
        self.__dict__['_GetMinimumRange'] = _raise_uninitialized_error
        self.__dict__['_SetMinimumRange'] = _raise_uninitialized_error
        self.__dict__['_GetMaximumRange'] = _raise_uninitialized_error
        self.__dict__['_SetMaximumRange'] = _raise_uninitialized_error
        self.__dict__['_GetUseMinimumRange'] = _raise_uninitialized_error
        self.__dict__['_SetUseMinimumRange'] = _raise_uninitialized_error
        self.__dict__['_GetUseMaximumRange'] = _raise_uninitialized_error
        self.__dict__['_SetUseMaximumRange'] = _raise_uninitialized_error
        self.__dict__['_SetRange'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointCentBodyIntersect._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointCentBodyIntersect from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointCentBodyIntersect = agcom.GUID(IAgCrdnPointCentBodyIntersect._uuid)
        vtable_offset_local = IAgCrdnPointCentBodyIntersect._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetDirectionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetDirectionVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+6, agcom.PVOID)
        self.__dict__['_GetIntersectionSurface'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetIntersectionSurface'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetUseRangeConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseRangeConstraint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__['_GetMinimumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMinimumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__['_GetMaximumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__['_SetMaximumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__['_GetUseMinimumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMinimumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__['_GetUseMaximumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMaximumRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__['_SetRange'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCentBodyIntersect, vtable_offset_local+21, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCentBodyIntersect.__dict__ and type(IAgCrdnPointCentBodyIntersect.__dict__[attrname]) == property:
            return IAgCrdnPointCentBodyIntersect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointCentBodyIntersect.')
    
    @property
    def CentralBody(self) -> str:
        """Central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))

    @property
    def ReferencePoint(self) -> "IAgCrdnPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, IAgCrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__['_SetReferencePoint'](arg_referencePoint.COM_val))

    @property
    def DirectionVector(self) -> "IAgCrdnVector":
        """A direction vector. Can be any vector from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirectionVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DirectionVector.setter
    def DirectionVector(self, directionVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(directionVector, IAgCrdnVector) as arg_directionVector:
            agcls.evaluate_hresult(self.__dict__['_SetDirectionVector'](arg_directionVector.COM_val))

    @property
    def IntersectionSurface(self) -> "AgECrdnIntersectionSurface":
        """An intersection surface."""
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntersectionSurface'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntersectionSurface.setter
    def IntersectionSurface(self, intersectionSurface:"AgECrdnIntersectionSurface") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface, intersectionSurface) as arg_intersectionSurface:
            agcls.evaluate_hresult(self.__dict__['_SetIntersectionSurface'](arg_intersectionSurface.COM_val))

    @property
    def Altitude(self) -> float:
        """An altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAltitude'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__['_SetAltitude'](arg_altitude.COM_val))

    @property
    def UseRangeConstraint(self) -> bool:
        """Whether to use range constraint."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseRangeConstraint'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseRangeConstraint.setter
    def UseRangeConstraint(self, useRangeConstraint:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useRangeConstraint) as arg_useRangeConstraint:
            agcls.evaluate_hresult(self.__dict__['_SetUseRangeConstraint'](arg_useRangeConstraint.COM_val))

    @property
    def MinimumRange(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMinimumRange'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumRange.setter
    def MinimumRange(self, minimumRange:float) -> None:
        with agmarshall.DOUBLE_arg(minimumRange) as arg_minimumRange:
            agcls.evaluate_hresult(self.__dict__['_SetMinimumRange'](arg_minimumRange.COM_val))

    @property
    def MaximumRange(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMaximumRange'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumRange.setter
    def MaximumRange(self, maximumRange:float) -> None:
        with agmarshall.DOUBLE_arg(maximumRange) as arg_maximumRange:
            agcls.evaluate_hresult(self.__dict__['_SetMaximumRange'](arg_maximumRange.COM_val))

    @property
    def UseMinimumRange(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMinimumRange'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumRange.setter
    def UseMinimumRange(self, useMinimumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumRange) as arg_useMinimumRange:
            agcls.evaluate_hresult(self.__dict__['_SetUseMinimumRange'](arg_useMinimumRange.COM_val))

    @property
    def UseMaximumRange(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMaximumRange'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumRange.setter
    def UseMaximumRange(self, useMaximumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumRange) as arg_useMaximumRange:
            agcls.evaluate_hresult(self.__dict__['_SetUseMaximumRange'](arg_useMaximumRange.COM_val))

    def SetRange(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg(minimum) as arg_minimum, \
             agmarshall.DOUBLE_arg(maximum) as arg_maximum:
            agcls.evaluate_hresult(self.__dict__['_SetRange'](arg_minimum.COM_val, arg_maximum.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{C0F5946B-9467-44AC-B16A-9276CE4EA141}', IAgCrdnPointCentBodyIntersect)
agcls.AgTypeNameMap['IAgCrdnPointCentBodyIntersect'] = IAgCrdnPointCentBodyIntersect
__all__.append('IAgCrdnPointCentBodyIntersect')

class IAgCrdnPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    _uuid = '{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetSourcePoint'] = _raise_uninitialized_error
        self.__dict__['_SetSourcePoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointAtTimeInstant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointAtTimeInstant = agcom.GUID(IAgCrdnPointAtTimeInstant._uuid)
        vtable_offset_local = IAgCrdnPointAtTimeInstant._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSourcePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetSourcePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointAtTimeInstant.__dict__ and type(IAgCrdnPointAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnPointAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointAtTimeInstant.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))

    @property
    def SourcePoint(self) -> "IAgCrdnPoint":
        """A source point. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourcePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourcePoint.setter
    def SourcePoint(self, sourcePoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(sourcePoint, IAgCrdnPoint) as arg_sourcePoint:
            agcls.evaluate_hresult(self.__dict__['_SetSourcePoint'](arg_sourcePoint.COM_val))

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """A reference system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}', IAgCrdnPointAtTimeInstant)
agcls.AgTypeNameMap['IAgCrdnPointAtTimeInstant'] = IAgCrdnPointAtTimeInstant
__all__.append('IAgCrdnPointAtTimeInstant')

class IAgCrdnPointPlugin(object):
    """A VGT point plugin."""
    _uuid = '{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetProgID'] = _raise_uninitialized_error
        self.__dict__['_GetDisplayName'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableProperties'] = _raise_uninitialized_error
        self.__dict__['_Reset'] = _raise_uninitialized_error
        self.__dict__['_SetProperty'] = _raise_uninitialized_error
        self.__dict__['_GetProperty'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointPlugin from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointPlugin = agcom.GUID(IAgCrdnPointPlugin._uuid)
        vtable_offset_local = IAgCrdnPointPlugin._vtable_offset - 1
        self.__dict__['_GetProgID'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetAvailableProperties'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Reset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+4, )
        self.__dict__['_SetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__['_GetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointPlugin.__dict__ and type(IAgCrdnPointPlugin.__dict__[attrname]) == property:
            return IAgCrdnPointPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointPlugin.')
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProgID'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDisplayName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableProperties'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__['_Reset']())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetProperty'](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProperty'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}', IAgCrdnPointPlugin)
agcls.AgTypeNameMap['IAgCrdnPointPlugin'] = IAgCrdnPointPlugin
__all__.append('IAgCrdnPointPlugin')

class IAgCrdnPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""
    _uuid = '{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceShape'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceShape'] = _raise_uninitialized_error
        self.__dict__['_GetPosition'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointCBFixedOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointCBFixedOffset from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointCBFixedOffset = agcom.GUID(IAgCrdnPointCBFixedOffset._uuid)
        vtable_offset_local = IAgCrdnPointCBFixedOffset._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCBFixedOffset, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCBFixedOffset, vtable_offset_local+2, agcom.BSTR)
        self.__dict__['_GetReferenceShape'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCBFixedOffset, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetReferenceShape'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCBFixedOffset, vtable_offset_local+4, agcom.LONG)
        self.__dict__['_GetPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointCBFixedOffset, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointCBFixedOffset.__dict__ and type(IAgCrdnPointCBFixedOffset.__dict__[attrname]) == property:
            return IAgCrdnPointCBFixedOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointCBFixedOffset.')
    
    @property
    def CentralBody(self) -> str:
        """Get the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceShape'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceShape'](arg_referenceShape.COM_val))

    @property
    def Position(self) -> "IAgPosition":
        """A position of the point fixed on the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}', IAgCrdnPointCBFixedOffset)
agcls.AgTypeNameMap['IAgCrdnPointCBFixedOffset'] = IAgCrdnPointCBFixedOffset
__all__.append('IAgCrdnPointCBFixedOffset')

class IAgCrdnSystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""
    _uuid = '{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginPoint'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemAssembled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemAssembled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemAssembled = agcom.GUID(IAgCrdnSystemAssembled._uuid)
        vtable_offset_local = IAgCrdnSystemAssembled._vtable_offset - 1
        self.__dict__['_GetOriginPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemAssembled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemAssembled, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemAssembled.__dict__ and type(IAgCrdnSystemAssembled.__dict__[attrname]) == property:
            return IAgCrdnSystemAssembled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemAssembled.')
    
    @property
    def OriginPoint(self) -> "IAgCrdnPointRefTo":
        """Specify a point of origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}', IAgCrdnSystemAssembled)
agcls.AgTypeNameMap['IAgCrdnSystemAssembled'] = IAgCrdnSystemAssembled
__all__.append('IAgCrdnSystemAssembled')

class IAgCrdnSystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    _uuid = '{15798E36-1EC0-4A73-A910-FC28CC404082}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetAzimuthAngle'] = _raise_uninitialized_error
        self.__dict__['_SetAzimuthAngle'] = _raise_uninitialized_error
        self.__dict__['_GetUseMSL'] = _raise_uninitialized_error
        self.__dict__['_SetUseMSL'] = _raise_uninitialized_error
        self.__dict__['_GetPosition'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemOnSurface from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemOnSurface = agcom.GUID(IAgCrdnSystemOnSurface._uuid)
        vtable_offset_local = IAgCrdnSystemOnSurface._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetAzimuthAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAzimuthAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__['_GetUseMSL'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseMSL'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__['_GetPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemOnSurface, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemOnSurface.__dict__ and type(IAgCrdnSystemOnSurface.__dict__[attrname]) == property:
            return IAgCrdnSystemOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemOnSurface.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AzimuthAngle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAzimuthAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AzimuthAngle.setter
    def AzimuthAngle(self, azimuthAngle:float) -> None:
        with agmarshall.DOUBLE_arg(azimuthAngle) as arg_azimuthAngle:
            agcls.evaluate_hresult(self.__dict__['_SetAzimuthAngle'](arg_azimuthAngle.COM_val))

    @property
    def UseMSL(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseMSL'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__['_SetUseMSL'](arg_useMSL.COM_val))

    @property
    def Position(self) -> "IAgCrdnLLAPosition":
        """Specify the position of the system's origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{15798E36-1EC0-4A73-A910-FC28CC404082}', IAgCrdnSystemOnSurface)
agcls.AgTypeNameMap['IAgCrdnSystemOnSurface'] = IAgCrdnSystemOnSurface
__all__.append('IAgCrdnSystemOnSurface')

class IAgCrdnLLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""
    _uuid = '{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetLatitude'] = _raise_uninitialized_error
        self.__dict__['_SetLatitude'] = _raise_uninitialized_error
        self.__dict__['_GetLongitude'] = _raise_uninitialized_error
        self.__dict__['_SetLongitude'] = _raise_uninitialized_error
        self.__dict__['_GetAltitude'] = _raise_uninitialized_error
        self.__dict__['_SetAltitude'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnLLAPosition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnLLAPosition from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnLLAPosition = agcom.GUID(IAgCrdnLLAPosition._uuid)
        vtable_offset_local = IAgCrdnLLAPosition._vtable_offset - 1
        self.__dict__['_GetLatitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__['_SetLatitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__['_GetLongitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetLongitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetAltitude'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnLLAPosition, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnLLAPosition.__dict__ and type(IAgCrdnLLAPosition.__dict__[attrname]) == property:
            return IAgCrdnLLAPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnLLAPosition.')
    
    @property
    def Latitude(self) -> float:
        """Specify a latitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLatitude'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Latitude.setter
    def Latitude(self, latitude:float) -> None:
        with agmarshall.DOUBLE_arg(latitude) as arg_latitude:
            agcls.evaluate_hresult(self.__dict__['_SetLatitude'](arg_latitude.COM_val))

    @property
    def Longitude(self) -> float:
        """Specify a longitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetLongitude'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Longitude.setter
    def Longitude(self, longitude:float) -> None:
        with agmarshall.DOUBLE_arg(longitude) as arg_longitude:
            agcls.evaluate_hresult(self.__dict__['_SetLongitude'](arg_longitude.COM_val))

    @property
    def Altitude(self) -> float:
        """Specify an altitude value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAltitude'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__['_SetAltitude'](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}', IAgCrdnLLAPosition)
agcls.AgTypeNameMap['IAgCrdnLLAPosition'] = IAgCrdnLLAPosition
__all__.append('IAgCrdnLLAPosition')

class IAgCrdnSystemCommonTasks(object):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = '{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_CreateEastNorthUpCartographic'] = _raise_uninitialized_error
        self.__dict__['_CreateAssembled'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemCommonTasks from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemCommonTasks = agcom.GUID(IAgCrdnSystemCommonTasks._uuid)
        vtable_offset_local = IAgCrdnSystemCommonTasks._vtable_offset - 1
        self.__dict__['_CreateEastNorthUpCartographic'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemCommonTasks, vtable_offset_local+1, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__['_CreateAssembled'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemCommonTasks.__dict__ and type(IAgCrdnSystemCommonTasks.__dict__[attrname]) == property:
            return IAgCrdnSystemCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemCommonTasks.')
    
    def CreateEastNorthUpCartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "IAgCrdnSystemAssembled":
        """Creates a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        with agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateEastNorthUpCartographic'](arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAssembled(self, originPoint:"IAgCrdnPoint", referenceAxes:"IAgCrdnAxes") -> "IAgCrdnSystemAssembled":
        """Creates a non-persistent system component assembled from an origin point and a set of reference axes."""
        with agmarshall.AgInterface_in_arg(originPoint, IAgCrdnPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateAssembled'](arg_originPoint.COM_val, arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}', IAgCrdnSystemCommonTasks)
agcls.AgTypeNameMap['IAgCrdnSystemCommonTasks'] = IAgCrdnSystemCommonTasks
__all__.append('IAgCrdnSystemCommonTasks')

class IAgCrdnVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    _uuid = '{CFC40EEB-A99F-4DAD-A366-1C7908C15128}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorAngleRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorAngleRate from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorAngleRate = agcom.GUID(IAgCrdnVectorAngleRate._uuid)
        vtable_offset_local = IAgCrdnVectorAngleRate._vtable_offset - 1
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngleRate, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngleRate, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngleRate, vtable_offset_local+3, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorAngleRate.__dict__ and type(IAgCrdnVectorAngleRate.__dict__[attrname]) == property:
            return IAgCrdnVectorAngleRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorAngleRate.')
    
    @property
    def Angle(self) -> "IAgCrdnAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{CFC40EEB-A99F-4DAD-A366-1C7908C15128}', IAgCrdnVectorAngleRate)
agcls.AgTypeNameMap['IAgCrdnVectorAngleRate'] = IAgCrdnVectorAngleRate
__all__.append('IAgCrdnVectorAngleRate')

class IAgCrdnVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = '{A082FC52-1C33-4D63-B02E-1D163FC2F837}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetMeanElementType'] = _raise_uninitialized_error
        self.__dict__['_SetMeanElementType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorApoapsis from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorApoapsis = agcom.GUID(IAgCrdnVectorApoapsis._uuid)
        vtable_offset_local = IAgCrdnVectorApoapsis._vtable_offset - 1
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorApoapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorApoapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorApoapsis.__dict__ and type(IAgCrdnVectorApoapsis.__dict__[attrname]) == property:
            return IAgCrdnVectorApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorApoapsis.')
    
    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMeanElementType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__['_SetMeanElementType'](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{A082FC52-1C33-4D63-B02E-1D163FC2F837}', IAgCrdnVectorApoapsis)
agcls.AgTypeNameMap['IAgCrdnVectorApoapsis'] = IAgCrdnVectorApoapsis
__all__.append('IAgCrdnVectorApoapsis')

class IAgCrdnVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""
    _uuid = '{7F816808-CF9D-434A-82CE-78F4A88BC75D}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetEpoch'] = _raise_uninitialized_error
        self.__dict__['_GetSourceVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFixedAtEpoch from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFixedAtEpoch = agcom.GUID(IAgCrdnVectorFixedAtEpoch._uuid)
        vtable_offset_local = IAgCrdnVectorFixedAtEpoch._vtable_offset - 1
        self.__dict__['_GetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__['_SetEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtEpoch, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__['_GetSourceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtEpoch, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedAtEpoch.__dict__ and type(IAgCrdnVectorFixedAtEpoch.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFixedAtEpoch.')
    
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__['_SetEpoch'](arg_epoch.COM_val))

    @property
    def SourceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{7F816808-CF9D-434A-82CE-78F4A88BC75D}', IAgCrdnVectorFixedAtEpoch)
agcls.AgTypeNameMap['IAgCrdnVectorFixedAtEpoch'] = IAgCrdnVectorFixedAtEpoch
__all__.append('IAgCrdnVectorFixedAtEpoch')

class IAgCrdnVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    _uuid = '{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorAngularVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorAngularVelocity from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorAngularVelocity = agcom.GUID(IAgCrdnVectorAngularVelocity._uuid)
        vtable_offset_local = IAgCrdnVectorAngularVelocity._vtable_offset - 1
        self.__dict__['_GetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngularVelocity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngularVelocity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngularVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorAngularVelocity, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorAngularVelocity.__dict__ and type(IAgCrdnVectorAngularVelocity.__dict__[attrname]) == property:
            return IAgCrdnVectorAngularVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorAngularVelocity.')
    
    @property
    def Axes(self) -> "IAgCrdnAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}', IAgCrdnVectorAngularVelocity)
agcls.AgTypeNameMap['IAgCrdnVectorAngularVelocity'] = IAgCrdnVectorAngularVelocity
__all__.append('IAgCrdnVectorAngularVelocity')

class IAgCrdnVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    _uuid = '{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAboutVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetStartClockAngle'] = _raise_uninitialized_error
        self.__dict__['_SetStartClockAngle'] = _raise_uninitialized_error
        self.__dict__['_GetStopClockAngle'] = _raise_uninitialized_error
        self.__dict__['_SetStopClockAngle'] = _raise_uninitialized_error
        self.__dict__['_GetStartEpoch'] = _raise_uninitialized_error
        self.__dict__['_SetStartEpoch'] = _raise_uninitialized_error
        self.__dict__['_GetClockAngleRate'] = _raise_uninitialized_error
        self.__dict__['_SetClockAngleRate'] = _raise_uninitialized_error
        self.__dict__['_GetMode'] = _raise_uninitialized_error
        self.__dict__['_SetMode'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorConing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorConing from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorConing = agcom.GUID(IAgCrdnVectorConing._uuid)
        vtable_offset_local = IAgCrdnVectorConing._vtable_offset - 1
        self.__dict__['_GetAboutVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetStartClockAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStartClockAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetStopClockAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetStopClockAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetStartEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__['_SetStartEpoch'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__['_GetClockAngleRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetClockAngleRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetMode'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__['_SetMode'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorConing, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorConing.__dict__ and type(IAgCrdnVectorConing.__dict__[attrname]) == property:
            return IAgCrdnVectorConing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorConing.')
    
    @property
    def AboutVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAboutVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def StartClockAngle(self) -> float:
        """Specify a start angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartClockAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartClockAngle.setter
    def StartClockAngle(self, startClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(startClockAngle) as arg_startClockAngle:
            agcls.evaluate_hresult(self.__dict__['_SetStartClockAngle'](arg_startClockAngle.COM_val))

    @property
    def StopClockAngle(self) -> float:
        """Specify a stop angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStopClockAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopClockAngle.setter
    def StopClockAngle(self, stopClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(stopClockAngle) as arg_stopClockAngle:
            agcls.evaluate_hresult(self.__dict__['_SetStopClockAngle'](arg_stopClockAngle.COM_val))

    @property
    def StartEpoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStartEpoch'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartEpoch.setter
    def StartEpoch(self, startEpoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__['_SetStartEpoch'](arg_startEpoch.COM_val))

    @property
    def ClockAngleRate(self) -> float:
        """Specify a rotation rate."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetClockAngleRate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockAngleRate.setter
    def ClockAngleRate(self, clockAngleRate:float) -> None:
        with agmarshall.DOUBLE_arg(clockAngleRate) as arg_clockAngleRate:
            agcls.evaluate_hresult(self.__dict__['_SetClockAngleRate'](arg_clockAngleRate.COM_val))

    @property
    def Mode(self) -> "AgECrdnSweepMode":
        """Specify either unidirectional or bidirectional mode."""
        with agmarshall.AgEnum_arg(AgECrdnSweepMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMode'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Mode.setter
    def Mode(self, mode:"AgECrdnSweepMode") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSweepMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__['_SetMode'](arg_mode.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}', IAgCrdnVectorConing)
agcls.AgTypeNameMap['IAgCrdnVectorConing'] = IAgCrdnVectorConing
__all__.append('IAgCrdnVectorConing')

class IAgCrdnVectorCross(object):
    """The vector cross product of two vectors."""
    _uuid = '{F695FE24-7AE1-4935-837F-D7106A3C99A4}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFrom'] = _raise_uninitialized_error
        self.__dict__['_GetTo'] = _raise_uninitialized_error
        self.__dict__['_GetIsNormalized'] = _raise_uninitialized_error
        self.__dict__['_SetIsNormalized'] = _raise_uninitialized_error
        self.__dict__['_GetDimension'] = _raise_uninitialized_error
        self.__dict__['_SetDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorCross._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorCross from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorCross = agcom.GUID(IAgCrdnVectorCross._uuid)
        vtable_offset_local = IAgCrdnVectorCross._vtable_offset - 1
        self.__dict__['_GetFrom'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetTo'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetIsNormalized'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIsNormalized'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_SetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCross, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorCross.__dict__ and type(IAgCrdnVectorCross.__dict__[attrname]) == property:
            return IAgCrdnVectorCross.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorCross.')
    
    @property
    def From(self) -> "IAgCrdnVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFrom'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def To(self) -> "IAgCrdnVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTo'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IsNormalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsNormalized'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__['_SetIsNormalized'](arg_isNormalized.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__['_SetDimension'](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{F695FE24-7AE1-4935-837F-D7106A3C99A4}', IAgCrdnVectorCross)
agcls.AgTypeNameMap['IAgCrdnVectorCross'] = IAgCrdnVectorCross
__all__.append('IAgCrdnVectorCross')

class IAgCrdnVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""
    _uuid = '{66756C64-795C-4E24-9D6A-E560851BBDE0}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetScriptFile'] = _raise_uninitialized_error
        self.__dict__['_SetScriptFile'] = _raise_uninitialized_error
        self.__dict__['_GetInitializationScriptFile'] = _raise_uninitialized_error
        self.__dict__['_SetInitializationScriptFile'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorCustomScript from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorCustomScript = agcom.GUID(IAgCrdnVectorCustomScript._uuid)
        vtable_offset_local = IAgCrdnVectorCustomScript._vtable_offset - 1
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetScriptFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_SetScriptFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCustomScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__['_GetInitializationScriptFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCustomScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__['_SetInitializationScriptFile'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorCustomScript, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorCustomScript.__dict__ and type(IAgCrdnVectorCustomScript.__dict__[attrname]) == property:
            return IAgCrdnVectorCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorCustomScript.')
    
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptFile(self) -> str:
        """Specify a script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScriptFile'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScriptFile.setter
    def ScriptFile(self, scriptFile:str) -> None:
        with agmarshall.BSTR_arg(scriptFile) as arg_scriptFile:
            agcls.evaluate_hresult(self.__dict__['_SetScriptFile'](arg_scriptFile.COM_val))

    @property
    def InitializationScriptFile(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInitializationScriptFile'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitializationScriptFile.setter
    def InitializationScriptFile(self, initializationScriptFile:str) -> None:
        with agmarshall.BSTR_arg(initializationScriptFile) as arg_initializationScriptFile:
            agcls.evaluate_hresult(self.__dict__['_SetInitializationScriptFile'](arg_initializationScriptFile.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{66756C64-795C-4E24-9D6A-E560851BBDE0}', IAgCrdnVectorCustomScript)
agcls.AgTypeNameMap['IAgCrdnVectorCustomScript'] = IAgCrdnVectorCustomScript
__all__.append('IAgCrdnVectorCustomScript')

class IAgCrdnVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""
    _uuid = '{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_GetForceUseOfNumericalDifferences'] = _raise_uninitialized_error
        self.__dict__['_SetForceUseOfNumericalDifferences'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorDerivative from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorDerivative = agcom.GUID(IAgCrdnVectorDerivative._uuid)
        vtable_offset_local = IAgCrdnVectorDerivative._vtable_offset - 1
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetForceUseOfNumericalDifferences'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetForceUseOfNumericalDifferences'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDerivative.__dict__ and type(IAgCrdnVectorDerivative.__dict__[attrname]) == property:
            return IAgCrdnVectorDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorDerivative.')
    
    @property
    def Vector(self) -> "IAgCrdnVectorRefTo":
        """Specify a base vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetForceUseOfNumericalDifferences'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__['_SetForceUseOfNumericalDifferences'](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}', IAgCrdnVectorDerivative)
agcls.AgTypeNameMap['IAgCrdnVectorDerivative'] = IAgCrdnVectorDerivative
__all__.append('IAgCrdnVectorDerivative')

class IAgCrdnVectorDisplacement(object):
    """Vector defined by its start and end points."""
    _uuid = '{457E8D69-0F1F-4C02-A9D6-F48F86F63853}'
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOrigin'] = _raise_uninitialized_error
        self.__dict__['_GetDestination'] = _raise_uninitialized_error
        self.__dict__['_GetApparent'] = _raise_uninitialized_error
        self.__dict__['_SetApparent'] = _raise_uninitialized_error
        self.__dict__['_GetIgnoreAberration'] = _raise_uninitialized_error
        self.__dict__['_SetIgnoreAberration'] = _raise_uninitialized_error
        self.__dict__['_GetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_SetSignalSense'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorDisplacement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorDisplacement from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorDisplacement = agcom.GUID(IAgCrdnVectorDisplacement._uuid)
        vtable_offset_local = IAgCrdnVectorDisplacement._vtable_offset - 1
        self.__dict__['_GetOrigin'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetDestination'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetApparent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetApparent'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__['_GetIgnoreAberration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIgnoreAberration'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__['_SetSignalSense'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+8, agcom.LONG)
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDisplacement, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDisplacement.__dict__ and type(IAgCrdnVectorDisplacement.__dict__[attrname]) == property:
            return IAgCrdnVectorDisplacement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorDisplacement.')
    
    @property
    def Origin(self) -> "IAgCrdnPointRefTo":
        """Specify the vector's origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrigin'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Destination(self) -> "IAgCrdnPointRefTo":
        """Specify the vector's destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDestination'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Apparent(self) -> bool:
        """Controls whether to take a light speed delay into account."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetApparent'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Apparent.setter
    def Apparent(self, apparent:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(apparent) as arg_apparent:
            agcls.evaluate_hresult(self.__dict__['_SetApparent'](arg_apparent.COM_val))

    @property
    def IgnoreAberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIgnoreAberration'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IgnoreAberration.setter
    def IgnoreAberration(self, ignoreAberration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(ignoreAberration) as arg_ignoreAberration:
            agcls.evaluate_hresult(self.__dict__['_SetIgnoreAberration'](arg_ignoreAberration.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSignalSense'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__['_SetSignalSense'](arg_signalSense.COM_val))

    @property
    def ReferenceSystem(self) -> "IAgCrdnSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{457E8D69-0F1F-4C02-A9D6-F48F86F63853}', IAgCrdnVectorDisplacement)
agcls.AgTypeNameMap['IAgCrdnVectorDisplacement'] = IAgCrdnVectorDisplacement
__all__.append('IAgCrdnVectorDisplacement')

class IAgCrdnVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""
    _uuid = '{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPlaneA'] = _raise_uninitialized_error
        self.__dict__['_GetPlaneB'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorTwoPlanesIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorTwoPlanesIntersection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorTwoPlanesIntersection = agcom.GUID(IAgCrdnVectorTwoPlanesIntersection._uuid)
        vtable_offset_local = IAgCrdnVectorTwoPlanesIntersection._vtable_offset - 1
        self.__dict__['_GetPlaneA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorTwoPlanesIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetPlaneB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorTwoPlanesIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorTwoPlanesIntersection.__dict__ and type(IAgCrdnVectorTwoPlanesIntersection.__dict__[attrname]) == property:
            return IAgCrdnVectorTwoPlanesIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorTwoPlanesIntersection.')
    
    @property
    def PlaneA(self) -> "IAgCrdnPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPlaneA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PlaneB(self) -> "IAgCrdnPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPlaneB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}', IAgCrdnVectorTwoPlanesIntersection)
agcls.AgTypeNameMap['IAgCrdnVectorTwoPlanesIntersection'] = IAgCrdnVectorTwoPlanesIntersection
__all__.append('IAgCrdnVectorTwoPlanesIntersection')

class IAgCrdnVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    _uuid = '{C4CCEE5C-B053-413F-8456-6A43720BD314}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetPointableElementName'] = _raise_uninitialized_error
        self.__dict__['_SetPointableElementName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorModelAttach from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorModelAttach = agcom.GUID(IAgCrdnVectorModelAttach._uuid)
        vtable_offset_local = IAgCrdnVectorModelAttach._vtable_offset - 1
        self.__dict__['_GetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetPointableElementName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorModelAttach.__dict__ and type(IAgCrdnVectorModelAttach.__dict__[attrname]) == property:
            return IAgCrdnVectorModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorModelAttach.')
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPointableElementName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__['_SetPointableElementName'](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{C4CCEE5C-B053-413F-8456-6A43720BD314}', IAgCrdnVectorModelAttach)
agcls.AgTypeNameMap['IAgCrdnVectorModelAttach'] = IAgCrdnVectorModelAttach
__all__.append('IAgCrdnVectorModelAttach')

class IAgCrdnVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""
    _uuid = '{2050D921-A98C-408C-8170-FDBB23FEA6E5}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSource'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePlane'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorProjection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorProjection = agcom.GUID(IAgCrdnVectorProjection._uuid)
        vtable_offset_local = IAgCrdnVectorProjection._vtable_offset - 1
        self.__dict__['_GetSource'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePlane'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorProjection.__dict__ and type(IAgCrdnVectorProjection.__dict__[attrname]) == property:
            return IAgCrdnVectorProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorProjection.')
    
    @property
    def Source(self) -> "IAgCrdnVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSource'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "IAgCrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePlane'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{2050D921-A98C-408C-8170-FDBB23FEA6E5}', IAgCrdnVectorProjection)
agcls.AgTypeNameMap['IAgCrdnVectorProjection'] = IAgCrdnVectorProjection
__all__.append('IAgCrdnVectorProjection')

class IAgCrdnVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    _uuid = '{7D89412E-17A8-43D2-9153-58F45E7072F6}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceVector'] = _raise_uninitialized_error
        self.__dict__['_GetScale'] = _raise_uninitialized_error
        self.__dict__['_SetScale'] = _raise_uninitialized_error
        self.__dict__['_GetIsNormalized'] = _raise_uninitialized_error
        self.__dict__['_SetIsNormalized'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorScaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorScaled = agcom.GUID(IAgCrdnVectorScaled._uuid)
        vtable_offset_local = IAgCrdnVectorScaled._vtable_offset - 1
        self.__dict__['_GetReferenceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScaled, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScale'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScaled, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__['_GetIsNormalized'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScaled, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetIsNormalized'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScaled, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScaled.__dict__ and type(IAgCrdnVectorScaled.__dict__[attrname]) == property:
            return IAgCrdnVectorScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorScaled.')
    
    @property
    def ReferenceVector(self) -> "IAgCrdnVectorRefTo":
        """A vector being scaled."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Scale(self) -> float:
        """A scaling multiple."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScale'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__['_SetScale'](arg_scale.COM_val))

    @property
    def IsNormalized(self) -> bool:
        """Controls whether to convert the reference vector to a unit vector before scalling."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsNormalized'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__['_SetIsNormalized'](arg_isNormalized.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{7D89412E-17A8-43D2-9153-58F45E7072F6}', IAgCrdnVectorScaled)
agcls.AgTypeNameMap['IAgCrdnVectorScaled'] = IAgCrdnVectorScaled
__all__.append('IAgCrdnVectorScaled')

class IAgCrdnVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = '{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetMeanElementType'] = _raise_uninitialized_error
        self.__dict__['_SetMeanElementType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorEccentricity from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorEccentricity = agcom.GUID(IAgCrdnVectorEccentricity._uuid)
        vtable_offset_local = IAgCrdnVectorEccentricity._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorEccentricity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorEccentricity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorEccentricity.__dict__ and type(IAgCrdnVectorEccentricity.__dict__[attrname]) == property:
            return IAgCrdnVectorEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorEccentricity.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Eliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMeanElementType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__['_SetMeanElementType'](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}', IAgCrdnVectorEccentricity)
agcls.AgTypeNameMap['IAgCrdnVectorEccentricity'] = IAgCrdnVectorEccentricity
__all__.append('IAgCrdnVectorEccentricity')

class IAgCrdnVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""
    _uuid = '{912ECDDB-B23C-4B7A-A173-AC22170DA343}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetDirection'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFixedInAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFixedInAxes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFixedInAxes = agcom.GUID(IAgCrdnVectorFixedInAxes._uuid)
        vtable_offset_local = IAgCrdnVectorFixedInAxes._vtable_offset - 1
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedInAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetDirection'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedInAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedInAxes.__dict__ and type(IAgCrdnVectorFixedInAxes.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedInAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFixedInAxes.')
    
    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "IAgDirection":
        """Specify the vector direction."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDirection'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{912ECDDB-B23C-4B7A-A173-AC22170DA343}', IAgCrdnVectorFixedInAxes)
agcls.AgTypeNameMap['IAgCrdnVectorFixedInAxes'] = IAgCrdnVectorFixedInAxes
__all__.append('IAgCrdnVectorFixedInAxes')

class IAgCrdnVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    _uuid = '{DC23EB21-198C-4E01-9898-D565E937AFF1}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorLineOfNodes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorLineOfNodes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorLineOfNodes = agcom.GUID(IAgCrdnVectorLineOfNodes._uuid)
        vtable_offset_local = IAgCrdnVectorLineOfNodes._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLineOfNodes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLineOfNodes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorLineOfNodes.__dict__ and type(IAgCrdnVectorLineOfNodes.__dict__[attrname]) == property:
            return IAgCrdnVectorLineOfNodes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorLineOfNodes.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{DC23EB21-198C-4E01-9898-D565E937AFF1}', IAgCrdnVectorLineOfNodes)
agcls.AgTypeNameMap['IAgCrdnVectorLineOfNodes'] = IAgCrdnVectorLineOfNodes
__all__.append('IAgCrdnVectorLineOfNodes')

class IAgCrdnVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = '{22C8270A-7B36-40D7-9EC5-44FED3DEE541}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetMeanElementType'] = _raise_uninitialized_error
        self.__dict__['_SetMeanElementType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorOrbitAngularMomentum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorOrbitAngularMomentum from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorOrbitAngularMomentum = agcom.GUID(IAgCrdnVectorOrbitAngularMomentum._uuid)
        vtable_offset_local = IAgCrdnVectorOrbitAngularMomentum._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitAngularMomentum, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitAngularMomentum, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitAngularMomentum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitAngularMomentum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorOrbitAngularMomentum.__dict__ and type(IAgCrdnVectorOrbitAngularMomentum.__dict__[attrname]) == property:
            return IAgCrdnVectorOrbitAngularMomentum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorOrbitAngularMomentum.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Eliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMeanElementType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__['_SetMeanElementType'](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{22C8270A-7B36-40D7-9EC5-44FED3DEE541}', IAgCrdnVectorOrbitAngularMomentum)
agcls.AgTypeNameMap['IAgCrdnVectorOrbitAngularMomentum'] = IAgCrdnVectorOrbitAngularMomentum
__all__.append('IAgCrdnVectorOrbitAngularMomentum')

class IAgCrdnVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = '{296D4695-53FE-40B7-BA3E-41A3C04A805F}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetMeanElementType'] = _raise_uninitialized_error
        self.__dict__['_SetMeanElementType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorOrbitNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorOrbitNormal from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorOrbitNormal = agcom.GUID(IAgCrdnVectorOrbitNormal._uuid)
        vtable_offset_local = IAgCrdnVectorOrbitNormal._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitNormal, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorOrbitNormal, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorOrbitNormal.__dict__ and type(IAgCrdnVectorOrbitNormal.__dict__[attrname]) == property:
            return IAgCrdnVectorOrbitNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorOrbitNormal.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Eliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMeanElementType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__['_SetMeanElementType'](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{296D4695-53FE-40B7-BA3E-41A3C04A805F}', IAgCrdnVectorOrbitNormal)
agcls.AgTypeNameMap['IAgCrdnVectorOrbitNormal'] = IAgCrdnVectorOrbitNormal
__all__.append('IAgCrdnVectorOrbitNormal')

class IAgCrdnVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = '{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetReferencePoint'] = _raise_uninitialized_error
        self.__dict__['_GetMeanElementType'] = _raise_uninitialized_error
        self.__dict__['_SetMeanElementType'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorPeriapsis from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorPeriapsis = agcom.GUID(IAgCrdnVectorPeriapsis._uuid)
        vtable_offset_local = IAgCrdnVectorPeriapsis._vtable_offset - 1
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPeriapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferencePoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPeriapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__['_SetMeanElementType'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorPeriapsis.__dict__ and type(IAgCrdnVectorPeriapsis.__dict__[attrname]) == property:
            return IAgCrdnVectorPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorPeriapsis.')
    
    @property
    def CentralBody(self) -> "IAgCrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "IAgCrdnPointRefTo":
        """Eliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferencePoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetMeanElementType'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__['_SetMeanElementType'](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}', IAgCrdnVectorPeriapsis)
agcls.AgTypeNameMap['IAgCrdnVectorPeriapsis'] = IAgCrdnVectorPeriapsis
__all__.append('IAgCrdnVectorPeriapsis')

class IAgCrdnVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    _uuid = '{AF054174-278A-41E6-B8FA-0FC48E19A8BC}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIncomingVector'] = _raise_uninitialized_error
        self.__dict__['_GetUseOppositeOfSelectedVector'] = _raise_uninitialized_error
        self.__dict__['_SetUseOppositeOfSelectedVector'] = _raise_uninitialized_error
        self.__dict__['_GetNormalVector'] = _raise_uninitialized_error
        self.__dict__['_GetAllowReflectionsOnBackside'] = _raise_uninitialized_error
        self.__dict__['_SetAllowReflectionsOnBackside'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactor'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactor'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorReflection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorReflection from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorReflection = agcom.GUID(IAgCrdnVectorReflection._uuid)
        vtable_offset_local = IAgCrdnVectorReflection._vtable_offset - 1
        self.__dict__['_GetIncomingVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetUseOppositeOfSelectedVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseOppositeOfSelectedVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__['_GetNormalVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetAllowReflectionsOnBackside'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetAllowReflectionsOnBackside'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetScaleFactor'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactor'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorReflection, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorReflection.__dict__ and type(IAgCrdnVectorReflection.__dict__[attrname]) == property:
            return IAgCrdnVectorReflection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorReflection.')
    
    @property
    def IncomingVector(self) -> "IAgCrdnVectorRefTo":
        """The reflecting vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIncomingVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseOppositeOfSelectedVector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseOppositeOfSelectedVector'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseOppositeOfSelectedVector.setter
    def UseOppositeOfSelectedVector(self, useOppositeOfSelectedVector:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useOppositeOfSelectedVector) as arg_useOppositeOfSelectedVector:
            agcls.evaluate_hresult(self.__dict__['_SetUseOppositeOfSelectedVector'](arg_useOppositeOfSelectedVector.COM_val))

    @property
    def NormalVector(self) -> "IAgCrdnVectorRefTo":
        """The vector defines the reflection surface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AllowReflectionsOnBackside(self) -> bool:
        """Controls whether to reflect the indicent vector on both sides of the plane."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAllowReflectionsOnBackside'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowReflectionsOnBackside.setter
    def AllowReflectionsOnBackside(self, allowReflectionsOnBackside:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowReflectionsOnBackside) as arg_allowReflectionsOnBackside:
            agcls.evaluate_hresult(self.__dict__['_SetAllowReflectionsOnBackside'](arg_allowReflectionsOnBackside.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """The vector's scale factor."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactor'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactor'](arg_scaleFactor.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{AF054174-278A-41E6-B8FA-0FC48E19A8BC}', IAgCrdnVectorReflection)
agcls.AgTypeNameMap['IAgCrdnVectorReflection'] = IAgCrdnVectorReflection
__all__.append('IAgCrdnVectorReflection')

class IAgCrdnVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    _uuid = '{2dc152fa-f029-4bc6-bc47-f27d92219a32}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetAxes'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_GetForceMinimumRotation'] = _raise_uninitialized_error
        self.__dict__['_SetForceMinimumRotation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorRotationVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorRotationVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorRotationVector = agcom.GUID(IAgCrdnVectorRotationVector._uuid)
        vtable_offset_local = IAgCrdnVectorRotationVector._vtable_offset - 1
        self.__dict__['_GetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRotationVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRotationVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetForceMinimumRotation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRotationVector, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetForceMinimumRotation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorRotationVector, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorRotationVector.__dict__ and type(IAgCrdnVectorRotationVector.__dict__[attrname]) == property:
            return IAgCrdnVectorRotationVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorRotationVector.')
    
    @property
    def Axes(self) -> "IAgCrdnAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ForceMinimumRotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetForceMinimumRotation'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceMinimumRotation.setter
    def ForceMinimumRotation(self, forceMinimumRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceMinimumRotation) as arg_forceMinimumRotation:
            agcls.evaluate_hresult(self.__dict__['_SetForceMinimumRotation'](arg_forceMinimumRotation.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{2dc152fa-f029-4bc6-bc47-f27d92219a32}', IAgCrdnVectorRotationVector)
agcls.AgTypeNameMap['IAgCrdnVectorRotationVector'] = IAgCrdnVectorRotationVector
__all__.append('IAgCrdnVectorRotationVector')

class IAgCrdnVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    _uuid = '{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSelectedStar'] = _raise_uninitialized_error
        self.__dict__['_SetSelectedStar'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorDirectionToStar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorDirectionToStar from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorDirectionToStar = agcom.GUID(IAgCrdnVectorDirectionToStar._uuid)
        vtable_offset_local = IAgCrdnVectorDirectionToStar._vtable_offset - 1
        self.__dict__['_GetSelectedStar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDirectionToStar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_SetSelectedStar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDirectionToStar, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDirectionToStar.__dict__ and type(IAgCrdnVectorDirectionToStar.__dict__[attrname]) == property:
            return IAgCrdnVectorDirectionToStar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorDirectionToStar.')
    
    @property
    def SelectedStar(self) -> str:
        """A fully qualified path to a Star object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSelectedStar'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedStar.setter
    def SelectedStar(self, selectedStar:str) -> None:
        with agmarshall.BSTR_arg(selectedStar) as arg_selectedStar:
            agcls.evaluate_hresult(self.__dict__['_SetSelectedStar'](arg_selectedStar.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}', IAgCrdnVectorDirectionToStar)
agcls.AgTypeNameMap['IAgCrdnVectorDirectionToStar'] = IAgCrdnVectorDirectionToStar
__all__.append('IAgCrdnVectorDirectionToStar')

class IAgCrdnVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    _uuid = '{B35CE60F-7CC5-4289-9052-2203B609087E}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceTimeInstant'] = _raise_uninitialized_error
        self.__dict__['_GetSourceVector'] = _raise_uninitialized_error
        self.__dict__['_SetSourceVector'] = _raise_uninitialized_error
        self.__dict__['_GetReferenceAxes'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFixedAtTimeInstant from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFixedAtTimeInstant = agcom.GUID(IAgCrdnVectorFixedAtTimeInstant._uuid)
        vtable_offset_local = IAgCrdnVectorFixedAtTimeInstant._vtable_offset - 1
        self.__dict__['_GetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceTimeInstant'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetSourceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetSourceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFixedAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFixedAtTimeInstant.__dict__ and type(IAgCrdnVectorFixedAtTimeInstant.__dict__[attrname]) == property:
            return IAgCrdnVectorFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFixedAtTimeInstant.')
    
    @property
    def ReferenceTimeInstant(self) -> "IAgCrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceTimeInstant'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"IAgCrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, IAgCrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceTimeInstant'](arg_referenceTimeInstant.COM_val))

    @property
    def SourceVector(self) -> "IAgCrdnVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IAgCrdnVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__['_SetSourceVector'](arg_sourceVector.COM_val))

    @property
    def ReferenceAxes(self) -> "IAgCrdnAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"IAgCrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, IAgCrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceAxes'](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{B35CE60F-7CC5-4289-9052-2203B609087E}', IAgCrdnVectorFixedAtTimeInstant)
agcls.AgTypeNameMap['IAgCrdnVectorFixedAtTimeInstant'] = IAgCrdnVectorFixedAtTimeInstant
__all__.append('IAgCrdnVectorFixedAtTimeInstant')

class IAgCrdnVectorLinearCombination(object):
    """Linear combination of two input vectors."""
    _uuid = '{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}'
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactorA'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactorA'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactorB'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactorB'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorLinearCombination from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorLinearCombination = agcom.GUID(IAgCrdnVectorLinearCombination._uuid)
        vtable_offset_local = IAgCrdnVectorLinearCombination._vtable_offset - 1
        self.__dict__['_GetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetScaleFactorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+8, agcom.PVOID)
        self.__dict__['_GetScaleFactorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__['_GetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__['_GetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__['_SetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+14, agcom.LONG)
        self.__dict__['_GetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorLinearCombination, vtable_offset_local+16, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorLinearCombination.__dict__ and type(IAgCrdnVectorLinearCombination.__dict__[attrname]) == property:
            return IAgCrdnVectorLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorLinearCombination.')
    
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IAgCrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__['_SetVectorA'](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactorA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactorA'](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorA'](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IAgCrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__['_SetVectorB'](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactorB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactorB'](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorB'](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimensionInheritance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimensionInheritance'](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimension'](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}', IAgCrdnVectorLinearCombination)
agcls.AgTypeNameMap['IAgCrdnVectorLinearCombination'] = IAgCrdnVectorLinearCombination
__all__.append('IAgCrdnVectorLinearCombination')

class IAgCrdnVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""
    _uuid = '{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetSourceVector'] = _raise_uninitialized_error
        self.__dict__['_SetSourceVector'] = _raise_uninitialized_error
        self.__dict__['_GetAlongVector'] = _raise_uninitialized_error
        self.__dict__['_SetAlongVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorProjectAlongVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorProjectAlongVector from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorProjectAlongVector = agcom.GUID(IAgCrdnVectorProjectAlongVector._uuid)
        vtable_offset_local = IAgCrdnVectorProjectAlongVector._vtable_offset - 1
        self.__dict__['_GetSourceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjectAlongVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetSourceVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjectAlongVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjectAlongVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetAlongVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorProjectAlongVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorProjectAlongVector.__dict__ and type(IAgCrdnVectorProjectAlongVector.__dict__[attrname]) == property:
            return IAgCrdnVectorProjectAlongVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorProjectAlongVector.')
    
    @property
    def SourceVector(self) -> "IAgCrdnVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSourceVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, IAgCrdnVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__['_SetSourceVector'](arg_sourceVector.COM_val))

    @property
    def AlongVector(self) -> "IAgCrdnVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAlongVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, IAgCrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__['_SetAlongVector'](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}', IAgCrdnVectorProjectAlongVector)
agcls.AgTypeNameMap['IAgCrdnVectorProjectAlongVector'] = IAgCrdnVectorProjectAlongVector
__all__.append('IAgCrdnVectorProjectAlongVector')

class IAgCrdnVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""
    _uuid = '{0886A066-8650-4C8D-B234-14D28A175A78}'
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactorA'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactorA'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorA'] = _raise_uninitialized_error
        self.__dict__['_GetUseScaleFromScalarA'] = _raise_uninitialized_error
        self.__dict__['_SetUseScaleFromScalarA'] = _raise_uninitialized_error
        self.__dict__['_GetUseScaleFromScalarB'] = _raise_uninitialized_error
        self.__dict__['_SetUseScaleFromScalarB'] = _raise_uninitialized_error
        self.__dict__['_GetScalarA'] = _raise_uninitialized_error
        self.__dict__['_SetScalarA'] = _raise_uninitialized_error
        self.__dict__['_GetScalarB'] = _raise_uninitialized_error
        self.__dict__['_SetScalarB'] = _raise_uninitialized_error
        self.__dict__['_GetVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactorB'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactorB'] = _raise_uninitialized_error
        self.__dict__['_GetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_SetNormalizeVectorB'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_GetOutputDimension'] = _raise_uninitialized_error
        self.__dict__['_SetOutputDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorScalarLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorScalarLinearCombination from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorScalarLinearCombination = agcom.GUID(IAgCrdnVectorScalarLinearCombination._uuid)
        vtable_offset_local = IAgCrdnVectorScalarLinearCombination._vtable_offset - 1
        self.__dict__['_GetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetScaleFactorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__['_GetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__['_GetUseScaleFromScalarA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseScaleFromScalarA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_GetUseScaleFromScalarB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetUseScaleFromScalarB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__['_GetScalarA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_SetScalarA'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+12, agcom.PVOID)
        self.__dict__['_GetScalarB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_SetScalarB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+14, agcom.PVOID)
        self.__dict__['_GetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__['_SetVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+16, agcom.PVOID)
        self.__dict__['_GetScaleFactorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__['_GetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalizeVectorB'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__['_GetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__['_SetOutputDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+22, agcom.LONG)
        self.__dict__['_GetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__['_SetOutputDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarLinearCombination, vtable_offset_local+24, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScalarLinearCombination.__dict__ and type(IAgCrdnVectorScalarLinearCombination.__dict__[attrname]) == property:
            return IAgCrdnVectorScalarLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorScalarLinearCombination.')
    
    @property
    def VectorA(self) -> "IAgCrdnVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, IAgCrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__['_SetVectorA'](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactorA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactorA'](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorA'](arg_normalizeVectorA.COM_val))

    @property
    def UseScaleFromScalarA(self) -> bool:
        """Whether to use a scale from scalar A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseScaleFromScalarA'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarA.setter
    def UseScaleFromScalarA(self, useScaleFromScalarA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarA) as arg_useScaleFromScalarA:
            agcls.evaluate_hresult(self.__dict__['_SetUseScaleFromScalarA'](arg_useScaleFromScalarA.COM_val))

    @property
    def UseScaleFromScalarB(self) -> bool:
        """Whether to use a scale from scalar B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetUseScaleFromScalarB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarB.setter
    def UseScaleFromScalarB(self, useScaleFromScalarB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarB) as arg_useScaleFromScalarB:
            agcls.evaluate_hresult(self.__dict__['_SetUseScaleFromScalarB'](arg_useScaleFromScalarB.COM_val))

    @property
    def ScalarA(self) -> "IAgCrdnCalcScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalarA'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarA.setter
    def ScalarA(self, scalarA:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarA, IAgCrdnCalcScalar) as arg_scalarA:
            agcls.evaluate_hresult(self.__dict__['_SetScalarA'](arg_scalarA.COM_val))

    @property
    def ScalarB(self) -> "IAgCrdnCalcScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScalarB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarB.setter
    def ScalarB(self, scalarB:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarB, IAgCrdnCalcScalar) as arg_scalarB:
            agcls.evaluate_hresult(self.__dict__['_SetScalarB'](arg_scalarB.COM_val))

    @property
    def VectorB(self) -> "IAgCrdnVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorB'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, IAgCrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__['_SetVectorB'](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactorB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactorB'](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalizeVectorB'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__['_SetNormalizeVectorB'](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimensionInheritance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimensionInheritance'](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOutputDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__['_SetOutputDimension'](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{0886A066-8650-4C8D-B234-14D28A175A78}', IAgCrdnVectorScalarLinearCombination)
agcls.AgTypeNameMap['IAgCrdnVectorScalarLinearCombination'] = IAgCrdnVectorScalarLinearCombination
__all__.append('IAgCrdnVectorScalarLinearCombination')

class IAgCrdnVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""
    _uuid = '{306C3852-C3E9-43EB-9371-1B9540B52097}'
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetInputVector'] = _raise_uninitialized_error
        self.__dict__['_SetInputVector'] = _raise_uninitialized_error
        self.__dict__['_GetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_SetInputScalar'] = _raise_uninitialized_error
        self.__dict__['_GetScaleFactor'] = _raise_uninitialized_error
        self.__dict__['_SetScaleFactor'] = _raise_uninitialized_error
        self.__dict__['_GetNormalize'] = _raise_uninitialized_error
        self.__dict__['_SetNormalize'] = _raise_uninitialized_error
        self.__dict__['_GetDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_SetDimensionInheritance'] = _raise_uninitialized_error
        self.__dict__['_GetDimension'] = _raise_uninitialized_error
        self.__dict__['_SetDimension'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorScalarScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorScalarScaled from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorScalarScaled = agcom.GUID(IAgCrdnVectorScalarScaled._uuid)
        vtable_offset_local = IAgCrdnVectorScalarScaled._vtable_offset - 1
        self.__dict__['_GetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetInputVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetInputScalar'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetScaleFactor'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetScaleFactor'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__['_GetNormalize'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_SetNormalize'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__['_GetDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__['_SetDimensionInheritance'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+10, agcom.LONG)
        self.__dict__['_GetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__['_SetDimension'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorScalarScaled, vtable_offset_local+12, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorScalarScaled.__dict__ and type(IAgCrdnVectorScalarScaled.__dict__[attrname]) == property:
            return IAgCrdnVectorScalarScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorScalarScaled.')
    
    @property
    def InputVector(self) -> "IAgCrdnVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"IAgCrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, IAgCrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__['_SetInputVector'](arg_inputVector.COM_val))

    @property
    def InputScalar(self) -> "IAgCrdnCalcScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInputScalar'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"IAgCrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, IAgCrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__['_SetInputScalar'](arg_inputScalar.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """A constant scale applied to the input vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetScaleFactor'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__['_SetScaleFactor'](arg_scaleFactor.COM_val))

    @property
    def Normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetNormalize'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Normalize.setter
    def Normalize(self, normalize:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalize) as arg_normalize:
            agcls.evaluate_hresult(self.__dict__['_SetNormalize'](arg_normalize.COM_val))

    @property
    def DimensionInheritance(self) -> "AgECrdnVectorScaledDimensionInheritance":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimensionInheritance'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DimensionInheritance.setter
    def DimensionInheritance(self, dimensionInheritance:"AgECrdnVectorScaledDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance, dimensionInheritance) as arg_dimensionInheritance:
            agcls.evaluate_hresult(self.__dict__['_SetDimensionInheritance'](arg_dimensionInheritance.COM_val))

    @property
    def Dimension(self) -> str:
        """A dimension assigned to the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDimension'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__['_SetDimension'](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{306C3852-C3E9-43EB-9371-1B9540B52097}', IAgCrdnVectorScalarScaled)
agcls.AgTypeNameMap['IAgCrdnVectorScalarScaled'] = IAgCrdnVectorScalarScaled
__all__.append('IAgCrdnVectorScalarScaled')

class IAgCrdnVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""
    _uuid = '{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_SetReferenceSystem'] = _raise_uninitialized_error
        self.__dict__['_GetPoint'] = _raise_uninitialized_error
        self.__dict__['_SetPoint'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorVelocityAcceleration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorVelocityAcceleration from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorVelocityAcceleration = agcom.GUID(IAgCrdnVectorVelocityAcceleration._uuid)
        vtable_offset_local = IAgCrdnVectorVelocityAcceleration._vtable_offset - 1
        self.__dict__['_GetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetReferenceSystem'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorVelocityAcceleration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorVelocityAcceleration.__dict__ and type(IAgCrdnVectorVelocityAcceleration.__dict__[attrname]) == property:
            return IAgCrdnVectorVelocityAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorVelocityAcceleration.')
    
    @property
    def ReferenceSystem(self) -> "IAgCrdnSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetReferenceSystem'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"IAgCrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, IAgCrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__['_SetReferenceSystem'](arg_referenceSystem.COM_val))

    @property
    def Point(self) -> "IAgCrdnPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, IAgCrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__['_SetPoint'](arg_point.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}', IAgCrdnVectorVelocityAcceleration)
agcls.AgTypeNameMap['IAgCrdnVectorVelocityAcceleration'] = IAgCrdnVectorVelocityAcceleration
__all__.append('IAgCrdnVectorVelocityAcceleration')

class IAgCrdnVectorPlugin(object):
    """A VGT vector plugin."""
    _uuid = '{F889F617-059E-4BC9-9000-206091889FEB}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetProgID'] = _raise_uninitialized_error
        self.__dict__['_GetDisplayName'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableProperties'] = _raise_uninitialized_error
        self.__dict__['_Reset'] = _raise_uninitialized_error
        self.__dict__['_SetProperty'] = _raise_uninitialized_error
        self.__dict__['_GetProperty'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorPlugin from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorPlugin = agcom.GUID(IAgCrdnVectorPlugin._uuid)
        vtable_offset_local = IAgCrdnVectorPlugin._vtable_offset - 1
        self.__dict__['_GetProgID'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__['_GetDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__['_GetAvailableProperties'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_Reset'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+4, )
        self.__dict__['_SetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__['_GetProperty'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorPlugin.__dict__ and type(IAgCrdnVectorPlugin.__dict__[attrname]) == property:
            return IAgCrdnVectorPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorPlugin.')
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProgID'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDisplayName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableProperties'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__['_Reset']())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__['_SetProperty'](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProperty'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F889F617-059E-4BC9-9000-206091889FEB}', IAgCrdnVectorPlugin)
agcls.AgTypeNameMap['IAgCrdnVectorPlugin'] = IAgCrdnVectorPlugin
__all__.append('IAgCrdnVectorPlugin')

class IAgCrdnVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    _uuid = '{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}'
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetOriginPoint'] = _raise_uninitialized_error
        self.__dict__['_SetOriginPoint'] = _raise_uninitialized_error
        self.__dict__['_GetDestinationPoint'] = _raise_uninitialized_error
        self.__dict__['_SetDestinationPoint'] = _raise_uninitialized_error
        self.__dict__['_GetSurfaceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_SetSurfaceCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetDifferencingTimeStep'] = _raise_uninitialized_error
        self.__dict__['_SetDifferencingTimeStep'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorDispSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorDispSurface from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorDispSurface = agcom.GUID(IAgCrdnVectorDispSurface._uuid)
        vtable_offset_local = IAgCrdnVectorDispSurface._vtable_offset - 1
        self.__dict__['_GetOriginPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_SetOriginPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetDestinationPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_SetDestinationPoint'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+4, agcom.PVOID)
        self.__dict__['_GetSurfaceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__['_SetSurfaceCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+6, agcom.BSTR)
        self.__dict__['_GetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__['_SetDifferencingTimeStep'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorDispSurface, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorDispSurface.__dict__ and type(IAgCrdnVectorDispSurface.__dict__[attrname]) == property:
            return IAgCrdnVectorDispSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorDispSurface.')
    
    @property
    def OriginPoint(self) -> "IAgCrdnPoint":
        """An origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginPoint.setter
    def OriginPoint(self, originPoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(originPoint, IAgCrdnPoint) as arg_originPoint:
            agcls.evaluate_hresult(self.__dict__['_SetOriginPoint'](arg_originPoint.COM_val))

    @property
    def DestinationPoint(self) -> "IAgCrdnPoint":
        """Destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDestinationPoint'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DestinationPoint.setter
    def DestinationPoint(self, destinationPoint:"IAgCrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(destinationPoint, IAgCrdnPoint) as arg_destinationPoint:
            agcls.evaluate_hresult(self.__dict__['_SetDestinationPoint'](arg_destinationPoint.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """surface central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSurfaceCentralBody'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__['_SetSurfaceCentralBody'](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetDifferencingTimeStep'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__['_SetDifferencingTimeStep'](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry('{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}', IAgCrdnVectorDispSurface)
agcls.AgTypeNameMap['IAgCrdnVectorDispSurface'] = IAgCrdnVectorDispSurface
__all__.append('IAgCrdnVectorDispSurface')

class IAgCrdnVectorFactory(object):
    """A Factory object to create vectors."""
    _uuid = '{09F7F253-392A-44D9-9701-51CC0110C033}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_CreateDisplacementVector'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableVectorPluginDisplayNames'] = _raise_uninitialized_error
        self.__dict__['_CreateVectorPluginFromDisplayName'] = _raise_uninitialized_error
        self.__dict__['_CreateCrossProductVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFactory = agcom.GUID(IAgCrdnVectorFactory._uuid)
        vtable_offset_local = IAgCrdnVectorFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_CreateDisplacementVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+3, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__['_GetAvailableVectorPluginDisplayNames'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__['_CreateVectorPluginFromDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreateCrossProductVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFactory, vtable_offset_local+6, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFactory.__dict__ and type(IAgCrdnVectorFactory.__dict__[attrname]) == property:
            return IAgCrdnVectorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFactory.')
    
    def Create(self, vectorName:str, description:str, vectorType:"AgECrdnVectorType") -> "IAgCrdnVector":
        """Creates a VGT vector using specified name, description and type."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVectorType, vectorType) as arg_vectorType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_vectorName.COM_val, arg_description.COM_val, arg_vectorType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnVectorType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateDisplacementVector(self, vectorName:str, originPoint:"IAgCrdnPoint", destPoint:"IAgCrdnPoint") -> "IAgCrdnVectorDisplacement":
        """Creates a displacement vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(originPoint, IAgCrdnPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(destPoint, IAgCrdnPoint) as arg_destPoint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateDisplacementVector'](arg_vectorName.COM_val, arg_originPoint.COM_val, arg_destPoint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AvailableVectorPluginDisplayNames(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableVectorPluginDisplayNames'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVectorPluginFromDisplayName(self, vectorName:str, description:str, displayName:str) -> "IAgCrdnVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateVectorPluginFromDisplayName'](arg_vectorName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCrossProductVector(self, vectorName:str, vectorA:"IAgCrdnVector", vectorB:"IAgCrdnVector") -> "IAgCrdnVectorCross":
        """Creates a cross product C = A x B."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(vectorA, IAgCrdnVector) as arg_vectorA, \
             agmarshall.AgInterface_in_arg(vectorB, IAgCrdnVector) as arg_vectorB, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateCrossProductVector'](arg_vectorName.COM_val, arg_vectorA.COM_val, arg_vectorB.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{09F7F253-392A-44D9-9701-51CC0110C033}', IAgCrdnVectorFactory)
agcls.AgTypeNameMap['IAgCrdnVectorFactory'] = IAgCrdnVectorFactory
__all__.append('IAgCrdnVectorFactory')

class IAgCrdnAxesFactory(object):
    """A Factory object to create axes."""
    _uuid = '{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_GetAvailableAxesPluginDisplayNames'] = _raise_uninitialized_error
        self.__dict__['_CreateAxesPluginFromDisplayName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesFactory = agcom.GUID(IAgCrdnAxesFactory._uuid)
        vtable_offset_local = IAgCrdnAxesFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAvailableAxesPluginDisplayNames'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_CreateAxesPluginFromDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFactory.__dict__ and type(IAgCrdnAxesFactory.__dict__[attrname]) == property:
            return IAgCrdnAxesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesFactory.')
    
    def Create(self, axesName:str, description:str, axesType:"AgECrdnAxesType") -> "IAgCrdnAxes":
        """Creates a VGT axes using specified name, description and type."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAxesType, axesType) as arg_axesType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_axesName.COM_val, arg_description.COM_val, arg_axesType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAxesType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableAxesPluginDisplayNames(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailableAxesPluginDisplayNames'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAxesPluginFromDisplayName(self, axesName:str, description:str, displayName:str) -> "IAgCrdnAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreateAxesPluginFromDisplayName'](arg_axesName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}', IAgCrdnAxesFactory)
agcls.AgTypeNameMap['IAgCrdnAxesFactory'] = IAgCrdnAxesFactory
__all__.append('IAgCrdnAxesFactory')

class IAgCrdnSystemFactory(object):
    """A Factory interface to create VGT systems."""
    _uuid = '{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemFactory = agcom.GUID(IAgCrdnSystemFactory._uuid)
        vtable_offset_local = IAgCrdnSystemFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemFactory.__dict__ and type(IAgCrdnSystemFactory.__dict__[attrname]) == property:
            return IAgCrdnSystemFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemFactory.')
    
    def Create(self, systemName:str, description:str, systemType:"AgECrdnSystemType") -> "IAgCrdnSystem":
        """Creates a VGT system using the specified name, description and type."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnSystemType, systemType) as arg_systemType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_systemName.COM_val, arg_description.COM_val, arg_systemType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnSystemType") -> bool:
        """Returns true if the specified system type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}', IAgCrdnSystemFactory)
agcls.AgTypeNameMap['IAgCrdnSystemFactory'] = IAgCrdnSystemFactory
__all__.append('IAgCrdnSystemFactory')

class IAgCrdnPointFactory(object):
    """A Factory object to create points."""
    _uuid = '{18FA11DA-BC93-4467-B53F-4D894739C3A3}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        self.__dict__['_GetAvailablePointPluginDisplayNames'] = _raise_uninitialized_error
        self.__dict__['_CreatePointPluginFromDisplayName'] = _raise_uninitialized_error
        self.__dict__['_CreatePointFixedOnCentralBody'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointFactory = agcom.GUID(IAgCrdnPointFactory._uuid)
        vtable_offset_local = IAgCrdnPointFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAvailablePointPluginDisplayNames'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_CreatePointPluginFromDisplayName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_CreatePointFixedOnCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointFactory.__dict__ and type(IAgCrdnPointFactory.__dict__[attrname]) == property:
            return IAgCrdnPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointFactory.')
    
    def Create(self, pointName:str, description:str, pointType:"AgECrdnPointType") -> "IAgCrdnPoint":
        """Creates a VGT point using the specified name, description and type."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPointType, pointType) as arg_pointType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_pointName.COM_val, arg_description.COM_val, arg_pointType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPointType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPointType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailablePointPluginDisplayNames(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAvailablePointPluginDisplayNames'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointPluginFromDisplayName(self, pointName:str, description:str, displayName:str) -> "IAgCrdnPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreatePointPluginFromDisplayName'](arg_pointName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointFixedOnCentralBody(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"AgECrdnReferenceShapeType") -> "IAgCrdnPoint":
        """Creates a point fixed on a central body."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_CreatePointFixedOnCentralBody'](arg_pointName.COM_val, arg_description.COM_val, arg_longitude.COM_val, arg_latitude.COM_val, arg_altitude.COM_val, arg_referenceShape.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{18FA11DA-BC93-4467-B53F-4D894739C3A3}', IAgCrdnPointFactory)
agcls.AgTypeNameMap['IAgCrdnPointFactory'] = IAgCrdnPointFactory
__all__.append('IAgCrdnPointFactory')

class IAgCrdnPlaneFactory(object):
    """A Factory object to create VGT planes."""
    _uuid = '{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneFactory = agcom.GUID(IAgCrdnPlaneFactory._uuid)
        vtable_offset_local = IAgCrdnPlaneFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFactory.__dict__ and type(IAgCrdnPlaneFactory.__dict__[attrname]) == property:
            return IAgCrdnPlaneFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneFactory.')
    
    def Create(self, planeName:str, description:str, planeType:"AgECrdnPlaneType") -> "IAgCrdnPlane":
        """Creates a VGT plane using the specified name, description and type."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPlaneType, planeType) as arg_planeType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_planeName.COM_val, arg_description.COM_val, arg_planeType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPlaneType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}', IAgCrdnPlaneFactory)
agcls.AgTypeNameMap['IAgCrdnPlaneFactory'] = IAgCrdnPlaneFactory
__all__.append('IAgCrdnPlaneFactory')

class IAgCrdnAngleFactory(object):
    """A Factory object to create angles."""
    _uuid = '{703883F3-9716-4D37-8930-184BECDE1461}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Create'] = _raise_uninitialized_error
        self.__dict__['_IsTypeSupported'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleFactory from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleFactory = agcom.GUID(IAgCrdnAngleFactory._uuid)
        vtable_offset_local = IAgCrdnAngleFactory._vtable_offset - 1
        self.__dict__['_Create'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_IsTypeSupported'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFactory.__dict__ and type(IAgCrdnAngleFactory.__dict__[attrname]) == property:
            return IAgCrdnAngleFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleFactory.')
    
    def Create(self, angleName:str, description:str, angleType:"AgECrdnAngleType") -> "IAgCrdnAngle":
        """Creates a VGT angle using specified name, description and type."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAngleType, angleType) as arg_angleType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Create'](arg_angleName.COM_val, arg_description.COM_val, arg_angleType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAngleType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_IsTypeSupported'](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{703883F3-9716-4D37-8930-184BECDE1461}', IAgCrdnAngleFactory)
agcls.AgTypeNameMap['IAgCrdnAngleFactory'] = IAgCrdnAngleFactory
__all__.append('IAgCrdnAngleFactory')

class IAgCrdnVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""
    _uuid = '{4412F0DD-2138-4653-8D20-9B4A0CA450D4}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorGroup = agcom.GUID(IAgCrdnVectorGroup._uuid)
        vtable_offset_local = IAgCrdnVectorGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorGroup.__dict__ and type(IAgCrdnVectorGroup.__dict__[attrname]) == property:
            return IAgCrdnVectorGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnVector":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, vectorName:str) -> None:
        """Removes a specified vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_vectorName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnVectorFactory":
        """Returns a Factory object used to create custom vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnVector":
        """Returns a vector by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{4412F0DD-2138-4653-8D20-9B4A0CA450D4}', IAgCrdnVectorGroup)
agcls.AgTypeNameMap['IAgCrdnVectorGroup'] = IAgCrdnVectorGroup
__all__.append('IAgCrdnVectorGroup')

class IAgCrdnPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""
    _uuid = '{6FB1415A-EC77-476F-B650-CC6813BE740C}'
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        self.__dict__['_GetCommonTasks'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointGroup = agcom.GUID(IAgCrdnPointGroup._uuid)
        vtable_offset_local = IAgCrdnPointGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_GetCommonTasks'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointGroup.__dict__ and type(IAgCrdnPointGroup.__dict__[attrname]) == property:
            return IAgCrdnPointGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnPoint":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, pointName:str) -> None:
        """Removes a specified point by name."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_pointName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnPointFactory":
        """Returns a Factory object used to create custom points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnPoint":
        """Returns a point by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IAgCrdnPointCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCommonTasks'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{6FB1415A-EC77-476F-B650-CC6813BE740C}', IAgCrdnPointGroup)
agcls.AgTypeNameMap['IAgCrdnPointGroup'] = IAgCrdnPointGroup
__all__.append('IAgCrdnPointGroup')

class IAgCrdnAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""
    _uuid = '{C025A1BA-F856-4B26-9134-BBCC785B6C45}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleGroup = agcom.GUID(IAgCrdnAngleGroup._uuid)
        vtable_offset_local = IAgCrdnAngleGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleGroup.__dict__ and type(IAgCrdnAngleGroup.__dict__[attrname]) == property:
            return IAgCrdnAngleGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnAngle":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, angleName:str) -> None:
        """Removes a specified Angle."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_angleName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnAngleFactory":
        """Returns a Factory object used to create custom angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnAngle":
        """Returns an angle by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{C025A1BA-F856-4B26-9134-BBCC785B6C45}', IAgCrdnAngleGroup)
agcls.AgTypeNameMap['IAgCrdnAngleGroup'] = IAgCrdnAngleGroup
__all__.append('IAgCrdnAngleGroup')

class IAgCrdnAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""
    _uuid = '{21C67E72-992F-481F-B77F-1DFC43B4B705}'
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        self.__dict__['_GetCommonTasks'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesGroup = agcom.GUID(IAgCrdnAxesGroup._uuid)
        vtable_offset_local = IAgCrdnAxesGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_GetCommonTasks'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesGroup.__dict__ and type(IAgCrdnAxesGroup.__dict__[attrname]) == property:
            return IAgCrdnAxesGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnAxes":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, axesName:str) -> None:
        """Removes a specified Axes."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_axesName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnAxesFactory":
        """Returns a Factory object used to create custom axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnAxes":
        """Returns an axes by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IAgCrdnAxesCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCommonTasks'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{21C67E72-992F-481F-B77F-1DFC43B4B705}', IAgCrdnAxesGroup)
agcls.AgTypeNameMap['IAgCrdnAxesGroup'] = IAgCrdnAxesGroup
__all__.append('IAgCrdnAxesGroup')

class IAgCrdnPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""
    _uuid = '{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}'
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneGroup = agcom.GUID(IAgCrdnPlaneGroup._uuid)
        vtable_offset_local = IAgCrdnPlaneGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneGroup.__dict__ and type(IAgCrdnPlaneGroup.__dict__[attrname]) == property:
            return IAgCrdnPlaneGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnPlane":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, planeName:str) -> None:
        """Removes a specified Plane."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_planeName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnPlaneFactory":
        """Returns a Factory object used to create custom planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnPlane":
        """Returns an Plane by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}', IAgCrdnPlaneGroup)
agcls.AgTypeNameMap['IAgCrdnPlaneGroup'] = IAgCrdnPlaneGroup
__all__.append('IAgCrdnPlaneGroup')

class IAgCrdnSystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""
    _uuid = '{05FF6322-1363-4B66-933E-03EA158B7523}'
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Remove'] = _raise_uninitialized_error
        self.__dict__['_GetContext'] = _raise_uninitialized_error
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_GetFactory'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        self.__dict__['_GetCommonTasks'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemGroup from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemGroup = agcom.GUID(IAgCrdnSystemGroup._uuid)
        vtable_offset_local = IAgCrdnSystemGroup._vtable_offset - 1
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_GetContext'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__['_GetFactory'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_GetCommonTasks'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemGroup.__dict__ and type(IAgCrdnSystemGroup.__dict__[attrname]) == property:
            return IAgCrdnSystemGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemGroup.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnSystem":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, systemName:str) -> None:
        """Removes a specified System."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_systemName.COM_val))

    @property
    def Context(self) -> "IAgCrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetContext'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "IAgCrdnSystemFactory":
        """Returns a Factory object used to create custom VGT systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFactory'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdnSystem":
        """Returns a System by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "IAgCrdnSystemCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCommonTasks'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{05FF6322-1363-4B66-933E-03EA158B7523}', IAgCrdnSystemGroup)
agcls.AgTypeNameMap['IAgCrdnSystemGroup'] = IAgCrdnSystemGroup
__all__.append('IAgCrdnSystemGroup')

class IAgCrdnProvider(object):
    """Allows accessing existing Vector Geometry Tool components."""
    _uuid = '{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}'
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetVectors'] = _raise_uninitialized_error
        self.__dict__['_GetPoints'] = _raise_uninitialized_error
        self.__dict__['_GetAngles'] = _raise_uninitialized_error
        self.__dict__['_GetAxes'] = _raise_uninitialized_error
        self.__dict__['_GetPlanes'] = _raise_uninitialized_error
        self.__dict__['_GetSystems'] = _raise_uninitialized_error
        self.__dict__['_GetWellKnownSystems'] = _raise_uninitialized_error
        self.__dict__['_GetWellKnownAxes'] = _raise_uninitialized_error
        self.__dict__['_GetEvents'] = _raise_uninitialized_error
        self.__dict__['_GetEventIntervals'] = _raise_uninitialized_error
        self.__dict__['_GetCalcScalars'] = _raise_uninitialized_error
        self.__dict__['_GetEventArrays'] = _raise_uninitialized_error
        self.__dict__['_GetEventIntervalLists'] = _raise_uninitialized_error
        self.__dict__['_GetEventIntervalCollections'] = _raise_uninitialized_error
        self.__dict__['_GetParameterSets'] = _raise_uninitialized_error
        self.__dict__['_GetConditions'] = _raise_uninitialized_error
        self.__dict__['_Supports'] = _raise_uninitialized_error
        self.__dict__['_GetConditionSets'] = _raise_uninitialized_error
        self.__dict__['_Import'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeGrids'] = _raise_uninitialized_error
        self.__dict__['_GetVolumes'] = _raise_uninitialized_error
        self.__dict__['_GetVolumeCalcs'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnProvider._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnProvider from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnProvider = agcom.GUID(IAgCrdnProvider._uuid)
        vtable_offset_local = IAgCrdnProvider._vtable_offset - 1
        self.__dict__['_GetVectors'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetPoints'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetAngles'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetPlanes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetSystems'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_GetWellKnownSystems'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__['_GetWellKnownAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__['_GetEvents'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__['_GetEventIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__['_GetCalcScalars'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__['_GetEventArrays'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__['_GetEventIntervalLists'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__['_GetEventIntervalCollections'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__['_GetParameterSets'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__['_GetConditions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__['_Supports'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetConditionSets'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__['_Import'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+19, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_GetVolumeGrids'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__['_GetVolumes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__['_GetVolumeCalcs'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnProvider, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnProvider.__dict__ and type(IAgCrdnProvider.__dict__[attrname]) == property:
            return IAgCrdnProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnProvider.')
    
    @property
    def Vectors(self) -> "IAgCrdnVectorGroup":
        """Returns a group of vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectors'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Points(self) -> "IAgCrdnPointGroup":
        """Returns a group of points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPoints'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Angles(self) -> "IAgCrdnAngleGroup":
        """Returns a group of angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngles'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Axes(self) -> "IAgCrdnAxesGroup":
        """Returns a group of axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Planes(self) -> "IAgCrdnPlaneGroup":
        """Returns a group of planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPlanes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Systems(self) -> "IAgCrdnSystemGroup":
        """Returns a group of systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSystems'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IAgCrdnWellKnownSystems":
        """Returns well-known systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetWellKnownSystems'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IAgCrdnWellKnownAxes":
        """Returns well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetWellKnownAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Events(self) -> "IAgCrdnEventGroup":
        """Returns a group of events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEvents'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervals(self) -> "IAgCrdnEventIntervalGroup":
        """Returns a group of event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEventIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcScalars(self) -> "IAgCrdnCalcScalarGroup":
        """Returns a group of calc scalars."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCalcScalars'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventArrays(self) -> "IAgCrdnEventArrayGroup":
        """Returns a group of event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEventArrays'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalLists(self) -> "IAgCrdnEventIntervalListGroup":
        """Returns a group of event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEventIntervalLists'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalCollections(self) -> "IAgCrdnEventIntervalCollectionGroup":
        """Returns a group of event interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEventIntervalCollections'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ParameterSets(self) -> "IAgCrdnParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetParameterSets'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Conditions(self) -> "IAgCrdnConditionGroup":
        """Returns a group of condition objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConditions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Supports(self, feature:"AgECrdnKind") -> bool:
        """Tests whether the specified VGT feature is supported."""
        with agmarshall.AgEnum_arg(AgECrdnKind, feature) as arg_feature, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Supports'](arg_feature.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ConditionSets(self) -> "IAgCrdnConditionSetGroup":
        """Returns a group of condition set objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetConditionSets'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Import(self, filename:str) -> "IAgCrdnCollection":
        """Imports Analysis Workbench components from a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Import'](arg_filename.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeGrids(self) -> "IAgCrdnVolumeGridGroup":
        """Returns a group of volume grid objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeGrids'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Volumes(self) -> "IAgCrdnVolumeGroup":
        """Returns a group of volume objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeCalcs(self) -> "IAgCrdnVolumeCalcGroup":
        """Returns a group of volume calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVolumeCalcs'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}', IAgCrdnProvider)
agcls.AgTypeNameMap['IAgCrdnProvider'] = IAgCrdnProvider
__all__.append('IAgCrdnProvider')

class IAgCrdnRoot(object):
    """Represents a VGT root object."""
    _uuid = '{FEF8B20D-5EEB-4299-8775-038EE30AA30B}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTemplateProvider'] = _raise_uninitialized_error
        self.__dict__['_GetProvider'] = _raise_uninitialized_error
        self.__dict__['_GetWellKnownSystems'] = _raise_uninitialized_error
        self.__dict__['_GetWellKnownAxes'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnRoot._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnRoot from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnRoot = agcom.GUID(IAgCrdnRoot._uuid)
        vtable_offset_local = IAgCrdnRoot._vtable_offset - 1
        self.__dict__['_GetTemplateProvider'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRoot, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_GetProvider'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRoot, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__['_GetWellKnownSystems'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRoot, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetWellKnownAxes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnRoot, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnRoot.__dict__ and type(IAgCrdnRoot.__dict__[attrname]) == property:
            return IAgCrdnRoot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnRoot.')
    
    def GetTemplateProvider(self, className:str) -> "IAgCrdnProvider":
        """Returns a template provider. The method takes a class name (i.e. \"Satellite\", \"Facility\", etc.)"""
        with agmarshall.BSTR_arg(className) as arg_className, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTemplateProvider'](arg_className.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetProvider(self, instPath:str) -> "IAgCrdnProvider":
        """Returns an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. \"Satellite/Satellite1\", \"CentralBody/Earth\", etc.)"""
        with agmarshall.BSTR_arg(instPath) as arg_instPath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetProvider'](arg_instPath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "IAgCrdnWellKnownSystems":
        """Returns the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetWellKnownSystems'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "IAgCrdnWellKnownAxes":
        """Returns the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetWellKnownAxes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{FEF8B20D-5EEB-4299-8775-038EE30AA30B}', IAgCrdnRoot)
agcls.AgTypeNameMap['IAgCrdnRoot'] = IAgCrdnRoot
__all__.append('IAgCrdnRoot')

class IAgCrdnWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""
    _uuid = '{230A8949-FB8F-415E-A786-5EED50AEB11B}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFixed'] = _raise_uninitialized_error
        self.__dict__['_GetICRF'] = _raise_uninitialized_error
        self.__dict__['_GetInertial'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownEarthSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownEarthSystems from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownEarthSystems = agcom.GUID(IAgCrdnWellKnownEarthSystems._uuid)
        vtable_offset_local = IAgCrdnWellKnownEarthSystems._vtable_offset - 1
        self.__dict__['_GetFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetICRF'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownEarthSystems.__dict__ and type(IAgCrdnWellKnownEarthSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownEarthSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownEarthSystems.')
    
    @property
    def Fixed(self) -> "IAgCrdnSystem":
        """Earth's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixed'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAgCrdnSystem":
        """Earth's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetICRF'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAgCrdnSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInertial'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{230A8949-FB8F-415E-A786-5EED50AEB11B}', IAgCrdnWellKnownEarthSystems)
agcls.AgTypeNameMap['IAgCrdnWellKnownEarthSystems'] = IAgCrdnWellKnownEarthSystems
__all__.append('IAgCrdnWellKnownEarthSystems')

class IAgCrdnWellKnownEarthAxes(object):
    """Well-known Earth's axes."""
    _uuid = '{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFixed'] = _raise_uninitialized_error
        self.__dict__['_GetICRF'] = _raise_uninitialized_error
        self.__dict__['_GetInertial'] = _raise_uninitialized_error
        self.__dict__['_GetJ2000'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownEarthAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownEarthAxes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownEarthAxes = agcom.GUID(IAgCrdnWellKnownEarthAxes._uuid)
        vtable_offset_local = IAgCrdnWellKnownEarthAxes._vtable_offset - 1
        self.__dict__['_GetFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetICRF'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetJ2000'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownEarthAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownEarthAxes.__dict__ and type(IAgCrdnWellKnownEarthAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownEarthAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownEarthAxes.')
    
    @property
    def Fixed(self) -> "IAgCrdnAxes":
        """Earth's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixed'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAgCrdnAxes":
        """Earth's ICRF axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetICRF'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAgCrdnAxes":
        """Earth's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInertial'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IAgCrdnAxes":
        """The Earth's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetJ2000'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}', IAgCrdnWellKnownEarthAxes)
agcls.AgTypeNameMap['IAgCrdnWellKnownEarthAxes'] = IAgCrdnWellKnownEarthAxes
__all__.append('IAgCrdnWellKnownEarthAxes')

class IAgCrdnWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""
    _uuid = '{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFixed'] = _raise_uninitialized_error
        self.__dict__['_GetICRF'] = _raise_uninitialized_error
        self.__dict__['_GetInertial'] = _raise_uninitialized_error
        self.__dict__['_GetJ2000'] = _raise_uninitialized_error
        self.__dict__['_GetBarycenter'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownSunSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownSunSystems from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownSunSystems = agcom.GUID(IAgCrdnWellKnownSunSystems._uuid)
        vtable_offset_local = IAgCrdnWellKnownSunSystems._vtable_offset - 1
        self.__dict__['_GetFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetICRF'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetJ2000'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunSystems, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetBarycenter'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunSystems, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSunSystems.__dict__ and type(IAgCrdnWellKnownSunSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSunSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownSunSystems.')
    
    @property
    def Fixed(self) -> "IAgCrdnSystem":
        """The Sun's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixed'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAgCrdnSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetICRF'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAgCrdnSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInertial'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IAgCrdnSystem":
        """The Sun's J2000 coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetJ2000'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Barycenter(self) -> "IAgCrdnSystem":
        """The Inertial system at the Sun's barycenter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetBarycenter'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}', IAgCrdnWellKnownSunSystems)
agcls.AgTypeNameMap['IAgCrdnWellKnownSunSystems'] = IAgCrdnWellKnownSunSystems
__all__.append('IAgCrdnWellKnownSunSystems')

class IAgCrdnWellKnownSunAxes(object):
    """Well-known Sun's axes."""
    _uuid = '{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetFixed'] = _raise_uninitialized_error
        self.__dict__['_GetICRF'] = _raise_uninitialized_error
        self.__dict__['_GetInertial'] = _raise_uninitialized_error
        self.__dict__['_GetJ2000'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownSunAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownSunAxes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownSunAxes = agcom.GUID(IAgCrdnWellKnownSunAxes._uuid)
        vtable_offset_local = IAgCrdnWellKnownSunAxes._vtable_offset - 1
        self.__dict__['_GetFixed'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetICRF'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetInertial'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetJ2000'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSunAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSunAxes.__dict__ and type(IAgCrdnWellKnownSunAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSunAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownSunAxes.')
    
    @property
    def Fixed(self) -> "IAgCrdnAxes":
        """Sun's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetFixed'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "IAgCrdnAxes":
        """Sun's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetICRF'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "IAgCrdnAxes":
        """Sun's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetInertial'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "IAgCrdnAxes":
        """The Sun's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetJ2000'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}', IAgCrdnWellKnownSunAxes)
agcls.AgTypeNameMap['IAgCrdnWellKnownSunAxes'] = IAgCrdnWellKnownSunAxes
__all__.append('IAgCrdnWellKnownSunAxes')

class IAgCrdnWellKnownSystems(object):
    """Well-known coordinate reference systems."""
    _uuid = '{D93C6B6F-D457-4D20-BA7B-960773E3652B}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEarth'] = _raise_uninitialized_error
        self.__dict__['_GetSun'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownSystems from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownSystems = agcom.GUID(IAgCrdnWellKnownSystems._uuid)
        vtable_offset_local = IAgCrdnWellKnownSystems._vtable_offset - 1
        self.__dict__['_GetEarth'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetSun'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownSystems.__dict__ and type(IAgCrdnWellKnownSystems.__dict__[attrname]) == property:
            return IAgCrdnWellKnownSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownSystems.')
    
    @property
    def Earth(self) -> "IAgCrdnWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEarth'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IAgCrdnWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSun'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{D93C6B6F-D457-4D20-BA7B-960773E3652B}', IAgCrdnWellKnownSystems)
agcls.AgTypeNameMap['IAgCrdnWellKnownSystems'] = IAgCrdnWellKnownSystems
__all__.append('IAgCrdnWellKnownSystems')

class IAgCrdnWellKnownAxes(object):
    """Well-known Axes."""
    _uuid = '{B2546963-CC14-4F18-91DE-7091EBEA34C5}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetEarth'] = _raise_uninitialized_error
        self.__dict__['_GetSun'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnWellKnownAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnWellKnownAxes from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnWellKnownAxes = agcom.GUID(IAgCrdnWellKnownAxes._uuid)
        vtable_offset_local = IAgCrdnWellKnownAxes._vtable_offset - 1
        self.__dict__['_GetEarth'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__['_GetSun'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnWellKnownAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnWellKnownAxes.__dict__ and type(IAgCrdnWellKnownAxes.__dict__[attrname]) == property:
            return IAgCrdnWellKnownAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnWellKnownAxes.')
    
    @property
    def Earth(self) -> "IAgCrdnWellKnownEarthAxes":
        """Earth's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetEarth'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "IAgCrdnWellKnownSunAxes":
        """The Sun's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetSun'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{B2546963-CC14-4F18-91DE-7091EBEA34C5}', IAgCrdnWellKnownAxes)
agcls.AgTypeNameMap['IAgCrdnWellKnownAxes'] = IAgCrdnWellKnownAxes
__all__.append('IAgCrdnWellKnownAxes')

class IAgCrdnAngleFindAngleResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    _uuid = '{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleFindAngleResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleFindAngleResult = agcom.GUID(IAgCrdnAngleFindAngleResult._uuid)
        vtable_offset_local = IAgCrdnAngleFindAngleResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindAngleResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindAngleResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindAngleResult.__dict__ and type(IAgCrdnAngleFindAngleResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindAngleResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleFindAngleResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}', IAgCrdnAngleFindAngleResult)
agcls.AgTypeNameMap['IAgCrdnAngleFindAngleResult'] = IAgCrdnAngleFindAngleResult
__all__.append('IAgCrdnAngleFindAngleResult')

class IAgCrdnAngleFindAngleWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    _uuid = '{E46570BA-661C-4974-A780-32DFEAFB9630}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetAngleRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleFindAngleWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleFindAngleWithRateResult = agcom.GUID(IAgCrdnAngleFindAngleWithRateResult._uuid)
        vtable_offset_local = IAgCrdnAngleFindAngleWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindAngleWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindAngleWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__['_GetAngleRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindAngleWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindAngleWithRateResult.__dict__ and type(IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleFindAngleWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngleRate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{E46570BA-661C-4974-A780-32DFEAFB9630}', IAgCrdnAngleFindAngleWithRateResult)
agcls.AgTypeNameMap['IAgCrdnAngleFindAngleWithRateResult'] = IAgCrdnAngleFindAngleWithRateResult
__all__.append('IAgCrdnAngleFindAngleWithRateResult')

class IAgCrdnAngleFindWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    _uuid = '{C4E80CE7-2E38-4364-96D5-004EE425471D}'
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetAngleRate'] = _raise_uninitialized_error
        self.__dict__['_GetVectorFrom'] = _raise_uninitialized_error
        self.__dict__['_GetVectorTo'] = _raise_uninitialized_error
        self.__dict__['_GetVectorAbout'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleFindWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleFindWithRateResult = agcom.GUID(IAgCrdnAngleFindWithRateResult._uuid)
        vtable_offset_local = IAgCrdnAngleFindWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__['_GetAngleRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__['_GetVectorFrom'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetVectorTo'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetVectorAbout'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindWithRateResult.__dict__ and type(IAgCrdnAngleFindWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleFindWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngleRate'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "IAgCartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorFrom'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "IAgCartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorTo'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "IAgCartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorAbout'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{C4E80CE7-2E38-4364-96D5-004EE425471D}', IAgCrdnAngleFindWithRateResult)
agcls.AgTypeNameMap['IAgCrdnAngleFindWithRateResult'] = IAgCrdnAngleFindWithRateResult
__all__.append('IAgCrdnAngleFindWithRateResult')

class IAgCrdnAngleFindResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinates method."""
    _uuid = '{36DD880D-214E-4987-A70A-EA31E7E26B84}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetAngle'] = _raise_uninitialized_error
        self.__dict__['_GetVectorFrom'] = _raise_uninitialized_error
        self.__dict__['_GetVectorTo'] = _raise_uninitialized_error
        self.__dict__['_GetVectorAbout'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAngleFindResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAngleFindResult = agcom.GUID(IAgCrdnAngleFindResult._uuid)
        vtable_offset_local = IAgCrdnAngleFindResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAngle'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__['_GetVectorFrom'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetVectorTo'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetVectorAbout'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAngleFindResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAngleFindResult.__dict__ and type(IAgCrdnAngleFindResult.__dict__[attrname]) == property:
            return IAgCrdnAngleFindResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAngleFindResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngle'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "IAgCartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorFrom'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "IAgCartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorTo'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "IAgCartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVectorAbout'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{36DD880D-214E-4987-A70A-EA31E7E26B84}', IAgCrdnAngleFindResult)
agcls.AgTypeNameMap['IAgCrdnAngleFindResult'] = IAgCrdnAngleFindResult
__all__.append('IAgCrdnAngleFindResult')

class IAgCrdnAxesTransformResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    _uuid = '{D4EC98BE-0D20-4284-96D0-3C40A3100A06}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesTransformResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesTransformResult = agcom.GUID(IAgCrdnAxesTransformResult._uuid)
        vtable_offset_local = IAgCrdnAxesTransformResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTransformResult.__dict__ and type(IAgCrdnAxesTransformResult.__dict__[attrname]) == property:
            return IAgCrdnAxesTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesTransformResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{D4EC98BE-0D20-4284-96D0-3C40A3100A06}', IAgCrdnAxesTransformResult)
agcls.AgTypeNameMap['IAgCrdnAxesTransformResult'] = IAgCrdnAxesTransformResult
__all__.append('IAgCrdnAxesTransformResult')

class IAgCrdnAxesTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    _uuid = '{6434061B-3584-49FF-99C5-2C2D6B385CF1}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_GetVelocity'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesTransformWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesTransformWithRateResult = agcom.GUID(IAgCrdnAxesTransformWithRateResult._uuid)
        vtable_offset_local = IAgCrdnAxesTransformWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesTransformWithRateResult.__dict__ and type(IAgCrdnAxesTransformWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAxesTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesTransformWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The vector velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{6434061B-3584-49FF-99C5-2C2D6B385CF1}', IAgCrdnAxesTransformWithRateResult)
agcls.AgTypeNameMap['IAgCrdnAxesTransformWithRateResult'] = IAgCrdnAxesTransformWithRateResult
__all__.append('IAgCrdnAxesTransformWithRateResult')

class IAgCrdnPlaneFindInAxesResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    _uuid = '{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetXAxis'] = _raise_uninitialized_error
        self.__dict__['_GetYAxis'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneFindInAxesResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneFindInAxesResult = agcom.GUID(IAgCrdnPlaneFindInAxesResult._uuid)
        vtable_offset_local = IAgCrdnPlaneFindInAxesResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetXAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInAxesResult.__dict__ and type(IAgCrdnPlaneFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneFindInAxesResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}', IAgCrdnPlaneFindInAxesResult)
agcls.AgTypeNameMap['IAgCrdnPlaneFindInAxesResult'] = IAgCrdnPlaneFindInAxesResult
__all__.append('IAgCrdnPlaneFindInAxesResult')

class IAgCrdnPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    _uuid = '{CD4424A8-28CF-4AE5-8242-480B6625F0EB}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetXAxis'] = _raise_uninitialized_error
        self.__dict__['_GetXAxisRate'] = _raise_uninitialized_error
        self.__dict__['_GetYAxis'] = _raise_uninitialized_error
        self.__dict__['_GetYAxisRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneFindInAxesWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneFindInAxesWithRateResult = agcom.GUID(IAgCrdnPlaneFindInAxesWithRateResult._uuid)
        vtable_offset_local = IAgCrdnPlaneFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetXAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetXAxisRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxisRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInAxesWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInAxesWithRateResult.__dict__ and type(IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneFindInAxesWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "IAgCartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxisRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "IAgCartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxisRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{CD4424A8-28CF-4AE5-8242-480B6625F0EB}', IAgCrdnPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap['IAgCrdnPlaneFindInAxesWithRateResult'] = IAgCrdnPlaneFindInAxesWithRateResult
__all__.append('IAgCrdnPlaneFindInAxesWithRateResult')

class IAgCrdnPlaneFindInSystemResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    _uuid = '{85D16885-3BEB-4590-963B-F1CC8D016097}'
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetOriginPosition'] = _raise_uninitialized_error
        self.__dict__['_GetXAxis'] = _raise_uninitialized_error
        self.__dict__['_GetYAxis'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneFindInSystemResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneFindInSystemResult = agcom.GUID(IAgCrdnPlaneFindInSystemResult._uuid)
        vtable_offset_local = IAgCrdnPlaneFindInSystemResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetOriginPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetXAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInSystemResult.__dict__ and type(IAgCrdnPlaneFindInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneFindInSystemResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "IAgCartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{85D16885-3BEB-4590-963B-F1CC8D016097}', IAgCrdnPlaneFindInSystemResult)
agcls.AgTypeNameMap['IAgCrdnPlaneFindInSystemResult'] = IAgCrdnPlaneFindInSystemResult
__all__.append('IAgCrdnPlaneFindInSystemResult')

class IAgCrdnPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    _uuid = '{888499CB-4BF7-46A6-A11B-3FFC05EA6804}'
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetOriginPosition'] = _raise_uninitialized_error
        self.__dict__['_GetOriginVelocity'] = _raise_uninitialized_error
        self.__dict__['_GetXAxis'] = _raise_uninitialized_error
        self.__dict__['_GetXAxisRate'] = _raise_uninitialized_error
        self.__dict__['_GetYAxis'] = _raise_uninitialized_error
        self.__dict__['_GetYAxisRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPlaneFindInSystemWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPlaneFindInSystemWithRateResult = agcom.GUID(IAgCrdnPlaneFindInSystemWithRateResult._uuid)
        vtable_offset_local = IAgCrdnPlaneFindInSystemWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetOriginPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetOriginVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetXAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetXAxisRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxis'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__['_GetYAxisRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPlaneFindInSystemWithRateResult, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPlaneFindInSystemWithRateResult.__dict__ and type(IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPlaneFindInSystemWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "IAgCartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginVelocity(self) -> "IAgCartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOriginVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "IAgCartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "IAgCartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetXAxisRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "IAgCartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxis'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "IAgCartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetYAxisRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{888499CB-4BF7-46A6-A11B-3FFC05EA6804}', IAgCrdnPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap['IAgCrdnPlaneFindInSystemWithRateResult'] = IAgCrdnPlaneFindInSystemWithRateResult
__all__.append('IAgCrdnPlaneFindInSystemWithRateResult')

class IAgCrdnAxesFindInAxesResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    _uuid = '{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetOrientation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesFindInAxesResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesFindInAxesResult = agcom.GUID(IAgCrdnAxesFindInAxesResult._uuid)
        vtable_offset_local = IAgCrdnAxesFindInAxesResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetOrientation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFindInAxesResult.__dict__ and type(IAgCrdnAxesFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnAxesFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesFindInAxesResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Orientation(self) -> "IAgOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrientation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}', IAgCrdnAxesFindInAxesResult)
agcls.AgTypeNameMap['IAgCrdnAxesFindInAxesResult'] = IAgCrdnAxesFindInAxesResult
__all__.append('IAgCrdnAxesFindInAxesResult')

class IAgCrdnAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    _uuid = '{72644DD0-D129-4D7A-8A81-586E86E639BD}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetAngularVelocity'] = _raise_uninitialized_error
        self.__dict__['_GetOrientation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesFindInAxesWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesFindInAxesWithRateResult = agcom.GUID(IAgCrdnAxesFindInAxesWithRateResult._uuid)
        vtable_offset_local = IAgCrdnAxesFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetAngularVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetOrientation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesFindInAxesWithRateResult.__dict__ and type(IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesFindInAxesWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngularVelocity(self) -> "IAgCartesian3Vector":
        """Axes' angular velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetAngularVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IAgOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrientation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{72644DD0-D129-4D7A-8A81-586E86E639BD}', IAgCrdnAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap['IAgCrdnAxesFindInAxesWithRateResult'] = IAgCrdnAxesFindInAxesWithRateResult
__all__.append('IAgCrdnAxesFindInAxesWithRateResult')

class IAgCrdnPointLocateInSystemResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystem method."""
    _uuid = '{84453DEC-5D01-4D47-A177-F8A737F0496D}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetPosition'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointLocateInSystemResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointLocateInSystemResult = agcom.GUID(IAgCrdnPointLocateInSystemResult._uuid)
        vtable_offset_local = IAgCrdnPointLocateInSystemResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLocateInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLocateInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLocateInSystemResult.__dict__ and type(IAgCrdnPointLocateInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnPointLocateInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointLocateInSystemResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "IAgCartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{84453DEC-5D01-4D47-A177-F8A737F0496D}', IAgCrdnPointLocateInSystemResult)
agcls.AgTypeNameMap['IAgCrdnPointLocateInSystemResult'] = IAgCrdnPointLocateInSystemResult
__all__.append('IAgCrdnPointLocateInSystemResult')

class IAgCrdnPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    _uuid = '{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetPosition'] = _raise_uninitialized_error
        self.__dict__['_GetVelocity'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointLocateInSystemWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointLocateInSystemWithRateResult = agcom.GUID(IAgCrdnPointLocateInSystemWithRateResult._uuid)
        vtable_offset_local = IAgCrdnPointLocateInSystemWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLocateInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLocateInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointLocateInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointLocateInSystemWithRateResult.__dict__ and type(IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointLocateInSystemWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "IAgCartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The point velocity in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}', IAgCrdnPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap['IAgCrdnPointLocateInSystemWithRateResult'] = IAgCrdnPointLocateInSystemWithRateResult
__all__.append('IAgCrdnPointLocateInSystemWithRateResult')

class IAgCrdnSystemTransformResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    _uuid = '{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemTransformResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemTransformResult = agcom.GUID(IAgCrdnSystemTransformResult._uuid)
        vtable_offset_local = IAgCrdnSystemTransformResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemTransformResult.__dict__ and type(IAgCrdnSystemTransformResult.__dict__[attrname]) == property:
            return IAgCrdnSystemTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemTransformResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}', IAgCrdnSystemTransformResult)
agcls.AgTypeNameMap['IAgCrdnSystemTransformResult'] = IAgCrdnSystemTransformResult
__all__.append('IAgCrdnSystemTransformResult')

class IAgCrdnSystemTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    _uuid = '{A9E92350-230F-45C7-A617-DB684FF89C78}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_GetVelocity'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemTransformWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemTransformWithRateResult = agcom.GUID(IAgCrdnSystemTransformWithRateResult._uuid)
        vtable_offset_local = IAgCrdnSystemTransformWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemTransformWithRateResult.__dict__ and type(IAgCrdnSystemTransformWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnSystemTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemTransformWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """The vector's velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A9E92350-230F-45C7-A617-DB684FF89C78}', IAgCrdnSystemTransformWithRateResult)
agcls.AgTypeNameMap['IAgCrdnSystemTransformWithRateResult'] = IAgCrdnSystemTransformWithRateResult
__all__.append('IAgCrdnSystemTransformWithRateResult')

class IAgCrdnSystemFindInSystemResult(object):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    _uuid = '{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetPosition'] = _raise_uninitialized_error
        self.__dict__['_GetVelocity'] = _raise_uninitialized_error
        self.__dict__['_GetRate'] = _raise_uninitialized_error
        self.__dict__['_GetOrientation'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnSystemFindInSystemResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnSystemFindInSystemResult = agcom.GUID(IAgCrdnSystemFindInSystemResult._uuid)
        vtable_offset_local = IAgCrdnSystemFindInSystemResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetPosition'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetVelocity'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_GetRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__['_GetOrientation'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnSystemFindInSystemResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnSystemFindInSystemResult.__dict__ and type(IAgCrdnSystemFindInSystemResult.__dict__[attrname]) == property:
            return IAgCrdnSystemFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnSystemFindInSystemResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "IAgCartesian3Vector":
        """A position vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPosition'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "IAgCartesian3Vector":
        """A velocity vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocity'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "IAgCartesian3Vector":
        """Rate of change."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IAgOrientation":
        """Orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetOrientation'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}', IAgCrdnSystemFindInSystemResult)
agcls.AgTypeNameMap['IAgCrdnSystemFindInSystemResult'] = IAgCrdnSystemFindInSystemResult
__all__.append('IAgCrdnSystemFindInSystemResult')

class IAgCrdnVectorFindInAxesResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    _uuid = '{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFindInAxesResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFindInAxesResult = agcom.GUID(IAgCrdnVectorFindInAxesResult._uuid)
        vtable_offset_local = IAgCrdnVectorFindInAxesResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFindInAxesResult.__dict__ and type(IAgCrdnVectorFindInAxesResult.__dict__[attrname]) == property:
            return IAgCrdnVectorFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFindInAxesResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}', IAgCrdnVectorFindInAxesResult)
agcls.AgTypeNameMap['IAgCrdnVectorFindInAxesResult'] = IAgCrdnVectorFindInAxesResult
__all__.append('IAgCrdnVectorFindInAxesResult')

class IAgCrdnVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    _uuid = '{A5EB9B7C-559C-4ABB-839E-47109CDC8446}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetVector'] = _raise_uninitialized_error
        self.__dict__['_GetRate'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnVectorFindInAxesWithRateResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnVectorFindInAxesWithRateResult = agcom.GUID(IAgCrdnVectorFindInAxesWithRateResult._uuid)
        vtable_offset_local = IAgCrdnVectorFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetVector'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__['_GetRate'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnVectorFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnVectorFindInAxesWithRateResult.__dict__ and type(IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]) == property:
            return IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnVectorFindInAxesWithRateResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "IAgCartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVector'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "IAgCartesian3Vector":
        """The vector rate in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetRate'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{A5EB9B7C-559C-4ABB-839E-47109CDC8446}', IAgCrdnVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap['IAgCrdnVectorFindInAxesWithRateResult'] = IAgCrdnVectorFindInAxesWithRateResult
__all__.append('IAgCrdnVectorFindInAxesWithRateResult')

class IAgCrdnMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""
    _uuid = '{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnMethodCallResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnMethodCallResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnMethodCallResult = agcom.GUID(IAgCrdnMethodCallResult._uuid)
        vtable_offset_local = IAgCrdnMethodCallResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnMethodCallResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnMethodCallResult.__dict__ and type(IAgCrdnMethodCallResult.__dict__[attrname]) == property:
            return IAgCrdnMethodCallResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnMethodCallResult.')
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}', IAgCrdnMethodCallResult)
agcls.AgTypeNameMap['IAgCrdnMethodCallResult'] = IAgCrdnMethodCallResult
__all__.append('IAgCrdnMethodCallResult')

class IAgCrdnCentralBody(object):
    """The interface represents a central body."""
    _uuid = '{8742150E-1663-4DCC-A442-278479FF93DC}'
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetName'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCentralBody from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCentralBody = agcom.GUID(IAgCrdnCentralBody._uuid)
        vtable_offset_local = IAgCrdnCentralBody._vtable_offset - 1
        self.__dict__['_GetName'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBody, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBody.__dict__ and type(IAgCrdnCentralBody.__dict__[attrname]) == property:
            return IAgCrdnCentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCentralBody.')
    
    @property
    def Name(self) -> str:
        """A name of the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetName'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{8742150E-1663-4DCC-A442-278479FF93DC}', IAgCrdnCentralBody)
agcls.AgTypeNameMap['IAgCrdnCentralBody'] = IAgCrdnCentralBody
__all__.append('IAgCrdnCentralBody')

class IAgCrdnCentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""
    _uuid = '{40596A74-4E5F-4406-85FF-70FA79893BFC}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_SetPath'] = _raise_uninitialized_error
        self.__dict__['_SetCentralBody'] = _raise_uninitialized_error
        self.__dict__['_GetCentralBody'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCentralBodyRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCentralBodyRefTo from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCentralBodyRefTo = agcom.GUID(IAgCrdnCentralBodyRefTo._uuid)
        vtable_offset_local = IAgCrdnCentralBodyRefTo._vtable_offset - 1
        self.__dict__['_SetPath'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__['_SetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__['_GetCentralBody'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBodyRefTo.__dict__ and type(IAgCrdnCentralBodyRefTo.__dict__[attrname]) == property:
            return IAgCrdnCentralBodyRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCentralBodyRefTo.')
    
    def SetPath(self, path:str) -> None:
        """Sets a new central body using specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__['_SetPath'](arg_path.COM_val))

    def SetCentralBody(self, centralBody:"IAgCrdnCentralBody") -> None:
        """Sets a new central body."""
        with agmarshall.AgInterface_in_arg(centralBody, IAgCrdnCentralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__['_SetCentralBody'](arg_centralBody.COM_val))

    def GetCentralBody(self) -> "IAgCrdnCentralBody":
        """Returns a central body or null if the central body is invalid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCentralBody'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{40596A74-4E5F-4406-85FF-70FA79893BFC}', IAgCrdnCentralBodyRefTo)
agcls.AgTypeNameMap['IAgCrdnCentralBodyRefTo'] = IAgCrdnCentralBodyRefTo
__all__.append('IAgCrdnCentralBodyRefTo')

class IAgCrdnCentralBodyCollection(object):
    """A collection of central body names."""
    _uuid = '{FB32C9FA-327D-4AF9-9330-7DE8854F827E}'
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        self.__dict__['_Add'] = _raise_uninitialized_error
        self.__dict__['_Remove'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCentralBodyCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCentralBodyCollection = agcom.GUID(IAgCrdnCentralBodyCollection._uuid)
        vtable_offset_local = IAgCrdnCentralBodyCollection._vtable_offset - 1
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__['_Add'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_Remove'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCentralBodyCollection, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCentralBodyCollection.__dict__ and type(IAgCrdnCentralBodyCollection.__dict__[attrname]) == property:
            return IAgCrdnCentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCentralBodyCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> str:
        """Returns a central body name at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, centralBodyName:str) -> bool:
        """Adds a central body to the collection of central bodies. True indicates success."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Add'](arg_centralBodyName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Remove(self, centralBodyName:str) -> None:
        """Removes a central body with the specified name from the collection of the central bodies."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName:
            agcls.evaluate_hresult(self.__dict__['_Remove'](arg_centralBodyName.COM_val))

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{FB32C9FA-327D-4AF9-9330-7DE8854F827E}', IAgCrdnCentralBodyCollection)
agcls.AgTypeNameMap['IAgCrdnCentralBodyCollection'] = IAgCrdnCentralBodyCollection
__all__.append('IAgCrdnCentralBodyCollection')

class IAgCrdnCollection(object):
    """A collection of VGT objects."""
    _uuid = '{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}'
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_Contains'] = _raise_uninitialized_error
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnCollection = agcom.GUID(IAgCrdnCollection._uuid)
        vtable_offset_local = IAgCrdnCollection._vtable_offset - 1
        self.__dict__['_Contains'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCollection, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnCollection.__dict__ and type(IAgCrdnCollection.__dict__[attrname]) == property:
            return IAgCrdnCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdn":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_Contains'](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "IAgCrdn":
        """Retrieves an element of the collection using the name of the element or a position in the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}', IAgCrdnCollection)
agcls.AgTypeNameMap['IAgCrdnCollection'] = IAgCrdnCollection
__all__.append('IAgCrdnCollection')

class IAgCrdnPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    _uuid = '{5131DB47-EFEA-4021-BEC5-DD13A73D9917}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointSamplingResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointSamplingResult = agcom.GUID(IAgCrdnPointSamplingResult._uuid)
        vtable_offset_local = IAgCrdnPointSamplingResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingResult.__dict__ and type(IAgCrdnPointSamplingResult.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointSamplingResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IAgCrdnPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{5131DB47-EFEA-4021-BEC5-DD13A73D9917}', IAgCrdnPointSamplingResult)
agcls.AgTypeNameMap['IAgCrdnPointSamplingResult'] = IAgCrdnPointSamplingResult
__all__.append('IAgCrdnPointSamplingResult')

class IAgCrdnPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""
    _uuid = '{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimes'] = _raise_uninitialized_error
        self.__dict__['_GetPositions'] = _raise_uninitialized_error
        self.__dict__['_GetVelocities'] = _raise_uninitialized_error
        self.__dict__['_GetStart'] = _raise_uninitialized_error
        self.__dict__['_GetStop'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointSamplingInterval from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointSamplingInterval = agcom.GUID(IAgCrdnPointSamplingInterval._uuid)
        vtable_offset_local = IAgCrdnPointSamplingInterval._vtable_offset - 1
        self.__dict__['_GetTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetPositions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetVelocities'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__['_GetStop'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingInterval.__dict__ and type(IAgCrdnPointSamplingInterval.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointSamplingInterval.')
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetPositions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocities'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStop'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}', IAgCrdnPointSamplingInterval)
agcls.AgTypeNameMap['IAgCrdnPointSamplingInterval'] = IAgCrdnPointSamplingInterval
__all__.append('IAgCrdnPointSamplingInterval')

class IAgCrdnPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    _uuid = '{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnPointSamplingIntervalCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnPointSamplingIntervalCollection = agcom.GUID(IAgCrdnPointSamplingIntervalCollection._uuid)
        vtable_offset_local = IAgCrdnPointSamplingIntervalCollection._vtable_offset - 1
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnPointSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnPointSamplingIntervalCollection.__dict__ and type(IAgCrdnPointSamplingIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnPointSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnPointSamplingIntervalCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnPointSamplingInterval":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IAgCrdnPointSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}', IAgCrdnPointSamplingIntervalCollection)
agcls.AgTypeNameMap['IAgCrdnPointSamplingIntervalCollection'] = IAgCrdnPointSamplingIntervalCollection
__all__.append('IAgCrdnPointSamplingIntervalCollection')

class IAgCrdnAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    _uuid = '{F01C2A06-2998-406C-9898-CB60F5711EF1}'
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetIsValid'] = _raise_uninitialized_error
        self.__dict__['_GetIntervals'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesSamplingResult from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesSamplingResult = agcom.GUID(IAgCrdnAxesSamplingResult._uuid)
        vtable_offset_local = IAgCrdnAxesSamplingResult._vtable_offset - 1
        self.__dict__['_GetIsValid'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__['_GetIntervals'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingResult.__dict__ and type(IAgCrdnAxesSamplingResult.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesSamplingResult.')
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIsValid'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "IAgCrdnAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetIntervals'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{F01C2A06-2998-406C-9898-CB60F5711EF1}', IAgCrdnAxesSamplingResult)
agcls.AgTypeNameMap['IAgCrdnAxesSamplingResult'] = IAgCrdnAxesSamplingResult
__all__.append('IAgCrdnAxesSamplingResult')

class IAgCrdnAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    _uuid = '{5BF49282-A56A-48F1-85C9-92CF71C803D0}'
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetTimes'] = _raise_uninitialized_error
        self.__dict__['_GetQuaternions'] = _raise_uninitialized_error
        self.__dict__['_GetVelocities'] = _raise_uninitialized_error
        self.__dict__['_GetStart'] = _raise_uninitialized_error
        self.__dict__['_GetStop'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesSamplingInterval from source object.')
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesSamplingInterval = agcom.GUID(IAgCrdnAxesSamplingInterval._uuid)
        vtable_offset_local = IAgCrdnAxesSamplingInterval._vtable_offset - 1
        self.__dict__['_GetTimes'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetQuaternions'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetVelocities'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__['_GetStart'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__['_GetStop'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingInterval.__dict__ and type(IAgCrdnAxesSamplingInterval.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesSamplingInterval.')
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetTimes'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetQuaternions'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of angular velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetVelocities'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStart'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetStop'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry('{5BF49282-A56A-48F1-85C9-92CF71C803D0}', IAgCrdnAxesSamplingInterval)
agcls.AgTypeNameMap['IAgCrdnAxesSamplingInterval'] = IAgCrdnAxesSamplingInterval
__all__.append('IAgCrdnAxesSamplingInterval')

class IAgCrdnAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    _uuid = '{F593657B-35A4-4F40-B697-4D14E66195AC}'
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__['_pUnk'] = None
        self.__dict__['_GetCount'] = _raise_uninitialized_error
        self.__dict__['_Item'] = _raise_uninitialized_error
        self.__dict__['_Get_NewEnum'] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__['_pUnk'] is not None:
            pUnk = sourceObject.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError('Failed to create IAgCrdnAxesSamplingIntervalCollection from source object.')
        self.__dict__['enumerator'] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IID_IAgCrdnAxesSamplingIntervalCollection = agcom.GUID(IAgCrdnAxesSamplingIntervalCollection._uuid)
        vtable_offset_local = IAgCrdnAxesSamplingIntervalCollection._vtable_offset - 1
        self.__dict__['_GetCount'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__['_Item'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__['_Get_NewEnum'] = IAGFUNCTYPE(pUnk, IID_IAgCrdnAxesSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAgCrdnAxesSamplingIntervalCollection.__dict__ and type(IAgCrdnAxesSamplingIntervalCollection.__dict__[attrname]) == property:
            return IAgCrdnAxesSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in IAgCrdnAxesSamplingIntervalCollection.')
    def __iter__(self):
        self.__dict__['enumerator'] = self._NewEnum
        self.__dict__['enumerator'].Reset()
        return self
    def __next__(self) -> "IAgCrdnAxesSamplingInterval":
        if self.__dict__['enumerator'] is None:
            raise StopIteration
        nextval = self.__dict__['enumerator'].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__['_GetCount'](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "IAgCrdnAxesSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Item'](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__['_Get_NewEnum'](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry('{F593657B-35A4-4F40-B697-4D14E66195AC}', IAgCrdnAxesSamplingIntervalCollection)
agcls.AgTypeNameMap['IAgCrdnAxesSamplingIntervalCollection'] = IAgCrdnAxesSamplingIntervalCollection
__all__.append('IAgCrdnAxesSamplingIntervalCollection')



class AgCrdnEvaluateResult(IAgCrdnEvaluateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvaluateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEvaluateResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}', AgCrdnEvaluateResult)
__all__.append('AgCrdnEvaluateResult')


class AgCrdnEvaluateWithRateResult(IAgCrdnEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEvaluateWithRateResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}', AgCrdnEvaluateWithRateResult)
__all__.append('AgCrdnEvaluateWithRateResult')


class AgCrdnEventIntervalResult(IAgCrdnEventIntervalResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{ACE6C28C-4664-4B7F-8736-91F55C7962A6}', AgCrdnEventIntervalResult)
__all__.append('AgCrdnEventIntervalResult')


class AgCrdnEventFindOccurrenceResult(IAgCrdnEventFindOccurrenceResult):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventFindOccurrenceResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventFindOccurrenceResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventFindOccurrenceResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventFindOccurrenceResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}', AgCrdnEventFindOccurrenceResult)
__all__.append('AgCrdnEventFindOccurrenceResult')


class AgCrdnFindTimesResult(IAgCrdnFindTimesResult):
    """Returns a collection of intervals and an array of times."""
    def __init__(self, sourceObject=None):
        IAgCrdnFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnFindTimesResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnFindTimesResult._get_property(self, attrname) is not None: found_prop = IAgCrdnFindTimesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnFindTimesResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}', AgCrdnFindTimesResult)
__all__.append('AgCrdnFindTimesResult')


class AgCrdnIntervalsVectorResult(IAgCrdnIntervalsVectorResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntervalsVectorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalsVectorResult._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalsVectorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntervalsVectorResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{233B8EB4-0B6A-485F-BACB-C678798FDA21}', AgCrdnIntervalsVectorResult)
__all__.append('AgCrdnIntervalsVectorResult')


class AgCrdnEventIntervalCollectionOccurredResult(IAgCrdnEventIntervalCollectionOccurredResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionOccurredResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionOccurredResult._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionOccurredResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionOccurredResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}', AgCrdnEventIntervalCollectionOccurredResult)
__all__.append('AgCrdnEventIntervalCollectionOccurredResult')


class AgCrdnIntervalListResult(IAgCrdnIntervalListResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntervalListResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalListResult._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalListResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntervalListResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}', AgCrdnIntervalListResult)
__all__.append('AgCrdnIntervalListResult')


class AgCrdnIntervalVectorCollection(IAgCrdnIntervalVectorCollection):
    """A collection of interval collections."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntervalVectorCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalVectorCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalVectorCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntervalVectorCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}', AgCrdnIntervalVectorCollection)
__all__.append('AgCrdnIntervalVectorCollection')


class AgCrdnEventGroup(IAgCrdnEventGroup):
    """Access or create VGT events associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{D5D83181-A954-4FA9-886E-A917F135C974}', AgCrdnEventGroup)
__all__.append('AgCrdnEventGroup')


class AgCrdnEventIntervalGroup(IAgCrdnEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}', AgCrdnEventIntervalGroup)
__all__.append('AgCrdnEventIntervalGroup')


class AgCrdnEventIntervalListGroup(IAgCrdnEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{3B2FDEBA-A2B9-4568-8F48-469F604DB966}', AgCrdnEventIntervalListGroup)
__all__.append('AgCrdnEventIntervalListGroup')


class AgCrdnEventArrayGroup(IAgCrdnEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{365C4A6E-9C2B-4883-96C6-CF689BCC2943}', AgCrdnEventArrayGroup)
__all__.append('AgCrdnEventArrayGroup')


class AgCrdnCalcScalarGroup(IAgCrdnCalcScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{DFAD8468-4480-460F-993D-74FFADB567B3}', AgCrdnCalcScalarGroup)
__all__.append('AgCrdnCalcScalarGroup')


class AgCrdnEventIntervalCollectionGroup(IAgCrdnEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{16E277E2-E306-40E7-B698-B725BDED5739}', AgCrdnEventIntervalCollectionGroup)
__all__.append('AgCrdnEventIntervalCollectionGroup')


class AgCrdnParameterSetGroup(IAgCrdnParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}', AgCrdnParameterSetGroup)
__all__.append('AgCrdnParameterSetGroup')


class AgCrdnConditionGroup(IAgCrdnConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}', AgCrdnConditionGroup)
__all__.append('AgCrdnConditionGroup')


class AgCrdnConditionSetGroup(IAgCrdnConditionSetGroup):
    """Allows accessing and creating condition set components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSetGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{D82D5C71-102E-4154-9FF6-153C4EDB5A94}', AgCrdnConditionSetGroup)
__all__.append('AgCrdnConditionSetGroup')


class AgCrdnConditionSetEvaluateResult(IAgCrdnConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSetEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetEvaluateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSetEvaluateResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{13F4EB53-F5AB-487A-BC09-AA186C884744}', AgCrdnConditionSetEvaluateResult)
__all__.append('AgCrdnConditionSetEvaluateResult')


class AgCrdnConditionSetEvaluateWithRateResult(IAgCrdnConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSetEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSetEvaluateWithRateResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{53051D77-87D0-432C-9044-A2AB1E2104BA}', AgCrdnConditionSetEvaluateWithRateResult)
__all__.append('AgCrdnConditionSetEvaluateWithRateResult')


class AgCrdnVolumeGridGroup(IAgCrdnVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}', AgCrdnVolumeGridGroup)
__all__.append('AgCrdnVolumeGridGroup')


class AgCrdnVolumeGroup(IAgCrdnVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{0055B726-654F-446B-82D7-BCDD744F1D8F}', AgCrdnVolumeGroup)
__all__.append('AgCrdnVolumeGroup')


class AgCrdnVolumeCalcGroup(IAgCrdnVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{b10331b7-f8c3-4a59-9e9b-b05dd6599167}', AgCrdnVolumeCalcGroup)
__all__.append('AgCrdnVolumeCalcGroup')


class AgCrdnCalcScalar(IAgCrdnCalcScalar, IAgCrdn):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalar.')
        
agcls.AgClassCatalog.add_catalog_entry('{440E178B-1B34-4896-A25F-2A4F3AD4848E}', AgCrdnCalcScalar)
__all__.append('AgCrdnCalcScalar')


class AgCrdnCalcScalarAngle(IAgCrdnCalcScalarAngle, IAgCrdnCalcScalar, IAgCrdn):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarAngle.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarAngle._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarAngle._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarAngle.')
        
agcls.AgClassCatalog.add_catalog_entry('{2E2A940D-2656-4410-86B4-D7314B788E47}', AgCrdnCalcScalarAngle)
__all__.append('AgCrdnCalcScalarAngle')


class AgCrdnCalcScalarConstant(IAgCrdnCalcScalarConstant, IAgCrdnCalcScalar, IAgCrdn):
    """Constant scalar value of specified dimension."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarConstant.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarConstant._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarConstant._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarConstant._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarConstant.')
        
agcls.AgClassCatalog.add_catalog_entry('{0725A767-6788-4FF4-B848-EF3D526BD7B0}', AgCrdnCalcScalarConstant)
__all__.append('AgCrdnCalcScalarConstant')


class AgCrdnCalcScalarCustom(IAgCrdnCalcScalarCustom, IAgCrdnCalcScalar, IAgCrdn):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarCustom.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarCustom._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarCustom._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarCustom._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarCustom.')
        
agcls.AgClassCatalog.add_catalog_entry('{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}', AgCrdnCalcScalarCustom)
__all__.append('AgCrdnCalcScalarCustom')


class AgCrdnCalcScalarDataElement(IAgCrdnCalcScalarDataElement, IAgCrdnCalcScalar, IAgCrdn):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDataElement.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarDataElement._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDataElement._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDataElement._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarDataElement.')
        
agcls.AgClassCatalog.add_catalog_entry('{260D686F-07E2-49DB-8E88-467EF79EFA54}', AgCrdnCalcScalarDataElement)
__all__.append('AgCrdnCalcScalarDataElement')


class AgCrdnCalcScalarDerivative(IAgCrdnCalcScalarDerivative, IAgCrdnCalcScalar, IAgCrdn):
    """Derivative of an input scalar calculation."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDerivative.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarDerivative._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDerivative._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarDerivative.')
        
agcls.AgClassCatalog.add_catalog_entry('{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}', AgCrdnCalcScalarDerivative)
__all__.append('AgCrdnCalcScalarDerivative')


class AgCrdnCalcScalarDotProduct(IAgCrdnCalcScalarDotProduct, IAgCrdnCalcScalar, IAgCrdn):
    """Dot product between two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarDotProduct.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarDotProduct._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarDotProduct._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarDotProduct._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarDotProduct.')
        
agcls.AgClassCatalog.add_catalog_entry('{703f009e-faab-4281-8d07-733b1344d42b}', AgCrdnCalcScalarDotProduct)
__all__.append('AgCrdnCalcScalarDotProduct')


class AgCrdnCalcScalarElapsedTime(IAgCrdnCalcScalarElapsedTime, IAgCrdnCalcScalar, IAgCrdn):
    """Time elapsed since the reference time instant. Negative if in the past."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarElapsedTime.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarElapsedTime._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarElapsedTime._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarElapsedTime._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarElapsedTime.')
        
agcls.AgClassCatalog.add_catalog_entry('{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}', AgCrdnCalcScalarElapsedTime)
__all__.append('AgCrdnCalcScalarElapsedTime')


class AgCrdnCalcScalarFactory(IAgCrdnCalcScalarFactory):
    """The factory creates scalar calculation components."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{47235112-821F-4DC2-9A70-57AB9F1F17E8}', AgCrdnCalcScalarFactory)
__all__.append('AgCrdnCalcScalarFactory')


class AgCrdnCalcScalarFile(IAgCrdnCalcScalarFile, IAgCrdnCalcScalar, IAgCrdn):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFile.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarFile._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFile._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFile._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarFile.')
        
agcls.AgClassCatalog.add_catalog_entry('{75F0039F-B789-4771-BD50-9AEF30F6038E}', AgCrdnCalcScalarFile)
__all__.append('AgCrdnCalcScalarFile')


class AgCrdnCalcScalarFixedAtTimeInstant(IAgCrdnCalcScalarFixedAtTimeInstant, IAgCrdnCalcScalar, IAgCrdn):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFixedAtTimeInstant.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarFixedAtTimeInstant._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarFixedAtTimeInstant.')
        
agcls.AgClassCatalog.add_catalog_entry('{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}', AgCrdnCalcScalarFixedAtTimeInstant)
__all__.append('AgCrdnCalcScalarFixedAtTimeInstant')


class AgCrdnCalcScalarFunction(IAgCrdnCalcScalarFunction, IAgCrdnCalcScalar, IAgCrdn):
    """Defined by performing the specified function on the input scalar or time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFunction.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarFunction._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFunction._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFunction._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarFunction.')
        
agcls.AgClassCatalog.add_catalog_entry('{40158F99-3146-4167-8BB0-A0046BB08EEB}', AgCrdnCalcScalarFunction)
__all__.append('AgCrdnCalcScalarFunction')


class AgCrdnCalcScalarFunction2Var(IAgCrdnCalcScalarFunction2Var, IAgCrdnCalcScalar, IAgCrdn):
    """Defined by performing a function(x,y) on two scalar arguments."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarFunction2Var.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarFunction2Var._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarFunction2Var._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarFunction2Var._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarFunction2Var.')
        
agcls.AgClassCatalog.add_catalog_entry('{05CA07A4-A36F-44EF-99C4-5E0999E79200}', AgCrdnCalcScalarFunction2Var)
__all__.append('AgCrdnCalcScalarFunction2Var')


class AgCrdnCalcScalarIntegral(IAgCrdnCalcScalarIntegral, IAgCrdnCalcScalar, IAgCrdn):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarIntegral.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarIntegral._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarIntegral._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarIntegral.')
        
agcls.AgClassCatalog.add_catalog_entry('{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}', AgCrdnCalcScalarIntegral)
__all__.append('AgCrdnCalcScalarIntegral')


class AgCrdnCalcScalarPlugin(IAgCrdnCalcScalarPlugin, IAgCrdnCalcScalar, IAgCrdn):
    """Use a scalar calculation plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarPlugin.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarPlugin._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarPlugin._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarPlugin.')
        
agcls.AgClassCatalog.add_catalog_entry('{E435E30B-EA9B-4EFB-852A-C20427B71484}', AgCrdnCalcScalarPlugin)
__all__.append('AgCrdnCalcScalarPlugin')


class AgCrdnCalcScalarSurfaceDistanceBetweenPoints(IAgCrdnCalcScalarSurfaceDistanceBetweenPoints, IAgCrdnCalcScalar, IAgCrdn):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarSurfaceDistanceBetweenPoints.')
        
agcls.AgClassCatalog.add_catalog_entry('{DEDCB488-6C70-4BC0-A719-68832FB6D30E}', AgCrdnCalcScalarSurfaceDistanceBetweenPoints)
__all__.append('AgCrdnCalcScalarSurfaceDistanceBetweenPoints')


class AgCrdnCalcScalarVectorComponent(IAgCrdnCalcScalarVectorComponent, IAgCrdnCalcScalar, IAgCrdn):
    """The specified component of a vector when resolved in the specified axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarVectorComponent.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarVectorComponent._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarVectorComponent._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarVectorComponent._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarVectorComponent.')
        
agcls.AgClassCatalog.add_catalog_entry('{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}', AgCrdnCalcScalarVectorComponent)
__all__.append('AgCrdnCalcScalarVectorComponent')


class AgCrdnCalcScalarVectorMagnitude(IAgCrdnCalcScalarVectorMagnitude, IAgCrdnCalcScalar, IAgCrdn):
    """Scalar equal to the magnitude of a specified vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnCalcScalarVectorMagnitude.__init__(self, sourceObject)
        IAgCrdnCalcScalar.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCalcScalarVectorMagnitude._private_init(self, pUnk)
        IAgCrdnCalcScalar._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCalcScalarVectorMagnitude._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalarVectorMagnitude._get_property(self, attrname)
        if IAgCrdnCalcScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnCalcScalar._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCalcScalarVectorMagnitude.')
        
agcls.AgClassCatalog.add_catalog_entry('{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}', AgCrdnCalcScalarVectorMagnitude)
__all__.append('AgCrdnCalcScalarVectorMagnitude')


class AgCrdnCondition(IAgCrdnCondition, IAgCrdn):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCondition._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCondition.')
        
agcls.AgClassCatalog.add_catalog_entry('{D1BED244-FFB2-4038-AE76-A9B3194B2E49}', AgCrdnCondition)
__all__.append('AgCrdnCondition')


class AgCrdnConditionCombined(IAgCrdnConditionCombined, IAgCrdnCondition, IAgCrdn):
    """Defines a condition which combines multiple conditions."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionCombined.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionCombined._private_init(self, pUnk)
        IAgCrdnCondition._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionCombined._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionCombined._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionCombined.')
        
agcls.AgClassCatalog.add_catalog_entry('{92F4488B-3543-4229-B1FB-447D282199B9}', AgCrdnConditionCombined)
__all__.append('AgCrdnConditionCombined')


class AgCrdnConditionFactory(IAgCrdnConditionFactory):
    """The factory creates condition components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{06C627F8-87EA-4552-86E8-7E5049914CDE}', AgCrdnConditionFactory)
__all__.append('AgCrdnConditionFactory')


class AgCrdnConditionPointInVolume(IAgCrdnConditionPointInVolume, IAgCrdnCondition, IAgCrdn):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionPointInVolume.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionPointInVolume._private_init(self, pUnk)
        IAgCrdnCondition._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionPointInVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionPointInVolume._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionPointInVolume.')
        
agcls.AgClassCatalog.add_catalog_entry('{41532AD9-B30C-44AE-8581-CE74C24846A8}', AgCrdnConditionPointInVolume)
__all__.append('AgCrdnConditionPointInVolume')


class AgCrdnConditionScalarBounds(IAgCrdnConditionScalarBounds, IAgCrdnCondition, IAgCrdn):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionScalarBounds.__init__(self, sourceObject)
        IAgCrdnCondition.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionScalarBounds._private_init(self, pUnk)
        IAgCrdnCondition._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionScalarBounds._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionScalarBounds._get_property(self, attrname)
        if IAgCrdnCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnCondition._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionScalarBounds.')
        
agcls.AgClassCatalog.add_catalog_entry('{452E2178-AFB0-4E61-8187-9C6CB4A704A0}', AgCrdnConditionScalarBounds)
__all__.append('AgCrdnConditionScalarBounds')


class AgCrdnConditionSet(IAgCrdnConditionSet, IAgCrdn):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSet._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSet.')
        
agcls.AgClassCatalog.add_catalog_entry('{B6407B1B-6858-49FC-845A-F8A6239162C2}', AgCrdnConditionSet)
__all__.append('AgCrdnConditionSet')


class AgCrdnConditionSetFactory(IAgCrdnConditionSetFactory):
    """The factory creates condition set components."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSetFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{D2445C98-9EA1-458F-9B6A-607249BF399A}', AgCrdnConditionSetFactory)
__all__.append('AgCrdnConditionSetFactory')


class AgCrdnConditionSetScalarThresholds(IAgCrdnConditionSetScalarThresholds, IAgCrdnConditionSet, IAgCrdn):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    def __init__(self, sourceObject=None):
        IAgCrdnConditionSetScalarThresholds.__init__(self, sourceObject)
        IAgCrdnConditionSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConditionSetScalarThresholds._private_init(self, pUnk)
        IAgCrdnConditionSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConditionSetScalarThresholds._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSetScalarThresholds._get_property(self, attrname)
        if IAgCrdnConditionSet._get_property(self, attrname) is not None: found_prop = IAgCrdnConditionSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConditionSetScalarThresholds.')
        
agcls.AgClassCatalog.add_catalog_entry('{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}', AgCrdnConditionSetScalarThresholds)
__all__.append('AgCrdnConditionSetScalarThresholds')


class AgCrdnConverge(IAgCrdnConverge, IAgCrdn):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnConverge.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConverge._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConverge._get_property(self, attrname) is not None: found_prop = IAgCrdnConverge._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConverge.')
        
agcls.AgClassCatalog.add_catalog_entry('{6A13D679-1970-43C2-8D4F-174B08AB04DC}', AgCrdnConverge)
__all__.append('AgCrdnConverge')


class AgCrdnConvergeBasic(IAgCrdnConvergeBasic, IAgCrdnConverge, IAgCrdn):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    def __init__(self, sourceObject=None):
        IAgCrdnConvergeBasic.__init__(self, sourceObject)
        IAgCrdnConverge.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnConvergeBasic._private_init(self, pUnk)
        IAgCrdnConverge._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnConvergeBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnConvergeBasic._get_property(self, attrname)
        if IAgCrdnConverge._get_property(self, attrname) is not None: found_prop = IAgCrdnConverge._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnConvergeBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{808F19C3-0E31-4C89-94C8-BBE01E067DFF}', AgCrdnConvergeBasic)
__all__.append('AgCrdnConvergeBasic')


class AgCrdnDerivative(IAgCrdnDerivative, IAgCrdn):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnDerivative.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnDerivative._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivative._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnDerivative.')
        
agcls.AgClassCatalog.add_catalog_entry('{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}', AgCrdnDerivative)
__all__.append('AgCrdnDerivative')


class AgCrdnDerivativeBasic(IAgCrdnDerivativeBasic, IAgCrdnDerivative, IAgCrdn):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    def __init__(self, sourceObject=None):
        IAgCrdnDerivativeBasic.__init__(self, sourceObject)
        IAgCrdnDerivative.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnDerivativeBasic._private_init(self, pUnk)
        IAgCrdnDerivative._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnDerivativeBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivativeBasic._get_property(self, attrname)
        if IAgCrdnDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnDerivative._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnDerivativeBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{3CD084C3-0045-4452-9793-AE8DF4073433}', AgCrdnDerivativeBasic)
__all__.append('AgCrdnDerivativeBasic')


class AgCrdnEvent(IAgCrdnEvent, IAgCrdn):
    """Defines an event (time instant)."""
    def __init__(self, sourceObject=None):
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEvent.')
        
agcls.AgClassCatalog.add_catalog_entry('{A4B75B25-5DAE-4AEC-86EF-512F5E031766}', AgCrdnEvent)
__all__.append('AgCrdnEvent')


class AgCrdnEventArray(IAgCrdnEventArray, IAgCrdn):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArray.')
        
agcls.AgClassCatalog.add_catalog_entry('{F5C87B1A-D519-4A01-8649-AA7560CD503A}', AgCrdnEventArray)
__all__.append('AgCrdnEventArray')


class AgCrdnEventArrayConditionCrossings(IAgCrdnEventArrayConditionCrossings, IAgCrdnEventArray, IAgCrdn):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayConditionCrossings.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayConditionCrossings._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayConditionCrossings._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayConditionCrossings._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayConditionCrossings.')
        
agcls.AgClassCatalog.add_catalog_entry('{B6FBC501-3521-4AE3-AFD8-4971F089D14F}', AgCrdnEventArrayConditionCrossings)
__all__.append('AgCrdnEventArrayConditionCrossings')


class AgCrdnEventArrayExtrema(IAgCrdnEventArrayExtrema, IAgCrdnEventArray, IAgCrdn):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayExtrema.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayExtrema._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayExtrema._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayExtrema._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayExtrema.')
        
agcls.AgClassCatalog.add_catalog_entry('{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}', AgCrdnEventArrayExtrema)
__all__.append('AgCrdnEventArrayExtrema')


class AgCrdnEventArrayFactory(IAgCrdnEventArrayFactory):
    """The factory creates event arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}', AgCrdnEventArrayFactory)
__all__.append('AgCrdnEventArrayFactory')


class AgCrdnEventArrayFiltered(IAgCrdnEventArrayFiltered, IAgCrdnEventArray, IAgCrdn):
    """Defined by filtering times from original time array according to specified filtering method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFiltered.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayFiltered._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFiltered._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFiltered._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayFiltered.')
        
agcls.AgClassCatalog.add_catalog_entry('{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}', AgCrdnEventArrayFiltered)
__all__.append('AgCrdnEventArrayFiltered')


class AgCrdnEventArrayFixedStep(IAgCrdnEventArrayFixedStep, IAgCrdnEventArray, IAgCrdn):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFixedStep.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayFixedStep._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFixedStep._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayFixedStep.')
        
agcls.AgClassCatalog.add_catalog_entry('{CDA379CC-7511-496E-874E-14E10F3E2B1A}', AgCrdnEventArrayFixedStep)
__all__.append('AgCrdnEventArrayFixedStep')


class AgCrdnEventArrayFixedTimes(IAgCrdnEventArrayFixedTimes, IAgCrdnEventArray, IAgCrdn):
    """Array defined by time ordered instants each explicitly specified."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayFixedTimes.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayFixedTimes._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayFixedTimes._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayFixedTimes._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayFixedTimes.')
        
agcls.AgClassCatalog.add_catalog_entry('{EA73AECA-23AB-4DA1-B297-E80E19C55C15}', AgCrdnEventArrayFixedTimes)
__all__.append('AgCrdnEventArrayFixedTimes')


class AgCrdnEventArrayMerged(IAgCrdnEventArrayMerged, IAgCrdnEventArray, IAgCrdn):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayMerged.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayMerged._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayMerged._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayMerged._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayMerged.')
        
agcls.AgClassCatalog.add_catalog_entry('{44FBC83E-D466-425F-ADF5-2003D754F935}', AgCrdnEventArrayMerged)
__all__.append('AgCrdnEventArrayMerged')


class AgCrdnEventArraySignaled(IAgCrdnEventArraySignaled, IAgCrdnEventArray, IAgCrdn):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArraySignaled.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArraySignaled._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArraySignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArraySignaled._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArraySignaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}', AgCrdnEventArraySignaled)
__all__.append('AgCrdnEventArraySignaled')


class AgCrdnEventArrayStartStopTimes(IAgCrdnEventArrayStartStopTimes, IAgCrdnEventArray, IAgCrdn):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventArrayStartStopTimes.__init__(self, sourceObject)
        IAgCrdnEventArray.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventArrayStartStopTimes._private_init(self, pUnk)
        IAgCrdnEventArray._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventArrayStartStopTimes._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArrayStartStopTimes._get_property(self, attrname)
        if IAgCrdnEventArray._get_property(self, attrname) is not None: found_prop = IAgCrdnEventArray._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventArrayStartStopTimes.')
        
agcls.AgClassCatalog.add_catalog_entry('{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}', AgCrdnEventArrayStartStopTimes)
__all__.append('AgCrdnEventArrayStartStopTimes')


class AgCrdnEventEpoch(IAgCrdnEventEpoch, IAgCrdnEvent, IAgCrdn):
    """Event set at specified date/time."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventEpoch.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventEpoch._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnEventEpoch._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventEpoch.')
        
agcls.AgClassCatalog.add_catalog_entry('{230426D4-438A-4B6E-A9D2-5393F7F87238}', AgCrdnEventEpoch)
__all__.append('AgCrdnEventEpoch')


class AgCrdnEventExtremum(IAgCrdnEventExtremum, IAgCrdnEvent, IAgCrdn):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventExtremum.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventExtremum._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventExtremum._get_property(self, attrname) is not None: found_prop = IAgCrdnEventExtremum._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventExtremum.')
        
agcls.AgClassCatalog.add_catalog_entry('{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}', AgCrdnEventExtremum)
__all__.append('AgCrdnEventExtremum')


class AgCrdnEventFactory(IAgCrdnEventFactory):
    """The factory creates events."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}', AgCrdnEventFactory)
__all__.append('AgCrdnEventFactory')


class AgCrdnEventInterval(IAgCrdnEventInterval, IAgCrdn):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventInterval.')
        
agcls.AgClassCatalog.add_catalog_entry('{2CDA6DDC-7412-441A-8F94-0671FD57D16A}', AgCrdnEventInterval)
__all__.append('AgCrdnEventInterval')


class AgCrdnEventIntervalBetweenTimeInstants(IAgCrdnEventIntervalBetweenTimeInstants, IAgCrdnEventInterval, IAgCrdn):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalBetweenTimeInstants._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalBetweenTimeInstants._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalBetweenTimeInstants._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalBetweenTimeInstants.')
        
agcls.AgClassCatalog.add_catalog_entry('{E84D9CAE-E919-4B84-99D7-553CCB97739C}', AgCrdnEventIntervalBetweenTimeInstants)
__all__.append('AgCrdnEventIntervalBetweenTimeInstants')


class AgCrdnEventIntervalCollection(IAgCrdnEventIntervalCollection, IAgCrdn):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollection._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{892BFFEB-D366-49D5-8220-50AC5E4529A1}', AgCrdnEventIntervalCollection)
__all__.append('AgCrdnEventIntervalCollection')


class AgCrdnEventIntervalCollectionCondition(IAgCrdnEventIntervalCollectionCondition, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionCondition.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionCondition._private_init(self, pUnk)
        IAgCrdnEventIntervalCollection._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionCondition._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionCondition.')
        
agcls.AgClassCatalog.add_catalog_entry('{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}', AgCrdnEventIntervalCollectionCondition)
__all__.append('AgCrdnEventIntervalCollectionCondition')


class AgCrdnEventIntervalCollectionFactory(IAgCrdnEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{C76F8390-6619-47D5-9D33-DD1FBBF19B63}', AgCrdnEventIntervalCollectionFactory)
__all__.append('AgCrdnEventIntervalCollectionFactory')


class AgCrdnEventIntervalCollectionLighting(IAgCrdnEventIntervalCollectionLighting, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionLighting.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionLighting._private_init(self, pUnk)
        IAgCrdnEventIntervalCollection._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionLighting._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionLighting._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionLighting.')
        
agcls.AgClassCatalog.add_catalog_entry('{5457BFBA-3076-4250-B0E0-81FA79D58F19}', AgCrdnEventIntervalCollectionLighting)
__all__.append('AgCrdnEventIntervalCollectionLighting')


class AgCrdnEventIntervalCollectionSignaled(IAgCrdnEventIntervalCollectionSignaled, IAgCrdnEventIntervalCollection, IAgCrdn):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalCollectionSignaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalCollection.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalCollectionSignaled._private_init(self, pUnk)
        IAgCrdnEventIntervalCollection._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalCollectionSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollectionSignaled._get_property(self, attrname)
        if IAgCrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalCollection._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalCollectionSignaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{D1ED3869-B0E3-40F6-967A-C539C5D5D630}', AgCrdnEventIntervalCollectionSignaled)
__all__.append('AgCrdnEventIntervalCollectionSignaled')


class AgCrdnEventIntervalFactory(IAgCrdnEventIntervalFactory):
    """The factory creates event intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{D5D195D8-DE6D-4926-B743-556B08A827C8}', AgCrdnEventIntervalFactory)
__all__.append('AgCrdnEventIntervalFactory')


class AgCrdnEventIntervalFixed(IAgCrdnEventIntervalFixed, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFixed.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalFixed._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFixed._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalFixed.')
        
agcls.AgClassCatalog.add_catalog_entry('{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}', AgCrdnEventIntervalFixed)
__all__.append('AgCrdnEventIntervalFixed')


class AgCrdnEventIntervalFixedDuration(IAgCrdnEventIntervalFixedDuration, IAgCrdnEventInterval, IAgCrdn):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFixedDuration.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalFixedDuration._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFixedDuration._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFixedDuration._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalFixedDuration.')
        
agcls.AgClassCatalog.add_catalog_entry('{84316F31-A3DB-4DF3-B8E3-352673D4E251}', AgCrdnEventIntervalFixedDuration)
__all__.append('AgCrdnEventIntervalFixedDuration')


class AgCrdnEventIntervalFromIntervalList(IAgCrdnEventIntervalFromIntervalList, IAgCrdnEventInterval, IAgCrdn):
    """Interval created from specified interval list by using one of several selection methods."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalFromIntervalList.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalFromIntervalList._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalFromIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalFromIntervalList._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalFromIntervalList.')
        
agcls.AgClassCatalog.add_catalog_entry('{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}', AgCrdnEventIntervalFromIntervalList)
__all__.append('AgCrdnEventIntervalFromIntervalList')


class AgCrdnEventIntervalList(IAgCrdnEventIntervalList, IAgCrdn):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalList.')
        
agcls.AgClassCatalog.add_catalog_entry('{050E0A6D-9960-4470-9803-AF58B43FD747}', AgCrdnEventIntervalList)
__all__.append('AgCrdnEventIntervalList')


class AgCrdnEventIntervalListCondition(IAgCrdnEventIntervalListCondition, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListCondition.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListCondition._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListCondition._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListCondition.')
        
agcls.AgClassCatalog.add_catalog_entry('{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}', AgCrdnEventIntervalListCondition)
__all__.append('AgCrdnEventIntervalListCondition')


class AgCrdnEventIntervalListFactory(IAgCrdnEventIntervalListFactory):
    """The factory creates event interval lists."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}', AgCrdnEventIntervalListFactory)
__all__.append('AgCrdnEventIntervalListFactory')


class AgCrdnEventIntervalListFile(IAgCrdnEventIntervalListFile, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFile.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListFile._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFile._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFile._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListFile.')
        
agcls.AgClassCatalog.add_catalog_entry('{5A3BC6C1-559F-448D-946E-3D608C0C59B4}', AgCrdnEventIntervalListFile)
__all__.append('AgCrdnEventIntervalListFile')


class AgCrdnEventIntervalListFiltered(IAgCrdnEventIntervalListFiltered, IAgCrdnEventIntervalList, IAgCrdn):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFiltered.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListFiltered._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFiltered._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFiltered._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListFiltered.')
        
agcls.AgClassCatalog.add_catalog_entry('{7123DA29-BECE-4032-9A81-77CDA69C5B13}', AgCrdnEventIntervalListFiltered)
__all__.append('AgCrdnEventIntervalListFiltered')


class AgCrdnEventIntervalListFixed(IAgCrdnEventIntervalListFixed, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListFixed.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListFixed._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListFixed._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListFixed.')
        
agcls.AgClassCatalog.add_catalog_entry('{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}', AgCrdnEventIntervalListFixed)
__all__.append('AgCrdnEventIntervalListFixed')


class AgCrdnEventIntervalListMerged(IAgCrdnEventIntervalListMerged, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListMerged.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListMerged._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListMerged._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListMerged._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListMerged.')
        
agcls.AgClassCatalog.add_catalog_entry('{115C7064-1624-4928-B401-2C2B8DA2A2DC}', AgCrdnEventIntervalListMerged)
__all__.append('AgCrdnEventIntervalListMerged')


class AgCrdnEventIntervalListScaled(IAgCrdnEventIntervalListScaled, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListScaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListScaled._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListScaled._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListScaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}', AgCrdnEventIntervalListScaled)
__all__.append('AgCrdnEventIntervalListScaled')


class AgCrdnEventIntervalListSignaled(IAgCrdnEventIntervalListSignaled, IAgCrdnEventIntervalList, IAgCrdn):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListSignaled.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListSignaled._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListSignaled._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListSignaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}', AgCrdnEventIntervalListSignaled)
__all__.append('AgCrdnEventIntervalListSignaled')


class AgCrdnEventIntervalListTimeOffset(IAgCrdnEventIntervalListTimeOffset, IAgCrdnEventIntervalList, IAgCrdn):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalListTimeOffset.__init__(self, sourceObject)
        IAgCrdnEventIntervalList.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalListTimeOffset._private_init(self, pUnk)
        IAgCrdnEventIntervalList._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalListTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalListTimeOffset._get_property(self, attrname)
        if IAgCrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalList._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalListTimeOffset.')
        
agcls.AgClassCatalog.add_catalog_entry('{BA2C1495-B20E-477A-A995-8B5B879DE84C}', AgCrdnEventIntervalListTimeOffset)
__all__.append('AgCrdnEventIntervalListTimeOffset')


class AgCrdnEventIntervalScaled(IAgCrdnEventIntervalScaled, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalScaled.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalScaled._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalScaled._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalScaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}', AgCrdnEventIntervalScaled)
__all__.append('AgCrdnEventIntervalScaled')


class AgCrdnEventIntervalSignaled(IAgCrdnEventIntervalSignaled, IAgCrdnEventInterval, IAgCrdn):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalSignaled.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalSignaled._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalSignaled._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalSignaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}', AgCrdnEventIntervalSignaled)
__all__.append('AgCrdnEventIntervalSignaled')


class AgCrdnEventIntervalSmartInterval(IAgCrdnEventIntervalSmartInterval, IAgCrdnEventInterval, IAgCrdn):
    """A smart interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalSmartInterval.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalSmartInterval._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalSmartInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalSmartInterval._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalSmartInterval.')
        
agcls.AgClassCatalog.add_catalog_entry('{F3D4E2AC-3845-4719-AD57-EE0C715A584D}', AgCrdnEventIntervalSmartInterval)
__all__.append('AgCrdnEventIntervalSmartInterval')


class AgCrdnEventIntervalTimeOffset(IAgCrdnEventIntervalTimeOffset, IAgCrdnEventInterval, IAgCrdn):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventIntervalTimeOffset.__init__(self, sourceObject)
        IAgCrdnEventInterval.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventIntervalTimeOffset._private_init(self, pUnk)
        IAgCrdnEventInterval._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventIntervalTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventIntervalTimeOffset._get_property(self, attrname)
        if IAgCrdnEventInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnEventInterval._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventIntervalTimeOffset.')
        
agcls.AgClassCatalog.add_catalog_entry('{DE89BB00-5A89-4DA4-8730-CA2C3495A867}', AgCrdnEventIntervalTimeOffset)
__all__.append('AgCrdnEventIntervalTimeOffset')


class AgCrdnEventSignaled(IAgCrdnEventSignaled, IAgCrdnEvent, IAgCrdn):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventSignaled.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventSignaled._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventSignaled._get_property(self, attrname) is not None: found_prop = IAgCrdnEventSignaled._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventSignaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}', AgCrdnEventSignaled)
__all__.append('AgCrdnEventSignaled')


class AgCrdnEventSmartEpoch(IAgCrdnEventSmartEpoch, IAgCrdnEvent, IAgCrdn):
    """A smart epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventSmartEpoch.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventSmartEpoch._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventSmartEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnEventSmartEpoch._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventSmartEpoch.')
        
agcls.AgClassCatalog.add_catalog_entry('{F722C253-92DA-4956-983B-B80AB469F192}', AgCrdnEventSmartEpoch)
__all__.append('AgCrdnEventSmartEpoch')


class AgCrdnEventStartStopTime(IAgCrdnEventStartStopTime, IAgCrdnEvent, IAgCrdn):
    """Event is either start or stop time selected from a reference interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventStartStopTime.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventStartStopTime._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventStartStopTime._get_property(self, attrname) is not None: found_prop = IAgCrdnEventStartStopTime._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventStartStopTime.')
        
agcls.AgClassCatalog.add_catalog_entry('{F0429607-A51C-495C-9902-585429D40D10}', AgCrdnEventStartStopTime)
__all__.append('AgCrdnEventStartStopTime')


class AgCrdnEventTimeOffset(IAgCrdnEventTimeOffset, IAgCrdnEvent, IAgCrdn):
    """Event at fixed offset from specified reference event."""
    def __init__(self, sourceObject=None):
        IAgCrdnEventTimeOffset.__init__(self, sourceObject)
        IAgCrdnEvent.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnEventTimeOffset._private_init(self, pUnk)
        IAgCrdnEvent._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnEventTimeOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnEventTimeOffset._get_property(self, attrname)
        if IAgCrdnEvent._get_property(self, attrname) is not None: found_prop = IAgCrdnEvent._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnEventTimeOffset.')
        
agcls.AgClassCatalog.add_catalog_entry('{EE2C89C8-C148-4044-B0BE-BF137D4B876B}', AgCrdnEventTimeOffset)
__all__.append('AgCrdnEventTimeOffset')


class AgCrdnFirstIntervalsFilter(IAgCrdnFirstIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects a portion of first intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnFirstIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnFirstIntervalsFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnFirstIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnFirstIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnFirstIntervalsFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{9A044590-5063-4331-9FC2-621221CF7EA9}', AgCrdnFirstIntervalsFilter)
__all__.append('AgCrdnFirstIntervalsFilter')


class AgCrdnGapsFilter(IAgCrdnGapsFilter, IAgCrdnPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnGapsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGapsFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGapsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnGapsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGapsFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{C54D3817-6B48-4436-8E1D-323A38DC2BC0}', AgCrdnGapsFilter)
__all__.append('AgCrdnGapsFilter')


class AgCrdnIntegral(IAgCrdnIntegral, IAgCrdn):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntegral.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntegral._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegral._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntegral.')
        
agcls.AgClassCatalog.add_catalog_entry('{9C6B1D39-FC48-475A-A888-DA9D459C1906}', AgCrdnIntegral)
__all__.append('AgCrdnIntegral')


class AgCrdnIntegralBasic(IAgCrdnIntegralBasic, IAgCrdnIntegral, IAgCrdn):
    """Integral definition determines how scalar calculation is numerically integrated."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntegralBasic.__init__(self, sourceObject)
        IAgCrdnIntegral.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntegralBasic._private_init(self, pUnk)
        IAgCrdnIntegral._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntegralBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegralBasic._get_property(self, attrname)
        if IAgCrdnIntegral._get_property(self, attrname) is not None: found_prop = IAgCrdnIntegral._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntegralBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}', AgCrdnIntegralBasic)
__all__.append('AgCrdnIntegralBasic')


class AgCrdnInterp(IAgCrdnInterp, IAgCrdn):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterp.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnInterp._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterp._get_property(self, attrname) is not None: found_prop = IAgCrdnInterp._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnInterp.')
        
agcls.AgClassCatalog.add_catalog_entry('{F73B3675-6FD4-4050-9566-797DCD695107}', AgCrdnInterp)
__all__.append('AgCrdnInterp')


class AgCrdnInterpBasic(IAgCrdnInterpBasic, IAgCrdnInterp, IAgCrdn):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterpBasic.__init__(self, sourceObject)
        IAgCrdnInterp.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnInterpBasic._private_init(self, pUnk)
        IAgCrdnInterp._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterpBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnInterpBasic._get_property(self, attrname)
        if IAgCrdnInterp._get_property(self, attrname) is not None: found_prop = IAgCrdnInterp._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnInterpBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{AB05143F-6997-4F40-BE86-DCF4D723F31E}', AgCrdnInterpBasic)
__all__.append('AgCrdnInterpBasic')


class AgCrdnIntervalsFilter(IAgCrdnIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects intervals of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntervalsFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntervalsFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}', AgCrdnIntervalsFilter)
__all__.append('AgCrdnIntervalsFilter')


class AgCrdnLastIntervalsFilter(IAgCrdnLastIntervalsFilter, IAgCrdnPruneFilter):
    """The filter selects a portion of last intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnLastIntervalsFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnLastIntervalsFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLastIntervalsFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnLastIntervalsFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnLastIntervalsFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}', AgCrdnLastIntervalsFilter)
__all__.append('AgCrdnLastIntervalsFilter')


class AgCrdnParameterSet(IAgCrdnParameterSet, IAgCrdn):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSet.')
        
agcls.AgClassCatalog.add_catalog_entry('{CD1D82FC-08BF-4854-9295-F90AC87FAE68}', AgCrdnParameterSet)
__all__.append('AgCrdnParameterSet')


class AgCrdnParameterSetAttitude(IAgCrdnParameterSetAttitude, IAgCrdnParameterSet, IAgCrdn):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetAttitude.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetAttitude._private_init(self, pUnk)
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetAttitude._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetAttitude._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetAttitude.')
        
agcls.AgClassCatalog.add_catalog_entry('{7082CB04-052B-46A2-A051-4FF52D0260B0}', AgCrdnParameterSetAttitude)
__all__.append('AgCrdnParameterSetAttitude')


class AgCrdnParameterSetFactory(IAgCrdnParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{FF399336-197C-480B-98AC-3F07E76FF3BC}', AgCrdnParameterSetFactory)
__all__.append('AgCrdnParameterSetFactory')


class AgCrdnParameterSetGroundTrajectory(IAgCrdnParameterSetGroundTrajectory, IAgCrdnParameterSet, IAgCrdn):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetGroundTrajectory.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetGroundTrajectory._private_init(self, pUnk)
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetGroundTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetGroundTrajectory._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetGroundTrajectory.')
        
agcls.AgClassCatalog.add_catalog_entry('{B1972E17-F000-4BFF-80A3-216A91D0E2B1}', AgCrdnParameterSetGroundTrajectory)
__all__.append('AgCrdnParameterSetGroundTrajectory')


class AgCrdnParameterSetOrbit(IAgCrdnParameterSetOrbit, IAgCrdnParameterSet, IAgCrdn):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetOrbit.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetOrbit._private_init(self, pUnk)
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetOrbit._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetOrbit._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetOrbit.')
        
agcls.AgClassCatalog.add_catalog_entry('{BF4A60A0-68E5-4000-8843-DD7FD76813A9}', AgCrdnParameterSetOrbit)
__all__.append('AgCrdnParameterSetOrbit')


class AgCrdnParameterSetTrajectory(IAgCrdnParameterSetTrajectory, IAgCrdnParameterSet, IAgCrdn):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetTrajectory.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetTrajectory._private_init(self, pUnk)
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetTrajectory._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetTrajectory.')
        
agcls.AgClassCatalog.add_catalog_entry('{542072ED-4073-4F91-8EC8-45F7CC401ED7}', AgCrdnParameterSetTrajectory)
__all__.append('AgCrdnParameterSetTrajectory')


class AgCrdnParameterSetVector(IAgCrdnParameterSetVector, IAgCrdnParameterSet, IAgCrdn):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnParameterSetVector.__init__(self, sourceObject)
        IAgCrdnParameterSet.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnParameterSetVector._private_init(self, pUnk)
        IAgCrdnParameterSet._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnParameterSetVector._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSetVector._get_property(self, attrname)
        if IAgCrdnParameterSet._get_property(self, attrname) is not None: found_prop = IAgCrdnParameterSet._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnParameterSetVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{DC7B40D5-7091-4A24-A698-436D2A274DC8}', AgCrdnParameterSetVector)
__all__.append('AgCrdnParameterSetVector')


class AgCrdnPruneFilter(IAgCrdnPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPruneFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{E08D63E9-CC8E-41F8-B3C5-0D062425C025}', AgCrdnPruneFilter)
__all__.append('AgCrdnPruneFilter')


class AgCrdnPruneFilterFactory(IAgCrdnPruneFilterFactory):
    """The factory creates pruning filters."""
    def __init__(self, sourceObject=None):
        IAgCrdnPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPruneFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPruneFilterFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPruneFilterFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{954284C2-3544-4888-9A56-759AA8C7E1F7}', AgCrdnPruneFilterFactory)
__all__.append('AgCrdnPruneFilterFactory')


class AgCrdnRelativeSatisfactionConditionFilter(IAgCrdnRelativeSatisfactionConditionFilter, IAgCrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    def __init__(self, sourceObject=None):
        IAgCrdnRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnRelativeSatisfactionConditionFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnRelativeSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnRelativeSatisfactionConditionFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnRelativeSatisfactionConditionFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{93A5C2C0-AABA-4DB3-9359-100604D0BA02}', AgCrdnRelativeSatisfactionConditionFilter)
__all__.append('AgCrdnRelativeSatisfactionConditionFilter')


class AgCrdnSampling(IAgCrdnSampling, IAgCrdn):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnSampling.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSampling._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSampling._get_property(self, attrname) is not None: found_prop = IAgCrdnSampling._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSampling.')
        
agcls.AgClassCatalog.add_catalog_entry('{17FC40E9-EF68-4FFD-8A16-071054486F6A}', AgCrdnSampling)
__all__.append('AgCrdnSampling')


class AgCrdnSamplingBasic(IAgCrdnSamplingBasic, IAgCrdnSampling, IAgCrdn):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingBasic.__init__(self, sourceObject)
        IAgCrdnSampling.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingBasic._private_init(self, pUnk)
        IAgCrdnSampling._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingBasic._get_property(self, attrname)
        if IAgCrdnSampling._get_property(self, attrname) is not None: found_prop = IAgCrdnSampling._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{CB786C50-8D9C-4333-A985-FFD2ADD20206}', AgCrdnSamplingBasic)
__all__.append('AgCrdnSamplingBasic')


class AgCrdnSamplingCurvatureTolerance(IAgCrdnSamplingCurvatureTolerance, IAgCrdnSamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingCurvatureTolerance.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingCurvatureTolerance._private_init(self, pUnk)
        IAgCrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingCurvatureTolerance._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingCurvatureTolerance._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingCurvatureTolerance.')
        
agcls.AgClassCatalog.add_catalog_entry('{EF49B404-27D2-4AC5-BB5E-EA223A237922}', AgCrdnSamplingCurvatureTolerance)
__all__.append('AgCrdnSamplingCurvatureTolerance')


class AgCrdnSamplingFixedStep(IAgCrdnSamplingFixedStep, IAgCrdnSamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingFixedStep.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingFixedStep._private_init(self, pUnk)
        IAgCrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingFixedStep._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingFixedStep.')
        
agcls.AgClassCatalog.add_catalog_entry('{9B7D520F-7835-4E84-BCA4-D748C73CB609}', AgCrdnSamplingFixedStep)
__all__.append('AgCrdnSamplingFixedStep')


class AgCrdnSamplingMethod(IAgCrdnSamplingMethod):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingMethod.')
        
agcls.AgClassCatalog.add_catalog_entry('{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}', AgCrdnSamplingMethod)
__all__.append('AgCrdnSamplingMethod')


class AgCrdnSamplingMethodFactory(IAgCrdnSamplingMethodFactory):
    """The factory creates sampling method components."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingMethodFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingMethodFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethodFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingMethodFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}', AgCrdnSamplingMethodFactory)
__all__.append('AgCrdnSamplingMethodFactory')


class AgCrdnSamplingRelativeTolerance(IAgCrdnSamplingRelativeTolerance, IAgCrdnSamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    def __init__(self, sourceObject=None):
        IAgCrdnSamplingRelativeTolerance.__init__(self, sourceObject)
        IAgCrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSamplingRelativeTolerance._private_init(self, pUnk)
        IAgCrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSamplingRelativeTolerance._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingRelativeTolerance._get_property(self, attrname)
        if IAgCrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSamplingRelativeTolerance.')
        
agcls.AgClassCatalog.add_catalog_entry('{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}', AgCrdnSamplingRelativeTolerance)
__all__.append('AgCrdnSamplingRelativeTolerance')


class AgCrdnSatisfactionConditionFilter(IAgCrdnSatisfactionConditionFilter, IAgCrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    def __init__(self, sourceObject=None):
        IAgCrdnSatisfactionConditionFilter.__init__(self, sourceObject)
        IAgCrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSatisfactionConditionFilter._private_init(self, pUnk)
        IAgCrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnSatisfactionConditionFilter._get_property(self, attrname)
        if IAgCrdnPruneFilter._get_property(self, attrname) is not None: found_prop = IAgCrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSatisfactionConditionFilter.')
        
agcls.AgClassCatalog.add_catalog_entry('{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}', AgCrdnSatisfactionConditionFilter)
__all__.append('AgCrdnSatisfactionConditionFilter')


class AgCrdnSignalDelay(IAgCrdnSignalDelay, IAgCrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnSignalDelay.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSignalDelay._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSignalDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelay._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSignalDelay.')
        
agcls.AgClassCatalog.add_catalog_entry('{71744841-D938-44BE-8336-2B54F06CF443}', AgCrdnSignalDelay)
__all__.append('AgCrdnSignalDelay')


class AgCrdnSignalDelayBasic(IAgCrdnSignalDelayBasic, IAgCrdnSignalDelay, IAgCrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        IAgCrdnSignalDelayBasic.__init__(self, sourceObject)
        IAgCrdnSignalDelay.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSignalDelayBasic._private_init(self, pUnk)
        IAgCrdnSignalDelay._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSignalDelayBasic._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelayBasic._get_property(self, attrname)
        if IAgCrdnSignalDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnSignalDelay._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSignalDelayBasic.')
        
agcls.AgClassCatalog.add_catalog_entry('{0763A330-475A-4E4E-AB26-8943A8CC1C92}', AgCrdnSignalDelayBasic)
__all__.append('AgCrdnSignalDelayBasic')


class AgCrdnVolumeCalcFactory(IAgCrdnVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{80956ae5-fb8c-4ce4-930f-56b362d07cec}', AgCrdnVolumeCalcFactory)
__all__.append('AgCrdnVolumeCalcFactory')


class AgCrdnVolumeFactory(IAgCrdnVolumeFactory):
    """The factory is used to create instances of volumes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{F9497BD8-A985-4054-8ADE-9042DE66125F}', AgCrdnVolumeFactory)
__all__.append('AgCrdnVolumeFactory')


class AgCrdnVolumeGridFactory(IAgCrdnVolumeGridFactory):
    """The factory is used to create instances of volume grids."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{F6359611-FB48-4B00-9017-01A4BE2B76E5}', AgCrdnVolumeGridFactory)
__all__.append('AgCrdnVolumeGridFactory')


class AgCrdnGridCoordinateDefinition(IAgCrdnGridCoordinateDefinition):
    """Defines a set of coordinate values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGridCoordinateDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridCoordinateDefinition._get_property(self, attrname) is not None: found_prop = IAgCrdnGridCoordinateDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGridCoordinateDefinition.')
        
agcls.AgClassCatalog.add_catalog_entry('{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}', AgCrdnGridCoordinateDefinition)
__all__.append('AgCrdnGridCoordinateDefinition')


class AgCrdnGridValuesCustom(IAgCrdnGridValuesCustom, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesCustom.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGridValuesCustom._private_init(self, pUnk)
        IAgCrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesCustom._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesCustom._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGridValuesCustom.')
        
agcls.AgClassCatalog.add_catalog_entry('{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}', AgCrdnGridValuesCustom)
__all__.append('AgCrdnGridValuesCustom')


class AgCrdnGridValuesFixedNumberOfSteps(IAgCrdnGridValuesFixedNumberOfSteps, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGridValuesFixedNumberOfSteps._private_init(self, pUnk)
        IAgCrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesFixedNumberOfSteps._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesFixedNumberOfSteps._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGridValuesFixedNumberOfSteps.')
        
agcls.AgClassCatalog.add_catalog_entry('{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}', AgCrdnGridValuesFixedNumberOfSteps)
__all__.append('AgCrdnGridValuesFixedNumberOfSteps')


class AgCrdnGridValuesFixedStep(IAgCrdnGridValuesFixedStep, IAgCrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesFixedStep.__init__(self, sourceObject)
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGridValuesFixedStep._private_init(self, pUnk)
        IAgCrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesFixedStep._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesFixedStep._get_property(self, attrname)
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGridValuesFixedStep.')
        
agcls.AgClassCatalog.add_catalog_entry('{0942EA2D-33DE-41B5-98BE-E53E659EC81D}', AgCrdnGridValuesFixedStep)
__all__.append('AgCrdnGridValuesFixedStep')


class AgCrdnGridValuesMethod(IAgCrdnGridValuesMethod):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        IAgCrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = IAgCrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGridValuesMethod.')
        
agcls.AgClassCatalog.add_catalog_entry('{D1D242BF-73F3-443A-AB46-64EAA02C5F37}', AgCrdnGridValuesMethod)
__all__.append('AgCrdnGridValuesMethod')


class AgCrdnLightTimeDelay(IAgCrdnLightTimeDelay):
    """Manage Light Time Delay options.."""
    def __init__(self, sourceObject=None):
        IAgCrdnLightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnLightTimeDelay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLightTimeDelay._get_property(self, attrname) is not None: found_prop = IAgCrdnLightTimeDelay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnLightTimeDelay.')
        
agcls.AgClassCatalog.add_catalog_entry('{085E2242-4392-4F35-857E-A46A72EADE70}', AgCrdnLightTimeDelay)
__all__.append('AgCrdnLightTimeDelay')


class AgCrdnVolume(IAgCrdnVolume, IAgCrdn):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolume.')
        
agcls.AgClassCatalog.add_catalog_entry('{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}', AgCrdnVolume)
__all__.append('AgCrdnVolume')


class AgCrdnVolumeCalc(IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalc.')
        
agcls.AgClassCatalog.add_catalog_entry('{d014bfd1-130d-4dc4-a841-76c75bc08f9c}', AgCrdnVolumeCalc)
__all__.append('AgCrdnVolumeCalc')


class AgCrdnVolumeCalcAltitude(IAgCrdnVolumeCalcAltitude, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc altitude interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcAltitude.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcAltitude._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcAltitude._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcAltitude._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcAltitude.')
        
agcls.AgClassCatalog.add_catalog_entry('{4e3c369c-c189-48ce-8e93-f0c6478f0abe}', AgCrdnVolumeCalcAltitude)
__all__.append('AgCrdnVolumeCalcAltitude')


class AgCrdnVolumeCalcAngleOffVector(IAgCrdnVolumeCalcAngleOffVector, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc angle off vector interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcAngleOffVector.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcAngleOffVector._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcAngleOffVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcAngleOffVector._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcAngleOffVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}', AgCrdnVolumeCalcAngleOffVector)
__all__.append('AgCrdnVolumeCalcAngleOffVector')


class AgCrdnVolumeCalcConditionSatMetric(IAgCrdnVolumeCalcConditionSatMetric, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc condition satisfaction interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcConditionSatMetric._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcConditionSatMetric._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcConditionSatMetric._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcConditionSatMetric.')
        
agcls.AgClassCatalog.add_catalog_entry('{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}', AgCrdnVolumeCalcConditionSatMetric)
__all__.append('AgCrdnVolumeCalcConditionSatMetric')


class AgCrdnVolumeCalcDelayRange(IAgCrdnVolumeCalcDelayRange, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc propagation delay to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcDelayRange.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcDelayRange._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcDelayRange._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcDelayRange._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcDelayRange.')
        
agcls.AgClassCatalog.add_catalog_entry('{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}', AgCrdnVolumeCalcDelayRange)
__all__.append('AgCrdnVolumeCalcDelayRange')


class AgCrdnVolumeCalcFile(IAgCrdnVolumeCalcFile, IAgCrdnVolumeCalc, IAgCrdn):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFile.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcFile._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFile._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFile._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcFile.')
        
agcls.AgClassCatalog.add_catalog_entry('{188f96c6-9568-4609-9944-dfc5fb7247c5}', AgCrdnVolumeCalcFile)
__all__.append('AgCrdnVolumeCalcFile')


class AgCrdnVolumeCalcFromScalar(IAgCrdnVolumeCalcFromScalar, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc scalar to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcFromScalar.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcFromScalar._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcFromScalar._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcFromScalar._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcFromScalar.')
        
agcls.AgClassCatalog.add_catalog_entry('{73219623-93c0-4c6e-961a-7fae5dfe9234}', AgCrdnVolumeCalcFromScalar)
__all__.append('AgCrdnVolumeCalcFromScalar')


class AgCrdnVolumeCalcRange(IAgCrdnVolumeCalcRange, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc distance to location interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcRange.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcRange._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcRange._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcRange._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcRange.')
        
agcls.AgClassCatalog.add_catalog_entry('{7f1aa95f-e8d6-4faf-925b-98785243ba67}', AgCrdnVolumeCalcRange)
__all__.append('AgCrdnVolumeCalcRange')


class AgCrdnVolumeCalcSolarIntensity(IAgCrdnVolumeCalcSolarIntensity, IAgCrdnVolumeCalc, IAgCrdn):
    """A volume calc solar intensityn interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCalcSolarIntensity.__init__(self, sourceObject)
        IAgCrdnVolumeCalc.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCalcSolarIntensity._private_init(self, pUnk)
        IAgCrdnVolumeCalc._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCalcSolarIntensity._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalcSolarIntensity._get_property(self, attrname)
        if IAgCrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCalc._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCalcSolarIntensity.')
        
agcls.AgClassCatalog.add_catalog_entry('{7796e871-d645-4f65-a3dc-de687b6fbcd5}', AgCrdnVolumeCalcSolarIntensity)
__all__.append('AgCrdnVolumeCalcSolarIntensity')


class AgCrdnVolumeCombined(IAgCrdnVolumeCombined, IAgCrdnVolume, IAgCrdn):
    """A combined volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeCombined.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeCombined._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeCombined._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeCombined._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeCombined.')
        
agcls.AgClassCatalog.add_catalog_entry('{7ECD2E89-B432-47C3-A80F-AF6429E66746}', AgCrdnVolumeCombined)
__all__.append('AgCrdnVolumeCombined')


class AgCrdnVolumeFromCalc(IAgCrdnVolumeFromCalc, IAgCrdnVolume, IAgCrdn):
    """An volume from calc volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromCalc.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeFromCalc._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromCalc._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromCalc._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeFromCalc.')
        
agcls.AgClassCatalog.add_catalog_entry('{0F2AC0BF-4645-4C7F-9660-A894E267FD59}', AgCrdnVolumeFromCalc)
__all__.append('AgCrdnVolumeFromCalc')


class AgCrdnVolumeFromCondition(IAgCrdnVolumeFromCondition, IAgCrdnVolume, IAgCrdn):
    """A volume from conditioninterface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromCondition.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeFromCondition._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromCondition._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromCondition._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeFromCondition.')
        
agcls.AgClassCatalog.add_catalog_entry('{A2546B12-78BF-4F8F-87C2-31BC73DA265B}', AgCrdnVolumeFromCondition)
__all__.append('AgCrdnVolumeFromCondition')


class AgCrdnVolumeFromGrid(IAgCrdnVolumeFromGrid, IAgCrdnVolume, IAgCrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromGrid.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeFromGrid._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromGrid._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeFromGrid.')
        
agcls.AgClassCatalog.add_catalog_entry('{D49FE282-4C05-4097-970C-1282997378E9}', AgCrdnVolumeFromGrid)
__all__.append('AgCrdnVolumeFromGrid')


class AgCrdnVolumeFromTimeSatisfaction(IAgCrdnVolumeFromTimeSatisfaction, IAgCrdnVolume, IAgCrdn):
    """An volume from time satisfaction volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeFromTimeSatisfaction._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeFromTimeSatisfaction._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeFromTimeSatisfaction._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeFromTimeSatisfaction.')
        
agcls.AgClassCatalog.add_catalog_entry('{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}', AgCrdnVolumeFromTimeSatisfaction)
__all__.append('AgCrdnVolumeFromTimeSatisfaction')


class AgCrdnVolumeGrid(IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGrid.')
        
agcls.AgClassCatalog.add_catalog_entry('{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}', AgCrdnVolumeGrid)
__all__.append('AgCrdnVolumeGrid')


class AgCrdnVolumeGridBearingAlt(IAgCrdnVolumeGridBearingAlt, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid bearing alt (Surface Bearing) interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridBearingAlt.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridBearingAlt._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridBearingAlt._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridBearingAlt._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridBearingAlt.')
        
agcls.AgClassCatalog.add_catalog_entry('{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}', AgCrdnVolumeGridBearingAlt)
__all__.append('AgCrdnVolumeGridBearingAlt')


class AgCrdnVolumeGridCartesian(IAgCrdnVolumeGridCartesian, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid Cartesian interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridCartesian.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridCartesian._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridCartesian._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridCartesian._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridCartesian.')
        
agcls.AgClassCatalog.add_catalog_entry('{AF15D0A4-BB42-4762-A761-9BD11DC948D0}', AgCrdnVolumeGridCartesian)
__all__.append('AgCrdnVolumeGridCartesian')


class AgCrdnVolumeGridConstrained(IAgCrdnVolumeGridConstrained, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid constrained interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridConstrained.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridConstrained._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridConstrained._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridConstrained._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridConstrained.')
        
agcls.AgClassCatalog.add_catalog_entry('{253FC52C-5554-4A53-AE3D-624316ECFFFD}', AgCrdnVolumeGridConstrained)
__all__.append('AgCrdnVolumeGridConstrained')


class AgCrdnVolumeGridCylindrical(IAgCrdnVolumeGridCylindrical, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid cylindrical interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridCylindrical.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridCylindrical._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridCylindrical._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridCylindrical._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridCylindrical.')
        
agcls.AgClassCatalog.add_catalog_entry('{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}', AgCrdnVolumeGridCylindrical)
__all__.append('AgCrdnVolumeGridCylindrical')


class AgCrdnVolumeGridLatLonAlt(IAgCrdnVolumeGridLatLonAlt, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridLatLonAlt.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridLatLonAlt._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridLatLonAlt._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridLatLonAlt._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridLatLonAlt.')
        
agcls.AgClassCatalog.add_catalog_entry('{89C10FC4-4031-4B63-9C55-E092DDF3839D}', AgCrdnVolumeGridLatLonAlt)
__all__.append('AgCrdnVolumeGridLatLonAlt')


class AgCrdnVolumeGridResult(IAgCrdnVolumeGridResult):
    """An interafcce that genereates Volume Grid results."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridResult._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}', AgCrdnVolumeGridResult)
__all__.append('AgCrdnVolumeGridResult')


class AgCrdnVolumeGridSpherical(IAgCrdnVolumeGridSpherical, IAgCrdnVolumeGrid, IAgCrdn):
    """A volume grid spherical interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeGridSpherical.__init__(self, sourceObject)
        IAgCrdnVolumeGrid.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeGridSpherical._private_init(self, pUnk)
        IAgCrdnVolumeGrid._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeGridSpherical._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGridSpherical._get_property(self, attrname)
        if IAgCrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeGrid._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeGridSpherical.')
        
agcls.AgClassCatalog.add_catalog_entry('{0DFD2937-3181-4895-AB05-A45FFD744964}', AgCrdnVolumeGridSpherical)
__all__.append('AgCrdnVolumeGridSpherical')


class AgCrdnVolumeInview(IAgCrdnVolumeInview, IAgCrdnVolume, IAgCrdn):
    """An Inview volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeInview.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeInview._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeInview._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeInview._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeInview.')
        
agcls.AgClassCatalog.add_catalog_entry('{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}', AgCrdnVolumeInview)
__all__.append('AgCrdnVolumeInview')


class AgCrdnVolumeLighting(IAgCrdnVolumeLighting, IAgCrdnVolume, IAgCrdn):
    """A lighting volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeLighting.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeLighting._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeLighting._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeLighting._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeLighting.')
        
agcls.AgClassCatalog.add_catalog_entry('{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}', AgCrdnVolumeLighting)
__all__.append('AgCrdnVolumeLighting')


class AgCrdnVolumeOverTime(IAgCrdnVolumeOverTime, IAgCrdnVolume, IAgCrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        IAgCrdnVolumeOverTime.__init__(self, sourceObject)
        IAgCrdnVolume.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVolumeOverTime._private_init(self, pUnk)
        IAgCrdnVolume._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVolumeOverTime._get_property(self, attrname) is not None: found_prop = IAgCrdnVolumeOverTime._get_property(self, attrname)
        if IAgCrdnVolume._get_property(self, attrname) is not None: found_prop = IAgCrdnVolume._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVolumeOverTime.')
        
agcls.AgClassCatalog.add_catalog_entry('{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}', AgCrdnVolumeOverTime)
__all__.append('AgCrdnVolumeOverTime')


class AgCrdnGeneric(IAgCrdn):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnGeneric.')
        
agcls.AgClassCatalog.add_catalog_entry('{2909EDFB-9BE2-4BD2-A678-186C9D136937}', AgCrdnGeneric)
__all__.append('AgCrdnGeneric')


class AgCrdnTypeInfo(IAgCrdnTypeInfo):
    """VGT component info."""
    def __init__(self, sourceObject=None):
        IAgCrdnTypeInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnTypeInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnTypeInfo._get_property(self, attrname) is not None: found_prop = IAgCrdnTypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnTypeInfo.')
        
agcls.AgClassCatalog.add_catalog_entry('{BA26887C-6DFE-4F18-96D8-5694296568D2}', AgCrdnTypeInfo)
__all__.append('AgCrdnTypeInfo')


class AgCrdnInstance(IAgCrdnContext, IAgCrdnInstance):
    """Enables to obtain information about the parent object that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdnContext.__init__(self, sourceObject)
        IAgCrdnInstance.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnContext._private_init(self, pUnk)
        IAgCrdnInstance._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnContext._get_property(self, attrname) is not None: found_prop = IAgCrdnContext._get_property(self, attrname)
        if IAgCrdnInstance._get_property(self, attrname) is not None: found_prop = IAgCrdnInstance._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnInstance.')
        
agcls.AgClassCatalog.add_catalog_entry('{28241775-2044-4AD1-BC1D-D5B345437415}', AgCrdnInstance)
__all__.append('AgCrdnInstance')


class AgCrdnTemplate(IAgCrdnContext, IAgCrdnTemplate):
    """Enables to obtain information about the STK class that owns the VGT component."""
    def __init__(self, sourceObject=None):
        IAgCrdnContext.__init__(self, sourceObject)
        IAgCrdnTemplate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnContext._private_init(self, pUnk)
        IAgCrdnTemplate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnContext._get_property(self, attrname) is not None: found_prop = IAgCrdnContext._get_property(self, attrname)
        if IAgCrdnTemplate._get_property(self, attrname) is not None: found_prop = IAgCrdnTemplate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnTemplate.')
        
agcls.AgClassCatalog.add_catalog_entry('{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}', AgCrdnTemplate)
__all__.append('AgCrdnTemplate')


class AgCrdnPointRefTo(IAgCrdnPointRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnPointRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}', AgCrdnPointRefTo)
__all__.append('AgCrdnPointRefTo')


class AgCrdnVectorRefTo(IAgCrdnVectorRefTo, IAgCrdnRefTo):
    """Represents a vector reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}', AgCrdnVectorRefTo)
__all__.append('AgCrdnVectorRefTo')


class AgCrdnAxesRefTo(IAgCrdnAxesRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{ABAD0C95-5570-461A-9DA0-FD800B10DB20}', AgCrdnAxesRefTo)
__all__.append('AgCrdnAxesRefTo')


class AgCrdnAngleRefTo(IAgCrdnAngleRefTo, IAgCrdnRefTo):
    """Represents a reference to a VGT angle."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{E1C8DFF6-65AA-4A6B-B160-7315BD795133}', AgCrdnAngleRefTo)
__all__.append('AgCrdnAngleRefTo')


class AgCrdnSystemRefTo(IAgCrdnSystemRefTo, IAgCrdnRefTo):
    """Represents a System reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}', AgCrdnSystemRefTo)
__all__.append('AgCrdnSystemRefTo')


class AgCrdnPlaneRefTo(IAgCrdnPlaneRefTo, IAgCrdnRefTo):
    """Represents a Plane reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}', AgCrdnPlaneRefTo)
__all__.append('AgCrdnPlaneRefTo')


class AgCrdnVector(IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{64392436-52D5-4274-9483-E10C56BBD037}', AgCrdnVector)
__all__.append('AgCrdnVector')


class AgCrdnAxesLabels(IAgCrdnAxesLabels):
    """Allows configuring the VGT axes labels."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesLabels._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesLabels.')
        
agcls.AgClassCatalog.add_catalog_entry('{AC9F13AD-1E42-4695-AC74-6259D2013E4F}', AgCrdnAxesLabels)
__all__.append('AgCrdnAxesLabels')


class AgCrdnAxes(IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxes.')
        
agcls.AgClassCatalog.add_catalog_entry('{50F5DD10-4D83-4603-94ED-BF7514C26282}', AgCrdnAxes)
__all__.append('AgCrdnAxes')


class AgCrdnPoint(IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPoint.')
        
agcls.AgClassCatalog.add_catalog_entry('{0092C129-467E-4B36-B971-C53F65481DA9}', AgCrdnPoint)
__all__.append('AgCrdnPoint')


class AgCrdnSystem(IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystem._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystem.')
        
agcls.AgClassCatalog.add_catalog_entry('{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}', AgCrdnSystem)
__all__.append('AgCrdnSystem')


class AgCrdnAngle(IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngle.')
        
agcls.AgClassCatalog.add_catalog_entry('{C3F96DA3-00EC-4E20-A66C-B3506100496B}', AgCrdnAngle)
__all__.append('AgCrdnAngle')


class AgCrdnPlaneLabels(IAgCrdnPlaneLabels):
    """Allows configuring the X and Y axes labels."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneLabels._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneLabels.')
        
agcls.AgClassCatalog.add_catalog_entry('{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}', AgCrdnPlaneLabels)
__all__.append('AgCrdnPlaneLabels')


class AgCrdnPlane(IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlane.')
        
agcls.AgClassCatalog.add_catalog_entry('{2E6EAA85-8440-4C4E-97FE-76491E05098A}', AgCrdnPlane)
__all__.append('AgCrdnPlane')


class AgCrdnAxesAlignedAndConstrained(IAgCrdnAxesAlignedAndConstrained, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAlignedAndConstrained.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesAlignedAndConstrained._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAlignedAndConstrained._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAlignedAndConstrained._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesAlignedAndConstrained.')
        
agcls.AgClassCatalog.add_catalog_entry('{46BB7D5B-6593-434F-B288-BF1445920A2C}', AgCrdnAxesAlignedAndConstrained)
__all__.append('AgCrdnAxesAlignedAndConstrained')


class AgCrdnAxesAngularOffset(IAgCrdnAxesAngularOffset, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAngularOffset.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesAngularOffset._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAngularOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAngularOffset._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesAngularOffset.')
        
agcls.AgClassCatalog.add_catalog_entry('{64503F8B-96E7-455B-B589-2578ADE1214B}', AgCrdnAxesAngularOffset)
__all__.append('AgCrdnAxesAngularOffset')


class AgCrdnAxesFixedAtEpoch(IAgCrdnAxesFixedAtEpoch, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes based on another set fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFixedAtEpoch.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesFixedAtEpoch._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFixedAtEpoch._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesFixedAtEpoch.')
        
agcls.AgClassCatalog.add_catalog_entry('{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}', AgCrdnAxesFixedAtEpoch)
__all__.append('AgCrdnAxesFixedAtEpoch')


class AgCrdnAxesBPlane(IAgCrdnAxesBPlane, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """B-Plane axes using the selected target body and reference vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesBPlane.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesBPlane._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesBPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesBPlane._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesBPlane.')
        
agcls.AgClassCatalog.add_catalog_entry('{E0F714EA-31E4-4F92-876F-BDD3183C29B5}', AgCrdnAxesBPlane)
__all__.append('AgCrdnAxesBPlane')


class AgCrdnAxesCustomScript(IAgCrdnAxesCustomScript, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Customized axes offset with respect to a set of reference Axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesCustomScript.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesCustomScript._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesCustomScript._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesCustomScript._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesCustomScript.')
        
agcls.AgClassCatalog.add_catalog_entry('{BC7A87DC-118E-46ED-8657-90DF42B7B101}', AgCrdnAxesCustomScript)
__all__.append('AgCrdnAxesCustomScript')


class AgCrdnAxesAttitudeFile(IAgCrdnAxesAttitudeFile, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes specified by data from a file."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAttitudeFile.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesAttitudeFile._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAttitudeFile._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAttitudeFile._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesAttitudeFile.')
        
agcls.AgClassCatalog.add_catalog_entry('{3505D063-9E1B-4964-9865-FFE41F64C8CF}', AgCrdnAxesAttitudeFile)
__all__.append('AgCrdnAxesAttitudeFile')


class AgCrdnAxesFixed(IAgCrdnAxesFixed, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFixed.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesFixed._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFixed._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFixed._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesFixed.')
        
agcls.AgClassCatalog.add_catalog_entry('{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}', AgCrdnAxesFixed)
__all__.append('AgCrdnAxesFixed')


class AgCrdnAxesModelAttach(IAgCrdnAxesModelAttach, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesModelAttach.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesModelAttach._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesModelAttach._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesModelAttach.')
        
agcls.AgClassCatalog.add_catalog_entry('{816C612A-13DD-4812-BFDE-E3861F8C39FD}', AgCrdnAxesModelAttach)
__all__.append('AgCrdnAxesModelAttach')


class AgCrdnAxesSpinning(IAgCrdnAxesSpinning, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSpinning.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesSpinning._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSpinning._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSpinning._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesSpinning.')
        
agcls.AgClassCatalog.add_catalog_entry('{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}', AgCrdnAxesSpinning)
__all__.append('AgCrdnAxesSpinning')


class AgCrdnAxesOnSurface(IAgCrdnAxesOnSurface, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Topocentric axes located at the reference point's projection on the central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesOnSurface.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesOnSurface._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesOnSurface._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesOnSurface.')
        
agcls.AgClassCatalog.add_catalog_entry('{CE8C301A-A846-44FD-8871-5AB4CAACEF11}', AgCrdnAxesOnSurface)
__all__.append('AgCrdnAxesOnSurface')


class AgCrdnAxesTrajectory(IAgCrdnAxesTrajectory, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesTrajectory.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesTrajectory._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesTrajectory._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesTrajectory.')
        
agcls.AgClassCatalog.add_catalog_entry('{4038771E-73C1-4989-A9AB-4DC37025FACC}', AgCrdnAxesTrajectory)
__all__.append('AgCrdnAxesTrajectory')


class AgCrdnAxesLagrangeLibration(IAgCrdnAxesLagrangeLibration, IAgCrdnAxes, IAgCrdnTimeProperties, IAgCrdn):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesLagrangeLibration.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesLagrangeLibration._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesLagrangeLibration._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesLagrangeLibration._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesLagrangeLibration.')
        
agcls.AgClassCatalog.add_catalog_entry('{16315085-7C87-4A20-865C-0F419A5CDA2F}', AgCrdnAxesLagrangeLibration)
__all__.append('AgCrdnAxesLagrangeLibration')


class AgCrdnAxesCommonTasks(IAgCrdnAxesCommonTasks):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesCommonTasks.')
        
agcls.AgClassCatalog.add_catalog_entry('{07D4865C-78F1-4B3A-9756-D70050613D4A}', AgCrdnAxesCommonTasks)
__all__.append('AgCrdnAxesCommonTasks')


class AgCrdnAxesAtTimeInstant(IAgCrdnAxesAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesAtTimeInstant._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesAtTimeInstant.')
        
agcls.AgClassCatalog.add_catalog_entry('{3845C20A-A6E2-45A0-A748-10E9B565C48D}', AgCrdnAxesAtTimeInstant)
__all__.append('AgCrdnAxesAtTimeInstant')


class AgCrdnAxesPlugin(IAgCrdnAxesPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnAxes):
    """A VGT axes plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesPlugin._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesPlugin.')
        
agcls.AgClassCatalog.add_catalog_entry('{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}', AgCrdnAxesPlugin)
__all__.append('AgCrdnAxesPlugin')


class AgCrdnAngleBetweenVectors(IAgCrdnAngleBetweenVectors, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleBetweenVectors.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleBetweenVectors._private_init(self, pUnk)
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleBetweenVectors._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleBetweenVectors._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleBetweenVectors.')
        
agcls.AgClassCatalog.add_catalog_entry('{2F0AA430-85D0-4479-9540-B1B64EB3B530}', AgCrdnAngleBetweenVectors)
__all__.append('AgCrdnAngleBetweenVectors')


class AgCrdnAngleBetweenPlanes(IAgCrdnAngleBetweenPlanes, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleBetweenPlanes.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleBetweenPlanes._private_init(self, pUnk)
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleBetweenPlanes._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleBetweenPlanes._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleBetweenPlanes.')
        
agcls.AgClassCatalog.add_catalog_entry('{30C2886F-8792-475D-9E42-975308B1B94E}', AgCrdnAngleBetweenPlanes)
__all__.append('AgCrdnAngleBetweenPlanes')


class AgCrdnAngleDihedral(IAgCrdnAngleDihedral, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between two vectors about an axis."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleDihedral.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleDihedral._private_init(self, pUnk)
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleDihedral._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleDihedral._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleDihedral.')
        
agcls.AgClassCatalog.add_catalog_entry('{550855BB-E8F1-440B-BA5C-024ACE2E2A17}', AgCrdnAngleDihedral)
__all__.append('AgCrdnAngleDihedral')


class AgCrdnAngleRotation(IAgCrdnAngleRotation, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleRotation.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleRotation._private_init(self, pUnk)
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleRotation._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleRotation._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleRotation.')
        
agcls.AgClassCatalog.add_catalog_entry('{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}', AgCrdnAngleRotation)
__all__.append('AgCrdnAngleRotation')


class AgCrdnAngleToPlane(IAgCrdnAngleToPlane, IAgCrdnAngle, IAgCrdnTimeProperties, IAgCrdn):
    """An angle between a vector and a plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleToPlane.__init__(self, sourceObject)
        IAgCrdnAngle.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleToPlane._private_init(self, pUnk)
        IAgCrdnAngle._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleToPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleToPlane._get_property(self, attrname)
        if IAgCrdnAngle._get_property(self, attrname) is not None: found_prop = IAgCrdnAngle._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleToPlane.')
        
agcls.AgClassCatalog.add_catalog_entry('{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}', AgCrdnAngleToPlane)
__all__.append('AgCrdnAngleToPlane')


class AgCrdnPlaneNormal(IAgCrdnPlaneNormal, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneNormal.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneNormal._private_init(self, pUnk)
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneNormal._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneNormal._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneNormal.')
        
agcls.AgClassCatalog.add_catalog_entry('{0AED319D-7B6C-462B-882B-D363F7A2A86C}', AgCrdnPlaneNormal)
__all__.append('AgCrdnPlaneNormal')


class AgCrdnPlaneQuadrant(IAgCrdnPlaneQuadrant, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane based on a selected Quadrant of a reference system."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneQuadrant.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneQuadrant._private_init(self, pUnk)
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneQuadrant._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneQuadrant._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneQuadrant.')
        
agcls.AgClassCatalog.add_catalog_entry('{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}', AgCrdnPlaneQuadrant)
__all__.append('AgCrdnPlaneQuadrant')


class AgCrdnPlaneTrajectory(IAgCrdnPlaneTrajectory, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTrajectory.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneTrajectory._private_init(self, pUnk)
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTrajectory._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTrajectory._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneTrajectory.')
        
agcls.AgClassCatalog.add_catalog_entry('{7BD18F79-6788-48B1-AFB5-243D62C01177}', AgCrdnPlaneTrajectory)
__all__.append('AgCrdnPlaneTrajectory')


class AgCrdnPlaneTriad(IAgCrdnPlaneTriad, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTriad.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneTriad._private_init(self, pUnk)
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTriad._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTriad._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneTriad.')
        
agcls.AgClassCatalog.add_catalog_entry('{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}', AgCrdnPlaneTriad)
__all__.append('AgCrdnPlaneTriad')


class AgCrdnPlaneTwoVector(IAgCrdnPlaneTwoVector, IAgCrdnPlane, IAgCrdnTimeProperties, IAgCrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneTwoVector.__init__(self, sourceObject)
        IAgCrdnPlane.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneTwoVector._private_init(self, pUnk)
        IAgCrdnPlane._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneTwoVector._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneTwoVector._get_property(self, attrname)
        if IAgCrdnPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPlane._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneTwoVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{49a61e7a-baba-48fd-9d9d-61f91c520291}', AgCrdnPlaneTwoVector)
__all__.append('AgCrdnPlaneTwoVector')


class AgCrdnPointBPlane(IAgCrdnPointBPlane, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """B-Plane point using the selected target body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointBPlane.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointBPlane._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointBPlane._get_property(self, attrname) is not None: found_prop = IAgCrdnPointBPlane._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointBPlane.')
        
agcls.AgClassCatalog.add_catalog_entry('{E62329EB-83D1-47CE-8B5B-B795995A2270}', AgCrdnPointBPlane)
__all__.append('AgCrdnPointBPlane')


class AgCrdnPointFile(IAgCrdnPointFile, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point specified by data from a file."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFile.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointFile._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFile._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFile._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointFile.')
        
agcls.AgClassCatalog.add_catalog_entry('{0E71C927-09CA-4A90-95F0-CB87E244CE72}', AgCrdnPointFile)
__all__.append('AgCrdnPointFile')


class AgCrdnPointFixedInSystem(IAgCrdnPointFixedInSystem, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFixedInSystem.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointFixedInSystem._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFixedInSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFixedInSystem._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointFixedInSystem.')
        
agcls.AgClassCatalog.add_catalog_entry('{9FA10E06-094A-446C-BE9A-5BA397776778}', AgCrdnPointFixedInSystem)
__all__.append('AgCrdnPointFixedInSystem')


class AgCrdnPointGrazing(IAgCrdnPointGrazing, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGrazing.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointGrazing._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGrazing._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGrazing._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointGrazing.')
        
agcls.AgClassCatalog.add_catalog_entry('{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}', AgCrdnPointGrazing)
__all__.append('AgCrdnPointGrazing')


class AgCrdnPointGlint(IAgCrdnPointGlint, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point on central body surface that reflects from source to observer."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGlint.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointGlint._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGlint._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGlint._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointGlint.')
        
agcls.AgClassCatalog.add_catalog_entry('{68F85553-0FA2-459D-93AC-BD4D68A01F6F}', AgCrdnPointGlint)
__all__.append('AgCrdnPointGlint')


class AgCrdnPointCovarianceGrazing(IAgCrdnPointCovarianceGrazing, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCovarianceGrazing.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointCovarianceGrazing._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCovarianceGrazing._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCovarianceGrazing._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointCovarianceGrazing.')
        
agcls.AgClassCatalog.add_catalog_entry('{84D91807-716E-46F4-AB70-53C73FA21C20}', AgCrdnPointCovarianceGrazing)
__all__.append('AgCrdnPointCovarianceGrazing')


class AgCrdnPointPlaneIntersection(IAgCrdnPointPlaneIntersection, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Point on a plane located along a given direction looking from a given origin."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlaneIntersection.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointPlaneIntersection._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlaneIntersection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlaneIntersection._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointPlaneIntersection.')
        
agcls.AgClassCatalog.add_catalog_entry('{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}', AgCrdnPointPlaneIntersection)
__all__.append('AgCrdnPointPlaneIntersection')


class AgCrdnPointOnSurface(IAgCrdnPointOnSurface, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The detic subpoint of the reference point as projected onto the central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointOnSurface.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointOnSurface._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnPointOnSurface._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointOnSurface.')
        
agcls.AgClassCatalog.add_catalog_entry('{03ECCFD1-B058-4817-826F-EDE2A6880757}', AgCrdnPointOnSurface)
__all__.append('AgCrdnPointOnSurface')


class AgCrdnPointModelAttach(IAgCrdnPointModelAttach, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointModelAttach.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointModelAttach._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnPointModelAttach._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointModelAttach.')
        
agcls.AgClassCatalog.add_catalog_entry('{15958616-F779-4772-9E54-9B134B69BE89}', AgCrdnPointModelAttach)
__all__.append('AgCrdnPointModelAttach')


class AgCrdnPointSatelliteCollectionEntry(IAgCrdnPointSatelliteCollectionEntry, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSatelliteCollectionEntry.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointSatelliteCollectionEntry._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSatelliteCollectionEntry._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSatelliteCollectionEntry._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointSatelliteCollectionEntry.')
        
agcls.AgClassCatalog.add_catalog_entry('{d0dacbed-0c16-4de5-b32a-9c7624297014}', AgCrdnPointSatelliteCollectionEntry)
__all__.append('AgCrdnPointSatelliteCollectionEntry')


class AgCrdnPointPlaneProjection(IAgCrdnPointPlaneProjection, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlaneProjection.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointPlaneProjection._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlaneProjection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlaneProjection._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointPlaneProjection.')
        
agcls.AgClassCatalog.add_catalog_entry('{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}', AgCrdnPointPlaneProjection)
__all__.append('AgCrdnPointPlaneProjection')


class AgCrdnPointLagrangeLibration(IAgCrdnPointLagrangeLibration, IAgCrdnPoint, IAgCrdnTimeProperties, IAgCrdn):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointLagrangeLibration.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointLagrangeLibration._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointLagrangeLibration._get_property(self, attrname) is not None: found_prop = IAgCrdnPointLagrangeLibration._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointLagrangeLibration.')
        
agcls.AgClassCatalog.add_catalog_entry('{6BF6D976-775A-445D-AD2B-899892F3127E}', AgCrdnPointLagrangeLibration)
__all__.append('AgCrdnPointLagrangeLibration')


class AgCrdnPointCommonTasks(IAgCrdnPointCommonTasks):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointCommonTasks.')
        
agcls.AgClassCatalog.add_catalog_entry('{9866644C-E731-465E-A7AA-3F4667C1729E}', AgCrdnPointCommonTasks)
__all__.append('AgCrdnPointCommonTasks')


class AgCrdnPointCentBodyIntersect(IAgCrdnPointCentBodyIntersect, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point on central body surface along direction vector originating at source point."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCentBodyIntersect.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointCentBodyIntersect._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCentBodyIntersect._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCentBodyIntersect._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointCentBodyIntersect.')
        
agcls.AgClassCatalog.add_catalog_entry('{882047E8-7CB3-489B-B029-33163CBBA583}', AgCrdnPointCentBodyIntersect)
__all__.append('AgCrdnPointCentBodyIntersect')


class AgCrdnPointAtTimeInstant(IAgCrdnPointAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointAtTimeInstant._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnPointAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointAtTimeInstant.')
        
agcls.AgClassCatalog.add_catalog_entry('{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}', AgCrdnPointAtTimeInstant)
__all__.append('AgCrdnPointAtTimeInstant')


class AgCrdnPointPlugin(IAgCrdnPointPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """A VGT point plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointPlugin._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnPointPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointPlugin.')
        
agcls.AgClassCatalog.add_catalog_entry('{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}', AgCrdnPointPlugin)
__all__.append('AgCrdnPointPlugin')


class AgCrdnPointCBFixedOffset(IAgCrdnPointCBFixedOffset, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnPoint):
    """Point specified by fixed components with respect to central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointCBFixedOffset.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointCBFixedOffset._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointCBFixedOffset._get_property(self, attrname) is not None: found_prop = IAgCrdnPointCBFixedOffset._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnPoint._get_property(self, attrname) is not None: found_prop = IAgCrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointCBFixedOffset.')
        
agcls.AgClassCatalog.add_catalog_entry('{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}', AgCrdnPointCBFixedOffset)
__all__.append('AgCrdnPointCBFixedOffset')


class AgCrdnSystemAssembled(IAgCrdnSystemAssembled, IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """A system assembled from an origin point and a set of reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemAssembled.__init__(self, sourceObject)
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemAssembled._private_init(self, pUnk)
        IAgCrdnSystem._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemAssembled._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemAssembled._get_property(self, attrname)
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemAssembled.')
        
agcls.AgClassCatalog.add_catalog_entry('{CE4E84B1-8CCF-467A-A3ED-274D0943407F}', AgCrdnSystemAssembled)
__all__.append('AgCrdnSystemAssembled')


class AgCrdnSystemOnSurface(IAgCrdnSystemOnSurface, IAgCrdnSystem, IAgCrdnTimeProperties, IAgCrdn):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemOnSurface.__init__(self, sourceObject)
        IAgCrdnSystem.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemOnSurface._private_init(self, pUnk)
        IAgCrdnSystem._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemOnSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemOnSurface._get_property(self, attrname)
        if IAgCrdnSystem._get_property(self, attrname) is not None: found_prop = IAgCrdnSystem._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemOnSurface.')
        
agcls.AgClassCatalog.add_catalog_entry('{073423F9-A59D-4313-B499-C86A45C63513}', AgCrdnSystemOnSurface)
__all__.append('AgCrdnSystemOnSurface')


class AgCrdnLLAPosition(IAgCrdnLLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""
    def __init__(self, sourceObject=None):
        IAgCrdnLLAPosition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnLLAPosition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnLLAPosition._get_property(self, attrname) is not None: found_prop = IAgCrdnLLAPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnLLAPosition.')
        
agcls.AgClassCatalog.add_catalog_entry('{CB962F51-978A-43F9-A88B-AAB62117F93C}', AgCrdnLLAPosition)
__all__.append('AgCrdnLLAPosition')


class AgCrdnSystemCommonTasks(IAgCrdnSystemCommonTasks):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemCommonTasks._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemCommonTasks.')
        
agcls.AgClassCatalog.add_catalog_entry('{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}', AgCrdnSystemCommonTasks)
__all__.append('AgCrdnSystemCommonTasks')


class AgCrdnVectorAngleRate(IAgCrdnVectorAngleRate, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorAngleRate.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorAngleRate._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorAngleRate._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorAngleRate._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorAngleRate.')
        
agcls.AgClassCatalog.add_catalog_entry('{5769E079-8E9B-40B2-B2EF-14F202AF5666}', AgCrdnVectorAngleRate)
__all__.append('AgCrdnVectorAngleRate')


class AgCrdnVectorApoapsis(IAgCrdnVectorApoapsis, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorApoapsis.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorApoapsis._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorApoapsis._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorApoapsis._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorApoapsis.')
        
agcls.AgClassCatalog.add_catalog_entry('{22E4138C-29C6-4401-91E0-DF0C00422302}', AgCrdnVectorApoapsis)
__all__.append('AgCrdnVectorApoapsis')


class AgCrdnVectorFixedAtEpoch(IAgCrdnVectorFixedAtEpoch, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Based on another vector fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedAtEpoch.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorFixedAtEpoch._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedAtEpoch._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedAtEpoch._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorFixedAtEpoch.')
        
agcls.AgClassCatalog.add_catalog_entry('{FA8DB5F5-1F28-40E6-9B86-489E06D61523}', AgCrdnVectorFixedAtEpoch)
__all__.append('AgCrdnVectorFixedAtEpoch')


class AgCrdnVectorAngularVelocity(IAgCrdnVectorAngularVelocity, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorAngularVelocity.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorAngularVelocity._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorAngularVelocity._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorAngularVelocity._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorAngularVelocity.')
        
agcls.AgClassCatalog.add_catalog_entry('{2ABC83DB-6F6C-4A91-8597-21BD2715D411}', AgCrdnVectorAngularVelocity)
__all__.append('AgCrdnVectorAngularVelocity')


class AgCrdnVectorConing(IAgCrdnVectorConing, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorConing.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorConing._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorConing._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorConing._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorConing.')
        
agcls.AgClassCatalog.add_catalog_entry('{74E6F986-E292-4115-84E4-9E9953C163B8}', AgCrdnVectorConing)
__all__.append('AgCrdnVectorConing')


class AgCrdnVectorCross(IAgCrdnVectorCross, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """The vector cross product of two vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorCross.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorCross._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorCross._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorCross._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorCross.')
        
agcls.AgClassCatalog.add_catalog_entry('{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}', AgCrdnVectorCross)
__all__.append('AgCrdnVectorCross')


class AgCrdnVectorCustomScript(IAgCrdnVectorCustomScript, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Customized vector components defined with respect to reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorCustomScript.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorCustomScript._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorCustomScript._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorCustomScript._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorCustomScript.')
        
agcls.AgClassCatalog.add_catalog_entry('{D65CDDC6-21DA-419F-BF72-79C2376648E8}', AgCrdnVectorCustomScript)
__all__.append('AgCrdnVectorCustomScript')


class AgCrdnVectorDerivative(IAgCrdnVectorDerivative, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A vector derivative of a vector computed with respect to specified axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDerivative.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorDerivative._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDerivative._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDerivative._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorDerivative.')
        
agcls.AgClassCatalog.add_catalog_entry('{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}', AgCrdnVectorDerivative)
__all__.append('AgCrdnVectorDerivative')


class AgCrdnVectorDisplacement(IAgCrdnVectorDisplacement, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector defined by its start and end points."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDisplacement.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorDisplacement._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDisplacement._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDisplacement._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorDisplacement.')
        
agcls.AgClassCatalog.add_catalog_entry('{6CAADA67-7238-4705-9F74-95596344DED0}', AgCrdnVectorDisplacement)
__all__.append('AgCrdnVectorDisplacement')


class AgCrdnVectorTwoPlanesIntersection(IAgCrdnVectorTwoPlanesIntersection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Defined along the intersection of two planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorTwoPlanesIntersection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorTwoPlanesIntersection._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorTwoPlanesIntersection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorTwoPlanesIntersection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorTwoPlanesIntersection.')
        
agcls.AgClassCatalog.add_catalog_entry('{B1145553-76CD-4C1E-AE08-E63E29CF4E46}', AgCrdnVectorTwoPlanesIntersection)
__all__.append('AgCrdnVectorTwoPlanesIntersection')


class AgCrdnVectorModelAttach(IAgCrdnVectorModelAttach, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorModelAttach.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorModelAttach._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorModelAttach._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorModelAttach._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorModelAttach.')
        
agcls.AgClassCatalog.add_catalog_entry('{E95BEEB8-C544-4852-9C82-20080343E585}', AgCrdnVectorModelAttach)
__all__.append('AgCrdnVectorModelAttach')


class AgCrdnVectorProjection(IAgCrdnVectorProjection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A projection of a vector computed with respect to a reference plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorProjection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorProjection._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorProjection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorProjection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorProjection.')
        
agcls.AgClassCatalog.add_catalog_entry('{7306544A-A8B0-477B-B89D-BA711C9ED600}', AgCrdnVectorProjection)
__all__.append('AgCrdnVectorProjection')


class AgCrdnVectorScaled(IAgCrdnVectorScaled, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScaled.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorScaled._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScaled._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorScaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{92D80C29-251B-436B-9DA0-D5BA4B262185}', AgCrdnVectorScaled)
__all__.append('AgCrdnVectorScaled')


class AgCrdnVectorEccentricity(IAgCrdnVectorEccentricity, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorEccentricity.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorEccentricity._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorEccentricity._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorEccentricity._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorEccentricity.')
        
agcls.AgClassCatalog.add_catalog_entry('{C7F157D7-11EB-4779-955F-98530B9C2608}', AgCrdnVectorEccentricity)
__all__.append('AgCrdnVectorEccentricity')


class AgCrdnVectorFixedInAxes(IAgCrdnVectorFixedInAxes, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector fixed in reference axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedInAxes.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorFixedInAxes._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedInAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedInAxes._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorFixedInAxes.')
        
agcls.AgClassCatalog.add_catalog_entry('{61E9F963-8CFC-4B24-B583-716A64BAE54C}', AgCrdnVectorFixedInAxes)
__all__.append('AgCrdnVectorFixedInAxes')


class AgCrdnVectorLineOfNodes(IAgCrdnVectorLineOfNodes, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorLineOfNodes.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorLineOfNodes._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorLineOfNodes._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorLineOfNodes._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorLineOfNodes.')
        
agcls.AgClassCatalog.add_catalog_entry('{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}', AgCrdnVectorLineOfNodes)
__all__.append('AgCrdnVectorLineOfNodes')


class AgCrdnVectorOrbitAngularMomentum(IAgCrdnVectorOrbitAngularMomentum, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorOrbitAngularMomentum.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorOrbitAngularMomentum._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorOrbitAngularMomentum._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorOrbitAngularMomentum._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorOrbitAngularMomentum.')
        
agcls.AgClassCatalog.add_catalog_entry('{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}', AgCrdnVectorOrbitAngularMomentum)
__all__.append('AgCrdnVectorOrbitAngularMomentum')


class AgCrdnVectorOrbitNormal(IAgCrdnVectorOrbitNormal, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorOrbitNormal.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorOrbitNormal._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorOrbitNormal._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorOrbitNormal._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorOrbitNormal.')
        
agcls.AgClassCatalog.add_catalog_entry('{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}', AgCrdnVectorOrbitNormal)
__all__.append('AgCrdnVectorOrbitNormal')


class AgCrdnVectorPeriapsis(IAgCrdnVectorPeriapsis, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorPeriapsis.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorPeriapsis._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorPeriapsis._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorPeriapsis._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorPeriapsis.')
        
agcls.AgClassCatalog.add_catalog_entry('{DA81B380-6D7C-48F4-8E7F-472035958B44}', AgCrdnVectorPeriapsis)
__all__.append('AgCrdnVectorPeriapsis')


class AgCrdnVectorReflection(IAgCrdnVectorReflection, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorReflection.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorReflection._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorReflection._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorReflection._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorReflection.')
        
agcls.AgClassCatalog.add_catalog_entry('{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}', AgCrdnVectorReflection)
__all__.append('AgCrdnVectorReflection')


class AgCrdnVectorRotationVector(IAgCrdnVectorRotationVector, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorRotationVector.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorRotationVector._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorRotationVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorRotationVector._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorRotationVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}', AgCrdnVectorRotationVector)
__all__.append('AgCrdnVectorRotationVector')


class AgCrdnVectorDirectionToStar(IAgCrdnVectorDirectionToStar, IAgCrdnVector, IAgCrdnTimeProperties, IAgCrdn):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDirectionToStar.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorDirectionToStar._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDirectionToStar._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDirectionToStar._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorDirectionToStar.')
        
agcls.AgClassCatalog.add_catalog_entry('{147FDFCC-767A-460C-9833-02A582AFCA9C}', AgCrdnVectorDirectionToStar)
__all__.append('AgCrdnVectorDirectionToStar')


class AgCrdnVectorFixedAtTimeInstant(IAgCrdnVectorFixedAtTimeInstant, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFixedAtTimeInstant.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorFixedAtTimeInstant._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFixedAtTimeInstant._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorFixedAtTimeInstant.')
        
agcls.AgClassCatalog.add_catalog_entry('{BC8737B3-A94E-4B68-857F-81E780C874FD}', AgCrdnVectorFixedAtTimeInstant)
__all__.append('AgCrdnVectorFixedAtTimeInstant')


class AgCrdnVectorLinearCombination(IAgCrdnVectorLinearCombination, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Linear combination of two input vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorLinearCombination.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorLinearCombination._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorLinearCombination._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorLinearCombination._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorLinearCombination.')
        
agcls.AgClassCatalog.add_catalog_entry('{59E2764C-7920-4CDC-B5FF-2590154E1ABE}', AgCrdnVectorLinearCombination)
__all__.append('AgCrdnVectorLinearCombination')


class AgCrdnVectorProjectAlongVector(IAgCrdnVectorProjectAlongVector, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """A projection of a source vector in the direction of another vector."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorProjectAlongVector.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorProjectAlongVector._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorProjectAlongVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorProjectAlongVector._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorProjectAlongVector.')
        
agcls.AgClassCatalog.add_catalog_entry('{7B76B999-135B-4AAF-ADEA-444FD759417D}', AgCrdnVectorProjectAlongVector)
__all__.append('AgCrdnVectorProjectAlongVector')


class AgCrdnVectorScalarLinearCombination(IAgCrdnVectorScalarLinearCombination, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Linear combination of two input vectors using scalars."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScalarLinearCombination.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorScalarLinearCombination._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScalarLinearCombination._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScalarLinearCombination._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorScalarLinearCombination.')
        
agcls.AgClassCatalog.add_catalog_entry('{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}', AgCrdnVectorScalarLinearCombination)
__all__.append('AgCrdnVectorScalarLinearCombination')


class AgCrdnVectorScalarScaled(IAgCrdnVectorScalarScaled, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Scaled version of the input vector using scalar."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorScalarScaled.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorScalarScaled._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorScalarScaled._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorScalarScaled._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorScalarScaled.')
        
agcls.AgClassCatalog.add_catalog_entry('{9C93B992-687F-4311-B339-DE0DA38409AE}', AgCrdnVectorScalarScaled)
__all__.append('AgCrdnVectorScalarScaled')


class AgCrdnVectorVelocityAcceleration(IAgCrdnVectorVelocityAcceleration, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Velocity vector of a point in a coordinate system."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorVelocityAcceleration.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorVelocityAcceleration._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorVelocityAcceleration._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorVelocityAcceleration._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorVelocityAcceleration.')
        
agcls.AgClassCatalog.add_catalog_entry('{75A62225-C09F-4F08-B7FE-9216B02DECF2}', AgCrdnVectorVelocityAcceleration)
__all__.append('AgCrdnVectorVelocityAcceleration')


class AgCrdnVectorPlugin(IAgCrdnVectorPlugin, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """A VGT vector plugin."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorPlugin.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorPlugin._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorPlugin._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorPlugin._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorPlugin.')
        
agcls.AgClassCatalog.add_catalog_entry('{E105429A-489E-47F6-B827-8E5819FCE917}', AgCrdnVectorPlugin)
__all__.append('AgCrdnVectorPlugin')


class AgCrdnVectorDispSurface(IAgCrdnVectorDispSurface, IAgCrdn, IAgCrdnTimeProperties, IAgCrdnVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorDispSurface.__init__(self, sourceObject)
        IAgCrdn.__init__(self, sourceObject)
        IAgCrdnTimeProperties.__init__(self, sourceObject)
        IAgCrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorDispSurface._private_init(self, pUnk)
        IAgCrdn._private_init(self, pUnk)
        IAgCrdnTimeProperties._private_init(self, pUnk)
        IAgCrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorDispSurface._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorDispSurface._get_property(self, attrname)
        if IAgCrdn._get_property(self, attrname) is not None: found_prop = IAgCrdn._get_property(self, attrname)
        if IAgCrdnTimeProperties._get_property(self, attrname) is not None: found_prop = IAgCrdnTimeProperties._get_property(self, attrname)
        if IAgCrdnVector._get_property(self, attrname) is not None: found_prop = IAgCrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorDispSurface.')
        
agcls.AgClassCatalog.add_catalog_entry('{ccd4af03-78af-47ae-902a-90860a17daa4}', AgCrdnVectorDispSurface)
__all__.append('AgCrdnVectorDispSurface')


class AgCrdnVectorFactory(IAgCrdnVectorFactory):
    """A Factory object to create vectors."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}', AgCrdnVectorFactory)
__all__.append('AgCrdnVectorFactory')


class AgCrdnAxesFactory(IAgCrdnAxesFactory):
    """A Factory object to create axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{7B3E2402-1E15-43DC-BB48-6E98D377B107}', AgCrdnAxesFactory)
__all__.append('AgCrdnAxesFactory')


class AgCrdnSystemFactory(IAgCrdnSystemFactory):
    """A Factory class to create VGT systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{01A37414-BA74-4DF3-A007-6A3395C8A859}', AgCrdnSystemFactory)
__all__.append('AgCrdnSystemFactory')


class AgCrdnPointFactory(IAgCrdnPointFactory):
    """A Factory object to create points."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{6C79F3B2-8AE5-468A-940F-F0988752B309}', AgCrdnPointFactory)
__all__.append('AgCrdnPointFactory')


class AgCrdnPlaneFactory(IAgCrdnPlaneFactory):
    """A Factory object to create VGT planes."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}', AgCrdnPlaneFactory)
__all__.append('AgCrdnPlaneFactory')


class AgCrdnAngleFactory(IAgCrdnAngleFactory):
    """A Factory object to create angles."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleFactory._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleFactory.')
        
agcls.AgClassCatalog.add_catalog_entry('{0888F89F-9D77-4FCE-9A08-67FCBE870187}', AgCrdnAngleFactory)
__all__.append('AgCrdnAngleFactory')


class AgCrdnVectorGroup(IAgCrdnVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnVectorGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnVectorGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnVectorGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnVectorGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnVectorGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}', AgCrdnVectorGroup)
__all__.append('AgCrdnVectorGroup')


class AgCrdnPointGroup(IAgCrdnPointGroup):
    """Access or create VGT points associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnPointGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}', AgCrdnPointGroup)
__all__.append('AgCrdnPointGroup')


class AgCrdnAngleGroup(IAgCrdnAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAngleGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAngleGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnAngleGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAngleGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}', AgCrdnAngleGroup)
__all__.append('AgCrdnAngleGroup')


class AgCrdnAxesGroup(IAgCrdnAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{2D792657-9D6E-4B1E-AEAB-B964839C6F94}', AgCrdnAxesGroup)
__all__.append('AgCrdnAxesGroup')


class AgCrdnPlaneGroup(IAgCrdnPlaneGroup):
    """Represents a VGT Plane component."""
    def __init__(self, sourceObject=None):
        IAgCrdnPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPlaneGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPlaneGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnPlaneGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPlaneGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{15117A82-3EE6-483E-A65E-2A44F60DB355}', AgCrdnPlaneGroup)
__all__.append('AgCrdnPlaneGroup')


class AgCrdnSystemGroup(IAgCrdnSystemGroup):
    """Access or create VGT systems associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnSystemGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnSystemGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnSystemGroup._get_property(self, attrname) is not None: found_prop = IAgCrdnSystemGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnSystemGroup.')
        
agcls.AgClassCatalog.add_catalog_entry('{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}', AgCrdnSystemGroup)
__all__.append('AgCrdnSystemGroup')


class AgCrdnProvider(IAgCrdnProvider):
    """Allows accessing existing Vector Geometry Tool components."""
    def __init__(self, sourceObject=None):
        IAgCrdnProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnProvider._get_property(self, attrname) is not None: found_prop = IAgCrdnProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnProvider.')
        
agcls.AgClassCatalog.add_catalog_entry('{D9031FE1-81E1-4818-944D-5F00FC3EC97D}', AgCrdnProvider)
__all__.append('AgCrdnProvider')


class AgCrdnRoot(IAgCrdnRoot):
    """Represents a VGT root."""
    def __init__(self, sourceObject=None):
        IAgCrdnRoot.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnRoot._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnRoot._get_property(self, attrname) is not None: found_prop = IAgCrdnRoot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnRoot.')
        
agcls.AgClassCatalog.add_catalog_entry('{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}', AgCrdnRoot)
__all__.append('AgCrdnRoot')


class AgCrdnWellKnownEarthSystems(IAgCrdnWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownEarthSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownEarthSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownEarthSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownEarthSystems.')
        
agcls.AgClassCatalog.add_catalog_entry('{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}', AgCrdnWellKnownEarthSystems)
__all__.append('AgCrdnWellKnownEarthSystems')


class AgCrdnWellKnownEarthAxes(IAgCrdnWellKnownEarthAxes):
    """Well-known Earth's axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownEarthAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownEarthAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownEarthAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownEarthAxes.')
        
agcls.AgClassCatalog.add_catalog_entry('{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}', AgCrdnWellKnownEarthAxes)
__all__.append('AgCrdnWellKnownEarthAxes')


class AgCrdnWellKnownSunSystems(IAgCrdnWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownSunSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSunSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSunSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownSunSystems.')
        
agcls.AgClassCatalog.add_catalog_entry('{855EB036-E71F-47F9-B27B-57247345282A}', AgCrdnWellKnownSunSystems)
__all__.append('AgCrdnWellKnownSunSystems')


class AgCrdnWellKnownSunAxes(IAgCrdnWellKnownSunAxes):
    """Well-known Sun's axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownSunAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSunAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSunAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownSunAxes.')
        
agcls.AgClassCatalog.add_catalog_entry('{7F786A33-8851-4FA4-A0CA-DC353170143E}', AgCrdnWellKnownSunAxes)
__all__.append('AgCrdnWellKnownSunAxes')


class AgCrdnWellKnownSystems(IAgCrdnWellKnownSystems):
    """Well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownSystems._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownSystems.')
        
agcls.AgClassCatalog.add_catalog_entry('{8C5101B3-3FDD-443D-A59F-B1E801873E0A}', AgCrdnWellKnownSystems)
__all__.append('AgCrdnWellKnownSystems')


class AgCrdnWellKnownAxes(IAgCrdnWellKnownAxes):
    """Represents well-known VGT Axes."""
    def __init__(self, sourceObject=None):
        IAgCrdnWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnWellKnownAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnWellKnownAxes._get_property(self, attrname) is not None: found_prop = IAgCrdnWellKnownAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnWellKnownAxes.')
        
agcls.AgClassCatalog.add_catalog_entry('{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}', AgCrdnWellKnownAxes)
__all__.append('AgCrdnWellKnownAxes')


class AgCrdnMethodCallResult(IAgCrdnAngleFindResult, IAgCrdnAngleFindWithRateResult, IAgCrdnAxesTransformResult, IAgCrdnAxesTransformWithRateResult, IAgCrdnAxesFindInAxesResult, IAgCrdnAxesFindInAxesWithRateResult, IAgCrdnPlaneFindInAxesResult, IAgCrdnPlaneFindInAxesWithRateResult, IAgCrdnPlaneFindInSystemResult, IAgCrdnPlaneFindInSystemWithRateResult, IAgCrdnPointLocateInSystemResult, IAgCrdnPointLocateInSystemWithRateResult, IAgCrdnSystemTransformResult, IAgCrdnSystemTransformWithRateResult, IAgCrdnSystemFindInSystemResult, IAgCrdnVectorFindInAxesResult, IAgCrdnVectorFindInAxesWithRateResult, IAgCrdnAngleFindAngleWithRateResult, IAgCrdnAngleFindAngleResult, IAgCrdnMethodCallResult):
    """
    Represents a result of a call to a VGT method.
    Some of the inherited interfaces for this class may be disabled at runtime.
    """
    def __init__(self, sourceObject=None):
        IAgCrdnAngleFindResult.__init__(self, sourceObject)
        IAgCrdnAngleFindWithRateResult.__init__(self, sourceObject)
        IAgCrdnAxesTransformResult.__init__(self, sourceObject)
        IAgCrdnAxesTransformWithRateResult.__init__(self, sourceObject)
        IAgCrdnAxesFindInAxesResult.__init__(self, sourceObject)
        IAgCrdnAxesFindInAxesWithRateResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInAxesResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInSystemResult.__init__(self, sourceObject)
        IAgCrdnPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
        IAgCrdnPointLocateInSystemResult.__init__(self, sourceObject)
        IAgCrdnPointLocateInSystemWithRateResult.__init__(self, sourceObject)
        IAgCrdnSystemTransformResult.__init__(self, sourceObject)
        IAgCrdnSystemTransformWithRateResult.__init__(self, sourceObject)
        IAgCrdnSystemFindInSystemResult.__init__(self, sourceObject)
        IAgCrdnVectorFindInAxesResult.__init__(self, sourceObject)
        IAgCrdnVectorFindInAxesWithRateResult.__init__(self, sourceObject)
        IAgCrdnAngleFindAngleWithRateResult.__init__(self, sourceObject)
        IAgCrdnAngleFindAngleResult.__init__(self, sourceObject)
        IAgCrdnMethodCallResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAngleFindResult._private_init(self, pUnk)
        IAgCrdnAngleFindWithRateResult._private_init(self, pUnk)
        IAgCrdnAxesTransformResult._private_init(self, pUnk)
        IAgCrdnAxesTransformWithRateResult._private_init(self, pUnk)
        IAgCrdnAxesFindInAxesResult._private_init(self, pUnk)
        IAgCrdnAxesFindInAxesWithRateResult._private_init(self, pUnk)
        IAgCrdnPlaneFindInAxesResult._private_init(self, pUnk)
        IAgCrdnPlaneFindInAxesWithRateResult._private_init(self, pUnk)
        IAgCrdnPlaneFindInSystemResult._private_init(self, pUnk)
        IAgCrdnPlaneFindInSystemWithRateResult._private_init(self, pUnk)
        IAgCrdnPointLocateInSystemResult._private_init(self, pUnk)
        IAgCrdnPointLocateInSystemWithRateResult._private_init(self, pUnk)
        IAgCrdnSystemTransformResult._private_init(self, pUnk)
        IAgCrdnSystemTransformWithRateResult._private_init(self, pUnk)
        IAgCrdnSystemFindInSystemResult._private_init(self, pUnk)
        IAgCrdnVectorFindInAxesResult._private_init(self, pUnk)
        IAgCrdnVectorFindInAxesWithRateResult._private_init(self, pUnk)
        IAgCrdnAngleFindAngleWithRateResult._private_init(self, pUnk)
        IAgCrdnAngleFindAngleResult._private_init(self, pUnk)
        IAgCrdnMethodCallResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAngleFindResult.__dict__ and type(IAgCrdnAngleFindResult.__dict__[attrname]) == property: found_prop = IAgCrdnAngleFindResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAngleFindWithRateResult.__dict__ and type(IAgCrdnAngleFindWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnAngleFindWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAxesTransformResult.__dict__ and type(IAgCrdnAxesTransformResult.__dict__[attrname]) == property: found_prop = IAgCrdnAxesTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAxesTransformWithRateResult.__dict__ and type(IAgCrdnAxesTransformWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnAxesTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAxesFindInAxesResult.__dict__ and type(IAgCrdnAxesFindInAxesResult.__dict__[attrname]) == property: found_prop = IAgCrdnAxesFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAxesFindInAxesWithRateResult.__dict__ and type(IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnAxesFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPlaneFindInAxesResult.__dict__ and type(IAgCrdnPlaneFindInAxesResult.__dict__[attrname]) == property: found_prop = IAgCrdnPlaneFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPlaneFindInAxesWithRateResult.__dict__ and type(IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnPlaneFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPlaneFindInSystemResult.__dict__ and type(IAgCrdnPlaneFindInSystemResult.__dict__[attrname]) == property: found_prop = IAgCrdnPlaneFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPlaneFindInSystemWithRateResult.__dict__ and type(IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnPlaneFindInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPointLocateInSystemResult.__dict__ and type(IAgCrdnPointLocateInSystemResult.__dict__[attrname]) == property: found_prop = IAgCrdnPointLocateInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnPointLocateInSystemWithRateResult.__dict__ and type(IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnPointLocateInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnSystemTransformResult.__dict__ and type(IAgCrdnSystemTransformResult.__dict__[attrname]) == property: found_prop = IAgCrdnSystemTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnSystemTransformWithRateResult.__dict__ and type(IAgCrdnSystemTransformWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnSystemTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnSystemFindInSystemResult.__dict__ and type(IAgCrdnSystemFindInSystemResult.__dict__[attrname]) == property: found_prop = IAgCrdnSystemFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnVectorFindInAxesResult.__dict__ and type(IAgCrdnVectorFindInAxesResult.__dict__[attrname]) == property: found_prop = IAgCrdnVectorFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnVectorFindInAxesWithRateResult.__dict__ and type(IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnVectorFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAngleFindAngleWithRateResult.__dict__ and type(IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]) == property: found_prop = IAgCrdnAngleFindAngleWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnAngleFindAngleResult.__dict__ and type(IAgCrdnAngleFindAngleResult.__dict__[attrname]) == property: found_prop = IAgCrdnAngleFindAngleResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnMethodCallResult._uuid))
        if pUnkTest is not None:
            if attrname in IAgCrdnMethodCallResult.__dict__ and type(IAgCrdnMethodCallResult.__dict__[attrname]) == property: found_prop = IAgCrdnMethodCallResult.__dict__[attrname]
            del(pUnkTest)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnMethodCallResult.')
    def __getattr__(self, attrname):
        found_attr = None
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAngleFindResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAngleFindWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAxesTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAxesTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAxesFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAxesFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAxesFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPlaneFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPlaneFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPlaneFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPlaneFindInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPlaneFindInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPointLocateInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnPointLocateInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnPointLocateInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnSystemTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnSystemTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnSystemFindInSystemResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnSystemFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnVectorFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnVectorFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnVectorFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleWithRateResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAngleFindAngleWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnAngleFindAngleResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnAngleFindAngleResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__['_pUnk'].QueryInterface(agcom.GUID(IAgCrdnMethodCallResult._uuid))
        if pUnk is not None:
            intf = IAgCrdnMethodCallResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        if found_attr is not None:
            return found_attr
        else:
            raise STKAttributeError(attrname + ' is not a valid attribute in this instance of AgCrdnMethodCallResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{03665183-03A3-4ABE-9954-476CD71C8BB3}', AgCrdnMethodCallResult)
__all__.append('AgCrdnMethodCallResult')


class AgCrdnInterval(IAgCrdnInterval):
    """Represents an interval."""
    def __init__(self, sourceObject=None):
        IAgCrdnInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnInterval.')
        
agcls.AgClassCatalog.add_catalog_entry('{7825007C-4D30-46EC-A047-EAF6683C4187}', AgCrdnInterval)
__all__.append('AgCrdnInterval')


class AgCrdnIntervalCollection(IAgCrdnIntervalCollection):
    """Represents a collection of intervals."""
    def __init__(self, sourceObject=None):
        IAgCrdnIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnIntervalCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{908714CE-1D69-4F68-875A-9B584CF8F2A7}', AgCrdnIntervalCollection)
__all__.append('AgCrdnIntervalCollection')


class AgCrdnCentralBody(IAgCrdnCentralBody):
    """Represents an central body."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBody.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCentralBody._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBody._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBody._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCentralBody.')
        
agcls.AgClassCatalog.add_catalog_entry('{9A0248DF-B126-4448-A653-CD5C28DC9229}', AgCrdnCentralBody)
__all__.append('AgCrdnCentralBody')


class AgCrdnCentralBodyRefTo(IAgCrdnCentralBodyRefTo, IAgCrdnRefTo):
    """Represents a central body reference."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBodyRefTo.__init__(self, sourceObject)
        IAgCrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCentralBodyRefTo._private_init(self, pUnk)
        IAgCrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBodyRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBodyRefTo._get_property(self, attrname)
        if IAgCrdnRefTo._get_property(self, attrname) is not None: found_prop = IAgCrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCentralBodyRefTo.')
        
agcls.AgClassCatalog.add_catalog_entry('{AFB22A58-DB60-4A1B-B0D4-44916CACC759}', AgCrdnCentralBodyRefTo)
__all__.append('AgCrdnCentralBodyRefTo')


class AgCrdnCentralBodyCollection(IAgCrdnCentralBodyCollection):
    """A collection of central body names."""
    def __init__(self, sourceObject=None):
        IAgCrdnCentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCentralBodyCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnCentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCentralBodyCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{E8951B8F-E457-4289-9125-5381515552C4}', AgCrdnCentralBodyCollection)
__all__.append('AgCrdnCentralBodyCollection')


class AgCrdnCollection(IAgCrdnCollection):
    """A collection of VGT objects."""
    def __init__(self, sourceObject=None):
        IAgCrdnCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}', AgCrdnCollection)
__all__.append('AgCrdnCollection')


class AgCrdnPointSamplingResult(IAgCrdnPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingResult._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointSamplingResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}', AgCrdnPointSamplingResult)
__all__.append('AgCrdnPointSamplingResult')


class AgCrdnPointSamplingInterval(IAgCrdnPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointSamplingInterval.')
        
agcls.AgClassCatalog.add_catalog_entry('{8B7546E8-0228-4269-92D1-B3C186AF18EF}', AgCrdnPointSamplingInterval)
__all__.append('AgCrdnPointSamplingInterval')


class AgCrdnPointSamplingIntervalCollection(IAgCrdnPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnPointSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnPointSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnPointSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnPointSamplingIntervalCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{3F6CF6B1-7192-4960-927D-1FC328122E59}', AgCrdnPointSamplingIntervalCollection)
__all__.append('AgCrdnPointSamplingIntervalCollection')


class AgCrdnAxesSamplingResult(IAgCrdnAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingResult._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesSamplingResult.')
        
agcls.AgClassCatalog.add_catalog_entry('{54622168-5440-4C86-9539-A0CA336E554B}', AgCrdnAxesSamplingResult)
__all__.append('AgCrdnAxesSamplingResult')


class AgCrdnAxesSamplingInterval(IAgCrdnAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingInterval._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesSamplingInterval.')
        
agcls.AgClassCatalog.add_catalog_entry('{069BCA07-B5AB-4A46-A508-AFE218E21B2F}', AgCrdnAxesSamplingInterval)
__all__.append('AgCrdnAxesSamplingInterval')


class AgCrdnAxesSamplingIntervalCollection(IAgCrdnAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        IAgCrdnAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__['_pUnk'] = pUnk
        IAgCrdnAxesSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAgCrdnAxesSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = IAgCrdnAxesSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + ' is not a recognized attribute in AgCrdnAxesSamplingIntervalCollection.')
        
agcls.AgClassCatalog.add_catalog_entry('{4AD4C296-E643-4CB6-A34A-D33748117EEF}', AgCrdnAxesSamplingIntervalCollection)
__all__.append('AgCrdnAxesSamplingIntervalCollection')



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
