################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AgECrdnAngleType", "AgECrdnAxesType", "AgECrdnCalcScalarType", "AgECrdnConditionCombinedOperationType", "AgECrdnConditionSetType", 
"AgECrdnConditionThresholdOption", "AgECrdnConditionType", "AgECrdnDimensionInheritance", "AgECrdnDirectionType", "AgECrdnDisplayAxisSelector", 
"AgECrdnEventArrayFilterType", "AgECrdnEventArrayType", "AgECrdnEventIntervalCollectionType", "AgECrdnEventIntervalListType", 
"AgECrdnEventIntervalType", "AgECrdnEventListMergeOperation", "AgECrdnEventType", "AgECrdnExtremumConstants", "AgECrdnFileInterpolatorType", 
"AgECrdnIntegralType", "AgECrdnIntegrationWindowType", "AgECrdnInterpolatorType", "AgECrdnIntersectionSurface", "AgECrdnIntervalDurationKind", 
"AgECrdnIntervalSelection", "AgECrdnKind", "AgECrdnLagrangeLibrationPointType", "AgECrdnMeanElementTheory", "AgECrdnParameterSetType", 
"AgECrdnPlaneType", "AgECrdnPointBPlaneType", "AgECrdnPointType", "AgECrdnPruneFilter", "AgECrdnQuadrantType", "AgECrdnReferenceShapeType", 
"AgECrdnSampledReferenceTime", "AgECrdnSamplingMethod", "AgECrdnSatisfactionCrossing", "AgECrdnSaveDataOption", "AgECrdnSignalPathReferenceSystem", 
"AgECrdnSignalSense", "AgECrdnSignedAngleType", "AgECrdnSmartEpochState", "AgECrdnSmartIntervalState", "AgECrdnSpeedOptions", 
"AgECrdnStartStopOption", "AgECrdnSurfaceType", "AgECrdnSweepMode", "AgECrdnSystemType", "AgECrdnThreshConvergeSense", "AgECrdnTrajectoryAxesType", 
"AgECrdnVectorComponentType", "AgECrdnVectorScaledDimensionInheritance", "AgECrdnVectorType", "AgECrdnVolumeAberrationType", 
"AgECrdnVolumeCalcAltitudeReferenceType", "AgECrdnVolumeCalcAngleOffVectorType", "AgECrdnVolumeCalcRangeDistanceType", "AgECrdnVolumeCalcRangeSpeedType", 
"AgECrdnVolumeCalcType", "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType", "AgECrdnVolumeCalcVolumeSatisfactionDurationType", 
"AgECrdnVolumeCalcVolumeSatisfactionFilterType", "AgECrdnVolumeCalcVolumeSatisfactionMetricType", "AgECrdnVolumeClockHostType", 
"AgECrdnVolumeCombinedOperationType", "AgECrdnVolumeFromGridEdgeType", "AgECrdnVolumeGridType", "AgECrdnVolumeLightingConditionsType", 
"AgECrdnVolumeOverTimeDurationType", "AgECrdnVolumeResultVectorRequest", "AgECrdnVolumeTimeSenseType", "AgECrdnVolumeType", 
"AgECrdnVolumetricGridValuesMethodType", "CrdnAngle", "CrdnAngleBetweenPlanes", "CrdnAngleBetweenVectors", "CrdnAngleDihedral", 
"CrdnAngleFactory", "CrdnAngleGroup", "CrdnAngleRefTo", "CrdnAngleRotation", "CrdnAngleToPlane", "CrdnAxes", "CrdnAxesAlignedAndConstrained", 
"CrdnAxesAngularOffset", "CrdnAxesAtTimeInstant", "CrdnAxesAttitudeFile", "CrdnAxesBPlane", "CrdnAxesCommonTasks", "CrdnAxesCustomScript", 
"CrdnAxesFactory", "CrdnAxesFixed", "CrdnAxesFixedAtEpoch", "CrdnAxesGroup", "CrdnAxesLabels", "CrdnAxesLagrangeLibration", 
"CrdnAxesModelAttach", "CrdnAxesOnSurface", "CrdnAxesPlugin", "CrdnAxesRefTo", "CrdnAxesSamplingInterval", "CrdnAxesSamplingIntervalCollection", 
"CrdnAxesSamplingResult", "CrdnAxesSpinning", "CrdnAxesTrajectory", "CrdnCalcScalar", "CrdnCalcScalarAngle", "CrdnCalcScalarConstant", 
"CrdnCalcScalarCustom", "CrdnCalcScalarDataElement", "CrdnCalcScalarDerivative", "CrdnCalcScalarDotProduct", "CrdnCalcScalarElapsedTime", 
"CrdnCalcScalarFactory", "CrdnCalcScalarFile", "CrdnCalcScalarFixedAtTimeInstant", "CrdnCalcScalarFunction", "CrdnCalcScalarFunction2Var", 
"CrdnCalcScalarGroup", "CrdnCalcScalarIntegral", "CrdnCalcScalarPlugin", "CrdnCalcScalarSurfaceDistanceBetweenPoints", "CrdnCalcScalarVectorComponent", 
"CrdnCalcScalarVectorMagnitude", "CrdnCentralBody", "CrdnCentralBodyCollection", "CrdnCentralBodyRefTo", "CrdnCollection", 
"CrdnCondition", "CrdnConditionCombined", "CrdnConditionFactory", "CrdnConditionGroup", "CrdnConditionPointInVolume", "CrdnConditionScalarBounds", 
"CrdnConditionSet", "CrdnConditionSetEvaluateResult", "CrdnConditionSetEvaluateWithRateResult", "CrdnConditionSetFactory", 
"CrdnConditionSetGroup", "CrdnConditionSetScalarThresholds", "CrdnConverge", "CrdnConvergeBasic", "CrdnDerivative", "CrdnDerivativeBasic", 
"CrdnEvaluateResult", "CrdnEvaluateWithRateResult", "CrdnEvent", "CrdnEventArray", "CrdnEventArrayConditionCrossings", "CrdnEventArrayExtrema", 
"CrdnEventArrayFactory", "CrdnEventArrayFiltered", "CrdnEventArrayFixedStep", "CrdnEventArrayFixedTimes", "CrdnEventArrayGroup", 
"CrdnEventArrayMerged", "CrdnEventArraySignaled", "CrdnEventArrayStartStopTimes", "CrdnEventEpoch", "CrdnEventExtremum", 
"CrdnEventFactory", "CrdnEventFindOccurrenceResult", "CrdnEventGroup", "CrdnEventInterval", "CrdnEventIntervalBetweenTimeInstants", 
"CrdnEventIntervalCollection", "CrdnEventIntervalCollectionCondition", "CrdnEventIntervalCollectionFactory", "CrdnEventIntervalCollectionGroup", 
"CrdnEventIntervalCollectionLighting", "CrdnEventIntervalCollectionOccurredResult", "CrdnEventIntervalCollectionSignaled", 
"CrdnEventIntervalFactory", "CrdnEventIntervalFixed", "CrdnEventIntervalFixedDuration", "CrdnEventIntervalFromIntervalList", 
"CrdnEventIntervalGroup", "CrdnEventIntervalList", "CrdnEventIntervalListCondition", "CrdnEventIntervalListFactory", "CrdnEventIntervalListFile", 
"CrdnEventIntervalListFiltered", "CrdnEventIntervalListFixed", "CrdnEventIntervalListGroup", "CrdnEventIntervalListMerged", 
"CrdnEventIntervalListScaled", "CrdnEventIntervalListSignaled", "CrdnEventIntervalListTimeOffset", "CrdnEventIntervalResult", 
"CrdnEventIntervalScaled", "CrdnEventIntervalSignaled", "CrdnEventIntervalSmartInterval", "CrdnEventIntervalTimeOffset", 
"CrdnEventSignaled", "CrdnEventSmartEpoch", "CrdnEventStartStopTime", "CrdnEventTimeOffset", "CrdnFindTimesResult", "CrdnFirstIntervalsFilter", 
"CrdnGapsFilter", "CrdnGeneric", "CrdnGridCoordinateDefinition", "CrdnGridValuesCustom", "CrdnGridValuesFixedNumberOfSteps", 
"CrdnGridValuesFixedStep", "CrdnGridValuesMethod", "CrdnInstance", "CrdnIntegral", "CrdnIntegralBasic", "CrdnInterp", "CrdnInterpBasic", 
"CrdnInterval", "CrdnIntervalCollection", "CrdnIntervalListResult", "CrdnIntervalVectorCollection", "CrdnIntervalsFilter", 
"CrdnIntervalsVectorResult", "CrdnLLAPosition", "CrdnLastIntervalsFilter", "CrdnLightTimeDelay", "CrdnMethodCallResult", 
"CrdnParameterSet", "CrdnParameterSetAttitude", "CrdnParameterSetFactory", "CrdnParameterSetGroundTrajectory", "CrdnParameterSetGroup", 
"CrdnParameterSetOrbit", "CrdnParameterSetTrajectory", "CrdnParameterSetVector", "CrdnPlane", "CrdnPlaneFactory", "CrdnPlaneGroup", 
"CrdnPlaneLabels", "CrdnPlaneNormal", "CrdnPlaneQuadrant", "CrdnPlaneRefTo", "CrdnPlaneTrajectory", "CrdnPlaneTriad", "CrdnPlaneTwoVector", 
"CrdnPoint", "CrdnPointAtTimeInstant", "CrdnPointBPlane", "CrdnPointCBFixedOffset", "CrdnPointCentBodyIntersect", "CrdnPointCommonTasks", 
"CrdnPointCovarianceGrazing", "CrdnPointFactory", "CrdnPointFile", "CrdnPointFixedInSystem", "CrdnPointGlint", "CrdnPointGrazing", 
"CrdnPointGroup", "CrdnPointLagrangeLibration", "CrdnPointModelAttach", "CrdnPointOnSurface", "CrdnPointPlaneIntersection", 
"CrdnPointPlaneProjection", "CrdnPointPlugin", "CrdnPointRefTo", "CrdnPointSamplingInterval", "CrdnPointSamplingIntervalCollection", 
"CrdnPointSamplingResult", "CrdnPointSatelliteCollectionEntry", "CrdnProvider", "CrdnPruneFilter", "CrdnPruneFilterFactory", 
"CrdnRelativeSatisfactionConditionFilter", "CrdnRoot", "CrdnSampling", "CrdnSamplingBasic", "CrdnSamplingCurvatureTolerance", 
"CrdnSamplingFixedStep", "CrdnSamplingMethod", "CrdnSamplingMethodFactory", "CrdnSamplingRelativeTolerance", "CrdnSatisfactionConditionFilter", 
"CrdnSignalDelay", "CrdnSignalDelayBasic", "CrdnSystem", "CrdnSystemAssembled", "CrdnSystemCommonTasks", "CrdnSystemFactory", 
"CrdnSystemGroup", "CrdnSystemOnSurface", "CrdnSystemRefTo", "CrdnTemplate", "CrdnTypeInfo", "CrdnVector", "CrdnVectorAngleRate", 
"CrdnVectorAngularVelocity", "CrdnVectorApoapsis", "CrdnVectorConing", "CrdnVectorCross", "CrdnVectorCustomScript", "CrdnVectorDerivative", 
"CrdnVectorDirectionToStar", "CrdnVectorDispSurface", "CrdnVectorDisplacement", "CrdnVectorEccentricity", "CrdnVectorFactory", 
"CrdnVectorFixedAtEpoch", "CrdnVectorFixedAtTimeInstant", "CrdnVectorFixedInAxes", "CrdnVectorGroup", "CrdnVectorLineOfNodes", 
"CrdnVectorLinearCombination", "CrdnVectorModelAttach", "CrdnVectorOrbitAngularMomentum", "CrdnVectorOrbitNormal", "CrdnVectorPeriapsis", 
"CrdnVectorPlugin", "CrdnVectorProjectAlongVector", "CrdnVectorProjection", "CrdnVectorRefTo", "CrdnVectorReflection", "CrdnVectorRotationVector", 
"CrdnVectorScalarLinearCombination", "CrdnVectorScalarScaled", "CrdnVectorScaled", "CrdnVectorTwoPlanesIntersection", "CrdnVectorVelocityAcceleration", 
"CrdnVolume", "CrdnVolumeCalc", "CrdnVolumeCalcAltitude", "CrdnVolumeCalcAngleOffVector", "CrdnVolumeCalcConditionSatMetric", 
"CrdnVolumeCalcDelayRange", "CrdnVolumeCalcFactory", "CrdnVolumeCalcFile", "CrdnVolumeCalcFromScalar", "CrdnVolumeCalcGroup", 
"CrdnVolumeCalcRange", "CrdnVolumeCalcSolarIntensity", "CrdnVolumeCombined", "CrdnVolumeFactory", "CrdnVolumeFromCalc", 
"CrdnVolumeFromCondition", "CrdnVolumeFromGrid", "CrdnVolumeFromTimeSatisfaction", "CrdnVolumeGrid", "CrdnVolumeGridBearingAlt", 
"CrdnVolumeGridCartesian", "CrdnVolumeGridConstrained", "CrdnVolumeGridCylindrical", "CrdnVolumeGridFactory", "CrdnVolumeGridGroup", 
"CrdnVolumeGridLatLonAlt", "CrdnVolumeGridResult", "CrdnVolumeGridSpherical", "CrdnVolumeGroup", "CrdnVolumeInview", "CrdnVolumeLighting", 
"CrdnVolumeOverTime", "CrdnWellKnownAxes", "CrdnWellKnownEarthAxes", "CrdnWellKnownEarthSystems", "CrdnWellKnownSunAxes", 
"CrdnWellKnownSunSystems", "CrdnWellKnownSystems", "ICrdn", "ICrdnAngle", "ICrdnAngleBetweenPlanes", "ICrdnAngleBetweenVectors", 
"ICrdnAngleDihedral", "ICrdnAngleFactory", "ICrdnAngleFindAngleResult", "ICrdnAngleFindAngleWithRateResult", "ICrdnAngleFindResult", 
"ICrdnAngleFindWithRateResult", "ICrdnAngleGroup", "ICrdnAngleRefTo", "ICrdnAngleRotation", "ICrdnAngleToPlane", "ICrdnAxes", 
"ICrdnAxesAlignedAndConstrained", "ICrdnAxesAngularOffset", "ICrdnAxesAtTimeInstant", "ICrdnAxesAttitudeFile", "ICrdnAxesBPlane", 
"ICrdnAxesCommonTasks", "ICrdnAxesCustomScript", "ICrdnAxesFactory", "ICrdnAxesFindInAxesResult", "ICrdnAxesFindInAxesWithRateResult", 
"ICrdnAxesFixed", "ICrdnAxesFixedAtEpoch", "ICrdnAxesGroup", "ICrdnAxesLabels", "ICrdnAxesLagrangeLibration", "ICrdnAxesModelAttach", 
"ICrdnAxesOnSurface", "ICrdnAxesPlugin", "ICrdnAxesRefTo", "ICrdnAxesSamplingInterval", "ICrdnAxesSamplingIntervalCollection", 
"ICrdnAxesSamplingResult", "ICrdnAxesSpinning", "ICrdnAxesTrajectory", "ICrdnAxesTransformResult", "ICrdnAxesTransformWithRateResult", 
"ICrdnCalcScalar", "ICrdnCalcScalarAngle", "ICrdnCalcScalarConstant", "ICrdnCalcScalarCustom", "ICrdnCalcScalarDataElement", 
"ICrdnCalcScalarDerivative", "ICrdnCalcScalarDotProduct", "ICrdnCalcScalarElapsedTime", "ICrdnCalcScalarFactory", "ICrdnCalcScalarFile", 
"ICrdnCalcScalarFixedAtTimeInstant", "ICrdnCalcScalarFunction", "ICrdnCalcScalarFunction2Var", "ICrdnCalcScalarGroup", "ICrdnCalcScalarIntegral", 
"ICrdnCalcScalarPlugin", "ICrdnCalcScalarSurfaceDistanceBetweenPoints", "ICrdnCalcScalarVectorComponent", "ICrdnCalcScalarVectorMagnitude", 
"ICrdnCentralBody", "ICrdnCentralBodyCollection", "ICrdnCentralBodyRefTo", "ICrdnCollection", "ICrdnCondition", "ICrdnConditionCombined", 
"ICrdnConditionFactory", "ICrdnConditionGroup", "ICrdnConditionPointInVolume", "ICrdnConditionScalarBounds", "ICrdnConditionSet", 
"ICrdnConditionSetEvaluateResult", "ICrdnConditionSetEvaluateWithRateResult", "ICrdnConditionSetFactory", "ICrdnConditionSetGroup", 
"ICrdnConditionSetScalarThresholds", "ICrdnContext", "ICrdnConverge", "ICrdnConvergeBasic", "ICrdnDerivative", "ICrdnDerivativeBasic", 
"ICrdnEvaluateResult", "ICrdnEvaluateWithRateResult", "ICrdnEvent", "ICrdnEventArray", "ICrdnEventArrayConditionCrossings", 
"ICrdnEventArrayExtrema", "ICrdnEventArrayFactory", "ICrdnEventArrayFiltered", "ICrdnEventArrayFixedStep", "ICrdnEventArrayFixedTimes", 
"ICrdnEventArrayGroup", "ICrdnEventArrayMerged", "ICrdnEventArraySignaled", "ICrdnEventArrayStartStopTimes", "ICrdnEventEpoch", 
"ICrdnEventExtremum", "ICrdnEventFactory", "ICrdnEventFindOccurrenceResult", "ICrdnEventGroup", "ICrdnEventInterval", "ICrdnEventIntervalBetweenTimeInstants", 
"ICrdnEventIntervalCollection", "ICrdnEventIntervalCollectionCondition", "ICrdnEventIntervalCollectionFactory", "ICrdnEventIntervalCollectionGroup", 
"ICrdnEventIntervalCollectionLighting", "ICrdnEventIntervalCollectionOccurredResult", "ICrdnEventIntervalCollectionSignaled", 
"ICrdnEventIntervalFactory", "ICrdnEventIntervalFixed", "ICrdnEventIntervalFixedDuration", "ICrdnEventIntervalFromIntervalList", 
"ICrdnEventIntervalGroup", "ICrdnEventIntervalList", "ICrdnEventIntervalListCondition", "ICrdnEventIntervalListFactory", 
"ICrdnEventIntervalListFile", "ICrdnEventIntervalListFiltered", "ICrdnEventIntervalListFixed", "ICrdnEventIntervalListGroup", 
"ICrdnEventIntervalListMerged", "ICrdnEventIntervalListScaled", "ICrdnEventIntervalListSignaled", "ICrdnEventIntervalListTimeOffset", 
"ICrdnEventIntervalResult", "ICrdnEventIntervalScaled", "ICrdnEventIntervalSignaled", "ICrdnEventIntervalSmartInterval", 
"ICrdnEventIntervalTimeOffset", "ICrdnEventSignaled", "ICrdnEventSmartEpoch", "ICrdnEventStartStopTime", "ICrdnEventTimeOffset", 
"ICrdnFindTimesResult", "ICrdnFirstIntervalsFilter", "ICrdnGapsFilter", "ICrdnGridCoordinateDefinition", "ICrdnGridValuesCustom", 
"ICrdnGridValuesFixedNumberOfSteps", "ICrdnGridValuesFixedStep", "ICrdnGridValuesMethod", "ICrdnInstance", "ICrdnIntegral", 
"ICrdnIntegralBasic", "ICrdnInterp", "ICrdnInterpBasic", "ICrdnInterval", "ICrdnIntervalCollection", "ICrdnIntervalListResult", 
"ICrdnIntervalVectorCollection", "ICrdnIntervalsFilter", "ICrdnIntervalsVectorResult", "ICrdnLLAPosition", "ICrdnLastIntervalsFilter", 
"ICrdnLightTimeDelay", "ICrdnMethodCallResult", "ICrdnParameterSet", "ICrdnParameterSetAttitude", "ICrdnParameterSetFactory", 
"ICrdnParameterSetGroundTrajectory", "ICrdnParameterSetGroup", "ICrdnParameterSetOrbit", "ICrdnParameterSetTrajectory", 
"ICrdnParameterSetVector", "ICrdnPlane", "ICrdnPlaneFactory", "ICrdnPlaneFindInAxesResult", "ICrdnPlaneFindInAxesWithRateResult", 
"ICrdnPlaneFindInSystemResult", "ICrdnPlaneFindInSystemWithRateResult", "ICrdnPlaneGroup", "ICrdnPlaneLabels", "ICrdnPlaneNormal", 
"ICrdnPlaneQuadrant", "ICrdnPlaneRefTo", "ICrdnPlaneTrajectory", "ICrdnPlaneTriad", "ICrdnPlaneTwoVector", "ICrdnPoint", 
"ICrdnPointAtTimeInstant", "ICrdnPointBPlane", "ICrdnPointCBFixedOffset", "ICrdnPointCentBodyIntersect", "ICrdnPointCommonTasks", 
"ICrdnPointCovarianceGrazing", "ICrdnPointFactory", "ICrdnPointFile", "ICrdnPointFixedInSystem", "ICrdnPointGlint", "ICrdnPointGrazing", 
"ICrdnPointGroup", "ICrdnPointLagrangeLibration", "ICrdnPointLocateInSystemResult", "ICrdnPointLocateInSystemWithRateResult", 
"ICrdnPointModelAttach", "ICrdnPointOnSurface", "ICrdnPointPlaneIntersection", "ICrdnPointPlaneProjection", "ICrdnPointPlugin", 
"ICrdnPointRefTo", "ICrdnPointSamplingInterval", "ICrdnPointSamplingIntervalCollection", "ICrdnPointSamplingResult", "ICrdnPointSatelliteCollectionEntry", 
"ICrdnProvider", "ICrdnPruneFilter", "ICrdnPruneFilterFactory", "ICrdnRefTo", "ICrdnRelativeSatisfactionConditionFilter", 
"ICrdnRoot", "ICrdnSampling", "ICrdnSamplingBasic", "ICrdnSamplingCurvatureTolerance", "ICrdnSamplingFixedStep", "ICrdnSamplingMethod", 
"ICrdnSamplingMethodFactory", "ICrdnSamplingRelativeTolerance", "ICrdnSatisfactionConditionFilter", "ICrdnSignalDelay", 
"ICrdnSignalDelayBasic", "ICrdnSystem", "ICrdnSystemAssembled", "ICrdnSystemCommonTasks", "ICrdnSystemFactory", "ICrdnSystemFindInSystemResult", 
"ICrdnSystemGroup", "ICrdnSystemOnSurface", "ICrdnSystemRefTo", "ICrdnSystemTransformResult", "ICrdnSystemTransformWithRateResult", 
"ICrdnTemplate", "ICrdnTimeProperties", "ICrdnTypeInfo", "ICrdnVector", "ICrdnVectorAngleRate", "ICrdnVectorAngularVelocity", 
"ICrdnVectorApoapsis", "ICrdnVectorConing", "ICrdnVectorCross", "ICrdnVectorCustomScript", "ICrdnVectorDerivative", "ICrdnVectorDirectionToStar", 
"ICrdnVectorDispSurface", "ICrdnVectorDisplacement", "ICrdnVectorEccentricity", "ICrdnVectorFactory", "ICrdnVectorFindInAxesResult", 
"ICrdnVectorFindInAxesWithRateResult", "ICrdnVectorFixedAtEpoch", "ICrdnVectorFixedAtTimeInstant", "ICrdnVectorFixedInAxes", 
"ICrdnVectorGroup", "ICrdnVectorLineOfNodes", "ICrdnVectorLinearCombination", "ICrdnVectorModelAttach", "ICrdnVectorOrbitAngularMomentum", 
"ICrdnVectorOrbitNormal", "ICrdnVectorPeriapsis", "ICrdnVectorPlugin", "ICrdnVectorProjectAlongVector", "ICrdnVectorProjection", 
"ICrdnVectorRefTo", "ICrdnVectorReflection", "ICrdnVectorRotationVector", "ICrdnVectorScalarLinearCombination", "ICrdnVectorScalarScaled", 
"ICrdnVectorScaled", "ICrdnVectorTwoPlanesIntersection", "ICrdnVectorVelocityAcceleration", "ICrdnVolume", "ICrdnVolumeCalc", 
"ICrdnVolumeCalcAltitude", "ICrdnVolumeCalcAngleOffVector", "ICrdnVolumeCalcConditionSatMetric", "ICrdnVolumeCalcDelayRange", 
"ICrdnVolumeCalcFactory", "ICrdnVolumeCalcFile", "ICrdnVolumeCalcFromScalar", "ICrdnVolumeCalcGroup", "ICrdnVolumeCalcRange", 
"ICrdnVolumeCalcSolarIntensity", "ICrdnVolumeCombined", "ICrdnVolumeFactory", "ICrdnVolumeFromCalc", "ICrdnVolumeFromCondition", 
"ICrdnVolumeFromGrid", "ICrdnVolumeFromTimeSatisfaction", "ICrdnVolumeGrid", "ICrdnVolumeGridBearingAlt", "ICrdnVolumeGridCartesian", 
"ICrdnVolumeGridConstrained", "ICrdnVolumeGridCylindrical", "ICrdnVolumeGridFactory", "ICrdnVolumeGridGroup", "ICrdnVolumeGridLatLonAlt", 
"ICrdnVolumeGridResult", "ICrdnVolumeGridSpherical", "ICrdnVolumeGroup", "ICrdnVolumeInview", "ICrdnVolumeLighting", "ICrdnVolumeOverTime", 
"ICrdnWellKnownAxes", "ICrdnWellKnownEarthAxes", "ICrdnWellKnownEarthSystems", "ICrdnWellKnownSunAxes", "ICrdnWellKnownSunSystems", 
"ICrdnWellKnownSystems"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame
except ModuleNotFoundError:
    pass

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal  import dataanalysisutil as agdata
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IDispatch, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgECrdnCalcScalarType(IntEnum):
    """Defines available calculation scalar types."""
    # Unknown or unsupported calculation scalar types
    eCrdnCalcScalarTypeUnknown = -1
    # Scalar equal to angular displacement obtained from any angle in VGT.
    eCrdnCalcScalarTypeAngle = 0
    # Constant scalar created by evaluating input scalar calculation at specified reference time instant.
    eCrdnCalcScalarTypeFixedAtTimeInstant = 1
    # Constant scalar value of specified dimension.
    eCrdnCalcScalarTypeConstant = 2
    # Any time-dependent data element from STK data providers available for parent STK object.
    eCrdnCalcScalarTypeDataElement = 3
    # Derivative of input scalar calculation.
    eCrdnCalcScalarTypeDerivative = 4
    # Time elapsed since reference time instant.
    eCrdnCalcScalarTypeElapsedTime = 5
    # Tabulated scalar calculation data loaded from specified file.
    eCrdnCalcScalarTypeFile = 6
    # Defined by performing one of specified functions on input scalar.
    eCrdnCalcScalarTypeFunction = 7
    # Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types.
    eCrdnCalcScalarTypeIntegral = 8
    # Defined by performing one of specified binary operations on two scalar arguments.
    eCrdnCalcScalarTypeFunction2Var = 9
    # Scalar equal to magnitude of specified vector.
    eCrdnCalcScalarTypeVectorMagnitude = 10
    # A calc scalar plugin based on a COM object.
    eCrdnCalcScalarTypePlugin = 11
    # A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate.
    eCrdnCalcScalarTypeCustomScript = 12
    # Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude).
    eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints = 13
    # Scalar equal to the dot product between two vectors.
    eCrdnCalcScalarTypeDotProduct = 14
    # Scalar equal to the specified component of a vector when resolved in the specified axes.
    eCrdnCalcScalarTypeVectorComponent = 15

AgECrdnCalcScalarType.eCrdnCalcScalarTypeUnknown.__doc__ = "Unknown or unsupported calculation scalar types"
AgECrdnCalcScalarType.eCrdnCalcScalarTypeAngle.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFixedAtTimeInstant.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeConstant.__doc__ = "Constant scalar value of specified dimension."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDataElement.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDerivative.__doc__ = "Derivative of input scalar calculation."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeElapsedTime.__doc__ = "Time elapsed since reference time instant."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFile.__doc__ = "Tabulated scalar calculation data loaded from specified file."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction.__doc__ = "Defined by performing one of specified functions on input scalar."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeIntegral.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeFunction2Var.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorMagnitude.__doc__ = "Scalar equal to magnitude of specified vector."
AgECrdnCalcScalarType.eCrdnCalcScalarTypePlugin.__doc__ = "A calc scalar plugin based on a COM object."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeCustomScript.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeSurfaceDistanceBetweenPoints.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeDotProduct.__doc__ = "Scalar equal to the dot product between two vectors."
AgECrdnCalcScalarType.eCrdnCalcScalarTypeVectorComponent.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."

agcls.AgTypeNameMap["AgECrdnCalcScalarType"] = AgECrdnCalcScalarType

class AgECrdnConditionCombinedOperationType(IntEnum):
    """Defines scalar condition combined operation types."""
    # Scalar condition combined AND operation.
    eCrdnConditionCombinedOperationTypeAND = 1
    # Scalar condition combined OR operation.
    eCrdnConditionCombinedOperationTypeOR = 2
    # Scalar condition combined XOR operation.
    eCrdnConditionCombinedOperationTypeXOR = 3
    # Scalar condition combined MINUS operation.
    eCrdnConditionCombinedOperationTypeMINUS = 4

AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeAND.__doc__ = "Scalar condition combined AND operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeOR.__doc__ = "Scalar condition combined OR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeXOR.__doc__ = "Scalar condition combined XOR operation."
AgECrdnConditionCombinedOperationType.eCrdnConditionCombinedOperationTypeMINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnConditionCombinedOperationType"] = AgECrdnConditionCombinedOperationType

class AgECrdnConditionSetType(IntEnum):
    """Defines available condition set types."""
    # Unknown or unsupported condition set types.
    eCrdnConditionSetTypeUnknown = -1
    # Condition set placing multiple thresholds on specified scalar.
    eCrdnConditionSetTypeScalarThresholds = 0

AgECrdnConditionSetType.eCrdnConditionSetTypeUnknown.__doc__ = "Unknown or unsupported condition set types."
AgECrdnConditionSetType.eCrdnConditionSetTypeScalarThresholds.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["AgECrdnConditionSetType"] = AgECrdnConditionSetType

class AgECrdnConditionThresholdOption(IntEnum):
    """Operations for Scalar Bounds Condition"""
    # Bound is above a minimum value
    eCrdnConditionThresholdOptionAboveMin = 1
    # Bound is below a maximum value
    eCrdnConditionThresholdOptionBelowMax = 2
    # Bound is between a minimum and maximum value
    eCrdnConditionThresholdOptionInsideMinMax = 3
    # Bound is outside a minimum and maximum value
    eCrdnConditionThresholdOptionOutsideMinMax = 4

AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionAboveMin.__doc__ = "Bound is above a minimum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionBelowMax.__doc__ = "Bound is below a maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionInsideMinMax.__doc__ = "Bound is between a minimum and maximum value"
AgECrdnConditionThresholdOption.eCrdnConditionThresholdOptionOutsideMinMax.__doc__ = "Bound is outside a minimum and maximum value"

agcls.AgTypeNameMap["AgECrdnConditionThresholdOption"] = AgECrdnConditionThresholdOption

class AgECrdnConditionType(IntEnum):
    """Defines available condition types."""
    # Unknown or unsupported condition type
    eCrdnConditionTypeUnknown = -1
    # Condition placing bounds on specified scalar.
    eCrdnConditionTypeScalarBounds = 0
    # Multiple conditiones on specified scalar.
    eCrdnConditionTypeCombined = 1
    # Condition placing point in volume.
    eCrdnConditionTypePointInVolume = 2

AgECrdnConditionType.eCrdnConditionTypeUnknown.__doc__ = "Unknown or unsupported condition type"
AgECrdnConditionType.eCrdnConditionTypeScalarBounds.__doc__ = "Condition placing bounds on specified scalar."
AgECrdnConditionType.eCrdnConditionTypeCombined.__doc__ = "Multiple conditiones on specified scalar."
AgECrdnConditionType.eCrdnConditionTypePointInVolume.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["AgECrdnConditionType"] = AgECrdnConditionType

class AgECrdnDimensionInheritance(IntEnum):
    """Defines how dimension is inherited"""
    # Do not inherit dimension.
    eCrdnDimensionInheritanceNone = 0
    # Inherit dimension from X scalar.
    eCrdnDimensionInheritanceFromX = 1
    # Inherit dimension from Y scalar.
    eCrdnDimensionInheritanceFromY = 2

AgECrdnDimensionInheritance.eCrdnDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromX.__doc__ = "Inherit dimension from X scalar."
AgECrdnDimensionInheritance.eCrdnDimensionInheritanceFromY.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["AgECrdnDimensionInheritance"] = AgECrdnDimensionInheritance

class AgECrdnEventArrayFilterType(IntEnum):
    """Event array filter types."""
    # Skip time step
    eCrdnEventArrayFilterTypeSkipTimeStep = 0
    # Skip count
    eCrdnEventArrayFilterTypeSkipCount = 1
    # Intervals
    eCrdnEventArrayFilterTypeIntervals = 2

AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipTimeStep.__doc__ = "Skip time step"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeSkipCount.__doc__ = "Skip count"
AgECrdnEventArrayFilterType.eCrdnEventArrayFilterTypeIntervals.__doc__ = "Intervals"

agcls.AgTypeNameMap["AgECrdnEventArrayFilterType"] = AgECrdnEventArrayFilterType

class AgECrdnEventArrayType(IntEnum):
    """Defines available time array types."""
    # Unknown or unsupported time array types
    eCrdnEventArrayTypeUnknown = -1
    # Determines time of local minimum and/or maximum of specified scalar calculation.
    eCrdnEventArrayTypeExtrema = 0
    # Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array.
    eCrdnEventArrayTypeStartStopTimes = 1
    # Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays.
    eCrdnEventArrayTypeMerged = 2
    # Defined by filtering times from original time array according to specified filtering method.
    eCrdnEventArrayTypeFiltered = 3
    # Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list.
    eCrdnEventArrayTypeFixedStep = 4
    # Time array containing times at which specified condition changes its satisfaction status.
    eCrdnEventArrayTypeConditionCrossings = 5
    # Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations.
    eCrdnEventArrayTypeSignaled = 6
    # Time array containing specific times.
    eCrdnEventArrayTypeFixedTimes = 7

AgECrdnEventArrayType.eCrdnEventArrayTypeUnknown.__doc__ = "Unknown or unsupported time array types"
AgECrdnEventArrayType.eCrdnEventArrayTypeExtrema.__doc__ = "Determines time of local minimum and/or maximum of specified scalar calculation."
AgECrdnEventArrayType.eCrdnEventArrayTypeStartStopTimes.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
AgECrdnEventArrayType.eCrdnEventArrayTypeMerged.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
AgECrdnEventArrayType.eCrdnEventArrayTypeFiltered.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedStep.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
AgECrdnEventArrayType.eCrdnEventArrayTypeConditionCrossings.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
AgECrdnEventArrayType.eCrdnEventArrayTypeSignaled.__doc__ = "Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
AgECrdnEventArrayType.eCrdnEventArrayTypeFixedTimes.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["AgECrdnEventArrayType"] = AgECrdnEventArrayType

class AgECrdnEventIntervalCollectionType(IntEnum):
    """Defines available interval collection types."""
    # Unknown or unsupported interval collection types
    eCrdnEventIntervalCollectionTypeUnknown = -1
    # Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies.
    eCrdnEventIntervalCollectionTypeLighting = 0
    # Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations.
    eCrdnEventIntervalCollectionTypeSignaled = 1
    # Interval collection containing intervals during which condition set is satisfied.
    eCrdnEventIntervalCollectionTypeCondition = 2

AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeUnknown.__doc__ = "Unknown or unsupported interval collection types"
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeLighting.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeSignaled.__doc__ = "Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
AgECrdnEventIntervalCollectionType.eCrdnEventIntervalCollectionTypeCondition.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["AgECrdnEventIntervalCollectionType"] = AgECrdnEventIntervalCollectionType

class AgECrdnEventIntervalListType(IntEnum):
    """Defines available interval list types."""
    # Unknown or unsupported interval list types
    eCrdnEventIntervalListTypeUnknown = -1
    # Interval list created by merging two constituent interval lists using specified logical operation.
    eCrdnEventIntervalListTypeMerged = 1
    # Defined by filtering intervals from original interval list using specified filtering method.
    eCrdnEventIntervalListTypeFiltered = 2
    # Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction).
    eCrdnEventIntervalListTypeCondition = 3
    # Interval List defined by scaling every interval in original interval list using either absolute or relative scale.
    eCrdnEventIntervalListTypeScaled = 4
    # Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations.
    eCrdnEventIntervalListTypeSignaled = 5
    # Interval List defined by shifting specified reference interval list by fixed time offset.
    eCrdnEventIntervalListTypeTimeOffset = 6
    # Interval list loaded from specified interval file
    eCrdnEventIntervalListTypeFile = 0
    # Interval list with individual intervals defined between explicitly specified start and stop times.
    eCrdnEventIntervalListTypeFixed = 7

AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeUnknown.__doc__ = "Unknown or unsupported interval list types"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeMerged.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFiltered.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeCondition.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeScaled.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeSignaled.__doc__ = "Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeTimeOffset.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFile.__doc__ = "Interval list loaded from specified interval file"
AgECrdnEventIntervalListType.eCrdnEventIntervalListTypeFixed.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["AgECrdnEventIntervalListType"] = AgECrdnEventIntervalListType

class AgECrdnEventIntervalType(IntEnum):
    """Defines available interval types."""
    # Unknown or unsupported interval types
    eCrdnEventIntervalTypeUnknown = -1
    # Interval defined between two explicitly specified start and stop times.
    eCrdnEventIntervalTypeFixed = 0
    # Interval of fixed duration specified using start and stop offsets relative to specified reference time instant.
    eCrdnEventIntervalTypeFixedDuration = 1
    # Interval between specified start and stop time instants.
    eCrdnEventIntervalTypeBetweenTimeInstants = 2
    # Interval created from specified interval list by using one of several selection methods.
    eCrdnEventIntervalTypeFromIntervalList = 3
    # Interval defined by scaling original interval using either absolute or relative scale.
    eCrdnEventIntervalTypeScaled = 4
    # Determines an interval recorded at a target clock location by performing signal transmission.
    eCrdnEventIntervalTypeSignaled = 5
    # Interval defined by shifting specified reference interval by fixed time offset.
    eCrdnEventIntervalTypeTimeOffset = 6
    # A smart interval.
    eCrdnEventIntervalTypeSmartInterval = 7

AgECrdnEventIntervalType.eCrdnEventIntervalTypeUnknown.__doc__ = "Unknown or unsupported interval types"
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixed.__doc__ = "Interval defined between two explicitly specified start and stop times."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFixedDuration.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeBetweenTimeInstants.__doc__ = "Interval between specified start and stop time instants."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeFromIntervalList.__doc__ = "Interval created from specified interval list by using one of several selection methods."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeScaled.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSignaled.__doc__ = "Determines an interval recorded at a target clock location by performing signal transmission."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeTimeOffset.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
AgECrdnEventIntervalType.eCrdnEventIntervalTypeSmartInterval.__doc__ = "A smart interval."

agcls.AgTypeNameMap["AgECrdnEventIntervalType"] = AgECrdnEventIntervalType

class AgECrdnEventListMergeOperation(IntEnum):
    """Defines merge operations for interval lists."""
    # Intervals both in A and B
    eCrdnEventListMergeOperationAND = 0
    # Intervals in A or B
    eCrdnEventListMergeOperationOR = 1
    # Intervals in A or B but not in both
    eCrdnEventListMergeOperationXOR = 2
    # Intervals in A and not in B
    eCrdnEventListMergeOperationMINUS = 3

AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationAND.__doc__ = "Intervals both in A and B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationOR.__doc__ = "Intervals in A or B"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationXOR.__doc__ = "Intervals in A or B but not in both"
AgECrdnEventListMergeOperation.eCrdnEventListMergeOperationMINUS.__doc__ = "Intervals in A and not in B"

agcls.AgTypeNameMap["AgECrdnEventListMergeOperation"] = AgECrdnEventListMergeOperation

class AgECrdnEventType(IntEnum):
    """Defines available time instant types."""
    # Unknown or unsupported time instant types
    eCrdnEventTypeUnknown = -1
    # Time instant set at specified date/time
    eCrdnEventTypeEpoch = 0
    # Determines time of global minimum or maximum of specified scalar calculation.
    eCrdnEventTypeExtremum = 1
    # Start or stop time of selected reference interval
    eCrdnEventTypeFromInterval = 2
    # Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations.
    eCrdnEventTypeSignaled = 3
    # Time instant at fixed offset from specified reference time instant
    eCrdnEventTypeTimeOffset = 4
    # A smart epoch.
    eCrdnEventTypeSmartEpoch = 5

AgECrdnEventType.eCrdnEventTypeUnknown.__doc__ = "Unknown or unsupported time instant types"
AgECrdnEventType.eCrdnEventTypeEpoch.__doc__ = "Time instant set at specified date/time"
AgECrdnEventType.eCrdnEventTypeExtremum.__doc__ = "Determines time of global minimum or maximum of specified scalar calculation."
AgECrdnEventType.eCrdnEventTypeFromInterval.__doc__ = "Start or stop time of selected reference interval"
AgECrdnEventType.eCrdnEventTypeSignaled.__doc__ = "Determines what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
AgECrdnEventType.eCrdnEventTypeTimeOffset.__doc__ = "Time instant at fixed offset from specified reference time instant"
AgECrdnEventType.eCrdnEventTypeSmartEpoch.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["AgECrdnEventType"] = AgECrdnEventType

class AgECrdnExtremumConstants(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
    # Find the minimum value
    eCrdnExtremumMinimum = 1
    # Find the maximum value
    eCrdnExtremumMaximum = 2

AgECrdnExtremumConstants.eCrdnExtremumMinimum.__doc__ = "Find the minimum value"
AgECrdnExtremumConstants.eCrdnExtremumMaximum.__doc__ = "Find the maximum value"

agcls.AgTypeNameMap["AgECrdnExtremumConstants"] = AgECrdnExtremumConstants

class AgECrdnFileInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnFileInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnFileInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnFileInterpolatorTypeHermite = 2
    # Holds the value at the closest previous sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldPrevious = 3
    # Holds the value at the closest next sample time to any requested time.
    eCrdnFileInterpolatorTypeHoldNext = 4
    # Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time.
    eCrdnFileInterpolatorTypeHoldNearest = 5

AgECrdnFileInterpolatorType.eCrdnFileInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHermite.__doc__ = "Hermite interpolation."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldPrevious.__doc__ = "Holds the value at the closest previous sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNext.__doc__ = "Holds the value at the closest next sample time to any requested time."
AgECrdnFileInterpolatorType.eCrdnFileInterpolatorTypeHoldNearest.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["AgECrdnFileInterpolatorType"] = AgECrdnFileInterpolatorType

class AgECrdnIntegralType(IntEnum):
    """Integral types."""
    # Simpson integral method
    eCrdnIntegralTypeFixedStepSimpson = 2
    # Trapezoidal integral method
    eCrdnIntegralTypeFixedStepTrapz = 1
    # Adaptive Lobatto integral method
    eCrdnIntegralTypeAdaptiveStep = 3

AgECrdnIntegralType.eCrdnIntegralTypeFixedStepSimpson.__doc__ = "Simpson integral method"
AgECrdnIntegralType.eCrdnIntegralTypeFixedStepTrapz.__doc__ = "Trapezoidal integral method"
AgECrdnIntegralType.eCrdnIntegralTypeAdaptiveStep.__doc__ = "Adaptive Lobatto integral method"

agcls.AgTypeNameMap["AgECrdnIntegralType"] = AgECrdnIntegralType

class AgECrdnIntegrationWindowType(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
    # Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant.
    eCrdnIntegrationWindowTypeTotal = 0
    # Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time.
    eCrdnIntegrationWindowTypeCumulativeToCurrent = 1
    # Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time.
    eCrdnIntegrationWindowTypeCumulativeFromCurrent = 2
    # Defines the integral's window as the interval of times centered around the current time with the specified front and back durations.
    eCrdnIntegrationWindowTypeSlidingWindow = 3

AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeTotal.__doc__ = "Defines the integral's window as the entire available interval list which effectively makes the value of the integral constant."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeToCurrent.__doc__ = "Defines the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeCumulativeFromCurrent.__doc__ = "Defines the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
AgECrdnIntegrationWindowType.eCrdnIntegrationWindowTypeSlidingWindow.__doc__ = "Defines the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["AgECrdnIntegrationWindowType"] = AgECrdnIntegrationWindowType

class AgECrdnInterpolatorType(IntEnum):
    """Interpolator types."""
    # Unknown or invalid interpolator.
    eCrdnInterpolatorInvalid = -1
    # Lagrange interpolation.
    eCrdnInterpolatorTypeLagrange = 1
    # Hermite interpolation.
    eCrdnInterpolatorTypeHermite = 2

AgECrdnInterpolatorType.eCrdnInterpolatorInvalid.__doc__ = "Unknown or invalid interpolator."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeLagrange.__doc__ = "Lagrange interpolation."
AgECrdnInterpolatorType.eCrdnInterpolatorTypeHermite.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["AgECrdnInterpolatorType"] = AgECrdnInterpolatorType

class AgECrdnIntervalDurationKind(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays"""
    # Filter by at least a specified number of seconds
    eCrdnIntervalDurationKindAtLeast = 0
    # Filter by at most a specified number of seconds
    eCrdnIntervalDurationKindAtMost = 1

AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtLeast.__doc__ = "Filter by at least a specified number of seconds"
AgECrdnIntervalDurationKind.eCrdnIntervalDurationKindAtMost.__doc__ = "Filter by at most a specified number of seconds"

agcls.AgTypeNameMap["AgECrdnIntervalDurationKind"] = AgECrdnIntervalDurationKind

class AgECrdnIntervalSelection(IntEnum):
    """Select the method to choose an interval from an interval list"""
    # Select an interval by counting a specified number from the first interval
    eCrdnIntervalSelectionFromStart = 1
    # Select an interval by counting a specified number back from the last interval
    eCrdnIntervalSelectionFromEnd = 2
    # Select the interval with the largest duration
    eCrdnIntervalSelectionMaxDuration = 4
    # Select the interval with the smallest duration
    eCrdnIntervalSelectionMinDuration = 5
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMaxGap = 9
    # Select the largest gap between intervals
    eCrdnIntervalSelectionMinGap = 10
    # Select the interval that is the span of the interval list
    eCrdnIntervalSelectionSpan = 100

AgECrdnIntervalSelection.eCrdnIntervalSelectionFromStart.__doc__ = "Select an interval by counting a specified number from the first interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionFromEnd.__doc__ = "Select an interval by counting a specified number back from the last interval"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxDuration.__doc__ = "Select the interval with the largest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinDuration.__doc__ = "Select the interval with the smallest duration"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMaxGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionMinGap.__doc__ = "Select the largest gap between intervals"
AgECrdnIntervalSelection.eCrdnIntervalSelectionSpan.__doc__ = "Select the interval that is the span of the interval list"

agcls.AgTypeNameMap["AgECrdnIntervalSelection"] = AgECrdnIntervalSelection

class AgECrdnParameterSetType(IntEnum):
    """Defines parameter set types."""
    # Unknown or unsupported parameter set
    eCrdnParameterSetTypeUnknown = -1
    # A parameter set type is defined by identifying one set of axes in reference to another.
    eCrdnParameterSetTypeAttitude = 0
    # A parameter set type is defined by identifying location in reference central body.
    eCrdnParameterSetTypeGroundTrajectory = 1
    # A parameter set type is defined by identifying location in reference coordinate system.
    eCrdnParameterSetTypeTrajectory = 2
    # A parameter set type is defined by identifying orbiting point and its central body.
    eCrdnParameterSetTypeOrbit = 3
    # A parameter set type is defined by identifying vector in reference axes.
    eCrdnParameterSetTypeVector = 4

AgECrdnParameterSetType.eCrdnParameterSetTypeUnknown.__doc__ = "Unknown or unsupported parameter set"
AgECrdnParameterSetType.eCrdnParameterSetTypeAttitude.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
AgECrdnParameterSetType.eCrdnParameterSetTypeGroundTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeTrajectory.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
AgECrdnParameterSetType.eCrdnParameterSetTypeOrbit.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
AgECrdnParameterSetType.eCrdnParameterSetTypeVector.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["AgECrdnParameterSetType"] = AgECrdnParameterSetType

class AgECrdnPruneFilter(IntEnum):
    """Specify the filter for filtering interval lists or time arrays"""
    # Unknown or unsupported prune filter
    eCrdnPruneFilterUnknown = 0
    # Selects specified number of first intervals from original list
    eCrdnPruneFilterFirstIntervals = 1
    # Selects specified number of last intervals from original list
    eCrdnPruneFilterLastIntervals = 2
    # Selects intervals which satisfy additional duration condition.
    eCrdnPruneFilterIntervals = 3
    # Selects gaps between intervals which satisfy additional duration condition.
    eCrdnPruneFilterGaps = 4
    # Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterSatisfactionIntervals = 5
    # Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration.
    eCrdnPruneFilterRelativeSatisfactionIntervals = 6

AgECrdnPruneFilter.eCrdnPruneFilterUnknown.__doc__ = "Unknown or unsupported prune filter"
AgECrdnPruneFilter.eCrdnPruneFilterFirstIntervals.__doc__ = "Selects specified number of first intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterLastIntervals.__doc__ = "Selects specified number of last intervals from original list"
AgECrdnPruneFilter.eCrdnPruneFilterIntervals.__doc__ = "Selects intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterGaps.__doc__ = "Selects gaps between intervals which satisfy additional duration condition."
AgECrdnPruneFilter.eCrdnPruneFilterSatisfactionIntervals.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
AgECrdnPruneFilter.eCrdnPruneFilterRelativeSatisfactionIntervals.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["AgECrdnPruneFilter"] = AgECrdnPruneFilter

class AgECrdnSampledReferenceTime(IntEnum):
    """Event array reference type."""
    # Use a Time Instant as the reference time
    eCrdnSampledReferenceTimeReferenceEvent = 0
    # Use the start of each interval as the reference time
    eCrdnSampledReferenceTimeStartOfEachInterval = 1
    # Use the stop of each interval as the reference time
    eCrdnSampledReferenceTimeStopOfEachInterval = 2
    # Use the start of each interval list as the reference time
    eCrdnSampledReferenceTimeStartOfIntervalList = 3
    # Use the stop of each interval list as the reference time
    eCrdnSampledReferenceTimeStopOfIntervalList = 4

AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeReferenceEvent.__doc__ = "Use a Time Instant as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfEachInterval.__doc__ = "Use the start of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfEachInterval.__doc__ = "Use the stop of each interval as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStartOfIntervalList.__doc__ = "Use the start of each interval list as the reference time"
AgECrdnSampledReferenceTime.eCrdnSampledReferenceTimeStopOfIntervalList.__doc__ = "Use the stop of each interval list as the reference time"

agcls.AgTypeNameMap["AgECrdnSampledReferenceTime"] = AgECrdnSampledReferenceTime

class AgECrdnSamplingMethod(IntEnum):
    """Defines the Sampling Method"""
    # Unknown or unsupported sampling method
    eCrdnSamplingMethodUnknown = 0
    # Fixed step sampling method
    eCrdnSamplingMethodFixedStep = 1
    # Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples.
    eCrdnSamplingMethodRelativeTolerance = 2
    # Curvature tolerance also uses changes in slope between samples
    eCrdnSamplingMethodCurvatureTolerance = 3

AgECrdnSamplingMethod.eCrdnSamplingMethodUnknown.__doc__ = "Unknown or unsupported sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodFixedStep.__doc__ = "Fixed step sampling method"
AgECrdnSamplingMethod.eCrdnSamplingMethodRelativeTolerance.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
AgECrdnSamplingMethod.eCrdnSamplingMethodCurvatureTolerance.__doc__ = "Curvature tolerance also uses changes in slope between samples"

agcls.AgTypeNameMap["AgECrdnSamplingMethod"] = AgECrdnSamplingMethod

class AgECrdnSatisfactionCrossing(IntEnum):
    """Direction crossing flags."""
    # Use either off-to-on or on-to-off condition to determine satisfaction
    eCrdnSatisfactionCrossingNone = 0
    # Satisfaction occurs when crossing from off to on condition
    eCrdnSatisfactionCrossingIn = 1
    # Satisfaction occurs when crossing from on to off condition
    eCrdnSatisfactionCrossingOut = 2

AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingNone.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingIn.__doc__ = "Satisfaction occurs when crossing from off to on condition"
AgECrdnSatisfactionCrossing.eCrdnSatisfactionCrossingOut.__doc__ = "Satisfaction occurs when crossing from on to off condition"

agcls.AgTypeNameMap["AgECrdnSatisfactionCrossing"] = AgECrdnSatisfactionCrossing

class AgECrdnSaveDataOption(IntEnum):
    """Method for saving computed data"""
    # Use the application setting to determine whether computed data should be saved/loaded.
    eCrdnSaveDataOptionApplicationSettings = -1
    # Save/load computed data.
    eCrdnSaveDataOptionYes = 100
    # Don't save computed data, recompute data on load.
    eCrdnSaveDataOptionNo = 10

AgECrdnSaveDataOption.eCrdnSaveDataOptionApplicationSettings.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
AgECrdnSaveDataOption.eCrdnSaveDataOptionYes.__doc__ = "Save/load computed data."
AgECrdnSaveDataOption.eCrdnSaveDataOptionNo.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["AgECrdnSaveDataOption"] = AgECrdnSaveDataOption

class AgECrdnSignalPathReferenceSystem(IntEnum):
    """Signal path reference system types."""
    # Use Access default system
    eCrdnSignalPathReferenceSystemUseAccessDefault = -1
    # Use central body inertial system
    eCrdnSignalPathReferenceSystemCentralBodyInertial = 0
    # Use solar system barycenter system
    eCrdnSignalPathReferenceSystemSolarSystemBarycenter = 1
    # User will specify a system
    eCrdnSignalPathReferenceSystemCustom = 2

AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemUseAccessDefault.__doc__ = "Use Access default system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCentralBodyInertial.__doc__ = "Use central body inertial system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemSolarSystemBarycenter.__doc__ = "Use solar system barycenter system"
AgECrdnSignalPathReferenceSystem.eCrdnSignalPathReferenceSystemCustom.__doc__ = "User will specify a system"

agcls.AgTypeNameMap["AgECrdnSignalPathReferenceSystem"] = AgECrdnSignalPathReferenceSystem

class AgECrdnSmartEpochState(IntEnum):
    """Smart epoch states."""
    # Smart epoch is specified explicitly using a time.
    eCrdnSmartEpochStateExplicit = 0
    # Smart epoch is specified implicitly.
    eCrdnSmartEpochStateImplicit = 3

AgECrdnSmartEpochState.eCrdnSmartEpochStateExplicit.__doc__ = "Smart epoch is specified explicitly using a time."
AgECrdnSmartEpochState.eCrdnSmartEpochStateImplicit.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["AgECrdnSmartEpochState"] = AgECrdnSmartEpochState

class AgECrdnSmartIntervalState(IntEnum):
    """Smart interval states."""
    # Smart interval is specified explicitly using start/stop times.
    eCrdnSmartIntervalStateExplicit = 0
    # Smart interval is specified implicitly using start/stop times.
    eCrdnSmartIntervalStateImplicit = 1
    # Smart interval is specified using smart epochs.
    eCrdnSmartIntervalStateStartStop = 2
    # Smart interval is specified using a start epoch and duration.
    eCrdnSmartIntervalStateStartDuration = 4
    # Smart interval is specified using a start time and explicit duration.
    eCrdnSmartIntervalStateExplicitDuration = 3

AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicit.__doc__ = "Smart interval is specified explicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateImplicit.__doc__ = "Smart interval is specified implicitly using start/stop times."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartStop.__doc__ = "Smart interval is specified using smart epochs."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateStartDuration.__doc__ = "Smart interval is specified using a start epoch and duration."
AgECrdnSmartIntervalState.eCrdnSmartIntervalStateExplicitDuration.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["AgECrdnSmartIntervalState"] = AgECrdnSmartIntervalState

class AgECrdnSpeedOptions(IntEnum):
    """Defines various speed options."""
    # Light transmission speed.
    eCrdnLightTransmissionSpeed = 1
    # Custom transmission speed.
    eCrdnCustomTransmissionSpeed = 2

AgECrdnSpeedOptions.eCrdnLightTransmissionSpeed.__doc__ = "Light transmission speed."
AgECrdnSpeedOptions.eCrdnCustomTransmissionSpeed.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["AgECrdnSpeedOptions"] = AgECrdnSpeedOptions

class AgECrdnStartStopOption(IntEnum):
    """Start/stop options."""
    # Use the start time of the interval
    eCrdnStartStopOptionCountStartOnly = 1
    # Use the stop time of the interval
    eCrdnStartStopOptionCountStopOnly = 2
    # Use the start time and stop time of the interval
    eCrdnStartStopOptionCountStartStop = 3

AgECrdnStartStopOption.eCrdnStartStopOptionCountStartOnly.__doc__ = "Use the start time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStopOnly.__doc__ = "Use the stop time of the interval"
AgECrdnStartStopOption.eCrdnStartStopOptionCountStartStop.__doc__ = "Use the start time and stop time of the interval"

agcls.AgTypeNameMap["AgECrdnStartStopOption"] = AgECrdnStartStopOption

class AgECrdnThreshConvergeSense(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
    # Just converge within tolerance.
    eCrdnThreshConvergeSenseSimple = 0
    # Result above or at threshold.
    eCrdnThreshConvergeSenseAbove = 1
    # Result below or at threshold.
    eCrdnThreshConvergeSenseBelow = 2

AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseSimple.__doc__ = "Just converge within tolerance."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseAbove.__doc__ = "Result above or at threshold."
AgECrdnThreshConvergeSense.eCrdnThreshConvergeSenseBelow.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["AgECrdnThreshConvergeSense"] = AgECrdnThreshConvergeSense

class AgECrdnVectorComponentType(IntEnum):
    """Defines component directions for a vector."""
    # X component.
    eCrdnVectorComponentX = 0
    # Y component.
    eCrdnVectorComponentY = 1
    # Z component.
    eCrdnVectorComponentZ = 2
    # -X component.
    eCrdnVectorComponentMinusX = 3
    # -Y component.
    eCrdnVectorComponentMinusY = 4
    # -Z component.
    eCrdnVectorComponentMinusZ = 5

AgECrdnVectorComponentType.eCrdnVectorComponentX.__doc__ = "X component."
AgECrdnVectorComponentType.eCrdnVectorComponentY.__doc__ = "Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentZ.__doc__ = "Z component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusX.__doc__ = "-X component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusY.__doc__ = "-Y component."
AgECrdnVectorComponentType.eCrdnVectorComponentMinusZ.__doc__ = "-Z component."

agcls.AgTypeNameMap["AgECrdnVectorComponentType"] = AgECrdnVectorComponentType

class AgECrdnVolumeCalcAltitudeReferenceType(IntEnum):
    """Defines volume calc altitude reference types."""
    # Volume calc altitude above reference ellipsoid.
    eCrdnVolumeCalcAltitudeReferenceEllipsoid = 0
    # Volume calc altitude reference above terrain.
    eCrdnVolumeCalcAltitudeReferenceTerrain = 1
    # Volume calc altitude reference above mean sea level.
    eCrdnVolumeCalcAltitudeReferenceMSL = 2

AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceEllipsoid.__doc__ = "Volume calc altitude above reference ellipsoid."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceTerrain.__doc__ = "Volume calc altitude reference above terrain."
AgECrdnVolumeCalcAltitudeReferenceType.eCrdnVolumeCalcAltitudeReferenceMSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAltitudeReferenceType"] = AgECrdnVolumeCalcAltitudeReferenceType

class AgECrdnVolumeCalcAngleOffVectorType(IntEnum):
    """Defines volume calc angle off vector reference types."""
    # Volume calc angle off plane signed.
    eCrdnVolumeCalcAngleOffPlaneSigned = 1
    # Volume calc angle off plane unsigned.
    eCrdnVolumeCalcAngleOffPlaneUnsigned = 2
    # Volume calc angle about vector signed.
    eCrdnVolumeCalcAngleAboutVectorSigned = 4
    # Volume calc angle about vector unsigned.
    eCrdnVolumeCalcAngleAboutVectorUnsigned = 8
    # Volume calc angle off vector.
    eCrdnVolumeCalcAngleOffVector = 16

AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneSigned.__doc__ = "Volume calc angle off plane signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffPlaneUnsigned.__doc__ = "Volume calc angle off plane unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorSigned.__doc__ = "Volume calc angle about vector signed."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleAboutVectorUnsigned.__doc__ = "Volume calc angle about vector unsigned."
AgECrdnVolumeCalcAngleOffVectorType.eCrdnVolumeCalcAngleOffVector.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["AgECrdnVolumeCalcAngleOffVectorType"] = AgECrdnVolumeCalcAngleOffVectorType

class AgECrdnVolumeCalcRangeDistanceType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceFromPoint = 0
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeDistanceAlongVectorSigned = 1
    # Volume calc range distance type along vector unsigned
    eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned = 2
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneSigned = 4
    # Volume calc range distance type plane signed
    eCrdnVolumeCalcRangeDistancePlaneUnsigned = 8

AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceFromPoint.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorSigned.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistanceAlongVectorUnsigned.__doc__ = "Volume calc range distance type along vector unsigned"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneSigned.__doc__ = "Volume calc range distance type plane signed"
AgECrdnVolumeCalcRangeDistanceType.eCrdnVolumeCalcRangeDistancePlaneUnsigned.__doc__ = "Volume calc range distance type plane signed"

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeDistanceType"] = AgECrdnVolumeCalcRangeDistanceType

class AgECrdnVolumeCalcRangeSpeedType(IntEnum):
    """Defines volume calc range distance types."""
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedLight = 1
    # Volume calc range distance type from point.
    eCrdnVolumeCalcRangeSpeedCustom = 2

AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedLight.__doc__ = "Volume calc range distance type from point."
AgECrdnVolumeCalcRangeSpeedType.eCrdnVolumeCalcRangeSpeedCustom.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["AgECrdnVolumeCalcRangeSpeedType"] = AgECrdnVolumeCalcRangeSpeedType

class AgECrdnVolumeCalcType(IntEnum):
    """Defines volume calc types."""
    # Unknown or unsupported volume calc.
    eCrdnVolumeCalcTypeUnknown = -1
    # volume calc type altitude to location.
    eCrdnVolumeCalcTypeAltitude = 0
    # volume calc type angle to location.
    eCrdnVolumeCalcTypeAngleOffVector = 1
    # volume calc type File.
    eCrdnVolumeCalcTypeFile = 2
    # volume calc type scalar at location.
    eCrdnVolumeCalcTypeFromScalar = 3
    # volume calc type Solar Intensity.
    eCrdnVolumeCalcTypeSolarIntensity = 4
    # volume calc type Spatial Condition Satisfaction Metric.
    eCrdnVolumeCalcTypeVolumeSatisfactionMetric = 5
    # volume calc type Distance to Location.
    eCrdnVolumeCalcTypeRange = 6
    # volume calc type Propagation Delay to Location.
    eCrdnVolumeCalcTypeDelayRange = 7

AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeUnknown.__doc__ = "Unknown or unsupported volume calc."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAltitude.__doc__ = "volume calc type altitude to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeAngleOffVector.__doc__ = "volume calc type angle to location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFile.__doc__ = "volume calc type File."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeFromScalar.__doc__ = "volume calc type scalar at location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeSolarIntensity.__doc__ = "volume calc type Solar Intensity."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeVolumeSatisfactionMetric.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeRange.__doc__ = "volume calc type Distance to Location."
AgECrdnVolumeCalcType.eCrdnVolumeCalcTypeDelayRange.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["AgECrdnVolumeCalcType"] = AgECrdnVolumeCalcType

class AgECrdnVolumeCalcVolumeSatisfactionAccumulationType(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
    # Volume calc spatial condition satisfaction accumulation type up to current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime = -1
    # Volume calc spatial condition satisfaction accumulation type current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime = 0
    # Volume calc spatial condition satisfaction accumulation type from current time.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime = 1
    # Volume calc spatial condition satisfaction accumulation type total.
    eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal = 10

AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationUpToCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationFromCurrentTime.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
AgECrdnVolumeCalcVolumeSatisfactionAccumulationType.eCrdnVolumeCalcVolumeSatisfactionAccumulationTotal.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionAccumulationType"] = AgECrdnVolumeCalcVolumeSatisfactionAccumulationType

class AgECrdnVolumeCalcVolumeSatisfactionDurationType(IntEnum):
    """Defines volume calc spatial condition duration types."""
    # Volume calc spatial condition satisfaction duration type minimum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMin = -1
    # Volume calc spatial condition satisfaction duration type sum.
    eCrdnVolumeCalcVolumeSatisfactionDurationSum = 0
    # Volume calc spatial condition satisfaction duration type maximum.
    eCrdnVolumeCalcVolumeSatisfactionDurationMax = 1

AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMin.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationSum.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
AgECrdnVolumeCalcVolumeSatisfactionDurationType.eCrdnVolumeCalcVolumeSatisfactionDurationMax.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionDurationType"] = AgECrdnVolumeCalcVolumeSatisfactionDurationType

class AgECrdnVolumeCalcVolumeSatisfactionFilterType(IntEnum):
    """Defines volume calc spatial condition filter types."""
    # Volume calc spatial condition satisfaction filter type first intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals = -10
    # Volume calc spatial condition satisfaction filter type last intervals.
    eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals = -20
    # Volume calc spatial condition satisfaction filter type none.
    eCrdnVolumeCalcVolumeSatisfactionFilterNone = 0
    # Volume calc spatial condition satisfaction filter type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration = 1
    # Volume calc spatial condition satisfaction filter type interval duration.
    eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration = 2

AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterFirstIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterLastIntervals.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterNone.__doc__ = "Volume calc spatial condition satisfaction filter type none."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterGapDuration.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
AgECrdnVolumeCalcVolumeSatisfactionFilterType.eCrdnVolumeCalcVolumeSatisfactionFilterIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionFilterType"] = AgECrdnVolumeCalcVolumeSatisfactionFilterType

class AgECrdnVolumeCalcVolumeSatisfactionMetricType(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
    # Volume calc spatial condition satisfaction metric type number of gaps.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps = -2
    # Volume calc spatial condition satisfaction metric type number of intervals.
    eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals = -1
    # Volume calc spatial condition satisfaction metric type time since last satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction = 1
    # Volume calc spatial condition satisfaction metric type time until next satisfaction.
    eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction = 2
    # Volume calc spatial condition satisfaction metric type interbnal duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration = 10
    # Volume calc spatial condition satisfaction metric type gap duration.
    eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration = 20

AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfGaps.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricNumberOfIntervals.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeSinceLastSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricTimeUntilNextSatisfaction.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricIntervalDuration.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
AgECrdnVolumeCalcVolumeSatisfactionMetricType.eCrdnVolumeCalcVolumeSatisfactionMetricGapDuration.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["AgECrdnVolumeCalcVolumeSatisfactionMetricType"] = AgECrdnVolumeCalcVolumeSatisfactionMetricType

class AgECrdnVolumeGridType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume grid.
    eCrdnVolumeGridTypeUnknown = -1
    # volume grid type cartesian.
    eCrdnVolumeGridTypeCartesian = 0
    # volume grid type Cylindrical.
    eCrdnVolumeGridTypeCylindrical = 1
    # volume grid type Spherical.
    eCrdnVolumeGridTypeSpherical = 2
    # volume grid type Constrained.
    eCrdnVolumeGridTypeConstrained = 3
    # volume grid type LatLonAlt (Cartographic).
    eCrdnVolumeGridTypeLatLonAlt = 4
    # volume grid type BearingAlt (Surface Bearing).
    eCrdnVolumeGridTypeBearingAlt = 5

AgECrdnVolumeGridType.eCrdnVolumeGridTypeUnknown.__doc__ = "Unknown or unsupported volume grid."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCartesian.__doc__ = "volume grid type cartesian."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeCylindrical.__doc__ = "volume grid type Cylindrical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeSpherical.__doc__ = "volume grid type Spherical."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeConstrained.__doc__ = "volume grid type Constrained."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeLatLonAlt.__doc__ = "volume grid type LatLonAlt (Cartographic)."
AgECrdnVolumeGridType.eCrdnVolumeGridTypeBearingAlt.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["AgECrdnVolumeGridType"] = AgECrdnVolumeGridType

class AgECrdnVolumeResultVectorRequest(IntEnum):
    """Defines volume result vector request types."""
    # volume result vector request pos type
    eCrdnVolumeResultVectorRequestPos = 1
    # volume result vector request native pos type
    eCrdnVolumeResultVectorRequestNativePos = 2
    # volume result vector request metric type
    eCrdnVolumeResultVectorRequestMetric = 16
    # volume result vector request satisfaction type
    eCrdnVolumeResultVectorRequestSatisfaction = 32
    # volume result vector request gradient type
    eCrdnVolumeResultVectorRequestGradient = 256

AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestPos.__doc__ = "volume result vector request pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestNativePos.__doc__ = "volume result vector request native pos type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestMetric.__doc__ = "volume result vector request metric type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestSatisfaction.__doc__ = "volume result vector request satisfaction type"
AgECrdnVolumeResultVectorRequest.eCrdnVolumeResultVectorRequestGradient.__doc__ = "volume result vector request gradient type"

agcls.AgTypeNameMap["AgECrdnVolumeResultVectorRequest"] = AgECrdnVolumeResultVectorRequest

class AgECrdnVolumeType(IntEnum):
    """Defines volume grid types."""
    # Unknown or unsupported volume.
    eCrdnVolumeTypeUnknown = -1
    # volume type combined.
    eCrdnVolumeTypeCombined = 0
    # volume type lighting.
    eCrdnVolumeTypeLighting = 1
    # volume type over time.
    eCrdnVolumeTypeOverTime = 2
    # volume type from grid (Grid Bounding Volume).
    eCrdnVolumeTypeFromGrid = 3
    # volume type from calc (Spatial Calculation Bounds).
    eCrdnVolumeTypeFromCalc = 4
    # volume type from time satisfaction (Valid Time At Location).
    eCrdnVolumeTypeFromTimeSatisfaction = 5
    # volume type from condition (Condition At Location).
    eCrdnVolumeTypeFromCondition = 6
    # volume type Inview (Access To Location).
    eCrdnVolumeTypeInview = 7

AgECrdnVolumeType.eCrdnVolumeTypeUnknown.__doc__ = "Unknown or unsupported volume."
AgECrdnVolumeType.eCrdnVolumeTypeCombined.__doc__ = "volume type combined."
AgECrdnVolumeType.eCrdnVolumeTypeLighting.__doc__ = "volume type lighting."
AgECrdnVolumeType.eCrdnVolumeTypeOverTime.__doc__ = "volume type over time."
AgECrdnVolumeType.eCrdnVolumeTypeFromGrid.__doc__ = "volume type from grid (Grid Bounding Volume)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCalc.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
AgECrdnVolumeType.eCrdnVolumeTypeFromTimeSatisfaction.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeFromCondition.__doc__ = "volume type from condition (Condition At Location)."
AgECrdnVolumeType.eCrdnVolumeTypeInview.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["AgECrdnVolumeType"] = AgECrdnVolumeType

class AgECrdnVolumeAberrationType(IntEnum):
    """Defines the model of aberration to use."""
    # Aberration type unknown.
    eCrdnVolumeAberrationUnknown = -1
    # Aberration type total.
    eCrdnVolumeAberrationTotal = 0
    # SAberration type annual.
    eCrdnVolumeAberrationAnnual = 1
    # Aberration type none.
    eCrdnVolumeAberrationNone = 2

AgECrdnVolumeAberrationType.eCrdnVolumeAberrationUnknown.__doc__ = "Aberration type unknown."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationTotal.__doc__ = "Aberration type total."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationAnnual.__doc__ = "SAberration type annual."
AgECrdnVolumeAberrationType.eCrdnVolumeAberrationNone.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["AgECrdnVolumeAberrationType"] = AgECrdnVolumeAberrationType

class AgECrdnVolumeClockHostType(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
    # Unknown
    eCrdnVolumeClockHostUnknown = -1
    # Base object holds time instance.
    eCrdnVolumeClockHostBase = 0
    # Target object holds time instance.
    eCrdnVolumeClockHostTarget = 1

AgECrdnVolumeClockHostType.eCrdnVolumeClockHostUnknown.__doc__ = "Unknown"
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostBase.__doc__ = "Base object holds time instance."
AgECrdnVolumeClockHostType.eCrdnVolumeClockHostTarget.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["AgECrdnVolumeClockHostType"] = AgECrdnVolumeClockHostType

class AgECrdnVolumeCombinedOperationType(IntEnum):
    """Defines spatial condition combined operation types."""
    # Spatial condition combined AND operation.
    eCrdnVolumeCombinedOperationTypeAND = 1
    # Spatial condition combined OR operation.
    eCrdnVolumeCombinedOperationTypeOR = 2
    # Spatial condition combined XOR operation.
    eCrdnVolumeCombinedOperationTypeXOR = 3
    # Spatial condition combined MINUS operation.
    eCrdnVolumeCombinedOperationTypeMINUS = 4

AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeAND.__doc__ = "Spatial condition combined AND operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeOR.__doc__ = "Spatial condition combined OR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeXOR.__doc__ = "Spatial condition combined XOR operation."
AgECrdnVolumeCombinedOperationType.eCrdnVolumeCombinedOperationTypeMINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["AgECrdnVolumeCombinedOperationType"] = AgECrdnVolumeCombinedOperationType

class AgECrdnVolumeFromGridEdgeType(IntEnum):
    """Defines spatial condition from grid edge type."""
    # Spatial condition over time from grid edge type mask points.
    eCrdnVolumeFromGridEdgeTypeMaskPoints = 16
    # Spatial condition over time from grid edge type mask voxels.
    eCrdnVolumeFromGridEdgeTypeMaskVoxels = 32

AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskPoints.__doc__ = "Spatial condition over time from grid edge type mask points."
AgECrdnVolumeFromGridEdgeType.eCrdnVolumeFromGridEdgeTypeMaskVoxels.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["AgECrdnVolumeFromGridEdgeType"] = AgECrdnVolumeFromGridEdgeType

class AgECrdnVolumeLightingConditionsType(IntFlag):
    """Defines spatial condition lighting conditions types."""
    # Spatial condition lighting undefined.
    eCrdnVolumeLightingConditionTypeUndefined = 0
    # Spatial condition lighting sun light.
    eCrdnVolumeLightingConditionTypeSunlight = 1
    # Spatial condition lighting penumbra.
    eCrdnVolumeLightingConditionTypePenumbra = 2
    # Spatial condition lighting umbra.
    eCrdnVolumeLightingConditionTypeUmbra = 4

AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUndefined.__doc__ = "Spatial condition lighting undefined."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeSunlight.__doc__ = "Spatial condition lighting sun light."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypePenumbra.__doc__ = "Spatial condition lighting penumbra."
AgECrdnVolumeLightingConditionsType.eCrdnVolumeLightingConditionTypeUmbra.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["AgECrdnVolumeLightingConditionsType"] = AgECrdnVolumeLightingConditionsType

class AgECrdnVolumeOverTimeDurationType(IntEnum):
    """Defines spatial condition over time duration type."""
    # Spatial condition over time duration type Static.
    eCrdnVolumeOverTimeDurationTypeStatic = 0
    # Spatial condition over time duration type CumulativeToCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent = 1
    # Spatial condition over time duration type CumulativeFromCurrent.
    eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent = 2
    # Spatial condition over time duration type SlidingWindow.
    eCrdnVolumeOverTimeDurationTypeSlidingWindow = 3

AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeStatic.__doc__ = "Spatial condition over time duration type Static."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeToCurrent.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeCumulativeFromCurrent.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
AgECrdnVolumeOverTimeDurationType.eCrdnVolumeOverTimeDurationTypeSlidingWindow.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["AgECrdnVolumeOverTimeDurationType"] = AgECrdnVolumeOverTimeDurationType

class AgECrdnVolumeTimeSenseType(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
    # Unklnown
    eCrdnVolumeTimeSenseUnknown = -1
    # Position is computed in Time Sense
    eCrdnVolumeTimeSenseTransmit = 0
    # Position is computed in Receive Sense
    eCrdnVolumeTimeSenseReceive = 1

AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseUnknown.__doc__ = "Unklnown"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseTransmit.__doc__ = "Position is computed in Time Sense"
AgECrdnVolumeTimeSenseType.eCrdnVolumeTimeSenseReceive.__doc__ = "Position is computed in Receive Sense"

agcls.AgTypeNameMap["AgECrdnVolumeTimeSenseType"] = AgECrdnVolumeTimeSenseType

class AgECrdnVolumetricGridValuesMethodType(IntEnum):
    """Defines volumetric grid values method types."""
    # Unknown or unsupportedgrid values method.
    eCrdnVolumetricGridValuesMethodMethodUnknown = -1
    # Fixed number steps grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedNumSteps = 0
    # Fixed step size grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodFixedStepSize = 1
    # Custom grid values method for volumetric grid.
    eCrdnVolumetricGridValuesMethodMethodCustomValues = 2

AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodUnknown.__doc__ = "Unknown or unsupportedgrid values method."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedNumSteps.__doc__ = "Fixed number steps grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodFixedStepSize.__doc__ = "Fixed step size grid values method for volumetric grid."
AgECrdnVolumetricGridValuesMethodType.eCrdnVolumetricGridValuesMethodMethodCustomValues.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["AgECrdnVolumetricGridValuesMethodType"] = AgECrdnVolumetricGridValuesMethodType

class AgECrdnKind(IntEnum):
    """Represents kinds of vectory geometry components."""
    # Unsupported component kind.
    eCrdnKindUnknown = -1
    # Invalid component.
    eCrdnKindInvalid = 0
    # Axes component.
    eCrdnKindAxes = 1
    # Angle component.
    eCrdnKindAngle = 2
    # Vector component.
    eCrdnKindVector = 3
    # Point component.
    eCrdnKindPoint = 4
    # Plane component.
    eCrdnKindPlane = 5
    # System component.
    eCrdnKindSystem = 6
    # An event.
    eCrdnKindEvent = 7
    # An event array.
    eCrdnKindEventArray = 8
    # An event interval.
    eCrdnKindEventInterval = 9
    # An event interval collection.
    eCrdnKindEventIntervalCollection = 10
    # A list of event intervals.
    eCrdnKindEventIntervalList = 11
    # A parameter set.
    eCrdnKindParameterSet = 12
    # A scalar.
    eCrdnKindCalcScalar = 13
    # A condition.
    eCrdnKindCondition = 14
    # A condition set.
    eCrdnKindConditionSet = 15
    # A volume grid.
    eCrdnKindVolumeGrid = 16
    # A volume.
    eCrdnKindVolume = 17
    # A volume calc.
    eCrdnKindVolumeCalc = 18

AgECrdnKind.eCrdnKindUnknown.__doc__ = "Unsupported component kind."
AgECrdnKind.eCrdnKindInvalid.__doc__ = "Invalid component."
AgECrdnKind.eCrdnKindAxes.__doc__ = "Axes component."
AgECrdnKind.eCrdnKindAngle.__doc__ = "Angle component."
AgECrdnKind.eCrdnKindVector.__doc__ = "Vector component."
AgECrdnKind.eCrdnKindPoint.__doc__ = "Point component."
AgECrdnKind.eCrdnKindPlane.__doc__ = "Plane component."
AgECrdnKind.eCrdnKindSystem.__doc__ = "System component."
AgECrdnKind.eCrdnKindEvent.__doc__ = "An event."
AgECrdnKind.eCrdnKindEventArray.__doc__ = "An event array."
AgECrdnKind.eCrdnKindEventInterval.__doc__ = "An event interval."
AgECrdnKind.eCrdnKindEventIntervalCollection.__doc__ = "An event interval collection."
AgECrdnKind.eCrdnKindEventIntervalList.__doc__ = "A list of event intervals."
AgECrdnKind.eCrdnKindParameterSet.__doc__ = "A parameter set."
AgECrdnKind.eCrdnKindCalcScalar.__doc__ = "A scalar."
AgECrdnKind.eCrdnKindCondition.__doc__ = "A condition."
AgECrdnKind.eCrdnKindConditionSet.__doc__ = "A condition set."
AgECrdnKind.eCrdnKindVolumeGrid.__doc__ = "A volume grid."
AgECrdnKind.eCrdnKindVolume.__doc__ = "A volume."
AgECrdnKind.eCrdnKindVolumeCalc.__doc__ = "A volume calc."

agcls.AgTypeNameMap["AgECrdnKind"] = AgECrdnKind

class AgECrdnAngleType(IntEnum):
    """Represents angle types."""
    # Unknown or unsupported type.
    eCrdnAngleTypeUnknown = -1
    # An angle between two vectors.
    eCrdnAngleTypeBetweenVectors = 0
    # An angle between two planes.
    eCrdnAngleTypeBetweenPlanes = 1
    # An angle between two vectors about an axis.
    eCrdnAngleTypeDihedralAngle = 2
    # Angle of the shortest rotation between the two specified axes.
    eCrdnAngleTypeRotation = 3
    # An angle between a vector and a plane.
    eCrdnAngleTypeToPlane = 4
    # Represents a VGT angle created from a template. This type of angle is not creatable.
    eCrdnAngleTypeTemplate = 5

AgECrdnAngleType.eCrdnAngleTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAngleType.eCrdnAngleTypeBetweenVectors.__doc__ = "An angle between two vectors."
AgECrdnAngleType.eCrdnAngleTypeBetweenPlanes.__doc__ = "An angle between two planes."
AgECrdnAngleType.eCrdnAngleTypeDihedralAngle.__doc__ = "An angle between two vectors about an axis."
AgECrdnAngleType.eCrdnAngleTypeRotation.__doc__ = "Angle of the shortest rotation between the two specified axes."
AgECrdnAngleType.eCrdnAngleTypeToPlane.__doc__ = "An angle between a vector and a plane."
AgECrdnAngleType.eCrdnAngleTypeTemplate.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["AgECrdnAngleType"] = AgECrdnAngleType

class AgECrdnAxesType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported type.
    eCrdnAxesTypeUnknown = -1
    # Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type.
    eCrdnAxesTypeLagrangeLibration = 0
    # Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset.
    eCrdnAxesTypeAngularOffset = 1
    # Axes based on another set fixed at a specified epoch.
    eCrdnAxesTypeFixedAtEpoch = 2
    # B-Plane axes using the selected target body and reference vector.
    eCrdnAxesTypeBPlane = 3
    # Customized axes offset with respect to a set of reference Axes.
    eCrdnAxesTypeCustomScript = 4
    # Axes fixed in reference axes.
    eCrdnAxesTypeFixed = 6
    # Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference.
    eCrdnAxesTypeAlignedAndConstrained = 7
    # Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element.
    eCrdnAxesTypeModelAttachment = 8
    # Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset.
    eCrdnAxesTypeSpinning = 9
    # Projection of the reference point onto the central body.
    eCrdnAxesTypeOnSurface = 10
    # Axes based on trajectory of the point relative to the reference coordinate system.
    eCrdnAxesTypeTrajectory = 11
    # Represents a VGT axes created from a template. This type of axes is not creatable.
    eCrdnAxesTypeTemplate = 12
    # Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant.
    eCrdnAxesTypeAtTimeInstant = 13
    # An axes plugin point.
    eCrdnAxesTypePlugin = 14
    # Axes specified by data from a file.
    eCrdnAxesTypeFile = 5

AgECrdnAxesType.eCrdnAxesTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnAxesType.eCrdnAxesTypeLagrangeLibration.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
AgECrdnAxesType.eCrdnAxesTypeAngularOffset.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeFixedAtEpoch.__doc__ = "Axes based on another set fixed at a specified epoch."
AgECrdnAxesType.eCrdnAxesTypeBPlane.__doc__ = "B-Plane axes using the selected target body and reference vector."
AgECrdnAxesType.eCrdnAxesTypeCustomScript.__doc__ = "Customized axes offset with respect to a set of reference Axes."
AgECrdnAxesType.eCrdnAxesTypeFixed.__doc__ = "Axes fixed in reference axes."
AgECrdnAxesType.eCrdnAxesTypeAlignedAndConstrained.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
AgECrdnAxesType.eCrdnAxesTypeModelAttachment.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
AgECrdnAxesType.eCrdnAxesTypeSpinning.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
AgECrdnAxesType.eCrdnAxesTypeOnSurface.__doc__ = "Projection of the reference point onto the central body."
AgECrdnAxesType.eCrdnAxesTypeTrajectory.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
AgECrdnAxesType.eCrdnAxesTypeTemplate.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
AgECrdnAxesType.eCrdnAxesTypeAtTimeInstant.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
AgECrdnAxesType.eCrdnAxesTypePlugin.__doc__ = "An axes plugin point."
AgECrdnAxesType.eCrdnAxesTypeFile.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["AgECrdnAxesType"] = AgECrdnAxesType

class AgECrdnPlaneType(IntEnum):
    """Represents plane types."""
    # Unknown or unsupported type.
    eCrdnPlaneTypeUnknown = -1
    # A plane normal to a vector at a given point.
    eCrdnPlaneTypeNormal = 0
    # A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system.
    eCrdnPlaneTypeQuadrant = 1
    # A plane is defined on the basis of a trajectory of a selected point with respect to a reference point.
    eCrdnPlaneTypeTrajectory = 2
    # A plane is defined by the three points.
    eCrdnPlaneTypeTriad = 3
    # Represents a VGT plane created from a template. This type of plane is not creatable.
    eCrdnPlaneTypeTemplate = 4
    # A plane passing through point and containing two given vectors.
    eCrdnPlaneTypeTwoVector = 5

AgECrdnPlaneType.eCrdnPlaneTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPlaneType.eCrdnPlaneTypeNormal.__doc__ = "A plane normal to a vector at a given point."
AgECrdnPlaneType.eCrdnPlaneTypeQuadrant.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
AgECrdnPlaneType.eCrdnPlaneTypeTrajectory.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
AgECrdnPlaneType.eCrdnPlaneTypeTriad.__doc__ = "A plane is defined by the three points."
AgECrdnPlaneType.eCrdnPlaneTypeTemplate.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
AgECrdnPlaneType.eCrdnPlaneTypeTwoVector.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["AgECrdnPlaneType"] = AgECrdnPlaneType

class AgECrdnPointType(IntEnum):
    """Represents point types."""
    # Unknown or unsupported type.
    eCrdnPointTypeUnknown = -1
    # B-Plane point using the selected target body.
    eCrdnPointTypeBPlane = 0
    # The grazing point is the point of closest approach to the surface of the selected central body along a defined direction.
    eCrdnPointTypeGrazing = 1
    # The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option.
    eCrdnPointTypeCovarianceGrazing = 2
    # Point fixed in a reference coordinate system.
    eCrdnPointTypeFixedInSystem = 4
    # Point on central body surface that reflects from source to observer.
    eCrdnPointTypeGlint = 5
    # Point on a plane located along a given direction looking from a given origin.
    eCrdnPointTypePlaneIntersection = 6
    # Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point.
    eCrdnPointTypeModelAttachment = 7
    # The projection of a point onto a reference plane.
    eCrdnPointTypePlaneProjection = 8
    # The detic subpoint of the reference point as projected onto the central body.
    eCrdnPointTypeOnSurface = 9
    # Libration point using one primary and multiple secondary central bodies.
    eCrdnPointTypeLagrangeLibration = 10
    # Represents a VGT point created from a template. This type of point is not creatable.
    eCrdnPointTypeTemplate = 11
    # Point on central body surface along direction vector originating at source point.
    eCrdnPointTypeCentralBodyIntersect = 12
    # Point fixed relative to reference system based on another point evaluated at specified time instant.
    eCrdnPointTypeAtTimeInstant = 13
    # A point plugin point.
    eCrdnPointTypePlugin = 14
    # Point specified by data from a file.
    eCrdnPointTypeFile = 3
    # Point fixed on a central body.
    eCrdnPointTypeFixedOnCentralBody = 15
    # A point placed at the center of mass of a specified satellite of the satellite collection.
    eCrdnPointTypeSatelliteCollectionEntry = 16

AgECrdnPointType.eCrdnPointTypeUnknown.__doc__ = "Unknown or unsupported type."
AgECrdnPointType.eCrdnPointTypeBPlane.__doc__ = "B-Plane point using the selected target body."
AgECrdnPointType.eCrdnPointTypeGrazing.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
AgECrdnPointType.eCrdnPointTypeCovarianceGrazing.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
AgECrdnPointType.eCrdnPointTypeFixedInSystem.__doc__ = "Point fixed in a reference coordinate system."
AgECrdnPointType.eCrdnPointTypeGlint.__doc__ = "Point on central body surface that reflects from source to observer."
AgECrdnPointType.eCrdnPointTypePlaneIntersection.__doc__ = "Point on a plane located along a given direction looking from a given origin."
AgECrdnPointType.eCrdnPointTypeModelAttachment.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
AgECrdnPointType.eCrdnPointTypePlaneProjection.__doc__ = "The projection of a point onto a reference plane."
AgECrdnPointType.eCrdnPointTypeOnSurface.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
AgECrdnPointType.eCrdnPointTypeLagrangeLibration.__doc__ = "Libration point using one primary and multiple secondary central bodies."
AgECrdnPointType.eCrdnPointTypeTemplate.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
AgECrdnPointType.eCrdnPointTypeCentralBodyIntersect.__doc__ = "Point on central body surface along direction vector originating at source point."
AgECrdnPointType.eCrdnPointTypeAtTimeInstant.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
AgECrdnPointType.eCrdnPointTypePlugin.__doc__ = "A point plugin point."
AgECrdnPointType.eCrdnPointTypeFile.__doc__ = "Point specified by data from a file."
AgECrdnPointType.eCrdnPointTypeFixedOnCentralBody.__doc__ = "Point fixed on a central body."
AgECrdnPointType.eCrdnPointTypeSatelliteCollectionEntry.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["AgECrdnPointType"] = AgECrdnPointType

class AgECrdnSystemType(IntEnum):
    """Represents system types."""
    # Unknown or unsupported system type.
    eCrdnSystemTypeUnknown = -1
    # A system assembled from an origin point and a set of reference axes.
    eCrdnSystemTypeAssembled = 0
    # A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle.
    eCrdnSystemTypeOnSurface = 1
    # Represents a VGT system created from a template. This type of system is not creatable.
    eCrdnSystemTypeTemplate = 2

AgECrdnSystemType.eCrdnSystemTypeUnknown.__doc__ = "Unknown or unsupported system type."
AgECrdnSystemType.eCrdnSystemTypeAssembled.__doc__ = "A system assembled from an origin point and a set of reference axes."
AgECrdnSystemType.eCrdnSystemTypeOnSurface.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
AgECrdnSystemType.eCrdnSystemTypeTemplate.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["AgECrdnSystemType"] = AgECrdnSystemType

class AgECrdnVectorType(IntEnum):
    """Represents vector types."""
    # Unknown or unsupported vector type.
    eCrdnVectorTypeUnknown = -1
    # Vector defined by its start and end points.
    eCrdnVectorTypeDisplacement = 0
    # Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeApoapsis = 1
    # Based on another vector fixed at a specified epoch.
    eCrdnVectorTypeFixedAtEpoch = 2
    # Angular velocity vector of one set of axes computed with respect to the reference set.
    eCrdnVectorTypeAngularVelocity = 3
    # Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode.
    eCrdnVectorTypeConing = 4
    # The vector cross product of two vectors.
    eCrdnVectorTypeCrossProduct = 5
    # Customized vector components defined with respect to reference axes.
    eCrdnVectorTypeCustomScript = 6
    # Derivative of a vector computed with respect to specified axes.
    eCrdnVectorTypeDerivative = 7
    # Angle rate vector perpendicular to the plane in which the angle is defined.
    eCrdnVectorTypeAngleRate = 8
    # Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypeEccentricity = 9
    # Vector fixed in reference axes.
    eCrdnVectorTypeFixedInAxes = 10
    # Defined along the intersection of two planes.
    eCrdnVectorTypeTwoPlanesIntersection = 12
    # Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body.
    eCrdnVectorTypeLineOfNodes = 13
    # Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element.
    eCrdnVectorTypeModelAttachment = 14
    # Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitAngularMomentum = 15
    # Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body.
    eCrdnVectorTypeOrbitNormal = 16
    # Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point.
    eCrdnVectorTypePeriapsis = 17
    # A projection of a vector computed with respect to a reference plane.
    eCrdnVectorTypeProjection = 18
    # Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane.
    eCrdnVectorTypeReflection = 19
    # Scaled version of the input vector.
    eCrdnVectorTypeScaled = 20
    # Defined with respect to a star object.
    eCrdnVectorTypeDirectionToStar = 21
    # Represents a VGT vector created from a template. This type of vector is not creatable.
    eCrdnVectorTypeTemplate = 22
    # Vector fixed relative to reference axes based on another vector evaluated at specified time instant.
    eCrdnVectorTypeAtTimeInstant = 23
    # Linear combination of two input vectors.
    eCrdnVectorTypeLinearCombination = 24
    # A projection of a source vector in the direction of another vector.
    eCrdnVectorTypeProjectAlong = 25
    # Linear combination of two input vectors using scalars.
    eCrdnVectorTypeScalarLinearCombination = 26
    # Scaled version of the input vector using scalar.
    eCrdnVectorTypeScalarScaled = 27
    # Velocity vector of a point in a coordinate system.
    eCrdnVectorTypeVelocity = 28
    # A vector plugin point.
    eCrdnVectorTypePlugin = 29
    # Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis.
    eCrdnVectorTypeRotationVector = 30
    # Displacement between origin and destination points using surface distance and altitude difference.
    eCrdnVectorTypeDisplacementOnSurface = 31

AgECrdnVectorType.eCrdnVectorTypeUnknown.__doc__ = "Unknown or unsupported vector type."
AgECrdnVectorType.eCrdnVectorTypeDisplacement.__doc__ = "Vector defined by its start and end points."
AgECrdnVectorType.eCrdnVectorTypeApoapsis.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedAtEpoch.__doc__ = "Based on another vector fixed at a specified epoch."
AgECrdnVectorType.eCrdnVectorTypeAngularVelocity.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
AgECrdnVectorType.eCrdnVectorTypeConing.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
AgECrdnVectorType.eCrdnVectorTypeCrossProduct.__doc__ = "The vector cross product of two vectors."
AgECrdnVectorType.eCrdnVectorTypeCustomScript.__doc__ = "Customized vector components defined with respect to reference axes."
AgECrdnVectorType.eCrdnVectorTypeDerivative.__doc__ = "Derivative of a vector computed with respect to specified axes."
AgECrdnVectorType.eCrdnVectorTypeAngleRate.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
AgECrdnVectorType.eCrdnVectorTypeEccentricity.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeFixedInAxes.__doc__ = "Vector fixed in reference axes."
AgECrdnVectorType.eCrdnVectorTypeTwoPlanesIntersection.__doc__ = "Defined along the intersection of two planes."
AgECrdnVectorType.eCrdnVectorTypeLineOfNodes.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeModelAttachment.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
AgECrdnVectorType.eCrdnVectorTypeOrbitAngularMomentum.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypeOrbitNormal.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
AgECrdnVectorType.eCrdnVectorTypePeriapsis.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
AgECrdnVectorType.eCrdnVectorTypeProjection.__doc__ = "A projection of a vector computed with respect to a reference plane."
AgECrdnVectorType.eCrdnVectorTypeReflection.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
AgECrdnVectorType.eCrdnVectorTypeScaled.__doc__ = "Scaled version of the input vector."
AgECrdnVectorType.eCrdnVectorTypeDirectionToStar.__doc__ = "Defined with respect to a star object."
AgECrdnVectorType.eCrdnVectorTypeTemplate.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
AgECrdnVectorType.eCrdnVectorTypeAtTimeInstant.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
AgECrdnVectorType.eCrdnVectorTypeLinearCombination.__doc__ = "Linear combination of two input vectors."
AgECrdnVectorType.eCrdnVectorTypeProjectAlong.__doc__ = "A projection of a source vector in the direction of another vector."
AgECrdnVectorType.eCrdnVectorTypeScalarLinearCombination.__doc__ = "Linear combination of two input vectors using scalars."
AgECrdnVectorType.eCrdnVectorTypeScalarScaled.__doc__ = "Scaled version of the input vector using scalar."
AgECrdnVectorType.eCrdnVectorTypeVelocity.__doc__ = "Velocity vector of a point in a coordinate system."
AgECrdnVectorType.eCrdnVectorTypePlugin.__doc__ = "A vector plugin point."
AgECrdnVectorType.eCrdnVectorTypeRotationVector.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
AgECrdnVectorType.eCrdnVectorTypeDisplacementOnSurface.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["AgECrdnVectorType"] = AgECrdnVectorType

class AgECrdnMeanElementTheory(IntEnum):
    """Mean element theory types for approximating motion."""
    # Osculating elements (six standard Keplerian orbital elements).
    eCrdnMeanElementTheoryOsculating = 1
    # The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377.
    eCrdnMeanElementTheoryKozai = 2
    # Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eCrdnMeanElementTheoryBrouwerLyddane_Long = 3
    # Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eCrdnMeanElementTheoryBrouwerLyddane_Short = 4

AgECrdnMeanElementTheory.eCrdnMeanElementTheoryOsculating.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryKozai.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Long.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgECrdnMeanElementTheory.eCrdnMeanElementTheoryBrouwerLyddane_Short.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["AgECrdnMeanElementTheory"] = AgECrdnMeanElementTheory

class AgECrdnDirectionType(IntEnum):
    """Direction options."""
    # Incoming direction.
    eCrdnDirectionIncomingAsymptote = 1
    # Outgoing direction.
    eCrdnDirectionOutgoingAsymptote = 2

AgECrdnDirectionType.eCrdnDirectionIncomingAsymptote.__doc__ = "Incoming direction."
AgECrdnDirectionType.eCrdnDirectionOutgoingAsymptote.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["AgECrdnDirectionType"] = AgECrdnDirectionType

class AgECrdnLagrangeLibrationPointType(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
    # A point between the Sun and Earth.
    eCrdnLagrangeLibrationPointTypeL1 = 1
    # Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth.
    eCrdnLagrangeLibrationPointTypeL2 = 2
    # L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times.
    eCrdnLagrangeLibrationPointTypeL3 = 3
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL4 = 4
    # The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points.
    eCrdnLagrangeLibrationPointTypeL5 = 5

AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL1.__doc__ = "A point between the Sun and Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."
AgECrdnLagrangeLibrationPointType.eCrdnLagrangeLibrationPointTypeL5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."

agcls.AgTypeNameMap["AgECrdnLagrangeLibrationPointType"] = AgECrdnLagrangeLibrationPointType

class AgECrdnQuadrantType(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY),"""
    # XY quadrant.
    eCrdnQuadrantXY = 1
    # YX quadrant.
    eCrdnQuadrantYX = 2
    # XZ quadrant.
    eCrdnQuadrantXZ = 3
    # ZX quadrant.
    eCrdnQuadrantZX = 4
    # YZ quadrant.
    eCrdnQuadrantYZ = 5
    # ZY quadrant.
    eCrdnQuadrantZY = 6

AgECrdnQuadrantType.eCrdnQuadrantXY.__doc__ = "XY quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYX.__doc__ = "YX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantXZ.__doc__ = "XZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZX.__doc__ = "ZX quadrant."
AgECrdnQuadrantType.eCrdnQuadrantYZ.__doc__ = "YZ quadrant."
AgECrdnQuadrantType.eCrdnQuadrantZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["AgECrdnQuadrantType"] = AgECrdnQuadrantType

class AgECrdnTrajectoryAxesType(IntEnum):
    """Trajectory axes coordinate types."""
    # Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack).
    eCrdnTrajectoryAxesICR = 0
    # Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal).
    eCrdnTrajectoryAxesVNC = 1
    # Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack).
    eCrdnTrajectoryAxesRIC = 2
    # Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal).
    eCrdnTrajectoryAxesLVLH = 3
    # Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity).
    eCrdnTrajectoryAxesVVLH = 4
    # Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesBBR = 5
    # Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X.
    eCrdnTrajectoryAxesEquinoctial = 6
    # Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal).
    eCrdnTrajectoryAxesNTC = 7

AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesRIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesLVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesVVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesBBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesEquinoctial.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
AgECrdnTrajectoryAxesType.eCrdnTrajectoryAxesNTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["AgECrdnTrajectoryAxesType"] = AgECrdnTrajectoryAxesType

class AgECrdnDisplayAxisSelector(IntEnum):
    """Rotation directions."""
    # Rotate about Axis X.
    eCrdnDisplayAxisX = 0
    # Rotate about Axis Y.
    eCrdnDisplayAxisY = 1
    # Rotate about Axis Z.
    eCrdnDisplayAxisZ = 2

AgECrdnDisplayAxisSelector.eCrdnDisplayAxisX.__doc__ = "Rotate about Axis X."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisY.__doc__ = "Rotate about Axis Y."
AgECrdnDisplayAxisSelector.eCrdnDisplayAxisZ.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["AgECrdnDisplayAxisSelector"] = AgECrdnDisplayAxisSelector

class AgECrdnSignedAngleType(IntEnum):
    """Defines options for computing an angle."""
    # Choose the option to use unsigned angle.
    eCrdnSignedAngleNone = 0
    # Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAnglePositive = 1
    # Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal.
    eCrdnSignedAngleNegative = 2

AgECrdnSignedAngleType.eCrdnSignedAngleNone.__doc__ = "Choose the option to use unsigned angle."
AgECrdnSignedAngleType.eCrdnSignedAnglePositive.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
AgECrdnSignedAngleType.eCrdnSignedAngleNegative.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["AgECrdnSignedAngleType"] = AgECrdnSignedAngleType

class AgECrdnPointBPlaneType(IntEnum):
    """B-Plane point types."""
    # Asymptote.
    eCrdnPointBPlaneAsymptote = 1
    # Two body.
    eCrdnPointBPlaneATwoBody = 2

AgECrdnPointBPlaneType.eCrdnPointBPlaneAsymptote.__doc__ = "Asymptote."
AgECrdnPointBPlaneType.eCrdnPointBPlaneATwoBody.__doc__ = "Two body."

agcls.AgTypeNameMap["AgECrdnPointBPlaneType"] = AgECrdnPointBPlaneType

class AgECrdnReferenceShapeType(IntEnum):
    """Surface shape types."""
    # An ellipsoid reference shape as defined by the central body (by default, it is WSG84).
    eCrdnReferenceShapeEllipsoid = 1
    # Terrain as the terrain reference.
    eCrdnReferenceShapeTerrain = 2
    # Mean Sea Level as the terrain reference.
    eCrdnReferenceShapeMSL = 3

AgECrdnReferenceShapeType.eCrdnReferenceShapeEllipsoid.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
AgECrdnReferenceShapeType.eCrdnReferenceShapeTerrain.__doc__ = "Terrain as the terrain reference."
AgECrdnReferenceShapeType.eCrdnReferenceShapeMSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["AgECrdnReferenceShapeType"] = AgECrdnReferenceShapeType

class AgECrdnSurfaceType(IntEnum):
    """Surface types."""
    # Detic surface model.
    eCrdnSurfaceDetic = 1
    # Centric surface model.
    eCrdnSurfaceCentric = 2

AgECrdnSurfaceType.eCrdnSurfaceDetic.__doc__ = "Detic surface model."
AgECrdnSurfaceType.eCrdnSurfaceCentric.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["AgECrdnSurfaceType"] = AgECrdnSurfaceType

class AgECrdnSweepMode(IntEnum):
    """The rotation sweeping modes."""
    # Bidirectional sweeping mode.
    eCrdnSweepModeBidirectional = 1
    # Unidirectional sweeping mode.
    eCrdnSweepModeUnidirectional = 2

AgECrdnSweepMode.eCrdnSweepModeBidirectional.__doc__ = "Bidirectional sweeping mode."
AgECrdnSweepMode.eCrdnSweepModeUnidirectional.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["AgECrdnSweepMode"] = AgECrdnSweepMode

class AgECrdnSignalSense(IntEnum):
    """Signal sense transmission options."""
    # Signal receive.
    eCrdnSignalSenseReceive = 1
    # Signal transmit.
    eCrdnSignalSenseTransmit = 2

AgECrdnSignalSense.eCrdnSignalSenseReceive.__doc__ = "Signal receive."
AgECrdnSignalSense.eCrdnSignalSenseTransmit.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["AgECrdnSignalSense"] = AgECrdnSignalSense

class AgECrdnIntersectionSurface(IntEnum):
    """Intersection surface flags."""
    # Intersection with central body ellipsoid.
    eCrdnIntersectionSurfaceAtCentralBodyEllipsoid = 0
    # Intersection at altitude.
    eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid = 1
    # Use terrain as intersection surface.
    eCrdnIntersectionSurfaceAtTerrain = 2

AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtCentralBodyEllipsoid.__doc__ = "Intersection with central body ellipsoid."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtAltitudeAboveEllipsoid.__doc__ = "Intersection at altitude."
AgECrdnIntersectionSurface.eCrdnIntersectionSurfaceAtTerrain.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["AgECrdnIntersectionSurface"] = AgECrdnIntersectionSurface

class AgECrdnVectorScaledDimensionInheritance(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
    # Do not inherit dimension.
    eCrdnVectorScaledDimensionInheritanceNone = 0
    # Inherit dimension from scalar.
    eCrdnVectorScaledDimensionInheritanceFromScalar = 1
    # Inherit dimension from vector.
    eCrdnVectorScaledDimensionInheritanceFromVector = 2

AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceNone.__doc__ = "Do not inherit dimension."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromScalar.__doc__ = "Inherit dimension from scalar."
AgECrdnVectorScaledDimensionInheritance.eCrdnVectorScaledDimensionInheritanceFromVector.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["AgECrdnVectorScaledDimensionInheritance"] = AgECrdnVectorScaledDimensionInheritance


class ICrdnIntervalCollection(object):
    """The interface represents a collection of intervals."""
    _uuid = "{DAE5D702-43F1-4544-8039-97E746D019AB}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntervalCollection = agcom.GUID(ICrdnIntervalCollection._uuid)
        vtable_offset_local = ICrdnIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntervalCollection.__dict__ and type(ICrdnIntervalCollection.__dict__[attrname]) == property:
            return ICrdnIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Return a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ICrdnInterval":
        """Returns an interval at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DAE5D702-43F1-4544-8039-97E746D019AB}", ICrdnIntervalCollection)
agcls.AgTypeNameMap["ICrdnIntervalCollection"] = ICrdnIntervalCollection

class ICrdnInterval(object):
    """The interface represents an interval."""
    _uuid = "{4A5031BC-45C0-4E75-9190-31F1802C173D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnInterval = agcom.GUID(ICrdnInterval._uuid)
        vtable_offset_local = ICrdnInterval._vtable_offset - 1
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterval, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterval, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnInterval.__dict__ and type(ICrdnInterval.__dict__[attrname]) == property:
            return ICrdnInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnInterval.")
    
    @property
    def Start(self) -> typing.Any:
        """The interval's start time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The interval's stop time."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A5031BC-45C0-4E75-9190-31F1802C173D}", ICrdnInterval)
agcls.AgTypeNameMap["ICrdnInterval"] = ICrdnInterval

class ICrdnPoint(object):
    """The interface defines methods and properties common to all points."""
    _uuid = "{086D1AA7-D85D-402D-9347-0B51EB552537}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_LocateInSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPoint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPoint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPoint = agcom.GUID(ICrdnPoint._uuid)
        vtable_offset_local = ICrdnPoint._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPoint, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_LocateInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPoint, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_LocateInSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPoint, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPoint.__dict__ and type(ICrdnPoint.__dict__[attrname]) == property:
            return ICrdnPoint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPoint.")
    
    @property
    def Type(self) -> "AgECrdnPointType":
        """Returns a type of the point object."""
        with agmarshall.AgEnum_arg(AgECrdnPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def LocateInSystemWithRate(self, epoch:typing.Any, system:"ICrdnSystem") -> "ICrdnPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def LocateInSystem(self, epoch:typing.Any, system:"ICrdnSystem") -> "ICrdnPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_LocateInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{086D1AA7-D85D-402D-9347-0B51EB552537}", ICrdnPoint)
agcls.AgTypeNameMap["ICrdnPoint"] = ICrdnPoint

class ICrdnVector(object):
    """The interface defines methods and properties common to all vectors."""
    _uuid = "{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVector = agcom.GUID(ICrdnVector._uuid)
        vtable_offset_local = ICrdnVector._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVector, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnVector, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVector.__dict__ and type(ICrdnVector.__dict__[attrname]) == property:
            return ICrdnVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVector.")
    
    @property
    def Type(self) -> "AgECrdnVectorType":
        """Returns a type of the vector object."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnVectorFindInAxesResult":
        """Computes the vector in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnVectorFindInAxesWithRateResult":
        """Computes the vector and its rate in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}", ICrdnVector)
agcls.AgTypeNameMap["ICrdnVector"] = ICrdnVector

class ICrdnSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""
    _uuid = "{14687421-5E90-4275-9DE5-21295EC14F65}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystem = agcom.GUID(ICrdnSystem._uuid)
        vtable_offset_local = ICrdnSystem._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystem, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystem, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystem, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystem, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystem.__dict__ and type(ICrdnSystem.__dict__[attrname]) == property:
            return ICrdnSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystem.")
    
    @property
    def Type(self) -> "AgECrdnSystemType":
        """Returns a type of the system object."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"ICrdnSystem") -> "ICrdnSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputSystem:"ICrdnSystem", positionInMySystem:"ICartesian3Vector") -> "ICrdnSystemTransformResult":
        """Translates the position vector from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, ICrdnSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputSystem:"ICrdnSystem", positionInMySystem:"ICartesian3Vector", velocityInMySystem:"ICartesian3Vector") -> "ICrdnSystemTransformWithRateResult":
        """Translates the position and rate vectors from this system into the output system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputSystem, ICrdnSystem) as arg_outputSystem, \
             agmarshall.AgInterface_in_arg(positionInMySystem, ICartesian3Vector) as arg_positionInMySystem, \
             agmarshall.AgInterface_in_arg(velocityInMySystem, ICartesian3Vector) as arg_velocityInMySystem, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputSystem.COM_val, arg_positionInMySystem.COM_val, arg_velocityInMySystem.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14687421-5E90-4275-9DE5-21295EC14F65}", ICrdnSystem)
agcls.AgTypeNameMap["ICrdnSystem"] = ICrdnSystem

class ICrdnAxes(object):
    """The interface defines methods and properties common to all axes."""
    _uuid = "{EE2FCF98-9315-406A-835C-40C56428C888}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_Transform"] = _raise_uninitialized_error
        self.__dict__["_TransformWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxes = agcom.GUID(ICrdnAxes._uuid)
        vtable_offset_local = ICrdnAxes._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_Transform"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+8, agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_TransformWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxes, vtable_offset_local+9, agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxes.__dict__ and type(ICrdnAxes.__dict__[attrname]) == property:
            return ICrdnAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxes.")
    
    @property
    def Type(self) -> "AgECrdnAxesType":
        """Returns a type of the axes object."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "ICrdnAxesLabels":
        """Returns an object that allows modifying the axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def X(self) -> "ICrdnVector":
        """Returns the X axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Y(self) -> "ICrdnVector":
        """Returns the Y axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Z(self) -> "ICrdnVector":
        """Returns the Z axis of the component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Transform(self, epoch:typing.Any, outputAxes:"ICrdnAxes", vectorInMyAxes:"ICartesian3Vector") -> "ICrdnAxesTransformResult":
        """Transforms the input vector from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, ICrdnAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Transform"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def TransformWithRate(self, epoch:typing.Any, outputAxes:"ICrdnAxes", vectorInMyAxes:"ICartesian3Vector", rateInMyAxes:"ICartesian3Vector") -> "ICrdnAxesTransformWithRateResult":
        """Transforms the input vector and vector's rate from this axes into the output axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(outputAxes, ICrdnAxes) as arg_outputAxes, \
             agmarshall.AgInterface_in_arg(vectorInMyAxes, ICartesian3Vector) as arg_vectorInMyAxes, \
             agmarshall.AgInterface_in_arg(rateInMyAxes, ICartesian3Vector) as arg_rateInMyAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_TransformWithRate"](arg_epoch.COM_val, arg_outputAxes.COM_val, arg_vectorInMyAxes.COM_val, arg_rateInMyAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE2FCF98-9315-406A-835C-40C56428C888}", ICrdnAxes)
agcls.AgTypeNameMap["ICrdnAxes"] = ICrdnAxes

class ICrdnAngle(object):
    """The interface defines methods and properties common to all angles."""
    _uuid = "{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindAngle"] = _raise_uninitialized_error
        self.__dict__["_FindAngleWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinates"] = _raise_uninitialized_error
        self.__dict__["_FindCoordinatesWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngle = agcom.GUID(ICrdnAngle._uuid)
        vtable_offset_local = ICrdnAngle._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngle, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngle, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindAngleWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngle, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngle, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindCoordinatesWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngle, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngle.__dict__ and type(ICrdnAngle.__dict__[attrname]) == property:
            return ICrdnAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngle.")
    
    @property
    def Type(self) -> "AgECrdnAngleType":
        """Returns a type of the angle object."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindAngle(self, epoch:typing.Any) -> "ICrdnAngleFindAngleResult":
        """Finds an angle at the specified epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngle"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindAngleWithRate(self, epoch:typing.Any) -> "ICrdnAngleFindAngleWithRateResult":
        """Finds an angle and angle rate."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindAngleWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinates(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnAngleFindResult":
        """Finds the angle value and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinates"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindCoordinatesWithRate(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnAngleFindWithRateResult":
        """Finds the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindCoordinatesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}", ICrdnAngle)
agcls.AgTypeNameMap["ICrdnAngle"] = ICrdnAngle

class ICrdnPlane(object):
    """The interface defines methods and properties common to all VGT planes."""
    _uuid = "{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindInAxes"] = _raise_uninitialized_error
        self.__dict__["_FindInAxesWithRate"] = _raise_uninitialized_error
        self.__dict__["_FindInSystem"] = _raise_uninitialized_error
        self.__dict__["_FindInSystemWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlane = agcom.GUID(ICrdnPlane._uuid)
        vtable_offset_local = ICrdnPlane._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindInAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+2, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInAxesWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+3, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+4, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_FindInSystemWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+5, agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlane, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlane.__dict__ and type(ICrdnPlane.__dict__[attrname]) == property:
            return ICrdnPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlane.")
    
    @property
    def Type(self) -> "AgECrdnPlaneType":
        """Returns a type of the plane object."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInAxes(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnPlaneFindInAxesResult":
        """Computes the plane's axes vectors in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxes"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInAxesWithRate(self, epoch:typing.Any, axes:"ICrdnAxes") -> "ICrdnPlaneFindInAxesWithRateResult":
        """Computes the plane's axes vectors and their rates in a specified reference axes."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInAxesWithRate"](arg_epoch.COM_val, arg_axes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystem(self, epoch:typing.Any, system:"ICrdnSystem") -> "ICrdnPlaneFindInSystemResult":
        """Computes the position and X and Y axes in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystem"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindInSystemWithRate(self, epoch:typing.Any, system:"ICrdnSystem") -> "ICrdnPlaneFindInSystemWithRateResult":
        """Computes the position, X and Y axes and their rates of change in the specified coordinate system."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInSystemWithRate"](arg_epoch.COM_val, arg_system.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Labels(self) -> "ICrdnPlaneLabels":
        """Allows configuring the plane's X and Y axes labels."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}", ICrdnPlane)
agcls.AgTypeNameMap["ICrdnPlane"] = ICrdnPlane

class ICrdnContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""
    _uuid = "{1003D700-A64E-438C-954A-AD3AA9EA9773}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnContext._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnContext from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnContext = agcom.GUID(ICrdnContext._uuid)
        vtable_offset_local = ICrdnContext._vtable_offset - 1
        self.__dict__["_GetIsTemplate"] = IAGFUNCTYPE(pUnk, IID_ICrdnContext, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnContext.__dict__ and type(ICrdnContext.__dict__[attrname]) == property:
            return ICrdnContext.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnContext.")
    
    @property
    def IsTemplate(self) -> bool:
        """Returns whether the current instance is a VGT template."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsTemplate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1003D700-A64E-438C-954A-AD3AA9EA9773}", ICrdnContext)
agcls.AgTypeNameMap["ICrdnContext"] = ICrdnContext

class ICrdn(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""
    _uuid = "{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetKind"] = _raise_uninitialized_error
        self.__dict__["_GetCategory"] = _raise_uninitialized_error
        self.__dict__["_SetCategory"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetDescription"] = _raise_uninitialized_error
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsDuplicable"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_GetTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetQualifiedPath"] = _raise_uninitialized_error
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIsReady"] = _raise_uninitialized_error
        self.__dict__["_GetIsReadOnly"] = _raise_uninitialized_error
        self.__dict__["_Duplicate"] = _raise_uninitialized_error
        self.__dict__["_AnonymousDuplicate"] = _raise_uninitialized_error
        self.__dict__["_DependsOn"] = _raise_uninitialized_error
        self.__dict__["_GetEmbeddedComponents"] = _raise_uninitialized_error
        self.__dict__["_Export"] = _raise_uninitialized_error
        self.__dict__["_Rename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdn from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdn = agcom.GUID(ICrdn._uuid)
        vtable_offset_local = ICrdn._vtable_offset - 1
        self.__dict__["_GetKind"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetCategory"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetCategory"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetDescription"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetIsDuplicable"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetTypeInfo"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetQualifiedPath"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReady"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIsReadOnly"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Duplicate"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_AnonymousDuplicate"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_DependsOn"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+16, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEmbeddedComponents"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_Export"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+18, agcom.BSTR, agcom.BSTR)
        self.__dict__["_Rename"] = IAGFUNCTYPE(pUnk, IID_ICrdn, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdn.__dict__ and type(ICrdn.__dict__[attrname]) == property:
            return ICrdn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdn.")
    
    @property
    def Kind(self) -> "AgECrdnKind":
        """Returns the component kind."""
        with agmarshall.AgEnum_arg(AgECrdnKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Category(self) -> str:
        """Allows the user to access or change the component category (Folder)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCategory"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Category.setter
    def Category(self, category:str) -> None:
        with agmarshall.BSTR_arg(category) as arg_category:
            agcls.evaluate_hresult(self.__dict__["_SetCategory"](arg_category.COM_val))

    @property
    def Name(self) -> str:
        """Returns the component name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Description(self) -> str:
        """Returns the component description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Path(self) -> str:
        """Returns the component's fully qualified path (ie. \"CentralBody/Earth Body\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsDuplicable(self) -> bool:
        """Returns whether the VGT component can be duplicated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsDuplicable"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Context(self) -> "ICrdnContext":
        """Returns the context object associated with the instance. The returned object is either an instance of IAgCrdnInstance or IAgCrdnTemplate interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TypeInfo(self) -> "ICrdnTypeInfo":
        """Returns the component type information."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def QualifiedPath(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. \"CentralBody/Earth Body Vector\", etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQualifiedPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsValid(self) -> bool:
        """Returns whether the component is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReady(self) -> bool:
        """Returns whether the component is ready. The component is ready if it's been fully initialized."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReady"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IsReadOnly(self) -> bool:
        """Returns whether the component is modifiable."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsReadOnly"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Duplicate(self, newName:str, description:str) -> "ICrdn":
        """Creates a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        with agmarshall.BSTR_arg(newName) as arg_newName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Duplicate"](arg_newName.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def AnonymousDuplicate(self) -> "ICrdn":
        """Creates an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_AnonymousDuplicate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def DependsOn(self, component:"ICrdn") -> bool:
        """Tests if the instance depends on another component."""
        with agmarshall.AgInterface_in_arg(component, ICrdn) as arg_component, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_DependsOn"](arg_component.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def EmbeddedComponents(self) -> "ICrdnCollection":
        """Returns a collection of embedded components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEmbeddedComponents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Export(self, filename:str, comments:str) -> None:
        """Exports the component to a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.BSTR_arg(comments) as arg_comments:
            agcls.evaluate_hresult(self.__dict__["_Export"](arg_filename.COM_val, arg_comments.COM_val))

    def Rename(self, newName:str) -> None:
        """Renames the component."""
        with agmarshall.BSTR_arg(newName) as arg_newName:
            agcls.evaluate_hresult(self.__dict__["_Rename"](arg_newName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}", ICrdn)
agcls.AgTypeNameMap["ICrdn"] = ICrdn

class ICrdnEvaluateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEvaluateResult = agcom.GUID(ICrdnEvaluateResult._uuid)
        vtable_offset_local = ICrdnEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvaluateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEvaluateResult.__dict__ and type(ICrdnEvaluateResult.__dict__[attrname]) == property:
            return ICrdnEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """The scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}", ICrdnEvaluateResult)
agcls.AgTypeNameMap["ICrdnEvaluateResult"] = ICrdnEvaluateResult

class ICrdnEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using IAgCrdnCalcScalar.Evaluate method."""
    _uuid = "{E9B2DA30-1317-43E2-8D47-9D675A28F748}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEvaluateWithRateResult = agcom.GUID(ICrdnEvaluateWithRateResult._uuid)
        vtable_offset_local = ICrdnEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEvaluateWithRateResult.__dict__ and type(ICrdnEvaluateWithRateResult.__dict__[attrname]) == property:
            return ICrdnEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Value(self) -> float:
        """Computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Rate(self) -> float:
        """A rate of change of the computed scalar value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9B2DA30-1317-43E2-8D47-9D675A28F748}", ICrdnEvaluateWithRateResult)
agcls.AgTypeNameMap["ICrdnEvaluateWithRateResult"] = ICrdnEvaluateWithRateResult

class ICrdnEventIntervalResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalResult = agcom.GUID(ICrdnEventIntervalResult._uuid)
        vtable_offset_local = ICrdnEventIntervalResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalResult.__dict__ and type(ICrdnEventIntervalResult.__dict__[attrname]) == property:
            return ICrdnEventIntervalResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interval(self) -> "ICrdnInterval":
        """An interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}", ICrdnEventIntervalResult)
agcls.AgTypeNameMap["ICrdnEventIntervalResult"] = ICrdnEventIntervalResult

class ICrdnEventFindOccurrenceResult(object):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    _uuid = "{20F964F0-8466-415E-9344-D6FBA53AF8B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventFindOccurrenceResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventFindOccurrenceResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventFindOccurrenceResult = agcom.GUID(ICrdnEventFindOccurrenceResult._uuid)
        vtable_offset_local = ICrdnEventFindOccurrenceResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFindOccurrenceResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFindOccurrenceResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventFindOccurrenceResult.__dict__ and type(ICrdnEventFindOccurrenceResult.__dict__[attrname]) == property:
            return ICrdnEventFindOccurrenceResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventFindOccurrenceResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{20F964F0-8466-415E-9344-D6FBA53AF8B0}", ICrdnEventFindOccurrenceResult)
agcls.AgTypeNameMap["ICrdnEventFindOccurrenceResult"] = ICrdnEventFindOccurrenceResult

class ICrdnFindTimesResult(object):
    """Returns a collection of intervals and an array of times."""
    _uuid = "{F7B644F0-0728-434D-8C86-C6267B625860}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnFindTimesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnFindTimesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnFindTimesResult = agcom.GUID(ICrdnFindTimesResult._uuid)
        vtable_offset_local = ICrdnFindTimesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnFindTimesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnFindTimesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnFindTimesResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ICrdnFindTimesResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnFindTimesResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnFindTimesResult.__dict__ and type(ICrdnFindTimesResult.__dict__[attrname]) == property:
            return ICrdnFindTimesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnFindTimesResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ICrdnIntervalCollection":
        """A collection of found intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Times(self) -> list:
        """An array of found times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F7B644F0-0728-434D-8C86-C6267B625860}", ICrdnFindTimesResult)
agcls.AgTypeNameMap["ICrdnFindTimesResult"] = ICrdnFindTimesResult

class ICrdnIntervalsVectorResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    _uuid = "{87F76F41-61FB-4DFF-A76E-25270023BE34}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalCollections"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntervalsVectorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntervalsVectorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntervalsVectorResult = agcom.GUID(ICrdnIntervalsVectorResult._uuid)
        vtable_offset_local = ICrdnIntervalsVectorResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsVectorResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsVectorResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntervalsVectorResult.__dict__ and type(ICrdnIntervalsVectorResult.__dict__[attrname]) == property:
            return ICrdnIntervalsVectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntervalsVectorResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def IntervalCollections(self) -> "ICrdnIntervalVectorCollection":
        """A collection of interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{87F76F41-61FB-4DFF-A76E-25270023BE34}", ICrdnIntervalsVectorResult)
agcls.AgTypeNameMap["ICrdnIntervalsVectorResult"] = ICrdnIntervalsVectorResult

class ICrdnEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    _uuid = "{A829181E-A9CD-452D-AC81-19C2DA96C490}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIndex"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionOccurredResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionOccurredResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionOccurredResult = agcom.GUID(ICrdnEventIntervalCollectionOccurredResult._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionOccurredResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionOccurredResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionOccurredResult, vtable_offset_local+2, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionOccurredResult.__dict__ and type(ICrdnEventIntervalCollectionOccurredResult.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionOccurredResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionOccurredResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Index(self) -> int:
        """Index of an interval in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIndex"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A829181E-A9CD-452D-AC81-19C2DA96C490}", ICrdnEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionOccurredResult"] = ICrdnEventIntervalCollectionOccurredResult

class ICrdnIntervalListResult(object):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    _uuid = "{D0FDA46F-8B86-4052-8EC7-1448284EABCF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntervalListResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntervalListResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntervalListResult = agcom.GUID(ICrdnIntervalListResult._uuid)
        vtable_offset_local = ICrdnIntervalListResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalListResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalListResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntervalListResult.__dict__ and type(ICrdnIntervalListResult.__dict__[attrname]) == property:
            return ICrdnIntervalListResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntervalListResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ICrdnIntervalCollection":
        """A list of intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D0FDA46F-8B86-4052-8EC7-1448284EABCF}", ICrdnIntervalListResult)
agcls.AgTypeNameMap["ICrdnIntervalListResult"] = ICrdnIntervalListResult

class ICrdnIntervalVectorCollection(object):
    """A collection of interval collections."""
    _uuid = "{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntervalVectorCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntervalVectorCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntervalVectorCollection = agcom.GUID(ICrdnIntervalVectorCollection._uuid)
        vtable_offset_local = ICrdnIntervalVectorCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalVectorCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalVectorCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalVectorCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntervalVectorCollection.__dict__ and type(ICrdnIntervalVectorCollection.__dict__[attrname]) == property:
            return ICrdnIntervalVectorCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntervalVectorCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ICrdnIntervalCollection":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}", ICrdnIntervalVectorCollection)
agcls.AgTypeNameMap["ICrdnIntervalVectorCollection"] = ICrdnIntervalVectorCollection

class ICrdnEventGroup(object):
    """Access or create VGT events associated with an object."""
    _uuid = "{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventGroup = agcom.GUID(ICrdnEventGroup._uuid)
        vtable_offset_local = ICrdnEventGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventGroup.__dict__ and type(ICrdnEventGroup.__dict__[attrname]) == property:
            return ICrdnEventGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnEvent":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnEventFactory":
        """Returns a Factory object used to create custom events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnEvent":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnEvent":
        """Retrieves an event from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnEvent":
        """Retrieves an event from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}", ICrdnEventGroup)
agcls.AgTypeNameMap["ICrdnEventGroup"] = ICrdnEventGroup

class ICrdnEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""
    _uuid = "{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalGroup = agcom.GUID(ICrdnEventIntervalGroup._uuid)
        vtable_offset_local = ICrdnEventIntervalGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalGroup.__dict__ and type(ICrdnEventIntervalGroup.__dict__[attrname]) == property:
            return ICrdnEventIntervalGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnEventInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventIntervalName:str) -> None:
        """Removes an element by name."""
        with agmarshall.BSTR_arg(eventIntervalName) as arg_eventIntervalName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventIntervalName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnEventIntervalFactory":
        """Returns a Factory object used to create custom event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnEventInterval":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnEventInterval":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnEventInterval":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}", ICrdnEventIntervalGroup)
agcls.AgTypeNameMap["ICrdnEventIntervalGroup"] = ICrdnEventIntervalGroup

class ICrdnEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""
    _uuid = "{E5721039-AE57-448A-9891-048ECB8BDC63}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListGroup = agcom.GUID(ICrdnEventIntervalListGroup._uuid)
        vtable_offset_local = ICrdnEventIntervalListGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListGroup.__dict__ and type(ICrdnEventIntervalListGroup.__dict__[attrname]) == property:
            return ICrdnEventIntervalListGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnEventIntervalList":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnEventIntervalListFactory":
        """Returns a factory object used to create custom event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnEventIntervalList":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnEventIntervalList":
        """Retrieves an event interval list from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnEventIntervalList":
        """Retrieves an event interval list from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{E5721039-AE57-448A-9891-048ECB8BDC63}", ICrdnEventIntervalListGroup)
agcls.AgTypeNameMap["ICrdnEventIntervalListGroup"] = ICrdnEventIntervalListGroup

class ICrdnEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""
    _uuid = "{37A14DB3-3A49-4A6B-B238-922B59737548}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayGroup = agcom.GUID(ICrdnEventArrayGroup._uuid)
        vtable_offset_local = ICrdnEventArrayGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayGroup.__dict__ and type(ICrdnEventArrayGroup.__dict__[attrname]) == property:
            return ICrdnEventArrayGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnEventArray":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnEventArrayFactory":
        """Returns a Factory object used to create event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnEventArray":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnEventArray":
        """Retrieves an event array from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnEventArray":
        """Retrieves an event array from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{37A14DB3-3A49-4A6B-B238-922B59737548}", ICrdnEventArrayGroup)
agcls.AgTypeNameMap["ICrdnEventArrayGroup"] = ICrdnEventArrayGroup

class ICrdnCalcScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    _uuid = "{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarGroup = agcom.GUID(ICrdnCalcScalarGroup._uuid)
        vtable_offset_local = ICrdnCalcScalarGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarGroup.__dict__ and type(ICrdnCalcScalarGroup.__dict__[attrname]) == property:
            return ICrdnCalcScalarGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnCalcScalar":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnCalcScalarFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnCalcScalar":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnCalcScalar":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnCalcScalar":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}", ICrdnCalcScalarGroup)
agcls.AgTypeNameMap["ICrdnCalcScalarGroup"] = ICrdnCalcScalarGroup

class ICrdnEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""
    _uuid = "{0166467D-9328-4E1B-A982-D9B1396A025E}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionGroup = agcom.GUID(ICrdnEventIntervalCollectionGroup._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionGroup.__dict__ and type(ICrdnEventIntervalCollectionGroup.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnEventIntervalCollection":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnEventIntervalCollectionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnEventIntervalCollection":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnEventIntervalCollection":
        """Retrieves an event interval from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnEventIntervalCollection":
        """Retrieves an event interval from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{0166467D-9328-4E1B-A982-D9B1396A025E}", ICrdnEventIntervalCollectionGroup)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionGroup"] = ICrdnEventIntervalCollectionGroup

class ICrdnParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""
    _uuid = "{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetGroup = agcom.GUID(ICrdnParameterSetGroup._uuid)
        vtable_offset_local = ICrdnParameterSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetGroup.__dict__ and type(ICrdnParameterSetGroup.__dict__[attrname]) == property:
            return ICrdnParameterSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnParameterSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnParameterSetFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnParameterSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnParameterSet":
        """Retrieves an element from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnParameterSet":
        """Retrieves an element from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}", ICrdnParameterSetGroup)
agcls.AgTypeNameMap["ICrdnParameterSetGroup"] = ICrdnParameterSetGroup

class ICrdnConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""
    _uuid = "{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionGroup = agcom.GUID(ICrdnConditionGroup._uuid)
        vtable_offset_local = ICrdnConditionGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionGroup.__dict__ and type(ICrdnConditionGroup.__dict__[attrname]) == property:
            return ICrdnConditionGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnCondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnConditionFactory":
        """Returns a factory object used to create calc scalar components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnCondition":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnCondition":
        """Retrieves a condition from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnCondition":
        """Retrieves a condition from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}", ICrdnConditionGroup)
agcls.AgTypeNameMap["ICrdnConditionGroup"] = ICrdnConditionGroup

class ICrdnConditionSetGroup(object):
    """Allows accessing and creating condition set components."""
    _uuid = "{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSetGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSetGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSetGroup = agcom.GUID(ICrdnConditionSetGroup._uuid)
        vtable_offset_local = ICrdnConditionSetGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSetGroup.__dict__ and type(ICrdnConditionSetGroup.__dict__[attrname]) == property:
            return ICrdnConditionSetGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSetGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnConditionSet":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnConditionSetFactory":
        """Returns a factory object used to create condition set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnConditionSet":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnConditionSet":
        """Retrieves a condition set from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnConditionSet":
        """Retrieves a condition set from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}", ICrdnConditionSetGroup)
agcls.AgTypeNameMap["ICrdnConditionSetGroup"] = ICrdnConditionSetGroup

class ICrdnConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""
    _uuid = "{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSetEvaluateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSetEvaluateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSetEvaluateResult = agcom.GUID(ICrdnConditionSetEvaluateResult._uuid)
        vtable_offset_local = ICrdnConditionSetEvaluateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetEvaluateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetEvaluateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSetEvaluateResult.__dict__ and type(ICrdnConditionSetEvaluateResult.__dict__[attrname]) == property:
            return ICrdnConditionSetEvaluateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSetEvaluateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}", ICrdnConditionSetEvaluateResult)
agcls.AgTypeNameMap["ICrdnConditionSetEvaluateResult"] = ICrdnConditionSetEvaluateResult

class ICrdnConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    _uuid = "{39814D49-3CF5-42B0-A46C-766781F45AB7}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_GetRates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSetEvaluateWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSetEvaluateWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSetEvaluateWithRateResult = agcom.GUID(ICrdnConditionSetEvaluateWithRateResult._uuid)
        vtable_offset_local = ICrdnConditionSetEvaluateWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetEvaluateWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetEvaluateWithRateResult, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetRates"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetEvaluateWithRateResult, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSetEvaluateWithRateResult.__dict__ and type(ICrdnConditionSetEvaluateWithRateResult.__dict__[attrname]) == property:
            return ICrdnConditionSetEvaluateWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSetEvaluateWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Values(self) -> list:
        """Computed values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rates(self) -> list:
        """Computed rates."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{39814D49-3CF5-42B0-A46C-766781F45AB7}", ICrdnConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["ICrdnConditionSetEvaluateWithRateResult"] = ICrdnConditionSetEvaluateWithRateResult

class ICrdnVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""
    _uuid = "{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridGroup = agcom.GUID(ICrdnVolumeGridGroup._uuid)
        vtable_offset_local = ICrdnVolumeGridGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridGroup.__dict__ and type(ICrdnVolumeGridGroup.__dict__[attrname]) == property:
            return ICrdnVolumeGridGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnVolumeGrid":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnVolumeGridFactory":
        """Returns a factory object used to create volume grid components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnVolumeGrid":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnVolumeGrid":
        """Retrieves a volume grid from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnVolumeGrid":
        """Retrieves a volume grid from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}", ICrdnVolumeGridGroup)
agcls.AgTypeNameMap["ICrdnVolumeGridGroup"] = ICrdnVolumeGridGroup

class ICrdnVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""
    _uuid = "{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGroup = agcom.GUID(ICrdnVolumeGroup._uuid)
        vtable_offset_local = ICrdnVolumeGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGroup.__dict__ and type(ICrdnVolumeGroup.__dict__[attrname]) == property:
            return ICrdnVolumeGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnVolume":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnVolumeFactory":
        """Returns a factory object used to create spatial condition components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnVolume":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnVolume":
        """Retrieves an volume from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnVolume":
        """Retrieves volume from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}", ICrdnVolumeGroup)
agcls.AgTypeNameMap["ICrdnVolumeGroup"] = ICrdnVolumeGroup

class ICrdnVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""
    _uuid = "{02991465-35ec-486a-913d-bf204afc9fb6}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcGroup = agcom.GUID(ICrdnVolumeCalcGroup._uuid)
        vtable_offset_local = ICrdnVolumeCalcGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcGroup.__dict__ and type(ICrdnVolumeCalcGroup.__dict__[attrname]) == property:
            return ICrdnVolumeCalcGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnVolumeCalc":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, eventName:str) -> None:
        """Removes a specified element."""
        with agmarshall.BSTR_arg(eventName) as arg_eventName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_eventName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnVolumeCalcFactory":
        """Returns a factory object used to create volume calc components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnVolumeCalc":
        """Returns an element by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnVolumeCalc":
        """Retrieves a volume calculation from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnVolumeCalc":
        """Retrieves a volume calculation from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{02991465-35ec-486a-913d-bf204afc9fb6}", ICrdnVolumeCalcGroup)
agcls.AgTypeNameMap["ICrdnVolumeCalcGroup"] = ICrdnVolumeCalcGroup

class ICrdnCalcScalar(object):
    """Any scalar calculation that is not constant by construction."""
    _uuid = "{55A75307-E283-4146-A456-732D08E47070}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRate"] = _raise_uninitialized_error
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        self.__dict__["_GetUnitOfMeasure"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateEventArray"] = _raise_uninitialized_error
        self.__dict__["_QuickEvaluateWithRateEventArray"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalar = agcom.GUID(ICrdnCalcScalar._uuid)
        vtable_offset_local = ICrdnCalcScalar._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_QuickEvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetUnitOfMeasure"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_QuickEvaluateArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+8, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.SAFEARRAY))
        self.__dict__["_QuickEvaluateWithRateEventArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalar, vtable_offset_local+11, agcom.PVOID, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalar.__dict__ and type(ICrdnCalcScalar.__dict__[attrname]) == property:
            return ICrdnCalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalar.")
    
    @property
    def Type(self) -> "AgECrdnCalcScalarType":
        """Returns the scalar calculation type."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICrdnEvaluateResult":
        """Evaluates the scalar calculation at the specified time instant."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICrdnEvaluateWithRateResult":
        """Evaluates the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRate(self, epoch:typing.Any) -> list:
        """Evaluates the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetAvailability(self) -> "ICrdnIntervalCollection":
        """Returns a list of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UnitOfMeasure(self) -> str:
        """Returns calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitOfMeasure"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def QuickEvaluateArray(self, times:list) -> list:
        """Evaluates the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateArray(self, times:list) -> list:
        """Evaluates the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateArray"](byref(arg_times.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateEventArray(self, refArray:"ICrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, ICrdnEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def QuickEvaluateWithRateEventArray(self, refArray:"ICrdnEventArray") -> list:
        """Evaluates the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        with agmarshall.AgInterface_in_arg(refArray, ICrdnEventArray) as arg_refArray, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuickEvaluateWithRateEventArray"](arg_refArray.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{55A75307-E283-4146-A456-732D08E47070}", ICrdnCalcScalar)
agcls.AgTypeNameMap["ICrdnCalcScalar"] = ICrdnCalcScalar

class ICrdnCalcScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    _uuid = "{52FB9533-9332-44D2-92B2-8AA2D8633112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputAngle"] = _raise_uninitialized_error
        self.__dict__["_SetInputAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarAngle = agcom.GUID(ICrdnCalcScalarAngle._uuid)
        vtable_offset_local = ICrdnCalcScalarAngle._vtable_offset - 1
        self.__dict__["_GetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarAngle, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarAngle.__dict__ and type(ICrdnCalcScalarAngle.__dict__[attrname]) == property:
            return ICrdnCalcScalarAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarAngle.")
    
    @property
    def InputAngle(self) -> "ICrdnAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputAngle.setter
    def InputAngle(self, inputAngle:"ICrdnAngle") -> None:
        with agmarshall.AgInterface_in_arg(inputAngle, ICrdnAngle) as arg_inputAngle:
            agcls.evaluate_hresult(self.__dict__["_SetInputAngle"](arg_inputAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52FB9533-9332-44D2-92B2-8AA2D8633112}", ICrdnCalcScalarAngle)
agcls.AgTypeNameMap["ICrdnCalcScalarAngle"] = ICrdnCalcScalarAngle

class ICrdnCalcScalarConstant(object):
    """Constant scalar value of specified dimension."""
    _uuid = "{96A1ABA9-663C-4CCC-A066-0166E285C3C2}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarConstant = agcom.GUID(ICrdnCalcScalarConstant._uuid)
        vtable_offset_local = ICrdnCalcScalarConstant._vtable_offset - 1
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarConstant, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarConstant, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarConstant.__dict__ and type(ICrdnCalcScalarConstant.__dict__[attrname]) == property:
            return ICrdnCalcScalarConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarConstant.")
    
    @property
    def Value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Value.setter
    def Value(self, value:float) -> None:
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_value.COM_val))

    @property
    def Dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96A1ABA9-663C-4CCC-A066-0166E285C3C2}", ICrdnCalcScalarConstant)
agcls.AgTypeNameMap["ICrdnCalcScalarConstant"] = ICrdnCalcScalarConstant

class ICrdnCalcScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    _uuid = "{6267B685-4486-4B11-A2CA-056D6A9B558C}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarCustom = agcom.GUID(ICrdnCalcScalarCustom._uuid)
        vtable_offset_local = ICrdnCalcScalarCustom._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarCustom, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarCustom, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarCustom, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarCustom.__dict__ and type(ICrdnCalcScalarCustom.__dict__[attrname]) == property:
            return ICrdnCalcScalarCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarCustom.")
    
    @property
    def Filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{6267B685-4486-4B11-A2CA-056D6A9B558C}", ICrdnCalcScalarCustom)
agcls.AgTypeNameMap["ICrdnCalcScalarCustom"] = ICrdnCalcScalarCustom

class ICrdnCalcScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    _uuid = "{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDataProvider"] = _raise_uninitialized_error
        self.__dict__["_GetElementName"] = _raise_uninitialized_error
        self.__dict__["_GetGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_SetUseSamples"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_SetWithGroup"] = _raise_uninitialized_error
        self.__dict__["_GetInvalidDataIndicator"] = _raise_uninitialized_error
        self.__dict__["_SetInvalidDataIndicator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarDataElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarDataElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarDataElement = agcom.GUID(ICrdnCalcScalarDataElement._uuid)
        vtable_offset_local = ICrdnCalcScalarDataElement._vtable_offset - 1
        self.__dict__["_GetDataProvider"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetGroup"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_GetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSamples"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+12, agcom.BSTR, agcom.BSTR)
        self.__dict__["_SetWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInvalidDataIndicator"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDataElement, vtable_offset_local+15, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarDataElement.__dict__ and type(ICrdnCalcScalarDataElement.__dict__[attrname]) == property:
            return ICrdnCalcScalarDataElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarDataElement.")
    
    @property
    def DataProvider(self) -> str:
        """The name of the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataProvider"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ElementName(self) -> str:
        """The name of the data element within the data provider."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGroup"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Interpolation(self) -> "ICrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"ICrdnInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, ICrdnInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def UseSamples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSamples"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseSamples.setter
    def UseSamples(self, useSamples:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useSamples) as arg_useSamples:
            agcls.evaluate_hresult(self.__dict__["_SetUseSamples"](arg_useSamples.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    def Set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_dataProvider.COM_val, arg_elementName.COM_val))

    def SetWithGroup(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        with agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(typeName) as arg_typeName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName:
            agcls.evaluate_hresult(self.__dict__["_SetWithGroup"](arg_dataProvider.COM_val, arg_typeName.COM_val, arg_elementName.COM_val))

    @property
    def InvalidDataIndicator(self) -> float:
        """Sets the value to display in a report or graph when the actual value is not a valid real number"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInvalidDataIndicator"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InvalidDataIndicator.setter
    def InvalidDataIndicator(self, invalidDataIndicator:float) -> None:
        with agmarshall.DOUBLE_arg(invalidDataIndicator) as arg_invalidDataIndicator:
            agcls.evaluate_hresult(self.__dict__["_SetInvalidDataIndicator"](arg_invalidDataIndicator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}", ICrdnCalcScalarDataElement)
agcls.AgTypeNameMap["ICrdnCalcScalarDataElement"] = ICrdnCalcScalarDataElement

class ICrdnCalcScalarDerivative(object):
    """Derivative of an input scalar calculation."""
    _uuid = "{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarDerivative = agcom.GUID(ICrdnCalcScalarDerivative._uuid)
        vtable_offset_local = ICrdnCalcScalarDerivative._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarDerivative.__dict__ and type(ICrdnCalcScalarDerivative.__dict__[attrname]) == property:
            return ICrdnCalcScalarDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarDerivative.")
    
    @property
    def Scalar(self) -> "ICrdnCalcScalar":
        """The input scalar component used to compute the derivative."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}", ICrdnCalcScalarDerivative)
agcls.AgTypeNameMap["ICrdnCalcScalarDerivative"] = ICrdnCalcScalarDerivative

class ICrdnCalcScalarDotProduct(object):
    """Dot product between two vectors."""
    _uuid = "{ffb69fa2-d123-413e-bb34-db750b7775ea}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarDotProduct from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarDotProduct = agcom.GUID(ICrdnCalcScalarDotProduct._uuid)
        vtable_offset_local = ICrdnCalcScalarDotProduct._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarDotProduct, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarDotProduct.__dict__ and type(ICrdnCalcScalarDotProduct.__dict__[attrname]) == property:
            return ICrdnCalcScalarDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarDotProduct.")
    
    @property
    def VectorA(self) -> "ICrdnVector":
        """First vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, ICrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "ICrdnVector":
        """Second vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, ICrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'Angle', 'Distance', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ffb69fa2-d123-413e-bb34-db750b7775ea}", ICrdnCalcScalarDotProduct)
agcls.AgTypeNameMap["ICrdnCalcScalarDotProduct"] = ICrdnCalcScalarDotProduct

class ICrdnCalcScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""
    _uuid = "{81238610-6A1B-499A-8C43-12337F64BC42}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarElapsedTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarElapsedTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarElapsedTime = agcom.GUID(ICrdnCalcScalarElapsedTime._uuid)
        vtable_offset_local = ICrdnCalcScalarElapsedTime._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarElapsedTime, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarElapsedTime, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarElapsedTime.__dict__ and type(ICrdnCalcScalarElapsedTime.__dict__[attrname]) == property:
            return ICrdnCalcScalarElapsedTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarElapsedTime.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{81238610-6A1B-499A-8C43-12337F64BC42}", ICrdnCalcScalarElapsedTime)
agcls.AgTypeNameMap["ICrdnCalcScalarElapsedTime"] = ICrdnCalcScalarElapsedTime

class ICrdnCalcScalarFactory(object):
    """The factory creates scalar calculation components."""
    _uuid = "{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarAngle"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarConstant"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElement"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDerivative"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarElapsedTime"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFile"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarIntegral"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFunction2Var"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarFromCustomScript"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarDotProduct"] = _raise_uninitialized_error
        self.__dict__["_CreateCalcScalarVectorComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarFactory = agcom.GUID(ICrdnCalcScalarFactory._uuid)
        vtable_offset_local = ICrdnCalcScalarFactory._vtable_offset - 1
        self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFixedAtTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarConstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElement"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDataElementWithGroup"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDerivative"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarElapsedTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+11, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarIntegral"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+12, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarFunction2Var"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+13, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorMagnitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+14, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+15, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+16, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateCalcScalarFromCustomScript"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+17, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+18, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarDotProduct"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+19, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCalcScalarVectorComponent"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFactory, vtable_offset_local+20, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarFactory.__dict__ and type(ICrdnCalcScalarFactory.__dict__[attrname]) == property:
            return ICrdnCalcScalarFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarFactory.")
    
    @property
    def AvailableCalcScalarPluginDisplayNames(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableCalcScalarPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnCalcScalarType") -> "ICrdnCalcScalar":
        """Creates and registers a scalar calculation using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnCalcScalarType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarAngle(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarAngle"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFixedAtTimeInstant(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFixedAtTimeInstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarConstant(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarConstant"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElement(self, name:str, description:str, dataProvider:str, elementName:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElement"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDataElementWithGroup(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(dataProvider) as arg_dataProvider, \
             agmarshall.BSTR_arg(groupName) as arg_groupName, \
             agmarshall.BSTR_arg(elementName) as arg_elementName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDataElementWithGroup"](arg_name.COM_val, arg_description.COM_val, arg_dataProvider.COM_val, arg_groupName.COM_val, arg_elementName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDerivative(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDerivative"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarElapsedTime(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarElapsedTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFile(self, name:str, description:str, filepath:str) -> "ICrdnCalcScalar":
        """Create scalar calculation specified by external data file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFile"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarIntegral(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarIntegral"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarFunction2Var(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFunction2Var"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorMagnitude(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorMagnitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarPluginFromDisplayName(self, name:str, description:str, displayName:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarPluginFromDisplayName"](arg_name.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnCalcScalarType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnCalcScalarType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateCalcScalarFromCustomScript(self, name:str, description:str, filepath:str) -> "ICrdnCalcScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filepath) as arg_filepath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarFromCustomScript"](arg_name.COM_val, arg_description.COM_val, arg_filepath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarSurfaceDistanceBetweenPoints(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarSurfaceDistanceBetweenPoints"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarDotProduct(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarDotProduct"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCalcScalarVectorComponent(self, name:str, description:str) -> "ICrdnCalcScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCalcScalarVectorComponent"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}", ICrdnCalcScalarFactory)
agcls.AgTypeNameMap["ICrdnCalcScalarFactory"] = ICrdnCalcScalarFactory

class ICrdnCalcScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    _uuid = "{98BC97CE-DA0B-4783-BB98-A988CA16447A}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationType"] = _raise_uninitialized_error
        self.__dict__["_GetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_SetFileInterpolationOrder"] = _raise_uninitialized_error
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarFile = agcom.GUID(ICrdnCalcScalarFile._uuid)
        vtable_offset_local = ICrdnCalcScalarFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetFileInterpolationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_SetFileInterpolationOrder"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+8, agcom.INT)
        self.__dict__["_GetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseNativeFileInterpolationSettings"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFile, vtable_offset_local+10, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarFile.__dict__ and type(ICrdnCalcScalarFile.__dict__[attrname]) == property:
            return ICrdnCalcScalarFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarFile.")
    
    @property
    def Filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reload the file specified with Filename property."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "ICrdnEventIntervalResult":
        """Computes the interval time span of the file."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FileInterpolationType(self) -> "AgECrdnFileInterpolatorType":
        """The interpolation method used with the data."""
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationType.setter
    def FileInterpolationType(self, fileInterpolationType:"AgECrdnFileInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnFileInterpolatorType, fileInterpolationType) as arg_fileInterpolationType:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationType"](arg_fileInterpolationType.COM_val))

    @property
    def FileInterpolationOrder(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileInterpolationOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FileInterpolationOrder.setter
    def FileInterpolationOrder(self, fileInterpolationOrder:int) -> None:
        with agmarshall.INT_arg(fileInterpolationOrder) as arg_fileInterpolationOrder:
            agcls.evaluate_hresult(self.__dict__["_SetFileInterpolationOrder"](arg_fileInterpolationOrder.COM_val))

    @property
    def UseNativeFileInterpolationSettings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseNativeFileInterpolationSettings"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseNativeFileInterpolationSettings.setter
    def UseNativeFileInterpolationSettings(self, useNativeFileInterpolationSettings:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useNativeFileInterpolationSettings) as arg_useNativeFileInterpolationSettings:
            agcls.evaluate_hresult(self.__dict__["_SetUseNativeFileInterpolationSettings"](arg_useNativeFileInterpolationSettings.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{98BC97CE-DA0B-4783-BB98-A988CA16447A}", ICrdnCalcScalarFile)
agcls.AgTypeNameMap["ICrdnCalcScalarFile"] = ICrdnCalcScalarFile

class ICrdnCalcScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    _uuid = "{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarFixedAtTimeInstant = agcom.GUID(ICrdnCalcScalarFixedAtTimeInstant._uuid)
        vtable_offset_local = ICrdnCalcScalarFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarFixedAtTimeInstant.__dict__ and type(ICrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]) == property:
            return ICrdnCalcScalarFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarFixedAtTimeInstant.")
    
    @property
    def InputScalar(self) -> "ICrdnCalcScalar":
        """The input scalar component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}", ICrdnCalcScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["ICrdnCalcScalarFixedAtTimeInstant"] = ICrdnCalcScalarFixedAtTimeInstant

class ICrdnCalcScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""
    _uuid = "{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}"
    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_SetUseScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetInputTime"] = _raise_uninitialized_error
        self.__dict__["_SetInputTime"] = _raise_uninitialized_error
        self.__dict__["_GetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetInputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetD"] = _raise_uninitialized_error
        self.__dict__["_SetD"] = _raise_uninitialized_error
        self.__dict__["_GetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_SetCoefficients"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_SetInheritDimensionFromInput"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarFunction = agcom.GUID(ICrdnCalcScalarFunction._uuid)
        vtable_offset_local = ICrdnCalcScalarFunction._vtable_offset - 1
        self.__dict__["_GetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetInputTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetInputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetD"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetD"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCoefficients"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+18, agcom.SAFEARRAY)
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInheritDimensionFromInput"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+23, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+29, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction, vtable_offset_local+31, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarFunction.__dict__ and type(ICrdnCalcScalarFunction.__dict__[attrname]) == property:
            return ICrdnCalcScalarFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarFunction.")
    
    @property
    def UseScalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScalar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScalar.setter
    def UseScalar(self, useScalar:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScalar) as arg_useScalar:
            agcls.evaluate_hresult(self.__dict__["_SetUseScalar"](arg_useScalar.COM_val))

    @property
    def InputScalar(self) -> "ICrdnCalcScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def InputTime(self) -> "ICrdnEvent":
        """The input time instant (used if UseScalar is false)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputTime"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputTime.setter
    def InputTime(self, inputTime:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(inputTime, ICrdnEvent) as arg_inputTime:
            agcls.evaluate_hresult(self.__dict__["_SetInputTime"](arg_inputTime.COM_val))

    @property
    def InputUnit(self) -> str:
        """The input time unit to interpret input time."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InputUnit.setter
    def InputUnit(self, inputUnit:str) -> None:
        with agmarshall.BSTR_arg(inputUnit) as arg_inputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetInputUnit"](arg_inputUnit.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def D(self) -> float:
        """The constant coefficient D."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetD"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @D.setter
    def D(self, d:float) -> None:
        with agmarshall.DOUBLE_arg(d) as arg_d:
            agcls.evaluate_hresult(self.__dict__["_SetD"](arg_d.COM_val))

    @property
    def Coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoefficients"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Coefficients.setter
    def Coefficients(self, coefficients:list) -> None:
        with agmarshall.SAFEARRAY_arg(coefficients) as arg_coefficients:
            agcls.evaluate_hresult(self.__dict__["_SetCoefficients"](arg_coefficients.COM_val))

    @property
    def SelectedFunction(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """Get the available function names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def InheritDimensionFromInput(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInheritDimensionFromInput"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InheritDimensionFromInput.setter
    def InheritDimensionFromInput(self, inheritDimensionFromInput:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inheritDimensionFromInput) as arg_inheritDimensionFromInput:
            agcls.evaluate_hresult(self.__dict__["_SetInheritDimensionFromInput"](arg_inheritDimensionFromInput.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def OutputUnit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}", ICrdnCalcScalarFunction)
agcls.AgTypeNameMap["ICrdnCalcScalarFunction"] = ICrdnCalcScalarFunction

class ICrdnCalcScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""
    _uuid = "{E56D021E-AD96-4ABE-857E-708CDCC4FF14}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetUnitX"] = _raise_uninitialized_error
        self.__dict__["_SetUnitX"] = _raise_uninitialized_error
        self.__dict__["_GetA"] = _raise_uninitialized_error
        self.__dict__["_SetA"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetUnitY"] = _raise_uninitialized_error
        self.__dict__["_SetUnitY"] = _raise_uninitialized_error
        self.__dict__["_GetB"] = _raise_uninitialized_error
        self.__dict__["_SetB"] = _raise_uninitialized_error
        self.__dict__["_GetC"] = _raise_uninitialized_error
        self.__dict__["_SetC"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedFunction"] = _raise_uninitialized_error
        self.__dict__["_GetOutputUnit"] = _raise_uninitialized_error
        self.__dict__["_SetOutputUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarFunction2Var._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarFunction2Var from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarFunction2Var = agcom.GUID(ICrdnCalcScalarFunction2Var._uuid)
        vtable_offset_local = ICrdnCalcScalarFunction2Var._vtable_offset - 1
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitX"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitY"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetAvailableFunctions"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+19, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedFunction"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+22, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputUnit"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarFunction2Var, vtable_offset_local+23, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarFunction2Var.__dict__ and type(ICrdnCalcScalarFunction2Var.__dict__[attrname]) == property:
            return ICrdnCalcScalarFunction2Var.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarFunction2Var.")
    
    @property
    def X(self) -> "ICrdnCalcScalar":
        """The scalar argument X."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @X.setter
    def X(self, x:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(x, ICrdnCalcScalar) as arg_x:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_x.COM_val))

    @property
    def UnitX(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitX.setter
    def UnitX(self, unitX:str) -> None:
        with agmarshall.BSTR_arg(unitX) as arg_unitX:
            agcls.evaluate_hresult(self.__dict__["_SetUnitX"](arg_unitX.COM_val))

    @property
    def A(self) -> float:
        """The constant coefficient A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @A.setter
    def A(self, a:float) -> None:
        with agmarshall.DOUBLE_arg(a) as arg_a:
            agcls.evaluate_hresult(self.__dict__["_SetA"](arg_a.COM_val))

    @property
    def Y(self) -> "ICrdnCalcScalar":
        """The scalar argument Y."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Y.setter
    def Y(self, y:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(y, ICrdnCalcScalar) as arg_y:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_y.COM_val))

    @property
    def UnitY(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UnitY.setter
    def UnitY(self, unitY:str) -> None:
        with agmarshall.BSTR_arg(unitY) as arg_unitY:
            agcls.evaluate_hresult(self.__dict__["_SetUnitY"](arg_unitY.COM_val))

    @property
    def B(self) -> float:
        """The constant coefficient B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @B.setter
    def B(self, b:float) -> None:
        with agmarshall.DOUBLE_arg(b) as arg_b:
            agcls.evaluate_hresult(self.__dict__["_SetB"](arg_b.COM_val))

    @property
    def C(self) -> float:
        """The constant coefficient C."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetC"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @C.setter
    def C(self, c:float) -> None:
        with agmarshall.DOUBLE_arg(c) as arg_c:
            agcls.evaluate_hresult(self.__dict__["_SetC"](arg_c.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Specifies whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))

    @property
    def AvailableFunctions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableFunctions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SelectedFunction(self) -> str:
        """The selected function."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedFunction"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedFunction.setter
    def SelectedFunction(self, selectedFunction:str) -> None:
        with agmarshall.BSTR_arg(selectedFunction) as arg_selectedFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedFunction"](arg_selectedFunction.COM_val))

    @property
    def OutputUnit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputUnit"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputUnit.setter
    def OutputUnit(self, outputUnit:str) -> None:
        with agmarshall.BSTR_arg(outputUnit) as arg_outputUnit:
            agcls.evaluate_hresult(self.__dict__["_SetOutputUnit"](arg_outputUnit.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E56D021E-AD96-4ABE-857E-708CDCC4FF14}", ICrdnCalcScalarFunction2Var)
agcls.AgTypeNameMap["ICrdnCalcScalarFunction2Var"] = ICrdnCalcScalarFunction2Var

class ICrdnCalcScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    _uuid = "{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_SetComputeAsAverage"] = _raise_uninitialized_error
        self.__dict__["_GetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_SetIntegrationWindowType"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolation"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetIntegral"] = _raise_uninitialized_error
        self.__dict__["_SetIntegral"] = _raise_uninitialized_error
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetOffsets"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarIntegral = agcom.GUID(ICrdnCalcScalarIntegral._uuid)
        vtable_offset_local = ICrdnCalcScalarIntegral._vtable_offset - 1
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetComputeAsAverage"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetIntegrationWindowType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_SetInterpolation"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+18, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+20, agcom.PVOID)
        self.__dict__["_GetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_SetIntegral"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+22, agcom.PVOID)
        self.__dict__["_GetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetKeepConstantOutsideTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_SetOffsets"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarIntegral, vtable_offset_local+25, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarIntegral.__dict__ and type(ICrdnCalcScalarIntegral.__dict__[attrname]) == property:
            return ICrdnCalcScalarIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarIntegral.")
    
    @property
    def InputScalar(self) -> "ICrdnCalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ComputeAsAverage(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputeAsAverage"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ComputeAsAverage.setter
    def ComputeAsAverage(self, computeAsAverage:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(computeAsAverage) as arg_computeAsAverage:
            agcls.evaluate_hresult(self.__dict__["_SetComputeAsAverage"](arg_computeAsAverage.COM_val))

    @property
    def IntegrationWindowType(self) -> "AgECrdnIntegrationWindowType":
        """The integration window, or accumulation, type."""
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegrationWindowType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntegrationWindowType.setter
    def IntegrationWindowType(self, integrationWindowType:"AgECrdnIntegrationWindowType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegrationWindowType, integrationWindowType) as arg_integrationWindowType:
            agcls.evaluate_hresult(self.__dict__["_SetIntegrationWindowType"](arg_integrationWindowType.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Interpolation(self) -> "ICrdnInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Interpolation.setter
    def Interpolation(self, interpolation:"ICrdnInterp") -> None:
        with agmarshall.AgInterface_in_arg(interpolation, ICrdnInterp) as arg_interpolation:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolation"](arg_interpolation.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Integral(self) -> "ICrdnIntegral":
        """The numerical integration method."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntegral"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Integral.setter
    def Integral(self, integral:"ICrdnIntegral") -> None:
        with agmarshall.AgInterface_in_arg(integral, ICrdnIntegral) as arg_integral:
            agcls.evaluate_hresult(self.__dict__["_SetIntegral"](arg_integral.COM_val))

    @property
    def KeepConstantOutsideTimeLimits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetKeepConstantOutsideTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @KeepConstantOutsideTimeLimits.setter
    def KeepConstantOutsideTimeLimits(self, keepConstantOutsideTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(keepConstantOutsideTimeLimits) as arg_keepConstantOutsideTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetKeepConstantOutsideTimeLimits"](arg_keepConstantOutsideTimeLimits.COM_val))

    def SetOffsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset, \
             agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetOffsets"](arg_startOffset.COM_val, arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}", ICrdnCalcScalarIntegral)
agcls.AgTypeNameMap["ICrdnCalcScalarIntegral"] = ICrdnCalcScalarIntegral

class ICrdnCalcScalarPlugin(object):
    """Use a scalar calculation plugin."""
    _uuid = "{1459313C-59BD-42FF-9F0D-AF4604F13D4C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarPlugin = agcom.GUID(ICrdnCalcScalarPlugin._uuid)
        vtable_offset_local = ICrdnCalcScalarPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarPlugin.__dict__ and type(ICrdnCalcScalarPlugin.__dict__[attrname]) == property:
            return ICrdnCalcScalarPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1459313C-59BD-42FF-9F0D-AF4604F13D4C}", ICrdnCalcScalarPlugin)
agcls.AgTypeNameMap["ICrdnCalcScalarPlugin"] = ICrdnCalcScalarPlugin

class ICrdnCalcScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    _uuid = "{DC5C0166-111F-4E8A-9650-012CE6A57911}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint1"] = _raise_uninitialized_error
        self.__dict__["_SetPoint1"] = _raise_uninitialized_error
        self.__dict__["_GetPoint2"] = _raise_uninitialized_error
        self.__dict__["_SetPoint2"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarSurfaceDistanceBetweenPoints._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarSurfaceDistanceBetweenPoints from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints = agcom.GUID(ICrdnCalcScalarSurfaceDistanceBetweenPoints._uuid)
        vtable_offset_local = ICrdnCalcScalarSurfaceDistanceBetweenPoints._vtable_offset - 1
        self.__dict__["_GetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint1"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint2"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarSurfaceDistanceBetweenPoints, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__ and type(ICrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]) == property:
            return ICrdnCalcScalarSurfaceDistanceBetweenPoints.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarSurfaceDistanceBetweenPoints.")
    
    @property
    def Point1(self) -> "ICrdnPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint1"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point1.setter
    def Point1(self, point1:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point1, ICrdnPoint) as arg_point1:
            agcls.evaluate_hresult(self.__dict__["_SetPoint1"](arg_point1.COM_val))

    @property
    def Point2(self) -> "ICrdnPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point2.setter
    def Point2(self, point2:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point2, ICrdnPoint) as arg_point2:
            agcls.evaluate_hresult(self.__dict__["_SetPoint2"](arg_point2.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DC5C0166-111F-4E8A-9650-012CE6A57911}", ICrdnCalcScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["ICrdnCalcScalarSurfaceDistanceBetweenPoints"] = ICrdnCalcScalarSurfaceDistanceBetweenPoints

class ICrdnCalcScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""
    _uuid = "{2adb8ac1-7836-45af-b7f1-77b13a9db586}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetComponent"] = _raise_uninitialized_error
        self.__dict__["_SetComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarVectorComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarVectorComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarVectorComponent = agcom.GUID(ICrdnCalcScalarVectorComponent._uuid)
        vtable_offset_local = ICrdnCalcScalarVectorComponent._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetComponent"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetComponent"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorComponent, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarVectorComponent.__dict__ and type(ICrdnCalcScalarVectorComponent.__dict__[attrname]) == property:
            return ICrdnCalcScalarVectorComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarVectorComponent.")
    
    @property
    def InputVector(self) -> "ICrdnVector":
        """Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, ICrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def ReferenceAxes(self) -> "ICrdnAxes":
        """Axes used to resolve the vector's components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))

    @property
    def Component(self) -> "AgECrdnVectorComponentType":
        """The component of the vector to return as the value of the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetComponent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Component.setter
    def Component(self, component:"AgECrdnVectorComponentType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorComponentType, component) as arg_component:
            agcls.evaluate_hresult(self.__dict__["_SetComponent"](arg_component.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2adb8ac1-7836-45af-b7f1-77b13a9db586}", ICrdnCalcScalarVectorComponent)
agcls.AgTypeNameMap["ICrdnCalcScalarVectorComponent"] = ICrdnCalcScalarVectorComponent

class ICrdnCalcScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""
    _uuid = "{57FC76A1-A63F-4A25-A3A6-3953275A15E4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCalcScalarVectorMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCalcScalarVectorMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCalcScalarVectorMagnitude = agcom.GUID(ICrdnCalcScalarVectorMagnitude._uuid)
        vtable_offset_local = ICrdnCalcScalarVectorMagnitude._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorMagnitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnCalcScalarVectorMagnitude, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCalcScalarVectorMagnitude.__dict__ and type(ICrdnCalcScalarVectorMagnitude.__dict__[attrname]) == property:
            return ICrdnCalcScalarVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCalcScalarVectorMagnitude.")
    
    @property
    def InputVector(self) -> "ICrdnVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, ICrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{57FC76A1-A63F-4A25-A3A6-3953275A15E4}", ICrdnCalcScalarVectorMagnitude)
agcls.AgTypeNameMap["ICrdnCalcScalarVectorMagnitude"] = ICrdnCalcScalarVectorMagnitude

class ICrdnCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    _uuid = "{8CA43B7E-6345-4F97-97B2-A4C4517739C8}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCondition = agcom.GUID(ICrdnCondition._uuid)
        vtable_offset_local = ICrdnCondition._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnCondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCondition, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnCondition, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCondition.__dict__ and type(ICrdnCondition.__dict__[attrname]) == property:
            return ICrdnCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCondition.")
    
    @property
    def Type(self) -> "AgECrdnConditionType":
        """Returns the type of condition."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICrdnEvaluateResult":
        """Returns result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICrdnEvaluateWithRateResult":
        """Returns result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8CA43B7E-6345-4F97-97B2-A4C4517739C8}", ICrdnCondition)
agcls.AgTypeNameMap["ICrdnCondition"] = ICrdnCondition

class ICrdnConditionCombined(object):
    """Defines a condition which combines multiple conditions."""
    _uuid = "{EB19E942-0C28-4AB9-B2C0-D31693564C99}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        self.__dict__["_AddCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionCombined = agcom.GUID(ICrdnConditionCombined._uuid)
        vtable_offset_local = ICrdnConditionCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+7, agcom.PVOID, agcom.INT)
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+8, agcom.INT)
        self.__dict__["_AddCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionCombined, vtable_offset_local+9, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionCombined.__dict__ and type(ICrdnConditionCombined.__dict__[attrname]) == property:
            return ICrdnConditionCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnConditionCombinedOperationType":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnConditionCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Gets the number of conditions in the combined condition."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all conditions that are being combined."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def GetCondition(self, pos:int) -> "ICrdnCondition":
        """Get the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetCondition(self, ref:"ICrdnCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        with agmarshall.AgInterface_in_arg(ref, ICrdnCondition) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def RemoveCondition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))

    def AddCondition(self, ref:"ICrdnCondition") -> None:
        """Adds a condition at the end of the list."""
        with agmarshall.AgInterface_in_arg(ref, ICrdnCondition) as arg_ref:
            agcls.evaluate_hresult(self.__dict__["_AddCondition"](arg_ref.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB19E942-0C28-4AB9-B2C0-D31693564C99}", ICrdnConditionCombined)
agcls.AgTypeNameMap["ICrdnConditionCombined"] = ICrdnConditionCombined

class ICrdnConditionFactory(object):
    """The factory creates condition components."""
    _uuid = "{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionScalarBounds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateConditionPointInVolume"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionFactory = agcom.GUID(ICrdnConditionFactory._uuid)
        vtable_offset_local = ICrdnConditionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionScalarBounds"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateConditionCombined"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateConditionPointInVolume"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionFactory.__dict__ and type(ICrdnConditionFactory.__dict__[attrname]) == property:
            return ICrdnConditionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionType") -> "ICrdnCondition":
        """Creates and registers a condition using specified name, description and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionScalarBounds(self, name:str, description:str) -> "ICrdnCondition":
        """Creates a condition placing bounds on specified scalar."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionScalarBounds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateConditionCombined(self, name:str, description:str) -> "ICrdnCondition":
        """Creates a condition which combines multiple conditions."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateConditionPointInVolume(self, name:str, description:str) -> "ICrdnCondition":
        """Creates a condition for point in volume."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateConditionPointInVolume"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}", ICrdnConditionFactory)
agcls.AgTypeNameMap["ICrdnConditionFactory"] = ICrdnConditionFactory

class ICrdnConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    _uuid = "{3C354DF9-E914-4542-9E21-F70A637C4EA4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionPointInVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionPointInVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionPointInVolume = agcom.GUID(ICrdnConditionPointInVolume._uuid)
        vtable_offset_local = ICrdnConditionPointInVolume._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionPointInVolume, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionPointInVolume, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionPointInVolume, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionPointInVolume, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionPointInVolume.__dict__ and type(ICrdnConditionPointInVolume.__dict__[attrname]) == property:
            return ICrdnConditionPointInVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionPointInVolume.")
    
    @property
    def Point(self) -> "ICrdnPoint":
        """Get the trajectory point from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def Constraint(self) -> "ICrdnVolume":
        """Get the volume constraint on trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"ICrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, ICrdnVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3C354DF9-E914-4542-9E21-F70A637C4EA4}", ICrdnConditionPointInVolume)
agcls.AgTypeNameMap["ICrdnConditionPointInVolume"] = ICrdnConditionPointInVolume

class ICrdnConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    _uuid = "{FE3FB52B-9784-4707-8266-28F1E13B79D1}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumUnitless"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumUnitless"] = _raise_uninitialized_error
        self.__dict__["_SetUnitless"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionScalarBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionScalarBounds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionScalarBounds = agcom.GUID(ICrdnConditionScalarBounds._uuid)
        vtable_offset_local = ICrdnConditionScalarBounds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
        self.__dict__["_GetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumUnitless"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_SetUnitless"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionScalarBounds, vtable_offset_local+14, agcom.DOUBLE, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionScalarBounds.__dict__ and type(ICrdnConditionScalarBounds.__dict__[attrname]) == property:
            return ICrdnConditionScalarBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionScalarBounds.")
    
    @property
    def Scalar(self) -> "ICrdnCalcScalar":
        """Get the scalar calculation from the condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))

    def GetMinimumUnitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMinimumUnitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumUnitless"](arg_value.COM_val))

    def GetMaximumUnitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumUnitless"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetMaximumUnitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        with agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumUnitless"](arg_value.COM_val))

    def SetUnitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetUnitless"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FE3FB52B-9784-4707-8266-28F1E13B79D1}", ICrdnConditionScalarBounds)
agcls.AgTypeNameMap["ICrdnConditionScalarBounds"] = ICrdnConditionScalarBounds

class ICrdnConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    _uuid = "{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_Evaluate"] = _raise_uninitialized_error
        self.__dict__["_EvaluateWithRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSet = agcom.GUID(ICrdnConditionSet._uuid)
        vtable_offset_local = ICrdnConditionSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Evaluate"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSet, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_EvaluateWithRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSet, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSet.__dict__ and type(ICrdnConditionSet.__dict__[attrname]) == property:
            return ICrdnConditionSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSet.")
    
    @property
    def Type(self) -> "AgECrdnConditionSetType":
        """Returns the type of condition set."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Evaluate(self, epoch:typing.Any) -> "ICrdnConditionSetEvaluateResult":
        """Returns an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Evaluate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def EvaluateWithRate(self, epoch:typing.Any) -> "ICrdnConditionSetEvaluateWithRateResult":
        """Returns an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_EvaluateWithRate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}", ICrdnConditionSet)
agcls.AgTypeNameMap["ICrdnConditionSet"] = ICrdnConditionSet

class ICrdnConditionSetFactory(object):
    """The factory creates condition set components."""
    _uuid = "{698D592C-B264-426D-8577-AC7087E3EE44}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateScalarThresholds"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSetFactory = agcom.GUID(ICrdnConditionSetFactory._uuid)
        vtable_offset_local = ICrdnConditionSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateScalarThresholds"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSetFactory.__dict__ and type(ICrdnConditionSetFactory.__dict__[attrname]) == property:
            return ICrdnConditionSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnConditionSetType") -> "ICrdnConditionSet":
        """Creates and registers a condition set using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnConditionSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateScalarThresholds(self, name:str, description:str) -> "ICrdnConditionSet":
        """Create a scalar thresholds condition set."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateScalarThresholds"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnConditionSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnConditionSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{698D592C-B264-426D-8577-AC7087E3EE44}", ICrdnConditionSetFactory)
agcls.AgTypeNameMap["ICrdnConditionSetFactory"] = ICrdnConditionSetFactory

class ICrdnConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    _uuid = "{57392078-7821-4910-B734-76B5C70CB6D9}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        self.__dict__["_GetThresholds"] = _raise_uninitialized_error
        self.__dict__["_GetThresholdLabels"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeAboveHighestThreshold"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBelowLowestThreshold"] = _raise_uninitialized_error
        self.__dict__["_SetThresholdsAndLabels"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConditionSetScalarThresholds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConditionSetScalarThresholds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConditionSetScalarThresholds = agcom.GUID(ICrdnConditionSetScalarThresholds._uuid)
        vtable_offset_local = ICrdnConditionSetScalarThresholds._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThresholds"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetThresholdLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeAboveHighestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBelowLowestThreshold"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_SetThresholdsAndLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnConditionSetScalarThresholds, vtable_offset_local+9, POINTER(agcom.SAFEARRAY), POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConditionSetScalarThresholds.__dict__ and type(ICrdnConditionSetScalarThresholds.__dict__[attrname]) == property:
            return ICrdnConditionSetScalarThresholds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConditionSetScalarThresholds.")
    
    @property
    def Scalar(self) -> "ICrdnCalcScalar":
        """The input scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))

    @property
    def Thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholds"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ThresholdLabels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThresholdLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IncludeAboveHighestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeAboveHighestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeAboveHighestThreshold.setter
    def IncludeAboveHighestThreshold(self, includeAboveHighestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeAboveHighestThreshold) as arg_includeAboveHighestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeAboveHighestThreshold"](arg_includeAboveHighestThreshold.COM_val))

    @property
    def IncludeBelowLowestThreshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBelowLowestThreshold"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeBelowLowestThreshold.setter
    def IncludeBelowLowestThreshold(self, includeBelowLowestThreshold:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeBelowLowestThreshold) as arg_includeBelowLowestThreshold:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBelowLowestThreshold"](arg_includeBelowLowestThreshold.COM_val))

    def SetThresholdsAndLabels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        with agmarshall.SAFEARRAY_arg(thresholds) as arg_thresholds, \
             agmarshall.SAFEARRAY_arg(thresholdLabels) as arg_thresholdLabels:
            agcls.evaluate_hresult(self.__dict__["_SetThresholdsAndLabels"](byref(arg_thresholds.COM_val), byref(arg_thresholdLabels.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{57392078-7821-4910-B734-76B5C70CB6D9}", ICrdnConditionSetScalarThresholds)
agcls.AgTypeNameMap["ICrdnConditionSetScalarThresholds"] = ICrdnConditionSetScalarThresholds

class ICrdnConverge(object):
    """Represents a base class for convergence definitions."""
    _uuid = "{28B17124-9BE6-4437-A7ED-0DDC24353430}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConverge._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConverge from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConverge = agcom.GUID(ICrdnConverge._uuid)
        vtable_offset_local = ICrdnConverge._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConverge.__dict__ and type(ICrdnConverge.__dict__[attrname]) == property:
            return ICrdnConverge.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConverge.")
    

agcls.AgClassCatalog.add_catalog_entry("{28B17124-9BE6-4437-A7ED-0DDC24353430}", ICrdnConverge)
agcls.AgTypeNameMap["ICrdnConverge"] = ICrdnConverge

class ICrdnConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    _uuid = "{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSense"] = _raise_uninitialized_error
        self.__dict__["_SetSense"] = _raise_uninitialized_error
        self.__dict__["_GetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnConvergeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnConvergeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnConvergeBasic = agcom.GUID(ICrdnConvergeBasic._uuid)
        vtable_offset_local = ICrdnConvergeBasic._vtable_offset - 1
        self.__dict__["_GetSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnConvergeBasic, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnConvergeBasic.__dict__ and type(ICrdnConvergeBasic.__dict__[attrname]) == property:
            return ICrdnConvergeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnConvergeBasic.")
    
    @property
    def Sense(self) -> "AgECrdnThreshConvergeSense":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Sense.setter
    def Sense(self, sense:"AgECrdnThreshConvergeSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnThreshConvergeSense, sense) as arg_sense:
            agcls.evaluate_hresult(self.__dict__["_SetSense"](arg_sense.COM_val))

    @property
    def TimeTolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeTolerance.setter
    def TimeTolerance(self, timeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(timeTolerance) as arg_timeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTimeTolerance"](arg_timeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}", ICrdnConvergeBasic)
agcls.AgTypeNameMap["ICrdnConvergeBasic"] = ICrdnConvergeBasic

class ICrdnDerivative(object):
    """Represents a base class for derivative definitions."""
    _uuid = "{737042BD-D873-4CF6-B5D5-6769849156FD}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnDerivative = agcom.GUID(ICrdnDerivative._uuid)
        vtable_offset_local = ICrdnDerivative._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnDerivative.__dict__ and type(ICrdnDerivative.__dict__[attrname]) == property:
            return ICrdnDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnDerivative.")
    

agcls.AgClassCatalog.add_catalog_entry("{737042BD-D873-4CF6-B5D5-6769849156FD}", ICrdnDerivative)
agcls.AgTypeNameMap["ICrdnDerivative"] = ICrdnDerivative

class ICrdnDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    _uuid = "{CD450BBA-9F54-4F15-B067-C5A80C970FA9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnDerivativeBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnDerivativeBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnDerivativeBasic = agcom.GUID(ICrdnDerivativeBasic._uuid)
        vtable_offset_local = ICrdnDerivativeBasic._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnDerivativeBasic, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnDerivativeBasic, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnDerivativeBasic.__dict__ and type(ICrdnDerivativeBasic.__dict__[attrname]) == property:
            return ICrdnDerivativeBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnDerivativeBasic.")
    
    @property
    def TimeStep(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CD450BBA-9F54-4F15-B067-C5A80C970FA9}", ICrdnDerivativeBasic)
agcls.AgTypeNameMap["ICrdnDerivativeBasic"] = ICrdnDerivativeBasic

class ICrdnEvent(object):
    """Defines an event (time instant)."""
    _uuid = "{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_GetNoonToday"] = _raise_uninitialized_error
        self.__dict__["_GetNoonTomorrow"] = _raise_uninitialized_error
        self.__dict__["_FindOccurrence"] = _raise_uninitialized_error
        self.__dict__["_OccursBefore"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEvent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEvent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEvent = agcom.GUID(ICrdnEvent._uuid)
        vtable_offset_local = ICrdnEvent._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonToday"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetNoonTomorrow"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_FindOccurrence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_OccursBefore"] = IAGFUNCTYPE(pUnk, IID_ICrdnEvent, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEvent.__dict__ and type(ICrdnEvent.__dict__[attrname]) == property:
            return ICrdnEvent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEvent.")
    
    @property
    def Type(self) -> "AgECrdnEventType":
        """Return the type of time instant."""
        with agmarshall.AgEnum_arg(AgECrdnEventType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Today(self) -> "ICrdnEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "ICrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonToday(self) -> "ICrdnEvent":
        """Return time instant that corresponds to today's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def NoonTomorrow(self) -> "ICrdnEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNoonTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindOccurrence(self) -> "ICrdnEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindOccurrence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def OccursBefore(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_OccursBefore"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}", ICrdnEvent)
agcls.AgTypeNameMap["ICrdnEvent"] = ICrdnEvent

class ICrdnEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""
    _uuid = "{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_FindTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArray from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArray = agcom.GUID(ICrdnEventArray._uuid)
        vtable_offset_local = ICrdnEventArray._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArray, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_FindTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArray, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArray.__dict__ and type(ICrdnEventArray.__dict__[attrname]) == property:
            return ICrdnEventArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArray.")
    
    @property
    def Type(self) -> "AgECrdnEventArrayType":
        """Return the type of time array."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindTimes(self) -> "ICrdnFindTimesResult":
        """Return computed array of times."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}", ICrdnEventArray)
agcls.AgTypeNameMap["ICrdnEventArray"] = ICrdnEventArray

class ICrdnEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    _uuid = "{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionCrossing"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayConditionCrossings._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayConditionCrossings from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayConditionCrossings = agcom.GUID(ICrdnEventArrayConditionCrossings._uuid)
        vtable_offset_local = ICrdnEventArrayConditionCrossings._vtable_offset - 1
        self.__dict__["_GetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionCrossing"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayConditionCrossings, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayConditionCrossings.__dict__ and type(ICrdnEventArrayConditionCrossings.__dict__[attrname]) == property:
            return ICrdnEventArrayConditionCrossings.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayConditionCrossings.")
    
    @property
    def SatisfactionCrossing(self) -> "AgECrdnSatisfactionCrossing":
        """The direction of interest for satisfaction crossing."""
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionCrossing"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionCrossing.setter
    def SatisfactionCrossing(self, satisfactionCrossing:"AgECrdnSatisfactionCrossing") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSatisfactionCrossing, satisfactionCrossing) as arg_satisfactionCrossing:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionCrossing"](arg_satisfactionCrossing.COM_val))

    @property
    def Condition(self) -> "ICrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}", ICrdnEventArrayConditionCrossings)
agcls.AgTypeNameMap["ICrdnEventArrayConditionCrossings"] = ICrdnEventArrayConditionCrossings

class ICrdnEventArrayExtrema(object):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{664C3048-BB87-4841-988A-0580F2976C0D}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_SetIsGlobal"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayExtrema._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayExtrema from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayExtrema = agcom.GUID(ICrdnEventArrayExtrema._uuid)
        vtable_offset_local = ICrdnEventArrayExtrema._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsGlobal"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayExtrema, vtable_offset_local+16, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayExtrema.__dict__ and type(ICrdnEventArrayExtrema.__dict__[attrname]) == property:
            return ICrdnEventArrayExtrema.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayExtrema.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def IsGlobal(self) -> bool:
        """Indicates whether to perform local or global search. The default is false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsGlobal"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsGlobal.setter
    def IsGlobal(self, isGlobal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isGlobal) as arg_isGlobal:
            agcls.evaluate_hresult(self.__dict__["_SetIsGlobal"](arg_isGlobal.COM_val))

    @property
    def Calculation(self) -> "ICrdnCalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICrdnCalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{664C3048-BB87-4841-988A-0580F2976C0D}", ICrdnEventArrayExtrema)
agcls.AgTypeNameMap["ICrdnEventArrayExtrema"] = ICrdnEventArrayExtrema

class ICrdnEventArrayFactory(object):
    """The factory creates event arrays."""
    _uuid = "{CE43C07E-4626-4CEA-A625-C42052111CDE}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayExtrema"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayStartStopTimes"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayConditionCrossings"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArraySignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventArrayFixedTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayFactory = agcom.GUID(ICrdnEventArrayFactory._uuid)
        vtable_offset_local = ICrdnEventArrayFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayExtrema"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayStartStopTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayMerged"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFiltered"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayFixedStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArrayConditionCrossings"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventArraySignaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventArrayFixedTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayFactory.__dict__ and type(ICrdnEventArrayFactory.__dict__[attrname]) == property:
            return ICrdnEventArrayFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventArrayType") -> "ICrdnEventArray":
        """Create and register an event array using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventArrayType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayExtrema(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayExtrema"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayStartStopTimes(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayStartStopTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayMerged(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFiltered(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayFixedStep(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedStep"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArrayConditionCrossings(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayConditionCrossings"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventArraySignaled(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArraySignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventArrayType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventArrayFixedTimes(self, name:str, description:str) -> "ICrdnEventArray":
        """Create an event array using specified times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventArrayFixedTimes"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE43C07E-4626-4CEA-A625-C42052111CDE}", ICrdnEventArrayFactory)
agcls.AgTypeNameMap["ICrdnEventArrayFactory"] = ICrdnEventArrayFactory

class ICrdnEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""
    _uuid = "{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        self.__dict__["_SetFilterType"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_SetCount"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalStopTimes"] = _raise_uninitialized_error
        self.__dict__["_GetFilterIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetFilterIntervalList"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayFiltered = agcom.GUID(ICrdnEventArrayFiltered._uuid)
        vtable_offset_local = ICrdnEventArrayFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetFilterType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalStopTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetFilterIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFiltered, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayFiltered.__dict__ and type(ICrdnEventArrayFiltered.__dict__[attrname]) == property:
            return ICrdnEventArrayFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayFiltered.")
    
    @property
    def OriginalTimeArray(self) -> "ICrdnEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"ICrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, ICrdnEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def FilterType(self) -> "AgECrdnEventArrayFilterType":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FilterType.setter
    def FilterType(self, filterType:"AgECrdnEventArrayFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventArrayFilterType, filterType) as arg_filterType:
            agcls.evaluate_hresult(self.__dict__["_SetFilterType"](arg_filterType.COM_val))

    @property
    def Count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Count.setter
    def Count(self, count:int) -> None:
        with agmarshall.INT_arg(count) as arg_count:
            agcls.evaluate_hresult(self.__dict__["_SetCount"](arg_count.COM_val))

    @property
    def Step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))

    @property
    def IncludeIntervalStopTimes(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalStopTimes"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalStopTimes.setter
    def IncludeIntervalStopTimes(self, includeIntervalStopTimes:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalStopTimes) as arg_includeIntervalStopTimes:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalStopTimes"](arg_includeIntervalStopTimes.COM_val))

    @property
    def FilterIntervalList(self) -> "ICrdnEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @FilterIntervalList.setter
    def FilterIntervalList(self, filterIntervalList:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(filterIntervalList, ICrdnEventIntervalList) as arg_filterIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetFilterIntervalList"](arg_filterIntervalList.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}", ICrdnEventArrayFiltered)
agcls.AgTypeNameMap["ICrdnEventArrayFiltered"] = ICrdnEventArrayFiltered

class ICrdnEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    _uuid = "{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetBoundingIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeIntervalEdges"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayFixedStep = agcom.GUID(ICrdnEventArrayFixedStep._uuid)
        vtable_offset_local = ICrdnEventArrayFixedStep._vtable_offset - 1
        self.__dict__["_GetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetBoundingIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSamplingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeIntervalEdges"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedStep, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayFixedStep.__dict__ and type(ICrdnEventArrayFixedStep.__dict__[attrname]) == property:
            return ICrdnEventArrayFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayFixedStep.")
    
    @property
    def BoundingIntervalList(self) -> "ICrdnEventIntervalList":
        """The bounding interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBoundingIntervalList"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BoundingIntervalList.setter
    def BoundingIntervalList(self, boundingIntervalList:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(boundingIntervalList, ICrdnEventIntervalList) as arg_boundingIntervalList:
            agcls.evaluate_hresult(self.__dict__["_SetBoundingIntervalList"](arg_boundingIntervalList.COM_val))

    @property
    def SamplingTimeStep(self) -> float:
        """The sampling time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SamplingTimeStep.setter
    def SamplingTimeStep(self, samplingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(samplingTimeStep) as arg_samplingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingTimeStep"](arg_samplingTimeStep.COM_val))

    @property
    def IncludeIntervalEdges(self) -> bool:
        """Specify whether to include interval edges."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeIntervalEdges"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeIntervalEdges.setter
    def IncludeIntervalEdges(self, includeIntervalEdges:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeIntervalEdges) as arg_includeIntervalEdges:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeIntervalEdges"](arg_includeIntervalEdges.COM_val))

    @property
    def ReferenceType(self) -> "AgECrdnSampledReferenceTime":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, referenceType:"AgECrdnSampledReferenceTime") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSampledReferenceTime, referenceType) as arg_referenceType:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceType"](arg_referenceType.COM_val))

    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}", ICrdnEventArrayFixedStep)
agcls.AgTypeNameMap["ICrdnEventArrayFixedStep"] = ICrdnEventArrayFixedStep

class ICrdnEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""
    _uuid = "{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetArrayTimes"] = _raise_uninitialized_error
        self.__dict__["_SetArrayTimes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayFixedTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayFixedTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayFixedTimes = agcom.GUID(ICrdnEventArrayFixedTimes._uuid)
        vtable_offset_local = ICrdnEventArrayFixedTimes._vtable_offset - 1
        self.__dict__["_GetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedTimes, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetArrayTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayFixedTimes, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayFixedTimes.__dict__ and type(ICrdnEventArrayFixedTimes.__dict__[attrname]) == property:
            return ICrdnEventArrayFixedTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayFixedTimes.")
    
    @property
    def ArrayTimes(self) -> list:
        """The array of times."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetArrayTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetArrayTimes(self, times:list) -> None:
        """Sets array of times."""
        with agmarshall.SAFEARRAY_arg(times) as arg_times:
            agcls.evaluate_hresult(self.__dict__["_SetArrayTimes"](byref(arg_times.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}", ICrdnEventArrayFixedTimes)
agcls.AgTypeNameMap["ICrdnEventArrayFixedTimes"] = ICrdnEventArrayFixedTimes

class ICrdnEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    _uuid = "{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayA"] = _raise_uninitialized_error
        self.__dict__["_GetTimeArrayB"] = _raise_uninitialized_error
        self.__dict__["_SetTimeArrayB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayMerged = agcom.GUID(ICrdnEventArrayMerged._uuid)
        vtable_offset_local = ICrdnEventArrayMerged._vtable_offset - 1
        self.__dict__["_GetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayA"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayMerged, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayMerged, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeArrayB"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayMerged, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayMerged.__dict__ and type(ICrdnEventArrayMerged.__dict__[attrname]) == property:
            return ICrdnEventArrayMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayMerged.")
    
    @property
    def TimeArrayA(self) -> "ICrdnEventArray":
        """The first time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayA.setter
    def TimeArrayA(self, timeArrayA:"ICrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayA, ICrdnEventArray) as arg_timeArrayA:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayA"](arg_timeArrayA.COM_val))

    @property
    def TimeArrayB(self) -> "ICrdnEventArray":
        """The second time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeArrayB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeArrayB.setter
    def TimeArrayB(self, timeArrayB:"ICrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(timeArrayB, ICrdnEventArray) as arg_timeArrayB:
            agcls.evaluate_hresult(self.__dict__["_SetTimeArrayB"](arg_timeArrayB.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}", ICrdnEventArrayMerged)
agcls.AgTypeNameMap["ICrdnEventArrayMerged"] = ICrdnEventArrayMerged

class ICrdnEventArraySignaled(object):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    _uuid = "{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeArray"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArraySignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArraySignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArraySignaled = agcom.GUID(ICrdnEventArraySignaled._uuid)
        vtable_offset_local = ICrdnEventArraySignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeArray"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArraySignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArraySignaled.__dict__ and type(ICrdnEventArraySignaled.__dict__[attrname]) == property:
            return ICrdnEventArraySignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArraySignaled.")
    
    @property
    def OriginalTimeArray(self) -> "ICrdnEventArray":
        """The original time array."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeArray"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeArray.setter
    def OriginalTimeArray(self, originalTimeArray:"ICrdnEventArray") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeArray, ICrdnEventArray) as arg_originalTimeArray:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeArray"](arg_originalTimeArray.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "ICrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, ICrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "ICrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, ICrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ICrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ICrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ICrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}", ICrdnEventArraySignaled)
agcls.AgTypeNameMap["ICrdnEventArraySignaled"] = ICrdnEventArraySignaled

class ICrdnEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    _uuid = "{1AB79442-7711-4342-B944-81C51D14FBE4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_SetStartStopOption"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventArrayStartStopTimes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventArrayStartStopTimes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventArrayStartStopTimes = agcom.GUID(ICrdnEventArrayStartStopTimes._uuid)
        vtable_offset_local = ICrdnEventArrayStartStopTimes._vtable_offset - 1
        self.__dict__["_GetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayStartStopTimes, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetStartStopOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayStartStopTimes, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayStartStopTimes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventArrayStartStopTimes, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventArrayStartStopTimes.__dict__ and type(ICrdnEventArrayStartStopTimes.__dict__[attrname]) == property:
            return ICrdnEventArrayStartStopTimes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventArrayStartStopTimes.")
    
    @property
    def StartStopOption(self) -> "AgECrdnStartStopOption":
        """The edge type. At least one of the two edge types must be selected."""
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartStopOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartStopOption.setter
    def StartStopOption(self, startStopOption:"AgECrdnStartStopOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnStartStopOption, startStopOption) as arg_startStopOption:
            agcls.evaluate_hresult(self.__dict__["_SetStartStopOption"](arg_startStopOption.COM_val))

    @property
    def ReferenceIntervals(self) -> "ICrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ICrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1AB79442-7711-4342-B944-81C51D14FBE4}", ICrdnEventArrayStartStopTimes)
agcls.AgTypeNameMap["ICrdnEventArrayStartStopTimes"] = ICrdnEventArrayStartStopTimes

class ICrdnEventEpoch(object):
    """Event set at specified date/time."""
    _uuid = "{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventEpoch = agcom.GUID(ICrdnEventEpoch._uuid)
        vtable_offset_local = ICrdnEventEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventEpoch, vtable_offset_local+2, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventEpoch.__dict__ and type(ICrdnEventEpoch.__dict__[attrname]) == property:
            return ICrdnEventEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}", ICrdnEventEpoch)
agcls.AgTypeNameMap["ICrdnEventEpoch"] = ICrdnEventEpoch

class ICrdnEventExtremum(object):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{C588FDD4-2008-4C33-AA63-1C59565AE4F3}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_SetExtremumType"] = _raise_uninitialized_error
        self.__dict__["_GetCalculation"] = _raise_uninitialized_error
        self.__dict__["_SetCalculation"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventExtremum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventExtremum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventExtremum = agcom.GUID(ICrdnEventExtremum._uuid)
        vtable_offset_local = ICrdnEventExtremum._vtable_offset - 1
        self.__dict__["_GetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetExtremumType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCalculation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCalculation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventExtremum, vtable_offset_local+14, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventExtremum.__dict__ and type(ICrdnEventExtremum.__dict__[attrname]) == property:
            return ICrdnEventExtremum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventExtremum.")
    
    @property
    def ExtremumType(self) -> "AgECrdnExtremumConstants":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExtremumType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ExtremumType.setter
    def ExtremumType(self, extremumType:"AgECrdnExtremumConstants") -> None:
        with agmarshall.AgEnum_arg(AgECrdnExtremumConstants, extremumType) as arg_extremumType:
            agcls.evaluate_hresult(self.__dict__["_SetExtremumType"](arg_extremumType.COM_val))

    @property
    def Calculation(self) -> "ICrdnCalcScalar":
        """The scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalculation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Calculation.setter
    def Calculation(self, calculation:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(calculation, ICrdnCalcScalar) as arg_calculation:
            agcls.evaluate_hresult(self.__dict__["_SetCalculation"](arg_calculation.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C588FDD4-2008-4C33-AA63-1C59565AE4F3}", ICrdnEventExtremum)
agcls.AgTypeNameMap["ICrdnEventExtremum"] = ICrdnEventExtremum

class ICrdnEventFactory(object):
    """The factory creates events."""
    _uuid = "{803DD343-F271-47D9-8D71-2092DD2A3387}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetToday"] = _raise_uninitialized_error
        self.__dict__["_GetTomorrow"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventEpoch"] = _raise_uninitialized_error
        self.__dict__["_CreateEventExtremum"] = _raise_uninitialized_error
        self.__dict__["_CreateEventStartStopTime"] = _raise_uninitialized_error
        self.__dict__["_CreateEventSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromTime"] = _raise_uninitialized_error
        self.__dict__["_CreateSmartEpochFromEvent"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventFactory = agcom.GUID(ICrdnEventFactory._uuid)
        vtable_offset_local = ICrdnEventFactory._vtable_offset - 1
        self.__dict__["_GetToday"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTomorrow"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventExtremum"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventStartStopTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventSignaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+9, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateSmartEpochFromEvent"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventFactory, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventFactory.__dict__ and type(ICrdnEventFactory.__dict__[attrname]) == property:
            return ICrdnEventFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventFactory.")
    
    @property
    def Today(self) -> "ICrdnEvent":
        """Returns Today time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToday"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Tomorrow(self) -> "ICrdnEvent":
        """Returns Tomorrow time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTomorrow"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnEventType") -> "ICrdnEvent":
        """Creates and registers an event using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventEpoch(self, name:str, description:str) -> "ICrdnEvent":
        """Creates an event set at a specified date/time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventEpoch"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventExtremum(self, name:str, description:str) -> "ICrdnEvent":
        """Creates an event that determines the time of global minimum or maximum of specified scalar calculation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventExtremum"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventStartStopTime(self, name:str, description:str) -> "ICrdnEvent":
        """Creates an event that is either the start or stop time selected from a reference interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventStartStopTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventSignaled(self, name:str, description:str) -> "ICrdnEvent":
        """Creates an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventTimeOffset(self, name:str, description:str) -> "ICrdnEvent":
        """Creates an event at fixed offset from specified reference event."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromTime(self, epoch:typing.Any) -> "ICrdnEventSmartEpoch":
        """Creates a smart epoch from STK epoch."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromTime"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateSmartEpochFromEvent(self, refEvent:"ICrdnEvent") -> "ICrdnEventSmartEpoch":
        """Creates a smart epoch from an event."""
        with agmarshall.AgInterface_in_arg(refEvent, ICrdnEvent) as arg_refEvent, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateSmartEpochFromEvent"](arg_refEvent.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{803DD343-F271-47D9-8D71-2092DD2A3387}", ICrdnEventFactory)
agcls.AgTypeNameMap["ICrdnEventFactory"] = ICrdnEventFactory

class ICrdnEventInterval(object):
    """A single time interval."""
    _uuid = "{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStartDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStopDescription"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStart"] = _raise_uninitialized_error
        self.__dict__["_GetLabelStop"] = _raise_uninitialized_error
        self.__dict__["_FindInterval"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventInterval = agcom.GUID(ICrdnEventInterval._uuid)
        vtable_offset_local = ICrdnEventInterval._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabelStartDescription"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStopDescription"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetLabelStop"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_FindInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventInterval, vtable_offset_local+7, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventInterval.__dict__ and type(ICrdnEventInterval.__dict__[attrname]) == property:
            return ICrdnEventInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventInterval.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalType":
        """Return the type of interval."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStartDescription(self) -> str:
        """The start description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStartDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStopDescription(self) -> str:
        """The stop description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStopDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStart(self) -> str:
        """A label associated with the interval start."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def LabelStop(self) -> str:
        """A label associated with the interval stop."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindInterval(self) -> "ICrdnEventIntervalResult":
        """Return computed interval if it exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}", ICrdnEventInterval)
agcls.AgTypeNameMap["ICrdnEventInterval"] = ICrdnEventInterval

class ICrdnEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    _uuid = "{18236EC1-B691-4FFD-995B-FB4896BAFD71}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStopTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetStopTimeInstant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalBetweenTimeInstants._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalBetweenTimeInstants from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalBetweenTimeInstants = agcom.GUID(ICrdnEventIntervalBetweenTimeInstants._uuid)
        vtable_offset_local = ICrdnEventIntervalBetweenTimeInstants._vtable_offset - 1
        self.__dict__["_GetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalBetweenTimeInstants, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetStartTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalBetweenTimeInstants, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalBetweenTimeInstants, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetStopTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalBetweenTimeInstants, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalBetweenTimeInstants.__dict__ and type(ICrdnEventIntervalBetweenTimeInstants.__dict__[attrname]) == property:
            return ICrdnEventIntervalBetweenTimeInstants.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalBetweenTimeInstants.")
    
    @property
    def StartTimeInstant(self) -> "ICrdnEvent":
        """The start time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StartTimeInstant.setter
    def StartTimeInstant(self, startTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(startTimeInstant, ICrdnEvent) as arg_startTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeInstant"](arg_startTimeInstant.COM_val))

    @property
    def StopTimeInstant(self) -> "ICrdnEvent":
        """The stop time instant of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @StopTimeInstant.setter
    def StopTimeInstant(self, stopTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(stopTimeInstant, ICrdnEvent) as arg_stopTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetStopTimeInstant"](arg_stopTimeInstant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18236EC1-B691-4FFD-995B-FB4896BAFD71}", ICrdnEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["ICrdnEventIntervalBetweenTimeInstants"] = ICrdnEventIntervalBetweenTimeInstants

class ICrdnEventIntervalCollection(object):
    """A collection of related interval lists."""
    _uuid = "{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_FindIntervalCollection"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollection = agcom.GUID(ICrdnEventIntervalCollection._uuid)
        vtable_offset_local = ICrdnEventIntervalCollection._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollection, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervalCollection"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollection, vtable_offset_local+4, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollection.__dict__ and type(ICrdnEventIntervalCollection.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollection.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalCollectionType":
        """Return the type of collection of interval lists."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervalCollection(self) -> "ICrdnIntervalsVectorResult":
        """Return computed collection of interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> "ICrdnEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}", ICrdnEventIntervalCollection)
agcls.AgTypeNameMap["ICrdnEventIntervalCollection"] = ICrdnEventIntervalCollection

class ICrdnEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{0253FA16-73AA-4F0A-9904-0789EC873ECB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_SetConditionSet"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionCondition = agcom.GUID(ICrdnEventIntervalCollectionCondition._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionCondition._vtable_offset - 1
        self.__dict__["_GetConditionSet"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetConditionSet"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionCondition.__dict__ and type(ICrdnEventIntervalCollectionCondition.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionCondition.")
    
    @property
    def ConditionSet(self) -> "ICrdnConditionSet":
        """Get/set the condition set object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSet"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ConditionSet.setter
    def ConditionSet(self, conditionSet:"ICrdnConditionSet") -> None:
        with agmarshall.AgInterface_in_arg(conditionSet, ICrdnConditionSet) as arg_conditionSet:
            agcls.evaluate_hresult(self.__dict__["_SetConditionSet"](arg_conditionSet.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determines if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0253FA16-73AA-4F0A-9904-0789EC873ECB}", ICrdnEventIntervalCollectionCondition)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionCondition"] = ICrdnEventIntervalCollectionCondition

class ICrdnEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""
    _uuid = "{15E2D2CF-61F9-4468-A5E1-770149F6B08C}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionFactory = agcom.GUID(ICrdnEventIntervalCollectionFactory._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionLighting"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalCollectionSignaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionFactory, vtable_offset_local+4, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalCollectionSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionFactory.__dict__ and type(ICrdnEventIntervalCollectionFactory.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalCollectionType") -> "ICrdnEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionLighting(self, name:str, description:str) -> "ICrdnEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalCollectionSignaled(self, name:str, description:str) -> "ICrdnEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalCollectionType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalCollectionType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalCollectionSatisfaction(self, name:str, description:str) -> "ICrdnEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalCollectionSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15E2D2CF-61F9-4468-A5E1-770149F6B08C}", ICrdnEventIntervalCollectionFactory)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionFactory"] = ICrdnEventIntervalCollectionFactory

class ICrdnEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    _uuid = "{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionLighting = agcom.GUID(ICrdnEventIntervalCollectionLighting._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionLighting._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+4, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionLighting, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionLighting.__dict__ and type(ICrdnEventIntervalCollectionLighting.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionLighting.")
    
    @property
    def Location(self) -> "ICrdnPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, ICrdnPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}", ICrdnEventIntervalCollectionLighting)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionLighting"] = ICrdnEventIntervalCollectionLighting

class ICrdnEventIntervalCollectionSignaled(object):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    _uuid = "{AE464683-EEEC-46CF-8886-91F7A30B7859}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalCollection"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalCollectionSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalCollectionSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalCollectionSignaled = agcom.GUID(ICrdnEventIntervalCollectionSignaled._uuid)
        vtable_offset_local = ICrdnEventIntervalCollectionSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalCollection"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalCollectionSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalCollectionSignaled.__dict__ and type(ICrdnEventIntervalCollectionSignaled.__dict__[attrname]) == property:
            return ICrdnEventIntervalCollectionSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalCollectionSignaled.")
    
    @property
    def OriginalCollection(self) -> "ICrdnEventIntervalCollection":
        """The original interval list collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalCollection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalCollection.setter
    def OriginalCollection(self, originalCollection:"ICrdnEventIntervalCollection") -> None:
        with agmarshall.AgInterface_in_arg(originalCollection, ICrdnEventIntervalCollection) as arg_originalCollection:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalCollection"](arg_originalCollection.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "ICrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, ICrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "ICrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, ICrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ICrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ICrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ICrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AE464683-EEEC-46CF-8886-91F7A30B7859}", ICrdnEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["ICrdnEventIntervalCollectionSignaled"] = ICrdnEventIntervalCollectionSignaled

class ICrdnEventIntervalFactory(object):
    """The factory creates event intervals."""
    _uuid = "{F87C00CA-725C-425C-941E-6987709D788F}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixed"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFixedDuration"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalFromIntervalList"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalFactory = agcom.GUID(ICrdnEventIntervalFactory._uuid)
        vtable_offset_local = ICrdnEventIntervalFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFixedDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalBetweenTimeInstants"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalFromIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalScaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalSignaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFactory, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalFactory.__dict__ and type(ICrdnEventIntervalFactory.__dict__[attrname]) == property:
            return ICrdnEventIntervalFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalType") -> "ICrdnEventInterval":
        """Create and register an interval using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixed(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFixedDuration(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFixedDuration"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalBetweenTimeInstants(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval using specified start and stop time instants."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalBetweenTimeInstants"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalFromIntervalList(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalFromIntervalList"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalScaled(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalSignaled(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalTimeOffset(self, name:str, description:str) -> "ICrdnEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F87C00CA-725C-425C-941E-6987709D788F}", ICrdnEventIntervalFactory)
agcls.AgTypeNameMap["ICrdnEventIntervalFactory"] = ICrdnEventIntervalFactory

class ICrdnEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    _uuid = "{2DBC4523-FDD0-413B-B933-9F74B9B17BED}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStartTime"] = _raise_uninitialized_error
        self.__dict__["_GetStopTime"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalFixed = agcom.GUID(ICrdnEventIntervalFixed._uuid)
        vtable_offset_local = ICrdnEventIntervalFixed._vtable_offset - 1
        self.__dict__["_GetStartTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixed, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetStopTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixed, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixed, vtable_offset_local+3, agcom.VARIANT, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalFixed.__dict__ and type(ICrdnEventIntervalFixed.__dict__[attrname]) == property:
            return ICrdnEventIntervalFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalFixed.")
    
    @property
    def StartTime(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def StopTime(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def SetInterval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch, \
             agmarshall.VARIANT_arg(stopEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_startEpoch.COM_val, arg_stopEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2DBC4523-FDD0-413B-B933-9F74B9B17BED}", ICrdnEventIntervalFixed)
agcls.AgTypeNameMap["ICrdnEventIntervalFixed"] = ICrdnEventIntervalFixed

class ICrdnEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    _uuid = "{2A20830B-D576-4DF1-9C15-51EB59AEC23F}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalFixedDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalFixedDuration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalFixedDuration = agcom.GUID(ICrdnEventIntervalFixedDuration._uuid)
        vtable_offset_local = ICrdnEventIntervalFixedDuration._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFixedDuration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalFixedDuration.__dict__ and type(ICrdnEventIntervalFixedDuration.__dict__[attrname]) == property:
            return ICrdnEventIntervalFixedDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalFixedDuration.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def StartOffset(self) -> float:
        """The start time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """The stop time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A20830B-D576-4DF1-9C15-51EB59AEC23F}", ICrdnEventIntervalFixedDuration)
agcls.AgTypeNameMap["ICrdnEventIntervalFixedDuration"] = ICrdnEventIntervalFixedDuration

class ICrdnEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""
    _uuid = "{DCF8AA30-67A3-4856-956D-C4952BF3818E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalSelection"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalNumber"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalNumber"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalFromIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalFromIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalFromIntervalList = agcom.GUID(ICrdnEventIntervalFromIntervalList._uuid)
        vtable_offset_local = ICrdnEventIntervalFromIntervalList._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetIntervalSelection"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetIntervalNumber"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalFromIntervalList, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalFromIntervalList.__dict__ and type(ICrdnEventIntervalFromIntervalList.__dict__[attrname]) == property:
            return ICrdnEventIntervalFromIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalFromIntervalList.")
    
    @property
    def ReferenceIntervals(self) -> "ICrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ICrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def IntervalSelection(self) -> "AgECrdnIntervalSelection":
        """The method used to select an interval from the reference interval list."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalSelection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalSelection.setter
    def IntervalSelection(self, intervalSelection:"AgECrdnIntervalSelection") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalSelection, intervalSelection) as arg_intervalSelection:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalSelection"](arg_intervalSelection.COM_val))

    @property
    def IntervalNumber(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd"""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalNumber"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalNumber.setter
    def IntervalNumber(self, intervalNumber:int) -> None:
        with agmarshall.INT_arg(intervalNumber) as arg_intervalNumber:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalNumber"](arg_intervalNumber.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DCF8AA30-67A3-4856-956D-C4952BF3818E}", ICrdnEventIntervalFromIntervalList)
agcls.AgTypeNameMap["ICrdnEventIntervalFromIntervalList"] = ICrdnEventIntervalFromIntervalList

class ICrdnEventIntervalList(object):
    """An ordered list of time intervals."""
    _uuid = "{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDescriptions"] = _raise_uninitialized_error
        self.__dict__["_FindIntervals"] = _raise_uninitialized_error
        self.__dict__["_Occurred"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalList._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalList from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalList = agcom.GUID(ICrdnEventIntervalList._uuid)
        vtable_offset_local = ICrdnEventIntervalList._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalList, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalList, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDescriptions"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalList, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_FindIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalList, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Occurred"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalList, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalList.__dict__ and type(ICrdnEventIntervalList.__dict__[attrname]) == property:
            return ICrdnEventIntervalList.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalList.")
    
    @property
    def Type(self) -> "AgECrdnEventIntervalListType":
        """Return the type of interval list."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDescriptions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def FindIntervals(self) -> "ICrdnIntervalListResult":
        """Return computed interval list that can be empty."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Occurred"](arg_epoch.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}", ICrdnEventIntervalList)
agcls.AgTypeNameMap["ICrdnEventIntervalList"] = ICrdnEventIntervalList

class ICrdnEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    _uuid = "{D073568A-7398-45C2-998A-CD2EC12F06E0}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_SetSaveDataOption"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListCondition = agcom.GUID(ICrdnEventIntervalListCondition._uuid)
        vtable_offset_local = ICrdnEventIntervalListCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSaveDataOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListCondition, vtable_offset_local+12, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListCondition.__dict__ and type(ICrdnEventIntervalListCondition.__dict__[attrname]) == property:
            return ICrdnEventIntervalListCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListCondition.")
    
    @property
    def Condition(self) -> "ICrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def SaveDataOption(self) -> "AgECrdnSaveDataOption":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveDataOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SaveDataOption.setter
    def SaveDataOption(self, saveDataOption:"AgECrdnSaveDataOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSaveDataOption, saveDataOption) as arg_saveDataOption:
            agcls.evaluate_hresult(self.__dict__["_SetSaveDataOption"](arg_saveDataOption.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D073568A-7398-45C2-998A-CD2EC12F06E0}", ICrdnEventIntervalListCondition)
agcls.AgTypeNameMap["ICrdnEventIntervalListCondition"] = ICrdnEventIntervalListCondition

class ICrdnEventIntervalListFactory(object):
    """The factory creates event interval lists."""
    _uuid = "{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListMerged"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFiltered"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListScaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListSignaled"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFile"] = _raise_uninitialized_error
        self.__dict__["_CreateEventIntervalListFixed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListFactory = agcom.GUID(ICrdnEventIntervalListFactory._uuid)
        vtable_offset_local = ICrdnEventIntervalListFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListMerged"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFiltered"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListScaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListSignaled"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateEventIntervalListFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateEventIntervalListFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListFactory.__dict__ and type(ICrdnEventIntervalListFactory.__dict__[attrname]) == property:
            return ICrdnEventIntervalListFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnEventIntervalListType") -> "ICrdnEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListMerged(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListMerged"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFiltered(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFiltered"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListCondition(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListScaled(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListScaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListSignaled(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListSignaled"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListTimeOffset(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListTimeOffset"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnEventIntervalListType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnEventIntervalListType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateEventIntervalListFile(self, name:str, description:str, filePath:str) -> "ICrdnEventIntervalList":
        """Create an interval list based on specified interval file."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(filePath) as arg_filePath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFile"](arg_name.COM_val, arg_description.COM_val, arg_filePath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateEventIntervalListFixed(self, name:str, description:str) -> "ICrdnEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEventIntervalListFixed"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}", ICrdnEventIntervalListFactory)
agcls.AgTypeNameMap["ICrdnEventIntervalListFactory"] = ICrdnEventIntervalListFactory

class ICrdnEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    _uuid = "{A17588F4-C944-44F8-B8D8-275B13D27E3A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        self.__dict__["_GetFileSpan"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListFile = agcom.GUID(ICrdnEventIntervalListFile._uuid)
        vtable_offset_local = ICrdnEventIntervalListFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFile, vtable_offset_local+3, )
        self.__dict__["_GetFileSpan"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFile, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListFile.__dict__ and type(ICrdnEventIntervalListFile.__dict__[attrname]) == property:
            return ICrdnEventIntervalListFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the interval list file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())

    def GetFileSpan(self) -> "ICrdnEventIntervalResult":
        """Computes the interval list file span."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileSpan"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A17588F4-C944-44F8-B8D8-275B13D27E3A}", ICrdnEventIntervalListFile)
agcls.AgTypeNameMap["ICrdnEventIntervalListFile"] = ICrdnEventIntervalListFile

class ICrdnEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    _uuid = "{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetFilterFactory"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListFiltered._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListFiltered from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListFiltered = agcom.GUID(ICrdnEventIntervalListFiltered._uuid)
        vtable_offset_local = ICrdnEventIntervalListFiltered._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFiltered, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFiltered, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetFilterFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFiltered, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFiltered, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFiltered, vtable_offset_local+5, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListFiltered.__dict__ and type(ICrdnEventIntervalListFiltered.__dict__[attrname]) == property:
            return ICrdnEventIntervalListFiltered.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListFiltered.")
    
    @property
    def OriginalIntervals(self) -> "ICrdnEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ICrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def FilterFactory(self) -> "ICrdnPruneFilterFactory":
        """Get the prune filter factory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filter(self) -> "ICrdnPruneFilter":
        """The pruning filter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"ICrdnPruneFilter") -> None:
        with agmarshall.AgInterface_in_arg(filter, ICrdnPruneFilter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}", ICrdnEventIntervalListFiltered)
agcls.AgTypeNameMap["ICrdnEventIntervalListFiltered"] = ICrdnEventIntervalListFiltered

class ICrdnEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    _uuid = "{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListFixed = agcom.GUID(ICrdnEventIntervalListFixed._uuid)
        vtable_offset_local = ICrdnEventIntervalListFixed._vtable_offset - 1
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFixed, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListFixed, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListFixed.__dict__ and type(ICrdnEventIntervalListFixed.__dict__[attrname]) == property:
            return ICrdnEventIntervalListFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListFixed.")
    
    def GetIntervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetIntervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        with agmarshall.SAFEARRAY_arg(intervals) as arg_intervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervals"](byref(arg_intervals.COM_val)))


agcls.AgClassCatalog.add_catalog_entry("{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}", ICrdnEventIntervalListFixed)
agcls.AgTypeNameMap["ICrdnEventIntervalListFixed"] = ICrdnEventIntervalListFixed

class ICrdnEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    _uuid = "{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIntervalListOrIntervalA"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalListOrIntervalB"] = _raise_uninitialized_error
        self.__dict__["_GetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetMergeOperation"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalA"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalListB"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalB"] = _raise_uninitialized_error
        self.__dict__["_AddInterval"] = _raise_uninitialized_error
        self.__dict__["_AddIntervalList"] = _raise_uninitialized_error
        self.__dict__["_SetInterval"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalList"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponent"] = _raise_uninitialized_error
        self.__dict__["_GetTimeComponentSize"] = _raise_uninitialized_error
        self.__dict__["_RemoveTimeComponent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListMerged._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListMerged from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListMerged = agcom.GUID(ICrdnEventIntervalListMerged._uuid)
        vtable_offset_local = ICrdnEventIntervalListMerged._vtable_offset - 1
        self.__dict__["_GetIntervalListOrIntervalA"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetIntervalListOrIntervalB"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMergeOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetIntervalListA"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+5, agcom.PVOID)
        self.__dict__["_SetIntervalA"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_SetIntervalListB"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+7, agcom.PVOID)
        self.__dict__["_SetIntervalB"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_AddInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+9, agcom.PVOID)
        self.__dict__["_AddIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_SetInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+11, agcom.PVOID, agcom.INT)
        self.__dict__["_SetIntervalList"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+12, agcom.PVOID, agcom.INT)
        self.__dict__["_GetTimeComponent"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+13, agcom.INT, POINTER(agcom.BSTR))
        self.__dict__["_GetTimeComponentSize"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+14, POINTER(agcom.INT))
        self.__dict__["_RemoveTimeComponent"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListMerged, vtable_offset_local+15, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListMerged.__dict__ and type(ICrdnEventIntervalListMerged.__dict__[attrname]) == property:
            return ICrdnEventIntervalListMerged.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListMerged.")
    
    @property
    def IntervalListOrIntervalA(self) -> "ICrdn":
        """The interval list or interval A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IntervalListOrIntervalB(self) -> "ICrdn":
        """The interval list or interval B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalListOrIntervalB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MergeOperation(self) -> "AgECrdnEventListMergeOperation":
        """The merge operation."""
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMergeOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MergeOperation.setter
    def MergeOperation(self, mergeOperation:"AgECrdnEventListMergeOperation") -> None:
        with agmarshall.AgEnum_arg(AgECrdnEventListMergeOperation, mergeOperation) as arg_mergeOperation:
            agcls.evaluate_hresult(self.__dict__["_SetMergeOperation"](arg_mergeOperation.COM_val))

    def SetIntervalListA(self, refIntervals:"ICrdnEventIntervalList") -> None:
        """Sets the interval list A."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListA"](arg_refIntervals.COM_val))

    def SetIntervalA(self, refIntervals:"ICrdnEventInterval") -> None:
        """Sets the interval A."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalA"](arg_refIntervals.COM_val))

    def SetIntervalListB(self, refIntervals:"ICrdnEventIntervalList") -> None:
        """Sets the interval list B."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalListB"](arg_refIntervals.COM_val))

    def SetIntervalB(self, refIntervals:"ICrdnEventInterval") -> None:
        """Sets the interval B."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalB"](arg_refIntervals.COM_val))

    def AddInterval(self, refIntervals:"ICrdnEventInterval") -> None:
        """Add interval."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventInterval) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddInterval"](arg_refIntervals.COM_val))

    def AddIntervalList(self, refIntervals:"ICrdnEventIntervalList") -> None:
        """Add interval list."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventIntervalList) as arg_refIntervals:
            agcls.evaluate_hresult(self.__dict__["_AddIntervalList"](arg_refIntervals.COM_val))

    def SetInterval(self, refIntervals:"ICrdnEventInterval", pos:int) -> None:
        """Sets the interval at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventInterval) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetInterval"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def SetIntervalList(self, refIntervals:"ICrdnEventIntervalList", pos:int) -> None:
        """Sets the interval list at given index."""
        with agmarshall.AgInterface_in_arg(refIntervals, ICrdnEventIntervalList) as arg_refIntervals, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalList"](arg_refIntervals.COM_val, arg_pos.COM_val))

    def GetTimeComponent(self, pos:int) -> str:
        """Gets time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponent"](arg_pos.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetTimeComponentSize(self) -> int:
        """Gets time component list size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeComponentSize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def RemoveTimeComponent(self, pos:int) -> None:
        """Remove time component at given position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveTimeComponent"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}", ICrdnEventIntervalListMerged)
agcls.AgTypeNameMap["ICrdnEventIntervalListMerged"] = ICrdnEventIntervalListMerged

class ICrdnEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    _uuid = "{7DDA88F8-A738-464E-9CDC-613E107F57D0}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListScaled = agcom.GUID(ICrdnEventIntervalListScaled._uuid)
        vtable_offset_local = ICrdnEventIntervalListScaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListScaled.__dict__ and type(ICrdnEventIntervalListScaled.__dict__[attrname]) == property:
            return ICrdnEventIntervalListScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListScaled.")
    
    @property
    def OriginalIntervals(self) -> "ICrdnEventIntervalList":
        """The original interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ICrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7DDA88F8-A738-464E-9CDC-613E107F57D0}", ICrdnEventIntervalListScaled)
agcls.AgTypeNameMap["ICrdnEventIntervalListScaled"] = ICrdnEventIntervalListScaled

class ICrdnEventIntervalListSignaled(object):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    _uuid = "{C40EA24E-E258-4B0E-8A0F-89424F93F837}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListSignaled = agcom.GUID(ICrdnEventIntervalListSignaled._uuid)
        vtable_offset_local = ICrdnEventIntervalListSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListSignaled.__dict__ and type(ICrdnEventIntervalListSignaled.__dict__[attrname]) == property:
            return ICrdnEventIntervalListSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListSignaled.")
    
    @property
    def OriginalIntervals(self) -> "ICrdnEventIntervalList":
        """The original time interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalIntervals.setter
    def OriginalIntervals(self, originalIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(originalIntervals, ICrdnEventIntervalList) as arg_originalIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalIntervals"](arg_originalIntervals.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "ICrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, ICrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "ICrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, ICrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ICrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ICrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ICrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C40EA24E-E258-4B0E-8A0F-89424F93F837}", ICrdnEventIntervalListSignaled)
agcls.AgTypeNameMap["ICrdnEventIntervalListSignaled"] = ICrdnEventIntervalListSignaled

class ICrdnEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    _uuid = "{EEA120D3-8E9F-419B-B11C-A034007EB2D0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalListTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalListTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalListTimeOffset = agcom.GUID(ICrdnEventIntervalListTimeOffset._uuid)
        vtable_offset_local = ICrdnEventIntervalListTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalListTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalListTimeOffset.__dict__ and type(ICrdnEventIntervalListTimeOffset.__dict__[attrname]) == property:
            return ICrdnEventIntervalListTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalListTimeOffset.")
    
    @property
    def ReferenceIntervals(self) -> "ICrdnEventIntervalList":
        """The reference interval list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ICrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEA120D3-8E9F-419B-B11C-A034007EB2D0}", ICrdnEventIntervalListTimeOffset)
agcls.AgTypeNameMap["ICrdnEventIntervalListTimeOffset"] = ICrdnEventIntervalListTimeOffset

class ICrdnEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    _uuid = "{FA9613FB-7341-4785-AD95-51CFA2B605BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIncrement"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteIncrement"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteIncrement"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalScaled = agcom.GUID(ICrdnEventIntervalScaled._uuid)
        vtable_offset_local = ICrdnEventIntervalScaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteIncrement"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalScaled.__dict__ and type(ICrdnEventIntervalScaled.__dict__[attrname]) == property:
            return ICrdnEventIntervalScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalScaled.")
    
    @property
    def OriginalInterval(self) -> "ICrdnEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"ICrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, ICrdnEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def AbsoluteIncrement(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteIncrement.setter
    def AbsoluteIncrement(self, absoluteIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteIncrement) as arg_absoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteIncrement"](arg_absoluteIncrement.COM_val))

    @property
    def RelativeIncrement(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIncrement.setter
    def RelativeIncrement(self, relativeIncrement:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIncrement) as arg_relativeIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIncrement"](arg_relativeIncrement.COM_val))

    @property
    def UseAbsoluteIncrement(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteIncrement"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseAbsoluteIncrement.setter
    def UseAbsoluteIncrement(self, useAbsoluteIncrement:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useAbsoluteIncrement) as arg_useAbsoluteIncrement:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteIncrement"](arg_useAbsoluteIncrement.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FA9613FB-7341-4785-AD95-51CFA2B605BC}", ICrdnEventIntervalScaled)
agcls.AgTypeNameMap["ICrdnEventIntervalScaled"] = ICrdnEventIntervalScaled

class ICrdnEventIntervalSignaled(object):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    _uuid = "{51B9DE87-9220-40B2-AA57-01F7B17BD945}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalInterval"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalSignaled = agcom.GUID(ICrdnEventIntervalSignaled._uuid)
        vtable_offset_local = ICrdnEventIntervalSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalSignaled.__dict__ and type(ICrdnEventIntervalSignaled.__dict__[attrname]) == property:
            return ICrdnEventIntervalSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalSignaled.")
    
    @property
    def OriginalInterval(self) -> "ICrdnEventInterval":
        """The original interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalInterval.setter
    def OriginalInterval(self, originalInterval:"ICrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(originalInterval, ICrdnEventInterval) as arg_originalInterval:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalInterval"](arg_originalInterval.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "ICrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, ICrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "ICrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, ICrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ICrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ICrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ICrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{51B9DE87-9220-40B2-AA57-01F7B17BD945}", ICrdnEventIntervalSignaled)
agcls.AgTypeNameMap["ICrdnEventIntervalSignaled"] = ICrdnEventIntervalSignaled

class ICrdnEventIntervalSmartInterval(object):
    """A smart interval."""
    _uuid = "{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_SetDurationAsString"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_FindStartTime"] = _raise_uninitialized_error
        self.__dict__["_FindStopTime"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStopEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitInterval"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopEpochs"] = _raise_uninitialized_error
        self.__dict__["_SetStartAndStopTimes"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpochAndDuration"] = _raise_uninitialized_error
        self.__dict__["_SetStartTimeAndDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalSmartInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalSmartInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalSmartInterval = agcom.GUID(ICrdnEventIntervalSmartInterval._uuid)
        vtable_offset_local = ICrdnEventIntervalSmartInterval._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetDurationAsString"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_SetImplicitInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_FindStartTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_FindStopTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+10, agcom.PVOID)
        self.__dict__["_GetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetStopEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_SetExplicitInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+13, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartAndStopEpochs"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+14, agcom.PVOID, agcom.PVOID)
        self.__dict__["_SetStartAndStopTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+15, agcom.VARIANT, agcom.VARIANT)
        self.__dict__["_SetStartEpochAndDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+16, agcom.PVOID, agcom.BSTR)
        self.__dict__["_SetStartTimeAndDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalSmartInterval, vtable_offset_local+17, agcom.VARIANT, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalSmartInterval.__dict__ and type(ICrdnEventIntervalSmartInterval.__dict__[attrname]) == property:
            return ICrdnEventIntervalSmartInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalSmartInterval.")
    
    @property
    def ReferenceInterval(self) -> "ICrdnEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DurationAsString(self) -> str:
        """The duration of the interval"""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationAsString"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationAsString.setter
    def DurationAsString(self, durationAsString:str) -> None:
        with agmarshall.BSTR_arg(durationAsString) as arg_durationAsString:
            agcls.evaluate_hresult(self.__dict__["_SetDurationAsString"](arg_durationAsString.COM_val))

    @property
    def State(self) -> "AgECrdnSmartIntervalState":
        """A state of the smart interval."""
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartIntervalState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartIntervalState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetImplicitInterval(self, eventInterval:"ICrdnEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventInterval, ICrdnEventInterval) as arg_eventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitInterval"](arg_eventInterval.COM_val))

    def FindStartTime(self) -> typing.Any:
        """Finds a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStartTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def FindStopTime(self) -> typing.Any:
        """Finds a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_FindStopTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetStartEpoch(self) -> "ICrdnEventSmartEpoch":
        """Returns a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStartEpoch(self, startEpoch:"ICrdnEventSmartEpoch") -> None:
        """Sets a start of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(startEpoch, ICrdnEventSmartEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    def GetStopEpoch(self) -> "ICrdnEventSmartEpoch":
        """Returns a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopEpoch"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetStopEpoch(self, stopEpoch:"ICrdnEventSmartEpoch") -> None:
        """Sets a stop of the interval using specified epoch component."""
        with agmarshall.AgInterface_in_arg(stopEpoch, ICrdnEventSmartEpoch) as arg_stopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStopEpoch"](arg_stopEpoch.COM_val))

    def SetExplicitInterval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(start) as arg_start, \
             agmarshall.VARIANT_arg(stop) as arg_stop:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitInterval"](arg_start.COM_val, arg_stop.COM_val))

    def SetStartAndStopEpochs(self, refStartEpoch:"ICrdnEventSmartEpoch", refStopEpoch:"ICrdnEventSmartEpoch") -> None:
        """Sets the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, ICrdnEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.AgInterface_in_arg(refStopEpoch, ICrdnEventSmartEpoch) as arg_refStopEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopEpochs"](arg_refStartEpoch.COM_val, arg_refStopEpoch.COM_val))

    def SetStartAndStopTimes(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Sets the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        with agmarshall.VARIANT_arg(startTime) as arg_startTime, \
             agmarshall.VARIANT_arg(stopTime) as arg_stopTime:
            agcls.evaluate_hresult(self.__dict__["_SetStartAndStopTimes"](arg_startTime.COM_val, arg_stopTime.COM_val))

    def SetStartEpochAndDuration(self, refStartEpoch:"ICrdnEventSmartEpoch", durationStr:str) -> None:
        """Sets the interval's start epoch and the interval's duration."""
        with agmarshall.AgInterface_in_arg(refStartEpoch, ICrdnEventSmartEpoch) as arg_refStartEpoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpochAndDuration"](arg_refStartEpoch.COM_val, arg_durationStr.COM_val))

    def SetStartTimeAndDuration(self, epoch:typing.Any, durationStr:str) -> None:
        """Sets the interval's start time and the interval's duration."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.BSTR_arg(durationStr) as arg_durationStr:
            agcls.evaluate_hresult(self.__dict__["_SetStartTimeAndDuration"](arg_epoch.COM_val, arg_durationStr.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}", ICrdnEventIntervalSmartInterval)
agcls.AgTypeNameMap["ICrdnEventIntervalSmartInterval"] = ICrdnEventIntervalSmartInterval

class ICrdnEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    _uuid = "{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceInterval"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventIntervalTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventIntervalTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventIntervalTimeOffset = agcom.GUID(ICrdnEventIntervalTimeOffset._uuid)
        vtable_offset_local = ICrdnEventIntervalTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventIntervalTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventIntervalTimeOffset.__dict__ and type(ICrdnEventIntervalTimeOffset.__dict__[attrname]) == property:
            return ICrdnEventIntervalTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventIntervalTimeOffset.")
    
    @property
    def ReferenceInterval(self) -> "ICrdnEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceInterval.setter
    def ReferenceInterval(self, referenceInterval:"ICrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceInterval, ICrdnEventInterval) as arg_referenceInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceInterval"](arg_referenceInterval.COM_val))

    @property
    def TimeOffset(self) -> float:
        """The time offset value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset.setter
    def TimeOffset(self, timeOffset:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset) as arg_timeOffset:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset"](arg_timeOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}", ICrdnEventIntervalTimeOffset)
agcls.AgTypeNameMap["ICrdnEventIntervalTimeOffset"] = ICrdnEventIntervalTimeOffset

class ICrdnEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    _uuid = "{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetOriginalTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetBaseClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_SetTargetClockLocation"] = _raise_uninitialized_error
        self.__dict__["_GetSignalDelay"] = _raise_uninitialized_error
        self.__dict__["_SetSignalDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventSignaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventSignaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventSignaled = agcom.GUID(ICrdnEventSignaled._uuid)
        vtable_offset_local = ICrdnEventSignaled._vtable_offset - 1
        self.__dict__["_GetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginalTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetBaseClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetTargetClockLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetSignalDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSignaled, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventSignaled.__dict__ and type(ICrdnEventSignaled.__dict__[attrname]) == property:
            return ICrdnEventSignaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventSignaled.")
    
    @property
    def OriginalTimeInstant(self) -> "ICrdnEvent":
        """The original time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginalTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginalTimeInstant.setter
    def OriginalTimeInstant(self, originalTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(originalTimeInstant, ICrdnEvent) as arg_originalTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetOriginalTimeInstant"](arg_originalTimeInstant.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def BaseClockLocation(self) -> "ICrdnPoint":
        """The base clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @BaseClockLocation.setter
    def BaseClockLocation(self, baseClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(baseClockLocation, ICrdnPoint) as arg_baseClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetBaseClockLocation"](arg_baseClockLocation.COM_val))

    @property
    def TargetClockLocation(self) -> "ICrdnPoint":
        """The target clock location, which is a point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetClockLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TargetClockLocation.setter
    def TargetClockLocation(self, targetClockLocation:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(targetClockLocation, ICrdnPoint) as arg_targetClockLocation:
            agcls.evaluate_hresult(self.__dict__["_SetTargetClockLocation"](arg_targetClockLocation.COM_val))

    @property
    def SignalDelay(self) -> "ICrdnSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SignalDelay.setter
    def SignalDelay(self, signalDelay:"ICrdnSignalDelay") -> None:
        with agmarshall.AgInterface_in_arg(signalDelay, ICrdnSignalDelay) as arg_signalDelay:
            agcls.evaluate_hresult(self.__dict__["_SetSignalDelay"](arg_signalDelay.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}", ICrdnEventSignaled)
agcls.AgTypeNameMap["ICrdnEventSignaled"] = ICrdnEventSignaled

class ICrdnEventSmartEpoch(object):
    """A smart epoch."""
    _uuid = "{4C5542F5-5B94-498B-90BC-CC7CB7C86629}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEvent"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetExplicitTime"] = _raise_uninitialized_error
        self.__dict__["_SetImplicitTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventSmartEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventSmartEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventSmartEpoch = agcom.GUID(ICrdnEventSmartEpoch._uuid)
        vtable_offset_local = ICrdnEventSmartEpoch._vtable_offset - 1
        self.__dict__["_GetTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetReferenceEvent"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_SetExplicitTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_SetImplicitTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventSmartEpoch, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventSmartEpoch.__dict__ and type(ICrdnEventSmartEpoch.__dict__[attrname]) == property:
            return ICrdnEventSmartEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventSmartEpoch.")
    
    @property
    def TimeInstant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeInstant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ReferenceEvent(self) -> "ICrdnEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEvent"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def State(self) -> "AgECrdnSmartEpochState":
        """State of the event."""
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @State.setter
    def State(self, state:"AgECrdnSmartEpochState") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSmartEpochState, state) as arg_state:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_state.COM_val))

    def SetExplicitTime(self, epoch:typing.Any) -> None:
        """Sets explicit time instant and the smart epoch's state to Explicit."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetExplicitTime"](arg_epoch.COM_val))

    def SetImplicitTime(self, eventEpoch:"ICrdnEvent") -> None:
        """Sets the reference event and the smart epoch's state to Implicit."""
        with agmarshall.AgInterface_in_arg(eventEpoch, ICrdnEvent) as arg_eventEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetImplicitTime"](arg_eventEpoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4C5542F5-5B94-498B-90BC-CC7CB7C86629}", ICrdnEventSmartEpoch)
agcls.AgTypeNameMap["ICrdnEventSmartEpoch"] = ICrdnEventSmartEpoch

class ICrdnEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""
    _uuid = "{EB96850C-18E7-4269-8D35-67FB7E55BD59}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseStart"] = _raise_uninitialized_error
        self.__dict__["_SetUseStart"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEventInterval"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEventInterval"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventStartStopTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventStartStopTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventStartStopTime = agcom.GUID(ICrdnEventStartStopTime._uuid)
        vtable_offset_local = ICrdnEventStartStopTime._vtable_offset - 1
        self.__dict__["_GetUseStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventStartStopTime, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventStartStopTime, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventStartStopTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceEventInterval"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventStartStopTime, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventStartStopTime.__dict__ and type(ICrdnEventStartStopTime.__dict__[attrname]) == property:
            return ICrdnEventStartStopTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventStartStopTime.")
    
    @property
    def UseStart(self) -> bool:
        """Indicates whether to use start (true) or stop (false)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseStart.setter
    def UseStart(self, useStart:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useStart) as arg_useStart:
            agcls.evaluate_hresult(self.__dict__["_SetUseStart"](arg_useStart.COM_val))

    @property
    def ReferenceEventInterval(self) -> "ICrdnEventInterval":
        """The reference interval."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEventInterval"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceEventInterval.setter
    def ReferenceEventInterval(self, referenceEventInterval:"ICrdnEventInterval") -> None:
        with agmarshall.AgInterface_in_arg(referenceEventInterval, ICrdnEventInterval) as arg_referenceEventInterval:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEventInterval"](arg_referenceEventInterval.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB96850C-18E7-4269-8D35-67FB7E55BD59}", ICrdnEventStartStopTime)
agcls.AgTypeNameMap["ICrdnEventStartStopTime"] = ICrdnEventStartStopTime

class ICrdnEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""
    _uuid = "{EB95E24E-6BDF-434C-A278-BF64475E4EB5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOffset2"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOffset2"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnEventTimeOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnEventTimeOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnEventTimeOffset = agcom.GUID(ICrdnEventTimeOffset._uuid)
        vtable_offset_local = ICrdnEventTimeOffset._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventTimeOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventTimeOffset, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventTimeOffset, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOffset2"] = IAGFUNCTYPE(pUnk, IID_ICrdnEventTimeOffset, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnEventTimeOffset.__dict__ and type(ICrdnEventTimeOffset.__dict__[attrname]) == property:
            return ICrdnEventTimeOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnEventTimeOffset.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """The reference time instant."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def TimeOffset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in \'TimeUnit\' dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOffset2"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeOffset2.setter
    def TimeOffset2(self, timeOffset2:float) -> None:
        with agmarshall.DOUBLE_arg(timeOffset2) as arg_timeOffset2:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOffset2"](arg_timeOffset2.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EB95E24E-6BDF-434C-A278-BF64475E4EB5}", ICrdnEventTimeOffset)
agcls.AgTypeNameMap["ICrdnEventTimeOffset"] = ICrdnEventTimeOffset

class ICrdnFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""
    _uuid = "{032A1F18-16B1-48B3-BB59-AFE83A834880}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnFirstIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnFirstIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnFirstIntervalsFilter = agcom.GUID(ICrdnFirstIntervalsFilter._uuid)
        vtable_offset_local = ICrdnFirstIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnFirstIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnFirstIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnFirstIntervalsFilter.__dict__ and type(ICrdnFirstIntervalsFilter.__dict__[attrname]) == property:
            return ICrdnFirstIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnFirstIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{032A1F18-16B1-48B3-BB59-AFE83A834880}", ICrdnFirstIntervalsFilter)
agcls.AgTypeNameMap["ICrdnFirstIntervalsFilter"] = ICrdnFirstIntervalsFilter

class ICrdnGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    _uuid = "{97B393F6-5E70-4D67-80C1-F85080D818F3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetGapDuration"] = _raise_uninitialized_error
        self.__dict__["_SetGapDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGapsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGapsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGapsFilter = agcom.GUID(ICrdnGapsFilter._uuid)
        vtable_offset_local = ICrdnGapsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnGapsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnGapsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetGapDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnGapsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGapDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnGapsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGapsFilter.__dict__ and type(ICrdnGapsFilter.__dict__[attrname]) == property:
            return ICrdnGapsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGapsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def GapDuration(self) -> float:
        """Duration of the gap."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGapDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GapDuration.setter
    def GapDuration(self, gapDuration:float) -> None:
        with agmarshall.DOUBLE_arg(gapDuration) as arg_gapDuration:
            agcls.evaluate_hresult(self.__dict__["_SetGapDuration"](arg_gapDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{97B393F6-5E70-4D67-80C1-F85080D818F3}", ICrdnGapsFilter)
agcls.AgTypeNameMap["ICrdnGapsFilter"] = ICrdnGapsFilter

class ICrdnIntegral(object):
    """Represents a base class for integral definitions."""
    _uuid = "{61D34977-CC2E-43C1-9103-692FF9B3DEF0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntegral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntegral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntegral = agcom.GUID(ICrdnIntegral._uuid)
        vtable_offset_local = ICrdnIntegral._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntegral.__dict__ and type(ICrdnIntegral.__dict__[attrname]) == property:
            return ICrdnIntegral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntegral.")
    

agcls.AgClassCatalog.add_catalog_entry("{61D34977-CC2E-43C1-9103-692FF9B3DEF0}", ICrdnIntegral)
agcls.AgTypeNameMap["ICrdnIntegral"] = ICrdnIntegral

class ICrdnIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""
    _uuid = "{19DEEA25-F655-487B-86FF-429B55093F77}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntegralBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntegralBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntegralBasic = agcom.GUID(ICrdnIntegralBasic._uuid)
        vtable_offset_local = ICrdnIntegralBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntegralBasic, vtable_offset_local+6, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntegralBasic.__dict__ and type(ICrdnIntegralBasic.__dict__[attrname]) == property:
            return ICrdnIntegralBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntegralBasic.")
    
    @property
    def Type(self) -> "AgECrdnIntegralType":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        with agmarshall.AgEnum_arg(AgECrdnIntegralType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnIntegralType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntegralType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Tolerance.setter
    def Tolerance(self, tolerance:float) -> None:
        with agmarshall.DOUBLE_arg(tolerance) as arg_tolerance:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_tolerance.COM_val))

    @property
    def MaximumIterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumIterations"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumIterations.setter
    def MaximumIterations(self, maximumIterations:int) -> None:
        with agmarshall.INT_arg(maximumIterations) as arg_maximumIterations:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumIterations"](arg_maximumIterations.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{19DEEA25-F655-487B-86FF-429B55093F77}", ICrdnIntegralBasic)
agcls.AgTypeNameMap["ICrdnIntegralBasic"] = ICrdnIntegralBasic

class ICrdnInterp(object):
    """Represents a base class for interpolation definitions."""
    _uuid = "{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnInterp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnInterp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnInterp = agcom.GUID(ICrdnInterp._uuid)
        vtable_offset_local = ICrdnInterp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnInterp.__dict__ and type(ICrdnInterp.__dict__[attrname]) == property:
            return ICrdnInterp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnInterp.")
    

agcls.AgClassCatalog.add_catalog_entry("{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}", ICrdnInterp)
agcls.AgTypeNameMap["ICrdnInterp"] = ICrdnInterp

class ICrdnInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    _uuid = "{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOrder"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnInterpBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnInterpBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnInterpBasic = agcom.GUID(ICrdnInterpBasic._uuid)
        vtable_offset_local = ICrdnInterpBasic._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterpBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterpBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetOrder"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterpBasic, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_SetOrder"] = IAGFUNCTYPE(pUnk, IID_ICrdnInterpBasic, vtable_offset_local+4, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnInterpBasic.__dict__ and type(ICrdnInterpBasic.__dict__[attrname]) == property:
            return ICrdnInterpBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnInterpBasic.")
    
    @property
    def Type(self) -> "AgECrdnInterpolatorType":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Type.setter
    def Type(self, type:"AgECrdnInterpolatorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnInterpolatorType, type) as arg_type:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_type.COM_val))

    @property
    def Order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrder"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Order.setter
    def Order(self, order:int) -> None:
        with agmarshall.INT_arg(order) as arg_order:
            agcls.evaluate_hresult(self.__dict__["_SetOrder"](arg_order.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}", ICrdnInterpBasic)
agcls.AgTypeNameMap["ICrdnInterpBasic"] = ICrdnInterpBasic

class ICrdnIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""
    _uuid = "{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnIntervalsFilter = agcom.GUID(ICrdnIntervalsFilter._uuid)
        vtable_offset_local = ICrdnIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsFilter, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsFilter, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsFilter, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnIntervalsFilter, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnIntervalsFilter.__dict__ and type(ICrdnIntervalsFilter.__dict__[attrname]) == property:
            return ICrdnIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnIntervalsFilter.")
    
    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """The interval duration."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}", ICrdnIntervalsFilter)
agcls.AgTypeNameMap["ICrdnIntervalsFilter"] = ICrdnIntervalsFilter

class ICrdnLastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""
    _uuid = "{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnLastIntervalsFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnLastIntervalsFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnLastIntervalsFilter = agcom.GUID(ICrdnLastIntervalsFilter._uuid)
        vtable_offset_local = ICrdnLastIntervalsFilter._vtable_offset - 1
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnLastIntervalsFilter, vtable_offset_local+1, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnLastIntervalsFilter, vtable_offset_local+2, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnLastIntervalsFilter.__dict__ and type(ICrdnLastIntervalsFilter.__dict__[attrname]) == property:
            return ICrdnLastIntervalsFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnLastIntervalsFilter.")
    
    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}", ICrdnLastIntervalsFilter)
agcls.AgTypeNameMap["ICrdnLastIntervalsFilter"] = ICrdnLastIntervalsFilter

class ICrdnParameterSet(object):
    """Parameter set contains various sets of scalar computations."""
    _uuid = "{285664E8-604B-4C0A-9ED0-5EE27CA1539D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetLabels"] = _raise_uninitialized_error
        self.__dict__["_GetDimensions"] = _raise_uninitialized_error
        self.__dict__["_GetScalarNames"] = _raise_uninitialized_error
        self.__dict__["_Calculate"] = _raise_uninitialized_error
        self.__dict__["_CalculateWithDerivative"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSet = agcom.GUID(ICrdnParameterSet._uuid)
        vtable_offset_local = ICrdnParameterSet._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetLabels"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetDimensions"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetScalarNames"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Calculate"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+5, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CalculateWithDerivative"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSet, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSet.__dict__ and type(ICrdnParameterSet.__dict__[attrname]) == property:
            return ICrdnParameterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSet.")
    
    @property
    def Type(self) -> "AgECrdnParameterSetType":
        """Get the type of parameter set."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabels"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScalarNames(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Calculate"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CalculateWithDerivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CalculateWithDerivative"](arg_epoch.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{285664E8-604B-4C0A-9ED0-5EE27CA1539D}", ICrdnParameterSet)
agcls.AgTypeNameMap["ICrdnParameterSet"] = ICrdnParameterSet

class ICrdnParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    _uuid = "{8B7DCF32-3CA4-4794-8468-81A3627B4043}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetAttitude = agcom.GUID(ICrdnParameterSetAttitude._uuid)
        vtable_offset_local = ICrdnParameterSetAttitude._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetAttitude, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetAttitude, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetAttitude, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetAttitude, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetAttitude.__dict__ and type(ICrdnParameterSetAttitude.__dict__[attrname]) == property:
            return ICrdnParameterSetAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetAttitude.")
    
    @property
    def Axes(self) -> "ICrdnAxes":
        """Get the axes for which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Axes.setter
    def Axes(self, axes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    @property
    def ReferenceAxes(self) -> "ICrdnAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B7DCF32-3CA4-4794-8468-81A3627B4043}", ICrdnParameterSetAttitude)
agcls.AgTypeNameMap["ICrdnParameterSetAttitude"] = ICrdnParameterSetAttitude

class ICrdnParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""
    _uuid = "{4D20E85F-1DEA-4963-9114-6B0407E53C5E}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetAttitude"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetGroundTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetOrbit"] = _raise_uninitialized_error
        self.__dict__["_CreateParameterSetVector"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetFactory = agcom.GUID(ICrdnParameterSetFactory._uuid)
        vtable_offset_local = ICrdnParameterSetFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetAttitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetGroundTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetOrbit"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateParameterSetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetFactory, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetFactory.__dict__ and type(ICrdnParameterSetFactory.__dict__[attrname]) == property:
            return ICrdnParameterSetFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnParameterSetType") -> "ICrdnParameterSet":
        """Creates and registers a parameter set using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnParameterSetType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetAttitude(self, name:str, description:str) -> "ICrdnParameterSet":
        """Creates a parameter set defined by identifying one set of axes in reference to another."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetAttitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetGroundTrajectory(self, name:str, description:str) -> "ICrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetGroundTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetTrajectory(self, name:str, description:str) -> "ICrdnParameterSet":
        """Creates a parameter set defined by identifying location in reference coordinate system."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetTrajectory"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetOrbit(self, name:str, description:str) -> "ICrdnParameterSet":
        """Creates a parameter set defined by identifying orbiting point and its central body."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetOrbit"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateParameterSetVector(self, name:str, description:str) -> "ICrdnParameterSet":
        """Creates a parameter set defined by identifying vector in reference axes."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateParameterSetVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnParameterSetType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnParameterSetType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4D20E85F-1DEA-4963-9114-6B0407E53C5E}", ICrdnParameterSetFactory)
agcls.AgTypeNameMap["ICrdnParameterSetFactory"] = ICrdnParameterSetFactory

class ICrdnParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    _uuid = "{53ABEB95-F846-4574-BA87-C76220FDC19F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLocation"] = _raise_uninitialized_error
        self.__dict__["_SetLocation"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetGroundTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetGroundTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetGroundTrajectory = agcom.GUID(ICrdnParameterSetGroundTrajectory._uuid)
        vtable_offset_local = ICrdnParameterSetGroundTrajectory._vtable_offset - 1
        self.__dict__["_GetLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroundTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroundTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroundTrajectory, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetGroundTrajectory, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetGroundTrajectory.__dict__ and type(ICrdnParameterSetGroundTrajectory.__dict__[attrname]) == property:
            return ICrdnParameterSetGroundTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetGroundTrajectory.")
    
    @property
    def Location(self) -> "ICrdnPoint":
        """Get the point for which ground trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Location.setter
    def Location(self, location:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(location, ICrdnPoint) as arg_location:
            agcls.evaluate_hresult(self.__dict__["_SetLocation"](arg_location.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{53ABEB95-F846-4574-BA87-C76220FDC19F}", ICrdnParameterSetGroundTrajectory)
agcls.AgTypeNameMap["ICrdnParameterSetGroundTrajectory"] = ICrdnParameterSetGroundTrajectory

class ICrdnParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    _uuid = "{141AEAB7-C017-4044-BE2C-EFE4AD724022}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitingPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = _raise_uninitialized_error
        self.__dict__["_GetUseCentralBodyInertial"] = _raise_uninitialized_error
        self.__dict__["_SetUseCentralBodyInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetOrbit from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetOrbit = agcom.GUID(ICrdnParameterSetOrbit._uuid)
        vtable_offset_local = ICrdnParameterSetOrbit._vtable_offset - 1
        self.__dict__["_GetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOrbitingPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyGravitationalParameter"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCentralBodyInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetOrbit, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetOrbit.__dict__ and type(ICrdnParameterSetOrbit.__dict__[attrname]) == property:
            return ICrdnParameterSetOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetOrbit.")
    
    @property
    def OrbitingPoint(self) -> "ICrdnPoint":
        """Get the point for which orbital parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitingPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OrbitingPoint.setter
    def OrbitingPoint(self, orbitingPoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(orbitingPoint, ICrdnPoint) as arg_orbitingPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitingPoint"](arg_orbitingPoint.COM_val))

    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def GravitationalParameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GravitationalParameter.setter
    def GravitationalParameter(self, gravitationalParameter:float) -> None:
        with agmarshall.DOUBLE_arg(gravitationalParameter) as arg_gravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetGravitationalParameter"](arg_gravitationalParameter.COM_val))

    @property
    def CentralBody(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def UseCentralBodyGravitationalParameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyGravitationalParameter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyGravitationalParameter.setter
    def UseCentralBodyGravitationalParameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyGravitationalParameter) as arg_useCentralBodyGravitationalParameter:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyGravitationalParameter"](arg_useCentralBodyGravitationalParameter.COM_val))

    @property
    def UseCentralBodyInertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCentralBodyInertial"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCentralBodyInertial.setter
    def UseCentralBodyInertial(self, useCentralBodyInertial:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCentralBodyInertial) as arg_useCentralBodyInertial:
            agcls.evaluate_hresult(self.__dict__["_SetUseCentralBodyInertial"](arg_useCentralBodyInertial.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{141AEAB7-C017-4044-BE2C-EFE4AD724022}", ICrdnParameterSetOrbit)
agcls.AgTypeNameMap["ICrdnParameterSetOrbit"] = ICrdnParameterSetOrbit

class ICrdnParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    _uuid = "{0FE9C601-61BB-4579-B91F-B1123A19AFB4}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetTrajectory = agcom.GUID(ICrdnParameterSetTrajectory._uuid)
        vtable_offset_local = ICrdnParameterSetTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetTrajectory, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetTrajectory, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetTrajectory, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetTrajectory.__dict__ and type(ICrdnParameterSetTrajectory.__dict__[attrname]) == property:
            return ICrdnParameterSetTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetTrajectory.")
    
    @property
    def Point(self) -> "ICrdnPoint":
        """Get the point for which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0FE9C601-61BB-4579-B91F-B1123A19AFB4}", ICrdnParameterSetTrajectory)
agcls.AgTypeNameMap["ICrdnParameterSetTrajectory"] = ICrdnParameterSetTrajectory

class ICrdnParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    _uuid = "{5B99EEC1-21BD-48B5-96A0-0230894532F1}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnParameterSetVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnParameterSetVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnParameterSetVector = agcom.GUID(ICrdnParameterSetVector._uuid)
        vtable_offset_local = ICrdnParameterSetVector._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnParameterSetVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnParameterSetVector.__dict__ and type(ICrdnParameterSetVector.__dict__[attrname]) == property:
            return ICrdnParameterSetVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnParameterSetVector.")
    
    @property
    def Vector(self) -> "ICrdnVector":
        """Get the vector for which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Vector.setter
    def Vector(self, vector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vector, ICrdnVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    @property
    def ReferenceAxes(self) -> "ICrdnAxes":
        """Get the reference axes relative to which representations are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5B99EEC1-21BD-48B5-96A0-0230894532F1}", ICrdnParameterSetVector)
agcls.AgTypeNameMap["ICrdnParameterSetVector"] = ICrdnParameterSetVector

class ICrdnPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""
    _uuid = "{89E95CD7-CDB2-4B17-9E47-DE17F551F873}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilterType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPruneFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPruneFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPruneFilter = agcom.GUID(ICrdnPruneFilter._uuid)
        vtable_offset_local = ICrdnPruneFilter._vtable_offset - 1
        self.__dict__["_GetFilterType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPruneFilter, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPruneFilter.__dict__ and type(ICrdnPruneFilter.__dict__[attrname]) == property:
            return ICrdnPruneFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPruneFilter.")
    
    @property
    def FilterType(self) -> "AgECrdnPruneFilter":
        """Returns a type of the filter."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilterType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{89E95CD7-CDB2-4B17-9E47-DE17F551F873}", ICrdnPruneFilter)
agcls.AgTypeNameMap["ICrdnPruneFilter"] = ICrdnPruneFilter

class ICrdnPruneFilterFactory(object):
    """The factory creates pruning filters."""
    _uuid = "{77E7099E-9B41-45FA-B50F-F8DE5964FABD}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPruneFilterFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPruneFilterFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPruneFilterFactory = agcom.GUID(ICrdnPruneFilterFactory._uuid)
        vtable_offset_local = ICrdnPruneFilterFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnPruneFilterFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPruneFilterFactory.__dict__ and type(ICrdnPruneFilterFactory.__dict__[attrname]) == property:
            return ICrdnPruneFilterFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPruneFilterFactory.")
    
    def Create(self, eFilter:"AgECrdnPruneFilter") -> "ICrdnPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        with agmarshall.AgEnum_arg(AgECrdnPruneFilter, eFilter) as arg_eFilter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_eFilter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{77E7099E-9B41-45FA-B50F-F8DE5964FABD}", ICrdnPruneFilterFactory)
agcls.AgTypeNameMap["ICrdnPruneFilterFactory"] = ICrdnPruneFilterFactory

class ICrdnRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    _uuid = "{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnRelativeSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnRelativeSatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnRelativeSatisfactionConditionFilter = agcom.GUID(ICrdnRelativeSatisfactionConditionFilter._uuid)
        vtable_offset_local = ICrdnRelativeSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnRelativeSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnRelativeSatisfactionConditionFilter.__dict__ and type(ICrdnRelativeSatisfactionConditionFilter.__dict__[attrname]) == property:
            return ICrdnRelativeSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnRelativeSatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def RelativeIntervalDuration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeIntervalDuration.setter
    def RelativeIntervalDuration(self, relativeIntervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(relativeIntervalDuration) as arg_relativeIntervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeIntervalDuration"](arg_relativeIntervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}", ICrdnRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["ICrdnRelativeSatisfactionConditionFilter"] = ICrdnRelativeSatisfactionConditionFilter

class ICrdnSampling(object):
    """Base sampling interface."""
    _uuid = "{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSampling._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSampling from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSampling = agcom.GUID(ICrdnSampling._uuid)
        vtable_offset_local = ICrdnSampling._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSampling.__dict__ and type(ICrdnSampling.__dict__[attrname]) == property:
            return ICrdnSampling.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSampling.")
    

agcls.AgClassCatalog.add_catalog_entry("{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}", ICrdnSampling)
agcls.AgTypeNameMap["ICrdnSampling"] = ICrdnSampling

class ICrdnSamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    _uuid = "{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSamplingMethod"] = _raise_uninitialized_error
        self.__dict__["_GetMethodFactory"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingBasic = agcom.GUID(ICrdnSamplingBasic._uuid)
        vtable_offset_local = ICrdnSamplingBasic._vtable_offset - 1
        self.__dict__["_GetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingBasic, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSamplingMethod"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingBasic, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetMethodFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingBasic.__dict__ and type(ICrdnSamplingBasic.__dict__[attrname]) == property:
            return ICrdnSamplingBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingBasic.")
    
    @property
    def SamplingMethod(self) -> "ICrdnSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSamplingMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SamplingMethod.setter
    def SamplingMethod(self, samplingMethod:"ICrdnSamplingMethod") -> None:
        with agmarshall.AgInterface_in_arg(samplingMethod, ICrdnSamplingMethod) as arg_samplingMethod:
            agcls.evaluate_hresult(self.__dict__["_SetSamplingMethod"](arg_samplingMethod.COM_val))

    @property
    def MethodFactory(self) -> "ICrdnSamplingMethodFactory":
        """Creates sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}", ICrdnSamplingBasic)
agcls.AgTypeNameMap["ICrdnSamplingBasic"] = ICrdnSamplingBasic

class ICrdnSamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    _uuid = "{618ADA55-9E3D-4CEC-815A-B028995774CB}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetCurvatureTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingCurvatureTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingCurvatureTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingCurvatureTolerance = agcom.GUID(ICrdnSamplingCurvatureTolerance._uuid)
        vtable_offset_local = ICrdnSamplingCurvatureTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingCurvatureTolerance, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingCurvatureTolerance.__dict__ and type(ICrdnSamplingCurvatureTolerance.__dict__[attrname]) == property:
            return ICrdnSamplingCurvatureTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingCurvatureTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))

    @property
    def CurvatureTolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurvatureTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CurvatureTolerance.setter
    def CurvatureTolerance(self, curvatureTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetCurvatureTolerance"](arg_curvatureTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{618ADA55-9E3D-4CEC-815A-B028995774CB}", ICrdnSamplingCurvatureTolerance)
agcls.AgTypeNameMap["ICrdnSamplingCurvatureTolerance"] = ICrdnSamplingCurvatureTolerance

class ICrdnSamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    _uuid = "{68784D1E-776C-4212-B35E-121FFE569627}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingFixedStep = agcom.GUID(ICrdnSamplingFixedStep._uuid)
        vtable_offset_local = ICrdnSamplingFixedStep._vtable_offset - 1
        self.__dict__["_GetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingFixedStep, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingFixedStep.__dict__ and type(ICrdnSamplingFixedStep.__dict__[attrname]) == property:
            return ICrdnSamplingFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingFixedStep.")
    
    @property
    def TimeStep(self) -> float:
        """Get the fixed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeStep.setter
    def TimeStep(self, timeStep:float) -> None:
        with agmarshall.DOUBLE_arg(timeStep) as arg_timeStep:
            agcls.evaluate_hresult(self.__dict__["_SetTimeStep"](arg_timeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68784D1E-776C-4212-B35E-121FFE569627}", ICrdnSamplingFixedStep)
agcls.AgTypeNameMap["ICrdnSamplingFixedStep"] = ICrdnSamplingFixedStep

class ICrdnSamplingMethod(object):
    """A sampling method."""
    _uuid = "{1D14391E-F22F-42FF-B3FA-902F061A6F7B}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingMethod = agcom.GUID(ICrdnSamplingMethod._uuid)
        vtable_offset_local = ICrdnSamplingMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingMethod.__dict__ and type(ICrdnSamplingMethod.__dict__[attrname]) == property:
            return ICrdnSamplingMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnSamplingMethod":
        """A sampling method type."""
        with agmarshall.AgEnum_arg(AgECrdnSamplingMethod) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1D14391E-F22F-42FF-B3FA-902F061A6F7B}", ICrdnSamplingMethod)
agcls.AgTypeNameMap["ICrdnSamplingMethod"] = ICrdnSamplingMethod

class ICrdnSamplingMethodFactory(object):
    """The factory creates sampling method components."""
    _uuid = "{C214929B-45FA-4023-9C40-6DCE747C151B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedStep"] = _raise_uninitialized_error
        self.__dict__["_CreateCurvatureTolerance"] = _raise_uninitialized_error
        self.__dict__["_CreateRelativeTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingMethodFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingMethodFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingMethodFactory = agcom.GUID(ICrdnSamplingMethodFactory._uuid)
        vtable_offset_local = ICrdnSamplingMethodFactory._vtable_offset - 1
        self.__dict__["_CreateFixedStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingMethodFactory, vtable_offset_local+1, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateCurvatureTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingMethodFactory, vtable_offset_local+2, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingMethodFactory, vtable_offset_local+3, agcom.DOUBLE, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingMethodFactory.__dict__ and type(ICrdnSamplingMethodFactory.__dict__[attrname]) == property:
            return ICrdnSamplingMethodFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingMethodFactory.")
    
    def CreateFixedStep(self, fixedStep:float) -> "ICrdnSamplingMethod":
        """Create a fixed time step sampling definition."""
        with agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedStep"](arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCurvatureTolerance(self, curvatureTolerance:float) -> "ICrdnSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        with agmarshall.DOUBLE_arg(curvatureTolerance) as arg_curvatureTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCurvatureTolerance"](arg_curvatureTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateRelativeTolerance(self, relativeTolerance:float) -> "ICrdnSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateRelativeTolerance"](arg_relativeTolerance.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C214929B-45FA-4023-9C40-6DCE747C151B}", ICrdnSamplingMethodFactory)
agcls.AgTypeNameMap["ICrdnSamplingMethodFactory"] = ICrdnSamplingMethodFactory

class ICrdnSamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    _uuid = "{32BB5026-A93C-41F7-ADE8-0A04A43627BC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_SetStepAtBoundaries"] = _raise_uninitialized_error
        self.__dict__["_GetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetRelativeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetAbsoluteTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetAbsoluteTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSamplingRelativeTolerance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSamplingRelativeTolerance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSamplingRelativeTolerance = agcom.GUID(ICrdnSamplingRelativeTolerance._uuid)
        vtable_offset_local = ICrdnSamplingRelativeTolerance._vtable_offset - 1
        self.__dict__["_GetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepAtBoundaries"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRelativeTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAbsoluteTolerance"] = IAGFUNCTYPE(pUnk, IID_ICrdnSamplingRelativeTolerance, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSamplingRelativeTolerance.__dict__ and type(ICrdnSamplingRelativeTolerance.__dict__[attrname]) == property:
            return ICrdnSamplingRelativeTolerance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSamplingRelativeTolerance.")
    
    @property
    def MinimumTimeStep(self) -> float:
        """Get the minimum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumTimeStep.setter
    def MinimumTimeStep(self, minimumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(minimumTimeStep) as arg_minimumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumTimeStep"](arg_minimumTimeStep.COM_val))

    @property
    def MaximumTimeStep(self) -> float:
        """Get the maximum allowed time step."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumTimeStep.setter
    def MaximumTimeStep(self, maximumTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(maximumTimeStep) as arg_maximumTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumTimeStep"](arg_maximumTimeStep.COM_val))

    @property
    def StepAtBoundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepAtBoundaries"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StepAtBoundaries.setter
    def StepAtBoundaries(self, stepAtBoundaries:float) -> None:
        with agmarshall.DOUBLE_arg(stepAtBoundaries) as arg_stepAtBoundaries:
            agcls.evaluate_hresult(self.__dict__["_SetStepAtBoundaries"](arg_stepAtBoundaries.COM_val))

    @property
    def RelativeTolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativeTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RelativeTolerance.setter
    def RelativeTolerance(self, relativeTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(relativeTolerance) as arg_relativeTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetRelativeTolerance"](arg_relativeTolerance.COM_val))

    @property
    def AbsoluteTolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAbsoluteTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AbsoluteTolerance.setter
    def AbsoluteTolerance(self, absoluteTolerance:float) -> None:
        with agmarshall.DOUBLE_arg(absoluteTolerance) as arg_absoluteTolerance:
            agcls.evaluate_hresult(self.__dict__["_SetAbsoluteTolerance"](arg_absoluteTolerance.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{32BB5026-A93C-41F7-ADE8-0A04A43627BC}", ICrdnSamplingRelativeTolerance)
agcls.AgTypeNameMap["ICrdnSamplingRelativeTolerance"] = ICrdnSamplingRelativeTolerance

class ICrdnSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    _uuid = "{84F129C1-1D47-4FE2-B87B-013BEF12269C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_SetDurationKind"] = _raise_uninitialized_error
        self.__dict__["_GetIntervalDuration"] = _raise_uninitialized_error
        self.__dict__["_SetIntervalDuration"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSatisfactionConditionFilter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSatisfactionConditionFilter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSatisfactionConditionFilter = agcom.GUID(ICrdnSatisfactionConditionFilter._uuid)
        vtable_offset_local = ICrdnSatisfactionConditionFilter._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDurationKind"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIntervalDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnSatisfactionConditionFilter, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSatisfactionConditionFilter.__dict__ and type(ICrdnSatisfactionConditionFilter.__dict__[attrname]) == property:
            return ICrdnSatisfactionConditionFilter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSatisfactionConditionFilter.")
    
    @property
    def Condition(self) -> "ICrdnCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def DurationKind(self) -> "AgECrdnIntervalDurationKind":
        """Choose a duration type (at least/at most)."""
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationKind"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationKind.setter
    def DurationKind(self, durationKind:"AgECrdnIntervalDurationKind") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntervalDurationKind, durationKind) as arg_durationKind:
            agcls.evaluate_hresult(self.__dict__["_SetDurationKind"](arg_durationKind.COM_val))

    @property
    def IntervalDuration(self) -> float:
        """A duration of time the condition must be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervalDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntervalDuration.setter
    def IntervalDuration(self, intervalDuration:float) -> None:
        with agmarshall.DOUBLE_arg(intervalDuration) as arg_intervalDuration:
            agcls.evaluate_hresult(self.__dict__["_SetIntervalDuration"](arg_intervalDuration.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{84F129C1-1D47-4FE2-B87B-013BEF12269C}", ICrdnSatisfactionConditionFilter)
agcls.AgTypeNameMap["ICrdnSatisfactionConditionFilter"] = ICrdnSatisfactionConditionFilter

class ICrdnSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{5ED53953-1C55-431D-88AF-1AF23B2FE424}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSignalDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSignalDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSignalDelay = agcom.GUID(ICrdnSignalDelay._uuid)
        vtable_offset_local = ICrdnSignalDelay._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSignalDelay.__dict__ and type(ICrdnSignalDelay.__dict__[attrname]) == property:
            return ICrdnSignalDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSignalDelay.")
    

agcls.AgClassCatalog.add_catalog_entry("{5ED53953-1C55-431D-88AF-1AF23B2FE424}", ICrdnSignalDelay)
agcls.AgTypeNameMap["ICrdnSignalDelay"] = ICrdnSignalDelay

class ICrdnSignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    _uuid = "{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetSignalPathReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedOption"] = _raise_uninitialized_error
        self.__dict__["_GetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetTransferSpeed"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSignalDelayBasic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSignalDelayBasic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSignalDelayBasic = agcom.GUID(ICrdnSignalDelayBasic._uuid)
        vtable_offset_local = ICrdnSignalDelayBasic._vtable_offset - 1
        self.__dict__["_GetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSignalPathReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedOption"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTransferSpeed"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnSignalDelayBasic, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSignalDelayBasic.__dict__ and type(ICrdnSignalDelayBasic.__dict__[attrname]) == property:
            return ICrdnSignalDelayBasic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSignalDelayBasic.")
    
    @property
    def SignalPathReferenceSystem(self) -> "AgECrdnSignalPathReferenceSystem":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalPathReferenceSystem"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalPathReferenceSystem.setter
    def SignalPathReferenceSystem(self, signalPathReferenceSystem:"AgECrdnSignalPathReferenceSystem") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalPathReferenceSystem, signalPathReferenceSystem) as arg_signalPathReferenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetSignalPathReferenceSystem"](arg_signalPathReferenceSystem.COM_val))

    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def SpeedOption(self) -> "AgECrdnSpeedOptions":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedOption.setter
    def SpeedOption(self, speedOption:"AgECrdnSpeedOptions") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSpeedOptions, speedOption) as arg_speedOption:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedOption"](arg_speedOption.COM_val))

    @property
    def TransferSpeed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTransferSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TransferSpeed.setter
    def TransferSpeed(self, transferSpeed:float) -> None:
        with agmarshall.DOUBLE_arg(transferSpeed) as arg_transferSpeed:
            agcls.evaluate_hresult(self.__dict__["_SetTransferSpeed"](arg_transferSpeed.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}", ICrdnSignalDelayBasic)
agcls.AgTypeNameMap["ICrdnSignalDelayBasic"] = ICrdnSignalDelayBasic

class ICrdnVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""
    _uuid = "{42eb6d4a-5cff-471f-997d-3f624cb4a416}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAltitude"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFile"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcFromScalar"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcRange"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCalcDelayRange"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcFactory = agcom.GUID(ICrdnVolumeCalcFactory._uuid)
        vtable_offset_local = ICrdnVolumeCalcFactory._vtable_offset - 1
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+1, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcAngleOffVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcFromScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcSolarIntensity"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeCalcDelayRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcFactory.__dict__ and type(ICrdnVolumeCalcFactory.__dict__[attrname]) == property:
            return ICrdnVolumeCalcFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcFactory.")
    
    def IsTypeSupported(self, eType:"AgECrdnVolumeCalcType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Create(self, name:str, description:str, type:"AgECrdnVolumeCalcType") -> "ICrdnVolumeCalc":
        """Creates and registers a volume calc using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeCalcType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAltitude(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a altitude to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAltitude"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcAngleOffVector(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a angle to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcAngleOffVector"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFile(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a file volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFile"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcFromScalar(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a scalar to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcFromScalar"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcSolarIntensity(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a solar intensity volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcSolarIntensity"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcVolumeSatisfactionMetric(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcVolumeSatisfactionMetric"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcRange(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeCalcDelayRange(self, name:str, description:str) -> "ICrdnVolumeCalc":
        """Creates and registers a distance to location volume calc type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCalcDelayRange"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{42eb6d4a-5cff-471f-997d-3f624cb4a416}", ICrdnVolumeCalcFactory)
agcls.AgTypeNameMap["ICrdnVolumeCalcFactory"] = ICrdnVolumeCalcFactory

class ICrdnVolumeFactory(object):
    """The factory is used to create instances of volumes."""
    _uuid = "{FE97990E-A152-417C-883E-64C42AB9B913}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeCombined"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeLighting"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeOverTime"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromGrid"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCalc"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeFromCondition"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeInview"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeFactory = agcom.GUID(ICrdnVolumeFactory._uuid)
        vtable_offset_local = ICrdnVolumeFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeCombined"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+3, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeLighting"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeOverTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromGrid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCalc"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeFromCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+9, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeInview"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFactory, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeFactory.__dict__ and type(ICrdnVolumeFactory.__dict__[attrname]) == property:
            return ICrdnVolumeFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeType") -> "ICrdnVolume":
        """Creates and registers a volume using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeCombined(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type combined."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeCombined"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeLighting(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type lighting."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeLighting"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeOverTime(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type over time."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeOverTime"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromGrid(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type from grid."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromGrid"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCalc(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type from calc."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCalc"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromTimeSatisfaction(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type from time satisfaction."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromTimeSatisfaction"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeFromCondition(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type condition."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeFromCondition"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeInview(self, name:str, description:str) -> "ICrdnVolume":
        """Creates a volume type Inview."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeInview"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE97990E-A152-417C-883E-64C42AB9B913}", ICrdnVolumeFactory)
agcls.AgTypeNameMap["ICrdnVolumeFactory"] = ICrdnVolumeFactory

class ICrdnVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""
    _uuid = "{4533DEA1-D754-4579-A79D-B5A639C2CD39}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCartesian"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridCylindrical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridSpherical"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridConstrained"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridLatLonAlt"] = _raise_uninitialized_error
        self.__dict__["_CreateVolumeGridBearingAlt"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridFactory = agcom.GUID(ICrdnVolumeGridFactory._uuid)
        vtable_offset_local = ICrdnVolumeGridFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridCartesian"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+2, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+3, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateVolumeGridCylindrical"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridSpherical"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridConstrained"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+6, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridLatLonAlt"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+7, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateVolumeGridBearingAlt"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridFactory, vtable_offset_local+8, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridFactory.__dict__ and type(ICrdnVolumeGridFactory.__dict__[attrname]) == property:
            return ICrdnVolumeGridFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridFactory.")
    
    def Create(self, name:str, description:str, type:"AgECrdnVolumeGridType") -> "ICrdnVolumeGrid":
        """Creates and registers a volume grid using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVolumeGridType, type) as arg_type, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_name.COM_val, arg_description.COM_val, arg_type.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridCartesian(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers a cartesian volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCartesian"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, eType:"AgECrdnVolumeGridType") -> bool:
        """Returns whether the specified type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeGridType, eType) as arg_eType, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_eType.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateVolumeGridCylindrical(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers a cylindrical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridCylindrical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridSpherical(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers a spherical volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridSpherical"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridConstrained(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridConstrained"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridLatLonAlt(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers cartographic volume grid type using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridLatLonAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVolumeGridBearingAlt(self, name:str, description:str) -> "ICrdnVolumeGrid":
        """Creates and registers a volume grid of type surface bearing using specified name and description."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVolumeGridBearingAlt"](arg_name.COM_val, arg_description.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4533DEA1-D754-4579-A79D-B5A639C2CD39}", ICrdnVolumeGridFactory)
agcls.AgTypeNameMap["ICrdnVolumeGridFactory"] = ICrdnVolumeGridFactory

class ICrdnGridCoordinateDefinition(object):
    """Defines a set of coordinate values."""
    _uuid = "{96875D1C-9CBC-4732-A678-2CB17995C0E9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        self.__dict__["_GetGridValuesMethod"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesCustom"] = _raise_uninitialized_error
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGridCoordinateDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGridCoordinateDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGridCoordinateDefinition = agcom.GUID(ICrdnGridCoordinateDefinition._uuid)
        vtable_offset_local = ICrdnGridCoordinateDefinition._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetGridValuesMethod"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+3, agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+4, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesCustom"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+5, POINTER(agcom.SAFEARRAY), POINTER(agcom.PVOID))
        self.__dict__["_SetGridValuesFixedNumberOfStepsEx"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridCoordinateDefinition, vtable_offset_local+6, agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGridCoordinateDefinition.__dict__ and type(ICrdnGridCoordinateDefinition.__dict__[attrname]) == property:
            return ICrdnGridCoordinateDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGridCoordinateDefinition.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def GridValuesMethod(self) -> "ICrdnGridValuesMethod":
        """Sets/Returns the grid values interface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGridValuesMethod"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedStep(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "ICrdnGridValuesFixedStep":
        """Sets grid values type to fixed step."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax, \
             agmarshall.DOUBLE_arg(refValue) as arg_refValue, \
             agmarshall.DOUBLE_arg(fixedStep) as arg_fixedStep, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedStep"](arg_min.COM_val, arg_max.COM_val, arg_includeMinMax.COM_val, arg_refValue.COM_val, arg_fixedStep.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfSteps(self, min:float, max:float, numSteps:int) -> "ICrdnGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        with agmarshall.DOUBLE_arg(min) as arg_min, \
             agmarshall.DOUBLE_arg(max) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfSteps"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesCustom(self, values:list) -> "ICrdnGridValuesCustom":
        """Sets grid values type to custom values."""
        with agmarshall.SAFEARRAY_arg(values) as arg_values, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesCustom"](byref(arg_values.COM_val), byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetGridValuesFixedNumberOfStepsEx(self, min:"IQuantity", max:"IQuantity", numSteps:int) -> "ICrdnGridValuesFixedNumberOfSteps":
        """Sets grid values type to fixed number of steps with min and max as IAgQuantity"""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max, \
             agmarshall.INT_arg(numSteps) as arg_numSteps, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridValuesFixedNumberOfStepsEx"](arg_min.COM_val, arg_max.COM_val, arg_numSteps.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{96875D1C-9CBC-4732-A678-2CB17995C0E9}", ICrdnGridCoordinateDefinition)
agcls.AgTypeNameMap["ICrdnGridCoordinateDefinition"] = ICrdnGridCoordinateDefinition

class ICrdnGridValuesCustom(object):
    """Fixed step grid values."""
    _uuid = "{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_SetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGridValuesCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGridValuesCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGridValuesCustom = agcom.GUID(ICrdnGridValuesCustom._uuid)
        vtable_offset_local = ICrdnGridValuesCustom._vtable_offset - 1
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesCustom, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetValues"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesCustom, vtable_offset_local+2, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGridValuesCustom.__dict__ and type(ICrdnGridValuesCustom.__dict__[attrname]) == property:
            return ICrdnGridValuesCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGridValuesCustom.")
    
    @property
    def Values(self) -> list:
        """Custom set of coordinate values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Values.setter
    def Values(self, values:list) -> None:
        with agmarshall.SAFEARRAY_arg(values) as arg_values:
            agcls.evaluate_hresult(self.__dict__["_SetValues"](arg_values.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}", ICrdnGridValuesCustom)
agcls.AgTypeNameMap["ICrdnGridValuesCustom"] = ICrdnGridValuesCustom

class ICrdnGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""
    _uuid = "{379ACEFA-1B1E-4753-BA9A-87939E5B8893}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_SetNumberOfSteps"] = _raise_uninitialized_error
        self.__dict__["_GetMinEx"] = _raise_uninitialized_error
        self.__dict__["_SetMinEx"] = _raise_uninitialized_error
        self.__dict__["_GetMaxEx"] = _raise_uninitialized_error
        self.__dict__["_SetMaxEx"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGridValuesFixedNumberOfSteps._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGridValuesFixedNumberOfSteps from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGridValuesFixedNumberOfSteps = agcom.GUID(ICrdnGridValuesFixedNumberOfSteps._uuid)
        vtable_offset_local = ICrdnGridValuesFixedNumberOfSteps._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+5, POINTER(agcom.INT))
        self.__dict__["_SetNumberOfSteps"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+6, agcom.INT)
        self.__dict__["_GetMinEx"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMinEx"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetMaxEx"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetMaxEx"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedNumberOfSteps, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGridValuesFixedNumberOfSteps.__dict__ and type(ICrdnGridValuesFixedNumberOfSteps.__dict__[attrname]) == property:
            return ICrdnGridValuesFixedNumberOfSteps.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGridValuesFixedNumberOfSteps.")
    
    @property
    def Min(self) -> float:
        """This property is deprecated. Use MinEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def NumberOfSteps(self) -> int:
        """The number of steps between coordinate values."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumberOfSteps"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NumberOfSteps.setter
    def NumberOfSteps(self, numberOfSteps:int) -> None:
        with agmarshall.INT_arg(numberOfSteps) as arg_numberOfSteps:
            agcls.evaluate_hresult(self.__dict__["_SetNumberOfSteps"](arg_numberOfSteps.COM_val))

    @property
    def MinEx(self) -> "IQuantity":
        """Minimum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MinEx.setter
    def MinEx(self, minEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(minEx, IQuantity) as arg_minEx:
            agcls.evaluate_hresult(self.__dict__["_SetMinEx"](arg_minEx.COM_val))

    @property
    def MaxEx(self) -> "IQuantity":
        """Maximum coordinate value as IAgQuantity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxEx"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @MaxEx.setter
    def MaxEx(self, maxEx:"IQuantity") -> None:
        with agmarshall.AgInterface_in_arg(maxEx, IQuantity) as arg_maxEx:
            agcls.evaluate_hresult(self.__dict__["_SetMaxEx"](arg_maxEx.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{379ACEFA-1B1E-4753-BA9A-87939E5B8893}", ICrdnGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["ICrdnGridValuesFixedNumberOfSteps"] = ICrdnGridValuesFixedNumberOfSteps

class ICrdnGridValuesFixedStep(object):
    """Fixed step grid values."""
    _uuid = "{7C18BF81-7E22-4A28-B462-37ED86EC3050}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMin"] = _raise_uninitialized_error
        self.__dict__["_SetMin"] = _raise_uninitialized_error
        self.__dict__["_GetMax"] = _raise_uninitialized_error
        self.__dict__["_SetMax"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeMinMax"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceValue"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGridValuesFixedStep._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGridValuesFixedStep from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGridValuesFixedStep = agcom.GUID(ICrdnGridValuesFixedStep._uuid)
        vtable_offset_local = ICrdnGridValuesFixedStep._vtable_offset - 1
        self.__dict__["_GetMin"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMin"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeMinMax"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceValue"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesFixedStep, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGridValuesFixedStep.__dict__ and type(ICrdnGridValuesFixedStep.__dict__[attrname]) == property:
            return ICrdnGridValuesFixedStep.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGridValuesFixedStep.")
    
    @property
    def Min(self) -> float:
        """Minimum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMin"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Min.setter
    def Min(self, min:float) -> None:
        with agmarshall.DOUBLE_arg(min) as arg_min:
            agcls.evaluate_hresult(self.__dict__["_SetMin"](arg_min.COM_val))

    @property
    def Max(self) -> float:
        """Maximum coordinate value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Max.setter
    def Max(self, max:float) -> None:
        with agmarshall.DOUBLE_arg(max) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_SetMax"](arg_max.COM_val))

    @property
    def IncludeMinMax(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeMinMax"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IncludeMinMax.setter
    def IncludeMinMax(self, includeMinMax:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(includeMinMax) as arg_includeMinMax:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeMinMax"](arg_includeMinMax.COM_val))

    @property
    def ReferenceValue(self) -> float:
        """Reference coordinate value from which steps are taken."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceValue.setter
    def ReferenceValue(self, referenceValue:float) -> None:
        with agmarshall.DOUBLE_arg(referenceValue) as arg_referenceValue:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceValue"](arg_referenceValue.COM_val))

    @property
    def Step(self) -> float:
        """Step between subsequent coordinate values."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Step.setter
    def Step(self, step:float) -> None:
        with agmarshall.DOUBLE_arg(step) as arg_step:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_step.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7C18BF81-7E22-4A28-B462-37ED86EC3050}", ICrdnGridValuesFixedStep)
agcls.AgTypeNameMap["ICrdnGridValuesFixedStep"] = ICrdnGridValuesFixedStep

class ICrdnGridValuesMethod(object):
    """A grid values method."""
    _uuid = "{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMethodType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnGridValuesMethod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnGridValuesMethod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnGridValuesMethod = agcom.GUID(ICrdnGridValuesMethod._uuid)
        vtable_offset_local = ICrdnGridValuesMethod._vtable_offset - 1
        self.__dict__["_GetMethodType"] = IAGFUNCTYPE(pUnk, IID_ICrdnGridValuesMethod, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnGridValuesMethod.__dict__ and type(ICrdnGridValuesMethod.__dict__[attrname]) == property:
            return ICrdnGridValuesMethod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnGridValuesMethod.")
    
    @property
    def MethodType(self) -> "AgECrdnVolumetricGridValuesMethodType":
        """Grid values method type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumetricGridValuesMethodType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMethodType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}", ICrdnGridValuesMethod)
agcls.AgTypeNameMap["ICrdnGridValuesMethod"] = ICrdnGridValuesMethod

class ICrdnLightTimeDelay(object):
    """Manage Light Time Delay options.."""
    _uuid = "{82765B62-B9AB-4D52-900E-52ADAC0365D0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_SetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_GetClockHost"] = _raise_uninitialized_error
        self.__dict__["_SetClockHost"] = _raise_uninitialized_error
        self.__dict__["_GetTimeSense"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSense"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnLightTimeDelay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnLightTimeDelay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnLightTimeDelay = agcom.GUID(ICrdnLightTimeDelay._uuid)
        vtable_offset_local = ICrdnLightTimeDelay._vtable_offset - 1
        self.__dict__["_GetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAberrationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetClockHost"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetClockHost"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetTimeSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnLightTimeDelay, vtable_offset_local+10, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnLightTimeDelay.__dict__ and type(ICrdnLightTimeDelay.__dict__[attrname]) == property:
            return ICrdnLightTimeDelay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnLightTimeDelay.")
    
    @property
    def UseLightTimeDelay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseLightTimeDelay"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, useLightTimeDelay:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useLightTimeDelay) as arg_useLightTimeDelay:
            agcls.evaluate_hresult(self.__dict__["_SetUseLightTimeDelay"](arg_useLightTimeDelay.COM_val))

    @property
    def TimeDelayConvergence(self) -> float:
        """Set light Time Delay Convergence."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergence"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeDelayConvergence.setter
    def TimeDelayConvergence(self, timeDelayConvergence:float) -> None:
        with agmarshall.DOUBLE_arg(timeDelayConvergence) as arg_timeDelayConvergence:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergence"](arg_timeDelayConvergence.COM_val))

    @property
    def AberrationType(self) -> "AgECrdnVolumeAberrationType":
        """Method used to Aberration Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAberrationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AberrationType.setter
    def AberrationType(self, aberrationType:"AgECrdnVolumeAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeAberrationType, aberrationType) as arg_aberrationType:
            agcls.evaluate_hresult(self.__dict__["_SetAberrationType"](arg_aberrationType.COM_val))

    @property
    def ClockHost(self) -> "AgECrdnVolumeClockHostType":
        """Indicates whether object1 or object2 of an Access instance holds the clock for Access times."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockHost"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockHost.setter
    def ClockHost(self, clockHost:"AgECrdnVolumeClockHostType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeClockHostType, clockHost) as arg_clockHost:
            agcls.evaluate_hresult(self.__dict__["_SetClockHost"](arg_clockHost.COM_val))

    @property
    def TimeSense(self) -> "AgECrdnVolumeTimeSenseType":
        """Indicates whether apparent position is computed in a transmit or receive sense"""
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TimeSense.setter
    def TimeSense(self, timeSense:"AgECrdnVolumeTimeSenseType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeTimeSenseType, timeSense) as arg_timeSense:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSense"](arg_timeSense.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{82765B62-B9AB-4D52-900E-52ADAC0365D0}", ICrdnLightTimeDelay)
agcls.AgTypeNameMap["ICrdnLightTimeDelay"] = ICrdnLightTimeDelay

class ICrdnVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    _uuid = "{F85958EC-F470-432F-81B1-8517D3952F1E}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolume._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolume from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolume = agcom.GUID(ICrdnVolume._uuid)
        vtable_offset_local = ICrdnVolume._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolume.__dict__ and type(ICrdnVolume.__dict__[attrname]) == property:
            return ICrdnVolume.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolume.")
    

agcls.AgClassCatalog.add_catalog_entry("{F85958EC-F470-432F-81B1-8517D3952F1E}", ICrdnVolume)
agcls.AgTypeNameMap["ICrdnVolume"] = ICrdnVolume

class ICrdnVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    _uuid = "{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalc = agcom.GUID(ICrdnVolumeCalc._uuid)
        vtable_offset_local = ICrdnVolumeCalc._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalc.__dict__ and type(ICrdnVolumeCalc.__dict__[attrname]) == property:
            return ICrdnVolumeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalc.")
    

agcls.AgClassCatalog.add_catalog_entry("{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}", ICrdnVolumeCalc)
agcls.AgTypeNameMap["ICrdnVolumeCalc"] = ICrdnVolumeCalc

class ICrdnVolumeCalcAltitude(object):
    """A volume calc altitude interface."""
    _uuid = "{6039868a-acea-4918-966b-c6f952fd94d3}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_SetShapeModel"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomReference"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcAltitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcAltitude = agcom.GUID(ICrdnVolumeCalcAltitude._uuid)
        vtable_offset_local = ICrdnVolumeCalcAltitude._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetShapeModel"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShapeModel"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomReference"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAltitude, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcAltitude.__dict__ and type(ICrdnVolumeCalcAltitude.__dict__[attrname]) == property:
            return ICrdnVolumeCalcAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcAltitude.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ShapeModel(self) -> "AgECrdnVolumeCalcAltitudeReferenceType":
        """The Volume Calc Altitude Reference Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShapeModel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ShapeModel.setter
    def ShapeModel(self, shapeModel:"AgECrdnVolumeCalcAltitudeReferenceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAltitudeReferenceType, shapeModel) as arg_shapeModel:
            agcls.evaluate_hresult(self.__dict__["_SetShapeModel"](arg_shapeModel.COM_val))

    @property
    def UseCustomReference(self) -> bool:
        """Whether to use custom reference."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomReference"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomReference.setter
    def UseCustomReference(self, useCustomReference:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomReference) as arg_useCustomReference:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomReference"](arg_useCustomReference.COM_val))

    @property
    def ReferencePoint(self) -> "ICrdnPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, ICrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6039868a-acea-4918-966b-c6f952fd94d3}", ICrdnVolumeCalcAltitude)
agcls.AgTypeNameMap["ICrdnVolumeCalcAltitude"] = ICrdnVolumeCalcAltitude

class ICrdnVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""
    _uuid = "{ad6880b4-afc1-47ba-b964-f38916955c7b}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_SetAboutVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcAngleOffVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcAngleOffVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcAngleOffVector = agcom.GUID(ICrdnVolumeCalcAngleOffVector._uuid)
        vtable_offset_local = ICrdnVolumeCalcAngleOffVector._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetAboutVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcAngleOffVector, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcAngleOffVector.__dict__ and type(ICrdnVolumeCalcAngleOffVector.__dict__[attrname]) == property:
            return ICrdnVolumeCalcAngleOffVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcAngleOffVector.")
    
    @property
    def Angle(self) -> "AgECrdnVolumeCalcAngleOffVectorType":
        """The Volume Calc Angle Off Vector Type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Angle.setter
    def Angle(self, angle:"AgECrdnVolumeCalcAngleOffVectorType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcAngleOffVectorType, angle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    @property
    def ReferencePlane(self) -> "ICrdnPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"ICrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, ICrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def ReferencePoint(self) -> "ICrdnPoint":
        """The Volume Calc Angle Off Vector reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, ICrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferenceVector(self) -> "ICrdnVector":
        """The Volume Calc Angle Off Vector reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVector.setter
    def ReferenceVector(self, referenceVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(referenceVector, ICrdnVector) as arg_referenceVector:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVector"](arg_referenceVector.COM_val))

    @property
    def AboutVector(self) -> "ICrdnVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AboutVector.setter
    def AboutVector(self, aboutVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(aboutVector, ICrdnVector) as arg_aboutVector:
            agcls.evaluate_hresult(self.__dict__["_SetAboutVector"](arg_aboutVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ad6880b4-afc1-47ba-b964-f38916955c7b}", ICrdnVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["ICrdnVolumeCalcAngleOffVector"] = ICrdnVolumeCalcAngleOffVector

class ICrdnVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""
    _uuid = "{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_SetSpatialCondition"] = _raise_uninitialized_error
        self.__dict__["_GetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_SetSatisfactionMetric"] = _raise_uninitialized_error
        self.__dict__["_GetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_SetAccumulationType"] = _raise_uninitialized_error
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetFilter"] = _raise_uninitialized_error
        self.__dict__["_SetFilter"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumNumberOfIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumDuration"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumDurationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumDurationTime"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcConditionSatMetric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcConditionSatMetric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcConditionSatMetric = agcom.GUID(ICrdnVolumeCalcConditionSatMetric._uuid)
        vtable_offset_local = ICrdnVolumeCalcConditionSatMetric._vtable_offset - 1
        self.__dict__["_GetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSpatialCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSatisfactionMetric"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAccumulationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetFilter"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetFilter"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+11, POINTER(agcom.INT))
        self.__dict__["_SetMaximumNumberOfIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+12, agcom.INT)
        self.__dict__["_GetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumDuration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumDurationTime"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcConditionSatMetric, vtable_offset_local+20, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcConditionSatMetric.__dict__ and type(ICrdnVolumeCalcConditionSatMetric.__dict__[attrname]) == property:
            return ICrdnVolumeCalcConditionSatMetric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcConditionSatMetric.")
    
    @property
    def SpatialCondition(self) -> "ICrdnVolume":
        """A spatial condition for satisfaction metric."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpatialCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SpatialCondition.setter
    def SpatialCondition(self, spatialCondition:"ICrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(spatialCondition, ICrdnVolume) as arg_spatialCondition:
            agcls.evaluate_hresult(self.__dict__["_SetSpatialCondition"](arg_spatialCondition.COM_val))

    @property
    def SatisfactionMetric(self) -> "AgECrdnVolumeCalcVolumeSatisfactionMetricType":
        """Spatial condition satisfaction metric types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatisfactionMetric"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SatisfactionMetric.setter
    def SatisfactionMetric(self, satisfactionMetric:"AgECrdnVolumeCalcVolumeSatisfactionMetricType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionMetricType, satisfactionMetric) as arg_satisfactionMetric:
            agcls.evaluate_hresult(self.__dict__["_SetSatisfactionMetric"](arg_satisfactionMetric.COM_val))

    @property
    def AccumulationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionAccumulationType":
        """Spatial condition satisfaction accumulation types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAccumulationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AccumulationType.setter
    def AccumulationType(self, accumulationType:"AgECrdnVolumeCalcVolumeSatisfactionAccumulationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionAccumulationType, accumulationType) as arg_accumulationType:
            agcls.evaluate_hresult(self.__dict__["_SetAccumulationType"](arg_accumulationType.COM_val))

    @property
    def DurationType(self) -> "AgECrdnVolumeCalcVolumeSatisfactionDurationType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeCalcVolumeSatisfactionDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def Filter(self) -> "AgECrdnVolumeCalcVolumeSatisfactionFilterType":
        """Spatial condition satisfaction duration types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilter"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filter.setter
    def Filter(self, filter:"AgECrdnVolumeCalcVolumeSatisfactionFilterType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcVolumeSatisfactionFilterType, filter) as arg_filter:
            agcls.evaluate_hresult(self.__dict__["_SetFilter"](arg_filter.COM_val))

    @property
    def MaximumNumberOfIntervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumNumberOfIntervals"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumNumberOfIntervals.setter
    def MaximumNumberOfIntervals(self, maximumNumberOfIntervals:int) -> None:
        with agmarshall.INT_arg(maximumNumberOfIntervals) as arg_maximumNumberOfIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumNumberOfIntervals"](arg_maximumNumberOfIntervals.COM_val))

    @property
    def UseMinimumDuration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumDuration.setter
    def UseMinimumDuration(self, useMinimumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumDuration) as arg_useMinimumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumDuration"](arg_useMinimumDuration.COM_val))

    @property
    def UseMaximumDuration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumDuration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumDuration.setter
    def UseMaximumDuration(self, useMaximumDuration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumDuration) as arg_useMaximumDuration:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumDuration"](arg_useMaximumDuration.COM_val))

    @property
    def MinimumDurationTime(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumDurationTime.setter
    def MinimumDurationTime(self, minimumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(minimumDurationTime) as arg_minimumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumDurationTime"](arg_minimumDurationTime.COM_val))

    @property
    def MaximumDurationTime(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumDurationTime"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumDurationTime.setter
    def MaximumDurationTime(self, maximumDurationTime:float) -> None:
        with agmarshall.DOUBLE_arg(maximumDurationTime) as arg_maximumDurationTime:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumDurationTime"](arg_maximumDurationTime.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}", ICrdnVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["ICrdnVolumeCalcConditionSatMetric"] = ICrdnVolumeCalcConditionSatMetric

class ICrdnVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""
    _uuid = "{874bf6c9-20d7-486c-918a-a0094093879a}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_GetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_SetSpeedType"] = _raise_uninitialized_error
        self.__dict__["_GetSpeed"] = _raise_uninitialized_error
        self.__dict__["_SetSpeed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcDelayRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcDelayRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcDelayRange = agcom.GUID(ICrdnVolumeCalcDelayRange._uuid)
        vtable_offset_local = ICrdnVolumeCalcDelayRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetSpeedType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetSpeedType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetSpeed"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpeed"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcDelayRange, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcDelayRange.__dict__ and type(ICrdnVolumeCalcDelayRange.__dict__[attrname]) == property:
            return ICrdnVolumeCalcDelayRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcDelayRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "ICrdnPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, ICrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "ICrdnPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"ICrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, ICrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "ICrdnVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, ICrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))

    @property
    def SpeedType(self) -> "AgECrdnVolumeCalcRangeSpeedType":
        """The Volume Calc range speed types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeedType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpeedType.setter
    def SpeedType(self, speedType:"AgECrdnVolumeCalcRangeSpeedType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeSpeedType, speedType) as arg_speedType:
            agcls.evaluate_hresult(self.__dict__["_SetSpeedType"](arg_speedType.COM_val))

    @property
    def Speed(self) -> float:
        """The Volume Calc range speed value"""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpeed"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Speed.setter
    def Speed(self, speed:float) -> None:
        with agmarshall.DOUBLE_arg(speed) as arg_speed:
            agcls.evaluate_hresult(self.__dict__["_SetSpeed"](arg_speed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{874bf6c9-20d7-486c-918a-a0094093879a}", ICrdnVolumeCalcDelayRange)
agcls.AgTypeNameMap["ICrdnVolumeCalcDelayRange"] = ICrdnVolumeCalcDelayRange

class ICrdnVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    _uuid = "{362b7405-edf6-486c-8fcf-1f9a93b75000}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_Reload"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcFile = agcom.GUID(ICrdnVolumeCalcFile._uuid)
        vtable_offset_local = ICrdnVolumeCalcFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_Reload"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFile, vtable_offset_local+3, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcFile.__dict__ and type(ICrdnVolumeCalcFile.__dict__[attrname]) == property:
            return ICrdnVolumeCalcFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcFile.")
    
    @property
    def Filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))

    def Reload(self) -> None:
        """Reloads the volume calc file."""
        agcls.evaluate_hresult(self.__dict__["_Reload"]())


agcls.AgClassCatalog.add_catalog_entry("{362b7405-edf6-486c-8fcf-1f9a93b75000}", ICrdnVolumeCalcFile)
agcls.AgTypeNameMap["ICrdnVolumeCalcFile"] = ICrdnVolumeCalcFile

class ICrdnVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""
    _uuid = "{6e537b27-ee55-44c5-89b2-f2c504a44bb6}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalar"] = _raise_uninitialized_error
        self.__dict__["_SetScalar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcFromScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcFromScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcFromScalar = agcom.GUID(ICrdnVolumeCalcFromScalar._uuid)
        vtable_offset_local = ICrdnVolumeCalcFromScalar._vtable_offset - 1
        self.__dict__["_GetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFromScalar, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcFromScalar, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcFromScalar.__dict__ and type(ICrdnVolumeCalcFromScalar.__dict__[attrname]) == property:
            return ICrdnVolumeCalcFromScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcFromScalar.")
    
    @property
    def Scalar(self) -> "ICrdnCalcScalar":
        """The Volume calc scalar to location Type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Scalar.setter
    def Scalar(self, scalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalar, ICrdnCalcScalar) as arg_scalar:
            agcls.evaluate_hresult(self.__dict__["_SetScalar"](arg_scalar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6e537b27-ee55-44c5-89b2-f2c504a44bb6}", ICrdnVolumeCalcFromScalar)
agcls.AgTypeNameMap["ICrdnVolumeCalcFromScalar"] = ICrdnVolumeCalcFromScalar

class ICrdnVolumeCalcRange(object):
    """A volume calc distance to location interface."""
    _uuid = "{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcRange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcRange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcRange = agcom.GUID(ICrdnVolumeCalcRange._uuid)
        vtable_offset_local = ICrdnVolumeCalcRange._vtable_offset - 1
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcRange, vtable_offset_local+8, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcRange.__dict__ and type(ICrdnVolumeCalcRange.__dict__[attrname]) == property:
            return ICrdnVolumeCalcRange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcRange.")
    
    @property
    def Distance(self) -> "AgECrdnVolumeCalcRangeDistanceType":
        """The Volume Calc range distance types."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:"AgECrdnVolumeCalcRangeDistanceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCalcRangeDistanceType, distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def ReferencePoint(self) -> "ICrdnPoint":
        """The Volume Calc Range reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, ICrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def ReferencePlane(self) -> "ICrdnPlane":
        """The Volume Calc Range reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePlane.setter
    def ReferencePlane(self, referencePlane:"ICrdnPlane") -> None:
        with agmarshall.AgInterface_in_arg(referencePlane, ICrdnPlane) as arg_referencePlane:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePlane"](arg_referencePlane.COM_val))

    @property
    def AlongVector(self) -> "ICrdnVector":
        """The Volume Calc Range Along Vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, ICrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}", ICrdnVolumeCalcRange)
agcls.AgTypeNameMap["ICrdnVolumeCalcRange"] = ICrdnVolumeCalcRange

class ICrdnVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""
    _uuid = "{40e35f2b-9a83-449a-9a4e-35bdee832061}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCalcSolarIntensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCalcSolarIntensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCalcSolarIntensity = agcom.GUID(ICrdnVolumeCalcSolarIntensity._uuid)
        vtable_offset_local = ICrdnVolumeCalcSolarIntensity._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcSolarIntensity, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcSolarIntensity, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcSolarIntensity, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCalcSolarIntensity, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCalcSolarIntensity.__dict__ and type(ICrdnVolumeCalcSolarIntensity.__dict__[attrname]) == property:
            return ICrdnVolumeCalcSolarIntensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCalcSolarIntensity.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{40e35f2b-9a83-449a-9a4e-35bdee832061}", ICrdnVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["ICrdnVolumeCalcSolarIntensity"] = ICrdnVolumeCalcSolarIntensity

class ICrdnVolumeCombined(object):
    """A combined volume interface."""
    _uuid = "{96684FB4-3839-44DB-AD80-B772BF58A39A}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_SetCombineOperation"] = _raise_uninitialized_error
        self.__dict__["_GetConditionCount"] = _raise_uninitialized_error
        self.__dict__["_GetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetAllConditions"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_RemoveCondition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeCombined._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeCombined from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeCombined = agcom.GUID(ICrdnVolumeCombined._uuid)
        vtable_offset_local = ICrdnVolumeCombined._vtable_offset - 1
        self.__dict__["_GetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCombineOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetConditionCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetAllConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+6, agcom.PVOID, agcom.INT)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_RemoveCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeCombined, vtable_offset_local+8, agcom.INT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeCombined.__dict__ and type(ICrdnVolumeCombined.__dict__[attrname]) == property:
            return ICrdnVolumeCombined.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeCombined.")
    
    @property
    def CombineOperation(self) -> "AgECrdnVolumeCombinedOperationType":
        """Sets/Returns volume combined operation."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCombineOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CombineOperation.setter
    def CombineOperation(self, combineOperation:"AgECrdnVolumeCombinedOperationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeCombinedOperationType, combineOperation) as arg_combineOperation:
            agcls.evaluate_hresult(self.__dict__["_SetCombineOperation"](arg_combineOperation.COM_val))

    @property
    def ConditionCount(self) -> int:
        """Returns the spatial condition vector size."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def GetAllConditions(self) -> list:
        """Get all spatial conditions."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetAllConditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        with agmarshall.SAFEARRAY_arg(conditions) as arg_conditions:
            agcls.evaluate_hresult(self.__dict__["_SetAllConditions"](byref(arg_conditions.COM_val)))

    def SetCondition(self, ref:"ICrdnVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        with agmarshall.AgInterface_in_arg(ref, ICrdnVolume) as arg_ref, \
             agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_ref.COM_val, arg_pos.COM_val))

    def GetCondition(self, pos:int) -> "ICrdnVolume":
        """Get spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](arg_pos.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def RemoveCondition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        with agmarshall.INT_arg(pos) as arg_pos:
            agcls.evaluate_hresult(self.__dict__["_RemoveCondition"](arg_pos.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{96684FB4-3839-44DB-AD80-B772BF58A39A}", ICrdnVolumeCombined)
agcls.AgTypeNameMap["ICrdnVolumeCombined"] = ICrdnVolumeCombined

class ICrdnVolumeFromCalc(object):
    """An volume from calc volume interface."""
    _uuid = "{018666E1-C0E6-46F6-A682-F91FBF3C74F3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOperation"] = _raise_uninitialized_error
        self.__dict__["_SetOperation"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeCalc"] = _raise_uninitialized_error
        self.__dict__["_GetMinimum"] = _raise_uninitialized_error
        self.__dict__["_SetMinimum"] = _raise_uninitialized_error
        self.__dict__["_GetMaximum"] = _raise_uninitialized_error
        self.__dict__["_SetMaximum"] = _raise_uninitialized_error
        self.__dict__["_Set"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeFromCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeFromCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeFromCalc = agcom.GUID(ICrdnVolumeFromCalc._uuid)
        vtable_offset_local = ICrdnVolumeFromCalc._vtable_offset - 1
        self.__dict__["_GetOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetOperation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeCalc"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetMinimum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetMaximum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_Set"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCalc, vtable_offset_local+9, agcom.PVOID, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeFromCalc.__dict__ and type(ICrdnVolumeFromCalc.__dict__[attrname]) == property:
            return ICrdnVolumeFromCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeFromCalc.")
    
    @property
    def Operation(self) -> "AgECrdnConditionThresholdOption":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Operation.setter
    def Operation(self, operation:"AgECrdnConditionThresholdOption") -> None:
        with agmarshall.AgEnum_arg(AgECrdnConditionThresholdOption, operation) as arg_operation:
            agcls.evaluate_hresult(self.__dict__["_SetOperation"](arg_operation.COM_val))

    @property
    def VolumeCalc(self) -> "ICrdnVolumeCalc":
        """Get the volume calc from the bounds."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalc"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeCalc.setter
    def VolumeCalc(self, volumeCalc:"ICrdnVolumeCalc") -> None:
        with agmarshall.AgInterface_in_arg(volumeCalc, ICrdnVolumeCalc) as arg_volumeCalc:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeCalc"](arg_volumeCalc.COM_val))

    def GetMinimum(self) -> "IQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMinimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMinimum"](arg_value.COM_val))

    def GetMaximum(self) -> "IQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def SetMaximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        with agmarshall.AgInterface_in_arg(value, IQuantity) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetMaximum"](arg_value.COM_val))

    def Set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        with agmarshall.AgInterface_in_arg(min, IQuantity) as arg_min, \
             agmarshall.AgInterface_in_arg(max, IQuantity) as arg_max:
            agcls.evaluate_hresult(self.__dict__["_Set"](arg_min.COM_val, arg_max.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{018666E1-C0E6-46F6-A682-F91FBF3C74F3}", ICrdnVolumeFromCalc)
agcls.AgTypeNameMap["ICrdnVolumeFromCalc"] = ICrdnVolumeFromCalc

class ICrdnVolumeFromCondition(object):
    """A volume from conditioninterface."""
    _uuid = "{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_SetCustomTimeLimits"] = _raise_uninitialized_error
        self.__dict__["_GetSampling"] = _raise_uninitialized_error
        self.__dict__["_SetSampling"] = _raise_uninitialized_error
        self.__dict__["_GetConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetConvergence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeFromCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeFromCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeFromCondition = agcom.GUID(ICrdnVolumeFromCondition._uuid)
        vtable_offset_local = ICrdnVolumeFromCondition._vtable_offset - 1
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCustomTimeLimits"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetSampling"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_SetConvergence"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromCondition, vtable_offset_local+10, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeFromCondition.__dict__ and type(ICrdnVolumeFromCondition.__dict__[attrname]) == property:
            return ICrdnVolumeFromCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeFromCondition.")
    
    @property
    def Condition(self) -> "ICrdnCondition":
        """The condition component."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Condition.setter
    def Condition(self, condition:"ICrdnCondition") -> None:
        with agmarshall.AgInterface_in_arg(condition, ICrdnCondition) as arg_condition:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_condition.COM_val))

    @property
    def UseCustomTimeLimits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomTimeLimits"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseCustomTimeLimits.setter
    def UseCustomTimeLimits(self, useCustomTimeLimits:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useCustomTimeLimits) as arg_useCustomTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomTimeLimits"](arg_useCustomTimeLimits.COM_val))

    @property
    def CustomTimeLimits(self) -> "ICrdnEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomTimeLimits"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CustomTimeLimits.setter
    def CustomTimeLimits(self, customTimeLimits:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(customTimeLimits, ICrdnEventIntervalList) as arg_customTimeLimits:
            agcls.evaluate_hresult(self.__dict__["_SetCustomTimeLimits"](arg_customTimeLimits.COM_val))

    @property
    def Sampling(self) -> "ICrdnSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSampling"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Sampling.setter
    def Sampling(self, sampling:"ICrdnSampling") -> None:
        with agmarshall.AgInterface_in_arg(sampling, ICrdnSampling) as arg_sampling:
            agcls.evaluate_hresult(self.__dict__["_SetSampling"](arg_sampling.COM_val))

    @property
    def Convergence(self) -> "ICrdnConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergence"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Convergence.setter
    def Convergence(self, convergence:"ICrdnConverge") -> None:
        with agmarshall.AgInterface_in_arg(convergence, ICrdnConverge) as arg_convergence:
            agcls.evaluate_hresult(self.__dict__["_SetConvergence"](arg_convergence.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}", ICrdnVolumeFromCondition)
agcls.AgTypeNameMap["ICrdnVolumeFromCondition"] = ICrdnVolumeFromCondition

class ICrdnVolumeFromGrid(object):
    """An over time volume interface."""
    _uuid = "{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_SetEdgeType"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrid"] = _raise_uninitialized_error
        self.__dict__["_SetVolumeGrid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeFromGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeFromGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeFromGrid = agcom.GUID(ICrdnVolumeFromGrid._uuid)
        vtable_offset_local = ICrdnVolumeFromGrid._vtable_offset - 1
        self.__dict__["_GetEdgeType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromGrid, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetEdgeType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromGrid, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromGrid, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetVolumeGrid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromGrid, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeFromGrid.__dict__ and type(ICrdnVolumeFromGrid.__dict__[attrname]) == property:
            return ICrdnVolumeFromGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeFromGrid.")
    
    @property
    def EdgeType(self) -> "AgECrdnVolumeFromGridEdgeType":
        """Sets/Returns the edge type."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEdgeType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EdgeType.setter
    def EdgeType(self, edgeType:"AgECrdnVolumeFromGridEdgeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeFromGridEdgeType, edgeType) as arg_edgeType:
            agcls.evaluate_hresult(self.__dict__["_SetEdgeType"](arg_edgeType.COM_val))

    @property
    def VolumeGrid(self) -> "ICrdnVolumeGrid":
        """Sets/Returns the volume grid for bounding."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VolumeGrid.setter
    def VolumeGrid(self, volumeGrid:"ICrdnVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(volumeGrid, ICrdnVolumeGrid) as arg_volumeGrid:
            agcls.evaluate_hresult(self.__dict__["_SetVolumeGrid"](arg_volumeGrid.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}", ICrdnVolumeFromGrid)
agcls.AgTypeNameMap["ICrdnVolumeFromGrid"] = ICrdnVolumeFromGrid

class ICrdnVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""
    _uuid = "{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeSatisfaction"] = _raise_uninitialized_error
        self.__dict__["_SetTimeSatisfaction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeFromTimeSatisfaction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeFromTimeSatisfaction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeFromTimeSatisfaction = agcom.GUID(ICrdnVolumeFromTimeSatisfaction._uuid)
        vtable_offset_local = ICrdnVolumeFromTimeSatisfaction._vtable_offset - 1
        self.__dict__["_GetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromTimeSatisfaction, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetTimeSatisfaction"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeFromTimeSatisfaction, vtable_offset_local+2, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeFromTimeSatisfaction.__dict__ and type(ICrdnVolumeFromTimeSatisfaction.__dict__[attrname]) == property:
            return ICrdnVolumeFromTimeSatisfaction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeFromTimeSatisfaction.")
    
    @property
    def TimeSatisfaction(self) -> "ICrdnEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeSatisfaction"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @TimeSatisfaction.setter
    def TimeSatisfaction(self, timeSatisfaction:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(timeSatisfaction, ICrdnEventIntervalList) as arg_timeSatisfaction:
            agcls.evaluate_hresult(self.__dict__["_SetTimeSatisfaction"](arg_timeSatisfaction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}", ICrdnVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["ICrdnVolumeFromTimeSatisfaction"] = ICrdnVolumeFromTimeSatisfaction

class ICrdnVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    _uuid = "{88BBE781-85C1-439D-A4F4-58006B9A35EC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGrid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGrid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGrid = agcom.GUID(ICrdnVolumeGrid._uuid)
        vtable_offset_local = ICrdnVolumeGrid._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGrid.__dict__ and type(ICrdnVolumeGrid.__dict__[attrname]) == property:
            return ICrdnVolumeGrid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGrid.")
    

agcls.AgClassCatalog.add_catalog_entry("{88BBE781-85C1-439D-A4F4-58006B9A35EC}", ICrdnVolumeGrid)
agcls.AgTypeNameMap["ICrdnVolumeGrid"] = ICrdnVolumeGrid

class ICrdnVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""
    _uuid = "{2814A890-E858-41A6-B640-19F9D27E5ACB}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAlongBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetCrossBearingCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_GetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_SetBearingAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceLocation"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceLocation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridBearingAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridBearingAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridBearingAlt = agcom.GUID(ICrdnVolumeGridBearingAlt._uuid)
        vtable_offset_local = ICrdnVolumeGridBearingAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetAlongBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCrossBearingCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_GetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBearingAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+10, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetReferenceLocation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridBearingAlt, vtable_offset_local+11, agcom.SAFEARRAY)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridBearingAlt.__dict__ and type(ICrdnVolumeGridBearingAlt.__dict__[attrname]) == property:
            return ICrdnVolumeGridBearingAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridBearingAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def AlongBearingCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns AlongBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CrossBearingCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns CrossBearing Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCrossBearingCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns altitude Coordinates parameters for the surface bearing."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))

    @property
    def BearingAngle(self) -> float:
        """Specify the Bearing Angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBearingAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @BearingAngle.setter
    def BearingAngle(self, bearingAngle:float) -> None:
        with agmarshall.DOUBLE_arg(bearingAngle) as arg_bearingAngle:
            agcls.evaluate_hresult(self.__dict__["_SetBearingAngle"](arg_bearingAngle.COM_val))

    @property
    def ReferenceLocation(self) -> list:
        """Get lat/lon for reference location"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceLocation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceLocation.setter
    def ReferenceLocation(self, referenceLocation:list) -> None:
        with agmarshall.SAFEARRAY_arg(referenceLocation) as arg_referenceLocation:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceLocation"](arg_referenceLocation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2814A890-E858-41A6-B640-19F9D27E5ACB}", ICrdnVolumeGridBearingAlt)
agcls.AgTypeNameMap["ICrdnVolumeGridBearingAlt"] = ICrdnVolumeGridBearingAlt

class ICrdnVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""
    _uuid = "{E959F851-165E-4201-8C13-81FA4C2D3E2D}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetXCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetYCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetZCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridCartesian = agcom.GUID(ICrdnVolumeGridCartesian._uuid)
        vtable_offset_local = ICrdnVolumeGridCartesian._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCartesian, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCartesian, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetXCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCartesian, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCartesian, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetZCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCartesian, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridCartesian.__dict__ and type(ICrdnVolumeGridCartesian.__dict__[attrname]) == property:
            return ICrdnVolumeGridCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridCartesian.")
    
    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def XCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns X Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns Y Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ZCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns Z Coordinates parameters for the Cartesian system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetZCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E959F851-165E-4201-8C13-81FA4C2D3E2D}", ICrdnVolumeGridCartesian)
agcls.AgTypeNameMap["ICrdnVolumeGridCartesian"] = ICrdnVolumeGridCartesian

class ICrdnVolumeGridConstrained(object):
    """A volume grid constrained interface."""
    _uuid = "{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceGrid"] = _raise_uninitialized_error
        self.__dict__["_GetConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetConstraint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridConstrained = agcom.GUID(ICrdnVolumeGridConstrained._uuid)
        vtable_offset_local = ICrdnVolumeGridConstrained._vtable_offset - 1
        self.__dict__["_GetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceGrid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridConstrained, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridConstrained, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridConstrained.__dict__ and type(ICrdnVolumeGridConstrained.__dict__[attrname]) == property:
            return ICrdnVolumeGridConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridConstrained.")
    
    @property
    def ReferenceGrid(self) -> "ICrdnVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceGrid"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceGrid.setter
    def ReferenceGrid(self, referenceGrid:"ICrdnVolumeGrid") -> None:
        with agmarshall.AgInterface_in_arg(referenceGrid, ICrdnVolumeGrid) as arg_referenceGrid:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceGrid"](arg_referenceGrid.COM_val))

    @property
    def Constraint(self) -> "ICrdnVolume":
        """Get the volume constraint on the grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Constraint.setter
    def Constraint(self, constraint:"ICrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(constraint, ICrdnVolume) as arg_constraint:
            agcls.evaluate_hresult(self.__dict__["_SetConstraint"](arg_constraint.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}", ICrdnVolumeGridConstrained)
agcls.AgTypeNameMap["ICrdnVolumeGridConstrained"] = ICrdnVolumeGridConstrained

class ICrdnVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""
    _uuid = "{0CF87427-CC2B-4282-9B41-0A2D86395AD4}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetThetaCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetHeightCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridCylindrical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridCylindrical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridCylindrical = agcom.GUID(ICrdnVolumeGridCylindrical._uuid)
        vtable_offset_local = ICrdnVolumeGridCylindrical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCylindrical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCylindrical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetThetaCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCylindrical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRadiusCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCylindrical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetHeightCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridCylindrical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridCylindrical.__dict__ and type(ICrdnVolumeGridCylindrical.__dict__[attrname]) == property:
            return ICrdnVolumeGridCylindrical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridCylindrical.")
    
    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def ThetaCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns theta Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetThetaCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RadiusCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns radius Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def HeightCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns height Coordinates parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetHeightCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0CF87427-CC2B-4282-9B41-0A2D86395AD4}", ICrdnVolumeGridCylindrical)
agcls.AgTypeNameMap["ICrdnVolumeGridCylindrical"] = ICrdnVolumeGridCylindrical

class ICrdnVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    _uuid = "{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetLatitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetLongitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetAutoFitBounds"] = _raise_uninitialized_error
        self.__dict__["_SetAutoFitBounds"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridLatLonAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridLatLonAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridLatLonAlt = agcom.GUID(ICrdnVolumeGridLatLonAlt._uuid)
        vtable_offset_local = ICrdnVolumeGridLatLonAlt._vtable_offset - 1
        self.__dict__["_GetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLatitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetLongitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitudeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAutoFitBounds"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridLatLonAlt, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridLatLonAlt.__dict__ and type(ICrdnVolumeGridLatLonAlt.__dict__[attrname]) == property:
            return ICrdnVolumeGridLatLonAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridLatLonAlt.")
    
    @property
    def ReferenceCentralBody(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceCentralBody.setter
    def ReferenceCentralBody(self, referenceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(referenceCentralBody) as arg_referenceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceCentralBody"](arg_referenceCentralBody.COM_val))

    @property
    def LatitudeCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns latitude Coordinates parameters for the Theta system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LongitudeCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns longtitude Coordinates parameters for the Radius system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AltitudeCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns altitude parameters for the Height system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AutoFitBounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAutoFitBounds"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AutoFitBounds.setter
    def AutoFitBounds(self, autoFitBounds:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(autoFitBounds) as arg_autoFitBounds:
            agcls.evaluate_hresult(self.__dict__["_SetAutoFitBounds"](arg_autoFitBounds.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}", ICrdnVolumeGridLatLonAlt)
agcls.AgTypeNameMap["ICrdnVolumeGridLatLonAlt"] = ICrdnVolumeGridLatLonAlt

class ICrdnVolumeGridResult(object):
    """An interface that generates Volume Grid results."""
    _uuid = "{1C3B106C-011E-4C51-B321-20389C8EAF76}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSizeI"] = _raise_uninitialized_error
        self.__dict__["_GetSizeJ"] = _raise_uninitialized_error
        self.__dict__["_GetSizeK"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricDataVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricPositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricNativePositionVector"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeMetricGradientVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridResult = agcom.GUID(ICrdnVolumeGridResult._uuid)
        vtable_offset_local = ICrdnVolumeGridResult._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_GetSizeI"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+2, POINTER(agcom.INT))
        self.__dict__["_GetSizeJ"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+3, POINTER(agcom.INT))
        self.__dict__["_GetSizeK"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+4, POINTER(agcom.INT))
        self.__dict__["_GetVolumeMetricDataVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricPositionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+6, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricNativePositionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVolumeMetricGradientVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridResult, vtable_offset_local+8, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridResult.__dict__ and type(ICrdnVolumeGridResult.__dict__[attrname]) == property:
            return ICrdnVolumeGridResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridResult.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeI(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeI"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeJ(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeJ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def SizeK(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        with agmarshall.INT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSizeK"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VolumeMetricDataVector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricDataVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricPositionVector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricPositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricNativePositionVector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricNativePositionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeMetricGradientVector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeMetricGradientVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1C3B106C-011E-4C51-B321-20389C8EAF76}", ICrdnVolumeGridResult)
agcls.AgTypeNameMap["ICrdnVolumeGridResult"] = ICrdnVolumeGridResult

class ICrdnVolumeGridSpherical(object):
    """A volume grid spherical interface."""
    _uuid = "{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetElevationCoordinates"] = _raise_uninitialized_error
        self.__dict__["_GetRangeCoordinates"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeGridSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeGridSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeGridSpherical = agcom.GUID(ICrdnVolumeGridSpherical._uuid)
        vtable_offset_local = ICrdnVolumeGridSpherical._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridSpherical, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridSpherical, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAzimuthCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridSpherical, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetElevationCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridSpherical, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetRangeCoordinates"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeGridSpherical, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeGridSpherical.__dict__ and type(ICrdnVolumeGridSpherical.__dict__[attrname]) == property:
            return ICrdnVolumeGridSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeGridSpherical.")
    
    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """Get the reference system in which spherical parameters are computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def AzimuthCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns azimuth coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ElevationCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns elevation coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetElevationCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RangeCoordinates(self) -> "ICrdnGridCoordinateDefinition":
        """Returns range coordinates parameters for the spherical volume grid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRangeCoordinates"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}", ICrdnVolumeGridSpherical)
agcls.AgTypeNameMap["ICrdnVolumeGridSpherical"] = ICrdnVolumeGridSpherical

class ICrdnVolumeInview(object):
    """An Inview volume interface."""
    _uuid = "{EF724630-CEB6-4818-A5BB-F74CF1B9D931}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_SetConstraintObject"] = _raise_uninitialized_error
        self.__dict__["_GetLightTimeDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeInview._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeInview from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeInview = agcom.GUID(ICrdnVolumeInview._uuid)
        vtable_offset_local = ICrdnVolumeInview._vtable_offset - 1
        self.__dict__["_GetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeInview, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetConstraintObject"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeInview, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeInview, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeInview.__dict__ and type(ICrdnVolumeInview.__dict__[attrname]) == property:
            return ICrdnVolumeInview.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeInview.")
    
    @property
    def ConstraintObject(self) -> typing.Any:
        """A constraint object of the access."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintObject"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ConstraintObject.setter
    def ConstraintObject(self, constraintObject:typing.Any) -> None:
        with agmarshall.VARIANT_arg(constraintObject) as arg_constraintObject:
            agcls.evaluate_hresult(self.__dict__["_SetConstraintObject"](arg_constraintObject.COM_val))

    @property
    def LightTimeDelay(self) -> "ICrdnLightTimeDelay":
        """Returns Light Time Delay options parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightTimeDelay"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF724630-CEB6-4818-A5BB-F74CF1B9D931}", ICrdnVolumeInview)
agcls.AgTypeNameMap["ICrdnVolumeInview"] = ICrdnVolumeInview

class ICrdnVolumeLighting(object):
    """A lighting volume interface."""
    _uuid = "{CE134C08-274E-4E29-9337-03E9C73AA8F9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_SetUseObjectEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetLightingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetLightingConditions"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeLighting._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeLighting from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeLighting = agcom.GUID(ICrdnVolumeLighting._uuid)
        vtable_offset_local = ICrdnVolumeLighting._vtable_offset - 1
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+2, agcom.SAFEARRAY)
        self.__dict__["_GetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseObjectEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetLightingConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeLighting, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeLighting.__dict__ and type(ICrdnVolumeLighting.__dict__[attrname]) == property:
            return ICrdnVolumeLighting.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeLighting.")
    
    @property
    def EclipsingBodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @EclipsingBodies.setter
    def EclipsingBodies(self, eclipsingBodies:list) -> None:
        with agmarshall.SAFEARRAY_arg(eclipsingBodies) as arg_eclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodies"](arg_eclipsingBodies.COM_val))

    @property
    def UseObjectEclipsingBodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseObjectEclipsingBodies"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseObjectEclipsingBodies.setter
    def UseObjectEclipsingBodies(self, useObjectEclipsingBodies:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useObjectEclipsingBodies) as arg_useObjectEclipsingBodies:
            agcls.evaluate_hresult(self.__dict__["_SetUseObjectEclipsingBodies"](arg_useObjectEclipsingBodies.COM_val))

    @property
    def LightingConditions(self) -> "AgECrdnVolumeLightingConditionsType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLightingConditions"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LightingConditions.setter
    def LightingConditions(self, lightingConditions:"AgECrdnVolumeLightingConditionsType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeLightingConditionsType, lightingConditions) as arg_lightingConditions:
            agcls.evaluate_hresult(self.__dict__["_SetLightingConditions"](arg_lightingConditions.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CE134C08-274E-4E29-9337-03E9C73AA8F9}", ICrdnVolumeLighting)
agcls.AgTypeNameMap["ICrdnVolumeLighting"] = ICrdnVolumeLighting

class ICrdnVolumeOverTime(object):
    """An over time volume interface."""
    _uuid = "{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDurationType"] = _raise_uninitialized_error
        self.__dict__["_SetDurationType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceVolume"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStartOffset"] = _raise_uninitialized_error
        self.__dict__["_GetStopOffset"] = _raise_uninitialized_error
        self.__dict__["_SetStopOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVolumeOverTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVolumeOverTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVolumeOverTime = agcom.GUID(ICrdnVolumeOverTime._uuid)
        vtable_offset_local = ICrdnVolumeOverTime._vtable_offset - 1
        self.__dict__["_GetDurationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDurationType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceVolume"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnVolumeOverTime, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVolumeOverTime.__dict__ and type(ICrdnVolumeOverTime.__dict__[attrname]) == property:
            return ICrdnVolumeOverTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVolumeOverTime.")
    
    @property
    def DurationType(self) -> "AgECrdnVolumeOverTimeDurationType":
        """Sets/Returns the lighting conditions."""
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDurationType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DurationType.setter
    def DurationType(self, durationType:"AgECrdnVolumeOverTimeDurationType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVolumeOverTimeDurationType, durationType) as arg_durationType:
            agcls.evaluate_hresult(self.__dict__["_SetDurationType"](arg_durationType.COM_val))

    @property
    def ReferenceVolume(self) -> "ICrdnVolume":
        """Sets/Returns the reference volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVolume"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceVolume.setter
    def ReferenceVolume(self, referenceVolume:"ICrdnVolume") -> None:
        with agmarshall.AgInterface_in_arg(referenceVolume, ICrdnVolume) as arg_referenceVolume:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceVolume"](arg_referenceVolume.COM_val))

    @property
    def ReferenceIntervals(self) -> "ICrdnEventIntervalList":
        """The reference interval list for the over time volume."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceIntervals.setter
    def ReferenceIntervals(self, referenceIntervals:"ICrdnEventIntervalList") -> None:
        with agmarshall.AgInterface_in_arg(referenceIntervals, ICrdnEventIntervalList) as arg_referenceIntervals:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceIntervals"](arg_referenceIntervals.COM_val))

    @property
    def StartOffset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartOffset.setter
    def StartOffset(self, startOffset:float) -> None:
        with agmarshall.DOUBLE_arg(startOffset) as arg_startOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStartOffset"](arg_startOffset.COM_val))

    @property
    def StopOffset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopOffset.setter
    def StopOffset(self, stopOffset:float) -> None:
        with agmarshall.DOUBLE_arg(stopOffset) as arg_stopOffset:
            agcls.evaluate_hresult(self.__dict__["_SetStopOffset"](arg_stopOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}", ICrdnVolumeOverTime)
agcls.AgTypeNameMap["ICrdnVolumeOverTime"] = ICrdnVolumeOverTime

class ICrdnTimeProperties(object):
    """Defines methods to compute time properties such as availability and special times."""
    _uuid = "{E95B72AA-F8DE-4122-AC60-54E46A208E19}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAvailability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnTimeProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnTimeProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnTimeProperties = agcom.GUID(ICrdnTimeProperties._uuid)
        vtable_offset_local = ICrdnTimeProperties._vtable_offset - 1
        self.__dict__["_GetAvailability"] = IAGFUNCTYPE(pUnk, IID_ICrdnTimeProperties, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnTimeProperties.__dict__ and type(ICrdnTimeProperties.__dict__[attrname]) == property:
            return ICrdnTimeProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnTimeProperties.")
    
    def GetAvailability(self) -> "ICrdnIntervalCollection":
        """Returns a collection of availability intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailability"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E95B72AA-F8DE-4122-AC60-54E46A208E19}", ICrdnTimeProperties)
agcls.AgTypeNameMap["ICrdnTimeProperties"] = ICrdnTimeProperties

class ICrdnTypeInfo(object):
    """Provides information about the type of VGT components."""
    _uuid = "{67E20A46-9550-4A68-9276-697DC821A23A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTypeDescription"] = _raise_uninitialized_error
        self.__dict__["_GetTypeName"] = _raise_uninitialized_error
        self.__dict__["_GetShortTypeDescription"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnTypeInfo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnTypeInfo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnTypeInfo = agcom.GUID(ICrdnTypeInfo._uuid)
        vtable_offset_local = ICrdnTypeInfo._vtable_offset - 1
        self.__dict__["_GetTypeDescription"] = IAGFUNCTYPE(pUnk, IID_ICrdnTypeInfo, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTypeName"] = IAGFUNCTYPE(pUnk, IID_ICrdnTypeInfo, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetShortTypeDescription"] = IAGFUNCTYPE(pUnk, IID_ICrdnTypeInfo, vtable_offset_local+3, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnTypeInfo.__dict__ and type(ICrdnTypeInfo.__dict__[attrname]) == property:
            return ICrdnTypeInfo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnTypeInfo.")
    
    @property
    def TypeDescription(self) -> str:
        """Return the type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def TypeName(self) -> str:
        """Return the type name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTypeName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShortTypeDescription(self) -> str:
        """Return the short type description."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetShortTypeDescription"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{67E20A46-9550-4A68-9276-697DC821A23A}", ICrdnTypeInfo)
agcls.AgTypeNameMap["ICrdnTypeInfo"] = ICrdnTypeInfo

class ICrdnRefTo(object):
    """A base interface for all VGT component references."""
    _uuid = "{2F3A17A6-4304-4565-BC1C-7A064DCFE310}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPath"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnRefTo = agcom.GUID(ICrdnRefTo._uuid)
        vtable_offset_local = ICrdnRefTo._vtable_offset - 1
        self.__dict__["_GetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnRefTo, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnRefTo.__dict__ and type(ICrdnRefTo.__dict__[attrname]) == property:
            return ICrdnRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnRefTo.")
    
    @property
    def Path(self) -> str:
        """Returns a path to the referenced VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2F3A17A6-4304-4565-BC1C-7A064DCFE310}", ICrdnRefTo)
agcls.AgTypeNameMap["ICrdnRefTo"] = ICrdnRefTo

class ICrdnTemplate(object):
    """The IAgCrdnTemplate interface enables to obtain information about the STK class that owns the VGT component."""
    _uuid = "{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetClassName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnTemplate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnTemplate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnTemplate = agcom.GUID(ICrdnTemplate._uuid)
        vtable_offset_local = ICrdnTemplate._vtable_offset - 1
        self.__dict__["_GetClassName"] = IAGFUNCTYPE(pUnk, IID_ICrdnTemplate, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnTemplate.__dict__ and type(ICrdnTemplate.__dict__[attrname]) == property:
            return ICrdnTemplate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnTemplate.")
    
    @property
    def ClassName(self) -> str:
        """Returns a class name (i.e. 'Satellite', 'Facility', etc.)."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClassName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}", ICrdnTemplate)
agcls.AgTypeNameMap["ICrdnTemplate"] = ICrdnTemplate

class ICrdnInstance(object):
    """The IAgCrdnInstance interface enables to obtain information about the parent object that owns the VGT component."""
    _uuid = "{17633665-9601-4FFF-8227-4D5DF0AAEA06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInstancePath"] = _raise_uninitialized_error
        self.__dict__["_GetTemplate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnInstance._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnInstance from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnInstance = agcom.GUID(ICrdnInstance._uuid)
        vtable_offset_local = ICrdnInstance._vtable_offset - 1
        self.__dict__["_GetInstancePath"] = IAGFUNCTYPE(pUnk, IID_ICrdnInstance, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetTemplate"] = IAGFUNCTYPE(pUnk, IID_ICrdnInstance, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnInstance.__dict__ and type(ICrdnInstance.__dict__[attrname]) == property:
            return ICrdnInstance.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnInstance.")
    
    @property
    def InstancePath(self) -> str:
        """Returns a path to the parent object that owns the VGT component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInstancePath"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Template(self) -> "ICrdn":
        """Returns a template object the VGT component was created from or null if the VGT component was not created from a template."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{17633665-9601-4FFF-8227-4D5DF0AAEA06}", ICrdnInstance)
agcls.AgTypeNameMap["ICrdnInstance"] = ICrdnInstance

class ICrdnPointRefTo(object):
    """Represents a reference to a VGT point."""
    _uuid = "{B553DE32-05C9-4944-918A-90552E039DBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointRefTo = agcom.GUID(ICrdnPointRefTo._uuid)
        vtable_offset_local = ICrdnPointRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointRefTo.__dict__ and type(ICrdnPointRefTo.__dict__[attrname]) == property:
            return ICrdnPointRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new point."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPoint(self, point:"ICrdnPoint") -> None:
        """Sets a new point."""
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    def GetPoint(self) -> "ICrdnPoint":
        """Returns the actual point object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, point:"ICrdnPoint") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_point.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B553DE32-05C9-4944-918A-90552E039DBE}", ICrdnPointRefTo)
agcls.AgTypeNameMap["ICrdnPointRefTo"] = ICrdnPointRefTo

class ICrdnVectorRefTo(object):
    """Represents a reference to a VGT vector."""
    _uuid = "{EDF2E070-340E-456C-BDA8-BE9B9B40E728}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorRefTo = agcom.GUID(ICrdnVectorRefTo._uuid)
        vtable_offset_local = ICrdnVectorRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorRefTo.__dict__ and type(ICrdnVectorRefTo.__dict__[attrname]) == property:
            return ICrdnVectorRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new vector."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetVector(self, vector:"ICrdnVector") -> None:
        """Sets a new vector."""
        with agmarshall.AgInterface_in_arg(vector, ICrdnVector) as arg_vector:
            agcls.evaluate_hresult(self.__dict__["_SetVector"](arg_vector.COM_val))

    def GetVector(self) -> "ICrdnVector":
        """Returns the actual vector object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, vector:"ICrdnVector") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(vector, ICrdnVector) as arg_vector, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_vector.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EDF2E070-340E-456C-BDA8-BE9B9B40E728}", ICrdnVectorRefTo)
agcls.AgTypeNameMap["ICrdnVectorRefTo"] = ICrdnVectorRefTo

class ICrdnAxesRefTo(object):
    """Represents a reference to a VGT axes."""
    _uuid = "{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesRefTo = agcom.GUID(ICrdnAxesRefTo._uuid)
        vtable_offset_local = ICrdnAxesRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesRefTo.__dict__ and type(ICrdnAxesRefTo.__dict__[attrname]) == property:
            return ICrdnAxesRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new axes."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAxes(self, axes:"ICrdnAxes") -> None:
        """Sets a new axes."""
        with agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes:
            agcls.evaluate_hresult(self.__dict__["_SetAxes"](arg_axes.COM_val))

    def GetAxes(self) -> "ICrdnAxes":
        """Returns the actual axes object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, axes:"ICrdnAxes") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_axes.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}", ICrdnAxesRefTo)
agcls.AgTypeNameMap["ICrdnAxesRefTo"] = ICrdnAxesRefTo

class ICrdnAngleRefTo(object):
    """Represents a reference to a VGT angle."""
    _uuid = "{7A9D809F-D819-4458-9855-2DA8507F6E57}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleRefTo = agcom.GUID(ICrdnAngleRefTo._uuid)
        vtable_offset_local = ICrdnAngleRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleRefTo.__dict__ and type(ICrdnAngleRefTo.__dict__[attrname]) == property:
            return ICrdnAngleRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new angle."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetAngle(self, angle:"ICrdnAngle") -> None:
        """Sets a new angle."""
        with agmarshall.AgInterface_in_arg(angle, ICrdnAngle) as arg_angle:
            agcls.evaluate_hresult(self.__dict__["_SetAngle"](arg_angle.COM_val))

    def GetAngle(self) -> "ICrdnAngle":
        """Returns the actual angle object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, angle:"ICrdnAngle") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(angle, ICrdnAngle) as arg_angle, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_angle.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7A9D809F-D819-4458-9855-2DA8507F6E57}", ICrdnAngleRefTo)
agcls.AgTypeNameMap["ICrdnAngleRefTo"] = ICrdnAngleRefTo

class ICrdnSystemRefTo(object):
    """Represents a reference to a VGT system."""
    _uuid = "{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSystem"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemRefTo = agcom.GUID(ICrdnSystemRefTo._uuid)
        vtable_offset_local = ICrdnSystemRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemRefTo.__dict__ and type(ICrdnSystemRefTo.__dict__[attrname]) == property:
            return ICrdnSystemRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new system."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetSystem(self, system:"ICrdnSystem") -> None:
        """Sets a new system."""
        with agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system:
            agcls.evaluate_hresult(self.__dict__["_SetSystem"](arg_system.COM_val))

    def GetSystem(self) -> "ICrdnSystem":
        """Returns the actual system object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, system:"ICrdnSystem") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(system, ICrdnSystem) as arg_system, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_system.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}", ICrdnSystemRefTo)
agcls.AgTypeNameMap["ICrdnSystemRefTo"] = ICrdnSystemRefTo

class ICrdnPlaneRefTo(object):
    """Represents a reference to a VGT plane."""
    _uuid = "{CE3D70F2-61E0-4A23-803F-A734005DC36D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetPlane"] = _raise_uninitialized_error
        self.__dict__["_GetPlane"] = _raise_uninitialized_error
        self.__dict__["_HasCyclicDependency"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneRefTo = agcom.GUID(ICrdnPlaneRefTo._uuid)
        vtable_offset_local = ICrdnPlaneRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetPlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_HasCyclicDependency"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneRefTo, vtable_offset_local+4, agcom.PVOID, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneRefTo.__dict__ and type(ICrdnPlaneRefTo.__dict__[attrname]) == property:
            return ICrdnPlaneRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new plane using a specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetPlane(self, plane:"ICrdnPlane") -> None:
        """Sets a new plane."""
        with agmarshall.AgInterface_in_arg(plane, ICrdnPlane) as arg_plane:
            agcls.evaluate_hresult(self.__dict__["_SetPlane"](arg_plane.COM_val))

    def GetPlane(self) -> "ICrdnPlane":
        """Returns the actual plane object behind the reference. Use IAgCrdn.IsValid to test the validity of the returned object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def HasCyclicDependency(self, plane:"ICrdnPlane") -> bool:
        """Tests whether the input component and the target component form a cyclic dependency."""
        with agmarshall.AgInterface_in_arg(plane, ICrdnPlane) as arg_plane, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_HasCyclicDependency"](arg_plane.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CE3D70F2-61E0-4A23-803F-A734005DC36D}", ICrdnPlaneRefTo)
agcls.AgTypeNameMap["ICrdnPlaneRefTo"] = ICrdnPlaneRefTo

class ICrdnAxesLabels(object):
    """Allows configuring the VGT axes labels."""
    _uuid = "{0CD79528-D932-4473-9CC4-0BF5C936A6CD}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLabelX"] = _raise_uninitialized_error
        self.__dict__["_SetLabelX"] = _raise_uninitialized_error
        self.__dict__["_GetLabelY"] = _raise_uninitialized_error
        self.__dict__["_SetLabelY"] = _raise_uninitialized_error
        self.__dict__["_GetLabelZ"] = _raise_uninitialized_error
        self.__dict__["_SetLabelZ"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesLabels = agcom.GUID(ICrdnAxesLabels._uuid)
        vtable_offset_local = ICrdnAxesLabels._vtable_offset - 1
        self.__dict__["_GetLabelX"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelX"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetLabelY"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelY"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetLabelZ"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetLabelZ"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLabels, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesLabels.__dict__ and type(ICrdnAxesLabels.__dict__[attrname]) == property:
            return ICrdnAxesLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesLabels.")
    
    @property
    def LabelX(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelX"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelX.setter
    def LabelX(self, labelX:str) -> None:
        with agmarshall.BSTR_arg(labelX) as arg_labelX:
            agcls.evaluate_hresult(self.__dict__["_SetLabelX"](arg_labelX.COM_val))

    @property
    def LabelY(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelY"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelY.setter
    def LabelY(self, labelY:str) -> None:
        with agmarshall.BSTR_arg(labelY) as arg_labelY:
            agcls.evaluate_hresult(self.__dict__["_SetLabelY"](arg_labelY.COM_val))

    @property
    def LabelZ(self) -> str:
        """Specify a Z axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLabelZ"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @LabelZ.setter
    def LabelZ(self, labelZ:str) -> None:
        with agmarshall.BSTR_arg(labelZ) as arg_labelZ:
            agcls.evaluate_hresult(self.__dict__["_SetLabelZ"](arg_labelZ.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0CD79528-D932-4473-9CC4-0BF5C936A6CD}", ICrdnAxesLabels)
agcls.AgTypeNameMap["ICrdnAxesLabels"] = ICrdnAxesLabels

class ICrdnPlaneLabels(object):
    """Allows configuring the X and Y axes labels."""
    _uuid = "{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetXAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisLabel"] = _raise_uninitialized_error
        self.__dict__["_SetYAxisLabel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneLabels._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneLabels from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneLabels = agcom.GUID(ICrdnPlaneLabels._uuid)
        vtable_offset_local = ICrdnPlaneLabels._vtable_offset - 1
        self.__dict__["_GetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneLabels, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetXAxisLabel"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneLabels, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneLabels, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetYAxisLabel"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneLabels, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneLabels.__dict__ and type(ICrdnPlaneLabels.__dict__[attrname]) == property:
            return ICrdnPlaneLabels.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneLabels.")
    
    @property
    def XAxisLabel(self) -> str:
        """Specify an X axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @XAxisLabel.setter
    def XAxisLabel(self, xAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(xAxisLabel) as arg_xAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetXAxisLabel"](arg_xAxisLabel.COM_val))

    @property
    def YAxisLabel(self) -> str:
        """Specify a Y axis label."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisLabel"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxisLabel.setter
    def YAxisLabel(self, yAxisLabel:str) -> None:
        with agmarshall.BSTR_arg(yAxisLabel) as arg_yAxisLabel:
            agcls.evaluate_hresult(self.__dict__["_SetYAxisLabel"](arg_yAxisLabel.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}", ICrdnPlaneLabels)
agcls.AgTypeNameMap["ICrdnPlaneLabels"] = ICrdnPlaneLabels

class ICrdnAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    _uuid = "{19991E4F-F368-41CD-AE27-96CF11EC963F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAlignmentReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlignmentDirection"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesAlignedAndConstrained._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesAlignedAndConstrained from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesAlignedAndConstrained = agcom.GUID(ICrdnAxesAlignedAndConstrained._uuid)
        vtable_offset_local = ICrdnAxesAlignedAndConstrained._vtable_offset - 1
        self.__dict__["_GetAlignmentReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAlignedAndConstrained, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAlignedAndConstrained, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAlignmentDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAlignedAndConstrained, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetConstraintDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAlignedAndConstrained, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesAlignedAndConstrained.__dict__ and type(ICrdnAxesAlignedAndConstrained.__dict__[attrname]) == property:
            return ICrdnAxesAlignedAndConstrained.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesAlignedAndConstrained.")
    
    @property
    def AlignmentReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify an alignment reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a constraint reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AlignmentDirection(self) -> "IDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlignmentDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ConstraintDirection(self) -> "IDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{19991E4F-F368-41CD-AE27-96CF11EC963F}", ICrdnAxesAlignedAndConstrained)
agcls.AgTypeNameMap["ICrdnAxesAlignedAndConstrained"] = ICrdnAxesAlignedAndConstrained

class ICrdnAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    _uuid = "{0096F935-281A-4EC9-92A4-7400BD2DEF60}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetRotationAngle"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOffsetAngle"] = _raise_uninitialized_error
        self.__dict__["_SetFixedOffsetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesAngularOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesAngularOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesAngularOffset = agcom.GUID(ICrdnAxesAngularOffset._uuid)
        vtable_offset_local = ICrdnAxesAngularOffset._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAngularOffset, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAngularOffset, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAngularOffset, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAngularOffset, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFixedOffsetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAngularOffset, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesAngularOffset.__dict__ and type(ICrdnAxesAngularOffset.__dict__[attrname]) == property:
            return ICrdnAxesAngularOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesAngularOffset.")
    
    @property
    def SpinVector(self) -> "ICrdnVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationAngle(self) -> "ICrdnAngleRefTo":
        """Specify a rotational angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOffsetAngle(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOffsetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @FixedOffsetAngle.setter
    def FixedOffsetAngle(self, fixedOffsetAngle:float) -> None:
        with agmarshall.DOUBLE_arg(fixedOffsetAngle) as arg_fixedOffsetAngle:
            agcls.evaluate_hresult(self.__dict__["_SetFixedOffsetAngle"](arg_fixedOffsetAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0096F935-281A-4EC9-92A4-7400BD2DEF60}", ICrdnAxesAngularOffset)
agcls.AgTypeNameMap["ICrdnAxesAngularOffset"] = ICrdnAxesAngularOffset

class ICrdnAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""
    _uuid = "{CEB9E066-A9F8-4B74-AF7A-0301BF611843}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesFixedAtEpoch = agcom.GUID(ICrdnAxesFixedAtEpoch._uuid)
        vtable_offset_local = ICrdnAxesFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixedAtEpoch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixedAtEpoch, vtable_offset_local+4, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesFixedAtEpoch.__dict__ and type(ICrdnAxesFixedAtEpoch.__dict__[attrname]) == property:
            return ICrdnAxesFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesFixedAtEpoch.")
    
    @property
    def SourceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a source axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CEB9E066-A9F8-4B74-AF7A-0301BF611843}", ICrdnAxesFixedAtEpoch)
agcls.AgTypeNameMap["ICrdnAxesFixedAtEpoch"] = ICrdnAxesFixedAtEpoch

class ICrdnAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""
    _uuid = "{72FD97D1-AE64-45D2-973E-E4F491B474AC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesBPlane = agcom.GUID(ICrdnAxesBPlane._uuid)
        vtable_offset_local = ICrdnAxesBPlane._vtable_offset - 1
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesBPlane, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesBPlane, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesBPlane, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesBPlane.__dict__ and type(ICrdnAxesBPlane.__dict__[attrname]) == property:
            return ICrdnAxesBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesBPlane.")
    
    @property
    def Trajectory(self) -> "ICrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72FD97D1-AE64-45D2-973E-E4F491B474AC}", ICrdnAxesBPlane)
agcls.AgTypeNameMap["ICrdnAxesBPlane"] = ICrdnAxesBPlane

class ICrdnAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""
    _uuid = "{F5A690E6-0304-49E0-BAB5-229F848B0401}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesCustomScript = agcom.GUID(ICrdnAxesCustomScript._uuid)
        vtable_offset_local = ICrdnAxesCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCustomScript, vtable_offset_local+3, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesCustomScript.__dict__ and type(ICrdnAxesCustomScript.__dict__[attrname]) == property:
            return ICrdnAxesCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Filename(self) -> str:
        """Can be MATLAB (.m or .dll), VB Script (.vbs) or Perl (.pl) script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F5A690E6-0304-49E0-BAB5-229F848B0401}", ICrdnAxesCustomScript)
agcls.AgTypeNameMap["ICrdnAxesCustomScript"] = ICrdnAxesCustomScript

class ICrdnAxesAttitudeFile(object):
    """Axes specified by data from a file."""
    _uuid = "{E4A194BD-44ED-498F-ACB2-9911C19F52E8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesAttitudeFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesAttitudeFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesAttitudeFile = agcom.GUID(ICrdnAxesAttitudeFile._uuid)
        vtable_offset_local = ICrdnAxesAttitudeFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAttitudeFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAttitudeFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesAttitudeFile.__dict__ and type(ICrdnAxesAttitudeFile.__dict__[attrname]) == property:
            return ICrdnAxesAttitudeFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesAttitudeFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E4A194BD-44ED-498F-ACB2-9911C19F52E8}", ICrdnAxesAttitudeFile)
agcls.AgTypeNameMap["ICrdnAxesAttitudeFile"] = ICrdnAxesAttitudeFile

class ICrdnAxesFixed(object):
    """Axes fixed in reference axes."""
    _uuid = "{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetFixedOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFixed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesFixed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesFixed = agcom.GUID(ICrdnAxesFixed._uuid)
        vtable_offset_local = ICrdnAxesFixed._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixed, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedOrientation"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFixed, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesFixed.__dict__ and type(ICrdnAxesFixed.__dict__[attrname]) == property:
            return ICrdnAxesFixed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesFixed.")
    
    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedOrientation(self) -> "IOrientation":
        """Specify a desired orientation and the applicable parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}", ICrdnAxesFixed)
agcls.AgTypeNameMap["ICrdnAxesFixed"] = ICrdnAxesFixed

class ICrdnAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{3A20DEC4-2D89-416C-8B47-D76E859763B0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesModelAttach = agcom.GUID(ICrdnAxesModelAttach._uuid)
        vtable_offset_local = ICrdnAxesModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesModelAttach.__dict__ and type(ICrdnAxesModelAttach.__dict__[attrname]) == property:
            return ICrdnAxesModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A20DEC4-2D89-416C-8B47-D76E859763B0}", ICrdnAxesModelAttach)
agcls.AgTypeNameMap["ICrdnAxesModelAttach"] = ICrdnAxesModelAttach

class ICrdnAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    _uuid = "{ECB36015-B534-40C6-B50F-298217335C38}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSpinVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_SetInitialOffset"] = _raise_uninitialized_error
        self.__dict__["_GetSpinRate"] = _raise_uninitialized_error
        self.__dict__["_SetSpinRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesSpinning._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesSpinning from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesSpinning = agcom.GUID(ICrdnAxesSpinning._uuid)
        vtable_offset_local = ICrdnAxesSpinning._vtable_offset - 1
        self.__dict__["_GetSpinVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetSpinRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSpinRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSpinning, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesSpinning.__dict__ and type(ICrdnAxesSpinning.__dict__[attrname]) == property:
            return ICrdnAxesSpinning.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesSpinning.")
    
    @property
    def SpinVector(self) -> "ICrdnVectorRefTo":
        """Specify a spin vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def InitialOffset(self) -> float:
        """Specify an additional rotational offset."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitialOffset.setter
    def InitialOffset(self, initialOffset:float) -> None:
        with agmarshall.DOUBLE_arg(initialOffset) as arg_initialOffset:
            agcls.evaluate_hresult(self.__dict__["_SetInitialOffset"](arg_initialOffset.COM_val))

    @property
    def SpinRate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpinRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SpinRate.setter
    def SpinRate(self, spinRate:float) -> None:
        with agmarshall.DOUBLE_arg(spinRate) as arg_spinRate:
            agcls.evaluate_hresult(self.__dict__["_SetSpinRate"](arg_spinRate.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ECB36015-B534-40C6-B50F-298217335C38}", ICrdnAxesSpinning)
agcls.AgTypeNameMap["ICrdnAxesSpinning"] = ICrdnAxesSpinning

class ICrdnAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""
    _uuid = "{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesOnSurface = agcom.GUID(ICrdnAxesOnSurface._uuid)
        vtable_offset_local = ICrdnAxesOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesOnSurface, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesOnSurface, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesOnSurface.__dict__ and type(ICrdnAxesOnSurface.__dict__[attrname]) == property:
            return ICrdnAxesOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesOnSurface.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseMSL(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}", ICrdnAxesOnSurface)
agcls.AgTypeNameMap["ICrdnAxesOnSurface"] = ICrdnAxesOnSurface

class ICrdnAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    _uuid = "{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrajectoryPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectoryAxesType"] = _raise_uninitialized_error
        self.__dict__["_SetTrajectoryAxesType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesTrajectory = agcom.GUID(ICrdnAxesTrajectory._uuid)
        vtable_offset_local = ICrdnAxesTrajectory._vtable_offset - 1
        self.__dict__["_GetTrajectoryPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTrajectory, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetTrajectoryAxesType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTrajectory, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesTrajectory.__dict__ and type(ICrdnAxesTrajectory.__dict__[attrname]) == property:
            return ICrdnAxesTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesTrajectory.")
    
    @property
    def TrajectoryPoint(self) -> "ICrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "ICrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TrajectoryAxesType(self) -> "AgECrdnTrajectoryAxesType":
        """Specify a type of the trajectory's coordinate frame."""
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectoryAxesType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TrajectoryAxesType.setter
    def TrajectoryAxesType(self, trajectoryAxesType:"AgECrdnTrajectoryAxesType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnTrajectoryAxesType, trajectoryAxesType) as arg_trajectoryAxesType:
            agcls.evaluate_hresult(self.__dict__["_SetTrajectoryAxesType"](arg_trajectoryAxesType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}", ICrdnAxesTrajectory)
agcls.AgTypeNameMap["ICrdnAxesTrajectory"] = ICrdnAxesTrajectory

class ICrdnAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    _uuid = "{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPrimaryCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesLagrangeLibration = agcom.GUID(ICrdnAxesLagrangeLibration._uuid)
        vtable_offset_local = ICrdnAxesLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetPrimaryCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesLagrangeLibration.__dict__ and type(ICrdnAxesLagrangeLibration.__dict__[attrname]) == property:
            return ICrdnAxesLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesLagrangeLibration.")
    
    @property
    def PrimaryCentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a primary central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPrimaryCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "ICrdnCentralBodyCollection":
        """Specify secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}", ICrdnAxesLagrangeLibration)
agcls.AgTypeNameMap["ICrdnAxesLagrangeLibration"] = ICrdnAxesLagrangeLibration

class ICrdnAxesCommonTasks(object):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateTopocentricAxesQuaternion"] = _raise_uninitialized_error
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = _raise_uninitialized_error
        self.__dict__["_CreateFixed"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesCommonTasks = agcom.GUID(ICrdnAxesCommonTasks._uuid)
        vtable_offset_local = ICrdnAxesCommonTasks._vtable_offset - 1
        self.__dict__["_CreateTopocentricAxesQuaternion"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateTopocentricAxesEulerAngles"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCommonTasks, vtable_offset_local+3, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesCommonTasks, vtable_offset_local+4, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesCommonTasks.__dict__ and type(ICrdnAxesCommonTasks.__dict__[attrname]) == property:
            return ICrdnAxesCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesCommonTasks.")
    
    def CreateTopocentricAxesQuaternion(self, originPoint:"ICrdnPoint", qx:float, qy:float, qz:float, qs:float) -> "ICrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, ICrdnPoint) as arg_originPoint, \
             agmarshall.DOUBLE_arg(qx) as arg_qx, \
             agmarshall.DOUBLE_arg(qy) as arg_qy, \
             agmarshall.DOUBLE_arg(qz) as arg_qz, \
             agmarshall.DOUBLE_arg(qs) as arg_qs, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesQuaternion"](arg_originPoint.COM_val, arg_qx.COM_val, arg_qy.COM_val, arg_qz.COM_val, arg_qs.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateTopocentricAxesEulerAngles(self, originPoint:"ICrdnPoint", sequence:"AgEEulerOrientationSequence", a:typing.Any, b:typing.Any, c:typing.Any) -> "ICrdnAxesFixed":
        """Creates non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        with agmarshall.AgInterface_in_arg(originPoint, ICrdnPoint) as arg_originPoint, \
             agmarshall.AgEnum_arg(AgEEulerOrientationSequence, sequence) as arg_sequence, \
             agmarshall.VARIANT_arg(a) as arg_a, \
             agmarshall.VARIANT_arg(b) as arg_b, \
             agmarshall.VARIANT_arg(c) as arg_c, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateTopocentricAxesEulerAngles"](arg_originPoint.COM_val, arg_sequence.COM_val, arg_a.COM_val, arg_b.COM_val, arg_c.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixed(self, referenceAxes:"ICrdnAxes") -> "ICrdnAxesFixed":
        """Creates non-persistent fixed axes based on specified axes."""
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixed"](arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, axes:"ICrdnAxes", referenceAxes:"ICrdnAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "ICrdnAxesSamplingResult":
        """Computes and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(axes, ICrdnAxes) as arg_axes, \
             agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_axes.COM_val, arg_referenceAxes.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}", ICrdnAxesCommonTasks)
agcls.AgTypeNameMap["ICrdnAxesCommonTasks"] = ICrdnAxesCommonTasks

class ICrdnAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    _uuid = "{193F4A55-5E79-43A1-8A2C-3C001F7608A5}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetSourceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesAtTimeInstant = agcom.GUID(ICrdnAxesAtTimeInstant._uuid)
        vtable_offset_local = ICrdnAxesAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesAtTimeInstant.__dict__ and type(ICrdnAxesAtTimeInstant.__dict__[attrname]) == property:
            return ICrdnAxesAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceAxes(self) -> "ICrdnAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceAxes.setter
    def SourceAxes(self, sourceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(sourceAxes, ICrdnAxes) as arg_sourceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetSourceAxes"](arg_sourceAxes.COM_val))

    @property
    def ReferenceAxes(self) -> "ICrdnAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{193F4A55-5E79-43A1-8A2C-3C001F7608A5}", ICrdnAxesAtTimeInstant)
agcls.AgTypeNameMap["ICrdnAxesAtTimeInstant"] = ICrdnAxesAtTimeInstant

class ICrdnAxesPlugin(object):
    """A VGT axes plugin."""
    _uuid = "{E63FD5E1-B844-4893-9E4C-3F02210AE74C}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesPlugin = agcom.GUID(ICrdnAxesPlugin._uuid)
        vtable_offset_local = ICrdnAxesPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesPlugin.__dict__ and type(ICrdnAxesPlugin.__dict__[attrname]) == property:
            return ICrdnAxesPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E63FD5E1-B844-4893-9E4C-3F02210AE74C}", ICrdnAxesPlugin)
agcls.AgTypeNameMap["ICrdnAxesPlugin"] = ICrdnAxesPlugin

class ICrdnAngleBetweenVectors(object):
    """An angle between two vectors."""
    _uuid = "{B3986E8E-A8CB-414F-8214-71C53ED00740}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleBetweenVectors._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleBetweenVectors from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleBetweenVectors = agcom.GUID(ICrdnAngleBetweenVectors._uuid)
        vtable_offset_local = ICrdnAngleBetweenVectors._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleBetweenVectors, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleBetweenVectors, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleBetweenVectors.__dict__ and type(ICrdnAngleBetweenVectors.__dict__[attrname]) == property:
            return ICrdnAngleBetweenVectors.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleBetweenVectors.")
    
    @property
    def FromVector(self) -> "ICrdnVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "ICrdnVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3986E8E-A8CB-414F-8214-71C53ED00740}", ICrdnAngleBetweenVectors)
agcls.AgTypeNameMap["ICrdnAngleBetweenVectors"] = ICrdnAngleBetweenVectors

class ICrdnAngleBetweenPlanes(object):
    """An angle between two planes."""
    _uuid = "{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromPlane"] = _raise_uninitialized_error
        self.__dict__["_GetToPlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleBetweenPlanes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleBetweenPlanes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleBetweenPlanes = agcom.GUID(ICrdnAngleBetweenPlanes._uuid)
        vtable_offset_local = ICrdnAngleBetweenPlanes._vtable_offset - 1
        self.__dict__["_GetFromPlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleBetweenPlanes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToPlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleBetweenPlanes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleBetweenPlanes.__dict__ and type(ICrdnAngleBetweenPlanes.__dict__[attrname]) == property:
            return ICrdnAngleBetweenPlanes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleBetweenPlanes.")
    
    @property
    def FromPlane(self) -> "ICrdnPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToPlane(self) -> "ICrdnPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToPlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}", ICrdnAngleBetweenPlanes)
agcls.AgTypeNameMap["ICrdnAngleBetweenPlanes"] = ICrdnAngleBetweenPlanes

class ICrdnAngleDihedral(object):
    """An angle between two vectors about an axis."""
    _uuid = "{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromVector"] = _raise_uninitialized_error
        self.__dict__["_GetToVector"] = _raise_uninitialized_error
        self.__dict__["_GetPoleAbout"] = _raise_uninitialized_error
        self.__dict__["_GetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_SetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_GetSignedAngle"] = _raise_uninitialized_error
        self.__dict__["_SetSignedAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleDihedral._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleDihedral from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleDihedral = agcom.GUID(ICrdnAngleDihedral._uuid)
        vtable_offset_local = ICrdnAngleDihedral._vtable_offset - 1
        self.__dict__["_GetFromVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPoleAbout"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSignedAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleDihedral, vtable_offset_local+7, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleDihedral.__dict__ and type(ICrdnAngleDihedral.__dict__[attrname]) == property:
            return ICrdnAngleDihedral.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleDihedral.")
    
    @property
    def FromVector(self) -> "ICrdnVectorRefTo":
        """Specify a first vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToVector(self) -> "ICrdnVectorRefTo":
        """Specify a second vector to measure the angle."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PoleAbout(self) -> "ICrdnVectorRefTo":
        """Specify a vector about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoleAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CounterClockwiseRotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCounterClockwiseRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, counterClockwiseRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(counterClockwiseRotation) as arg_counterClockwiseRotation:
            agcls.evaluate_hresult(self.__dict__["_SetCounterClockwiseRotation"](arg_counterClockwiseRotation.COM_val))

    @property
    def SignedAngle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignedAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignedAngle.setter
    def SignedAngle(self, signedAngle:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(signedAngle) as arg_signedAngle:
            agcls.evaluate_hresult(self.__dict__["_SetSignedAngle"](arg_signedAngle.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}", ICrdnAngleDihedral)
agcls.AgTypeNameMap["ICrdnAngleDihedral"] = ICrdnAngleDihedral

class ICrdnAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    _uuid = "{9E842F77-B3A8-475C-96AA-E692B35E8E05}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFromAxes"] = _raise_uninitialized_error
        self.__dict__["_GetToAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDirection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleRotation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleRotation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleRotation = agcom.GUID(ICrdnAngleRotation._uuid)
        vtable_offset_local = ICrdnAngleRotation._vtable_offset - 1
        self.__dict__["_GetFromAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRotation, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetToAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRotation, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRotation, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleRotation, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleRotation.__dict__ and type(ICrdnAngleRotation.__dict__[attrname]) == property:
            return ICrdnAngleRotation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleRotation.")
    
    @property
    def FromAxes(self) -> "ICrdnAxesRefTo":
        """Specify an axes to rotate from."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFromAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ToAxes(self) -> "ICrdnAxesRefTo":
        """Specify an axes to rotate to."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetToAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceDirection(self) -> "AgECrdnDisplayAxisSelector":
        """Specify a rotation direction."""
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, referenceDirection:"AgECrdnDisplayAxisSelector") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDisplayAxisSelector, referenceDirection) as arg_referenceDirection:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDirection"](arg_referenceDirection.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9E842F77-B3A8-475C-96AA-E692B35E8E05}", ICrdnAngleRotation)
agcls.AgTypeNameMap["ICrdnAngleRotation"] = ICrdnAngleRotation

class ICrdnAngleToPlane(object):
    """An angle between a vector and a plane."""
    _uuid = "{DDFA25AD-174D-407B-B90C-747B3E43F7C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetSigned"] = _raise_uninitialized_error
        self.__dict__["_SetSigned"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleToPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleToPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleToPlane = agcom.GUID(ICrdnAngleToPlane._uuid)
        vtable_offset_local = ICrdnAngleToPlane._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleToPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleToPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetSigned"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleToPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSigned"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleToPlane, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleToPlane.__dict__ and type(ICrdnAngleToPlane.__dict__[attrname]) == property:
            return ICrdnAngleToPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleToPlane.")
    
    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "ICrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Signed(self) -> "AgECrdnSignedAngleType":
        """Controls whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSigned"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Signed.setter
    def Signed(self, signed:"AgECrdnSignedAngleType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignedAngleType, signed) as arg_signed:
            agcls.evaluate_hresult(self.__dict__["_SetSigned"](arg_signed.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DDFA25AD-174D-407B-B90C-747B3E43F7C9}", ICrdnAngleToPlane)
agcls.AgTypeNameMap["ICrdnAngleToPlane"] = ICrdnAngleToPlane

class ICrdnPlaneNormal(object):
    """A plane normal to a vector at a given point."""
    _uuid = "{AAF66E5C-B310-4387-BDAE-D45F24F226BC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneNormal = agcom.GUID(ICrdnPlaneNormal._uuid)
        vtable_offset_local = ICrdnPlaneNormal._vtable_offset - 1
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneNormal, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneNormal.__dict__ and type(ICrdnPlaneNormal.__dict__[attrname]) == property:
            return ICrdnPlaneNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneNormal.")
    
    @property
    def NormalVector(self) -> "ICrdnVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{AAF66E5C-B310-4387-BDAE-D45F24F226BC}", ICrdnPlaneNormal)
agcls.AgTypeNameMap["ICrdnPlaneNormal"] = ICrdnPlaneNormal

class ICrdnPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""
    _uuid = "{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetQuadrant"] = _raise_uninitialized_error
        self.__dict__["_SetQuadrant"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneQuadrant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneQuadrant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneQuadrant = agcom.GUID(ICrdnPlaneQuadrant._uuid)
        vtable_offset_local = ICrdnPlaneQuadrant._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneQuadrant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetQuadrant"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneQuadrant, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetQuadrant"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneQuadrant, vtable_offset_local+3, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneQuadrant.__dict__ and type(ICrdnPlaneQuadrant.__dict__[attrname]) == property:
            return ICrdnPlaneQuadrant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneQuadrant.")
    
    @property
    def ReferenceSystem(self) -> "ICrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quadrant(self) -> "AgECrdnQuadrantType":
        """Specify a quadrant."""
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuadrant"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Quadrant.setter
    def Quadrant(self, quadrant:"AgECrdnQuadrantType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnQuadrantType, quadrant) as arg_quadrant:
            agcls.evaluate_hresult(self.__dict__["_SetQuadrant"](arg_quadrant.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}", ICrdnPlaneQuadrant)
agcls.AgTypeNameMap["ICrdnPlaneQuadrant"] = ICrdnPlaneQuadrant

class ICrdnPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    _uuid = "{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneTrajectory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneTrajectory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneTrajectory = agcom.GUID(ICrdnPlaneTrajectory._uuid)
        vtable_offset_local = ICrdnPlaneTrajectory._vtable_offset - 1
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTrajectory, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTrajectory, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTrajectory, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTrajectory, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneTrajectory.__dict__ and type(ICrdnPlaneTrajectory.__dict__[attrname]) == property:
            return ICrdnPlaneTrajectory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneTrajectory.")
    
    @property
    def Point(self) -> "ICrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceSystem(self) -> "ICrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}", ICrdnPlaneTrajectory)
agcls.AgTypeNameMap["ICrdnPlaneTrajectory"] = ICrdnPlaneTrajectory

class ICrdnPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""
    _uuid = "{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointA"] = _raise_uninitialized_error
        self.__dict__["_GetPointB"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneTriad._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneTriad from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneTriad = agcom.GUID(ICrdnPlaneTriad._uuid)
        vtable_offset_local = ICrdnPlaneTriad._vtable_offset - 1
        self.__dict__["_GetPointA"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTriad, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointB"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTriad, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTriad, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTriad, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTriad, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneTriad.__dict__ and type(ICrdnPlaneTriad.__dict__[attrname]) == property:
            return ICrdnPlaneTriad.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneTriad.")
    
    @property
    def PointA(self) -> "ICrdnPointRefTo":
        """Specify a point A."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointB(self) -> "ICrdnPointRefTo":
        """Specify a point B."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RotationOffset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, rotationOffset:float) -> None:
        with agmarshall.DOUBLE_arg(rotationOffset) as arg_rotationOffset:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_rotationOffset.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}", ICrdnPlaneTriad)
agcls.AgTypeNameMap["ICrdnPlaneTriad"] = ICrdnPlaneTriad

class ICrdnPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""
    _uuid = "{345761f0-0ace-494c-8d9c-0f3e3af9c2da}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetVector2"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneTwoVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneTwoVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneTwoVector = agcom.GUID(ICrdnPlaneTwoVector._uuid)
        vtable_offset_local = ICrdnPlaneTwoVector._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTwoVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetVector2"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTwoVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneTwoVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneTwoVector.__dict__ and type(ICrdnPlaneTwoVector.__dict__[attrname]) == property:
            return ICrdnPlaneTwoVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneTwoVector.")
    
    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Vector2(self) -> "ICrdnVectorRefTo":
        """Specify a Normal vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector2"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{345761f0-0ace-494c-8d9c-0f3e3af9c2da}", ICrdnPlaneTwoVector)
agcls.AgTypeNameMap["ICrdnPlaneTwoVector"] = ICrdnPlaneTwoVector

class ICrdnPointBPlane(object):
    """B-Plane point using the selected target body."""
    _uuid = "{CC3B797F-5327-4D04-911D-8ED499E056AF}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBody"] = _raise_uninitialized_error
        self.__dict__["_GetTrajectory"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointBPlane = agcom.GUID(ICrdnPointBPlane._uuid)
        vtable_offset_local = ICrdnPointBPlane._vtable_offset - 1
        self.__dict__["_GetTargetBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTrajectory"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointBPlane, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointBPlane.__dict__ and type(ICrdnPointBPlane.__dict__[attrname]) == property:
            return ICrdnPointBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointBPlane.")
    
    @property
    def TargetBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a target central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Trajectory(self) -> "ICrdnPointRefTo":
        """Specify a trajectory point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrajectory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnPointBPlaneType":
        """Specify a point type."""
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnPointBPlaneType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnPointBPlaneType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def Direction(self) -> "AgECrdnDirectionType":
        """Specify a direction (incoming or outgoing)."""
        with agmarshall.AgEnum_arg(AgECrdnDirectionType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Direction.setter
    def Direction(self, direction:"AgECrdnDirectionType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDirectionType, direction) as arg_direction:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_direction.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC3B797F-5327-4D04-911D-8ED499E056AF}", ICrdnPointBPlane)
agcls.AgTypeNameMap["ICrdnPointBPlane"] = ICrdnPointBPlane

class ICrdnPointFile(object):
    """Point specified by data from a file."""
    _uuid = "{9612277C-2238-42BD-89D7-E54D7701D8F2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointFile = agcom.GUID(ICrdnPointFile._uuid)
        vtable_offset_local = ICrdnPointFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointFile.__dict__ and type(ICrdnPointFile.__dict__[attrname]) == property:
            return ICrdnPointFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointFile.")
    
    @property
    def Filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Filename.setter
    def Filename(self, filename:str) -> None:
        with agmarshall.BSTR_arg(filename) as arg_filename:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_filename.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9612277C-2238-42BD-89D7-E54D7701D8F2}", ICrdnPointFile)
agcls.AgTypeNameMap["ICrdnPointFile"] = ICrdnPointFile

class ICrdnPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    _uuid = "{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetFixedPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointFixedInSystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointFixedInSystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointFixedInSystem = agcom.GUID(ICrdnPointFixedInSystem._uuid)
        vtable_offset_local = ICrdnPointFixedInSystem._vtable_offset - 1
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFixedInSystem, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetFixedPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFixedInSystem, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointFixedInSystem.__dict__ and type(ICrdnPointFixedInSystem.__dict__[attrname]) == property:
            return ICrdnPointFixedInSystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointFixedInSystem.")
    
    @property
    def Reference(self) -> "ICrdnSystemRefTo":
        """Specify a reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FixedPoint(self) -> "IPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}", ICrdnPointFixedInSystem)
agcls.AgTypeNameMap["ICrdnPointFixedInSystem"] = ICrdnPointFixedInSystem

class ICrdnPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    _uuid = "{7FDF037E-1367-4590-A330-660EF3442DE1}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointGrazing = agcom.GUID(ICrdnPointGrazing._uuid)
        vtable_offset_local = ICrdnPointGrazing._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGrazing, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGrazing, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGrazing, vtable_offset_local+5, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointGrazing.__dict__ and type(ICrdnPointGrazing.__dict__[attrname]) == property:
            return ICrdnPointGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointGrazing.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "ICrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7FDF037E-1367-4590-A330-660EF3442DE1}", ICrdnPointGrazing)
agcls.AgTypeNameMap["ICrdnPointGrazing"] = ICrdnPointGrazing

class ICrdnPointGlint(object):
    """Point on central body surface that reflects from source to observer."""
    _uuid = "{C4168949-A6F2-42B7-8019-671FF808836D}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetObserverPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointGlint._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointGlint from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointGlint = agcom.GUID(ICrdnPointGlint._uuid)
        vtable_offset_local = ICrdnPointGlint._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGlint, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGlint, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetObserverPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGlint, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointGlint.__dict__ and type(ICrdnPointGlint.__dict__[attrname]) == property:
            return ICrdnPointGlint.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointGlint.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SourcePoint(self) -> "ICrdnPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ObserverPoint(self) -> "ICrdnPointRefTo":
        """Specify an observer point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetObserverPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4168949-A6F2-42B7-8019-671FF808836D}", ICrdnPointGlint)
agcls.AgTypeNameMap["ICrdnPointGlint"] = ICrdnPointGlint

class ICrdnPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    _uuid = "{CC9E8B92-77D8-46A9-BD52-3DABB173913D}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetTargetName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetName"] = _raise_uninitialized_error
        self.__dict__["_GetDistance"] = _raise_uninitialized_error
        self.__dict__["_SetDistance"] = _raise_uninitialized_error
        self.__dict__["_GetProbability"] = _raise_uninitialized_error
        self.__dict__["_SetProbability"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetUseProbability"] = _raise_uninitialized_error
        self.__dict__["_SetUseProbability"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointCovarianceGrazing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointCovarianceGrazing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointCovarianceGrazing = agcom.GUID(ICrdnPointCovarianceGrazing._uuid)
        vtable_offset_local = ICrdnPointCovarianceGrazing._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargetName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDistance"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetProbability"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetProbability"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseProbability"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseProbability"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCovarianceGrazing, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointCovarianceGrazing.__dict__ and type(ICrdnPointCovarianceGrazing.__dict__[attrname]) == property:
            return ICrdnPointCovarianceGrazing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointCovarianceGrazing.")
    
    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DirectionVector(self) -> "ICrdnVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TargetName(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @TargetName.setter
    def TargetName(self, targetName:str) -> None:
        with agmarshall.BSTR_arg(targetName) as arg_targetName:
            agcls.evaluate_hresult(self.__dict__["_SetTargetName"](arg_targetName.COM_val))

    @property
    def Distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDistance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Distance.setter
    def Distance(self, distance:float) -> None:
        with agmarshall.DOUBLE_arg(distance) as arg_distance:
            agcls.evaluate_hresult(self.__dict__["_SetDistance"](arg_distance.COM_val))

    @property
    def Probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Probability.setter
    def Probability(self, probability:float) -> None:
        with agmarshall.DOUBLE_arg(probability) as arg_probability:
            agcls.evaluate_hresult(self.__dict__["_SetProbability"](arg_probability.COM_val))

    @property
    def Scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def UseProbability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseProbability"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseProbability.setter
    def UseProbability(self, useProbability:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useProbability) as arg_useProbability:
            agcls.evaluate_hresult(self.__dict__["_SetUseProbability"](arg_useProbability.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CC9E8B92-77D8-46A9-BD52-3DABB173913D}", ICrdnPointCovarianceGrazing)
agcls.AgTypeNameMap["ICrdnPointCovarianceGrazing"] = ICrdnPointCovarianceGrazing

class ICrdnPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""
    _uuid = "{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointPlaneIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointPlaneIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointPlaneIntersection = agcom.GUID(ICrdnPointPlaneIntersection._uuid)
        vtable_offset_local = ICrdnPointPlaneIntersection._vtable_offset - 1
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlaneIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlaneIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlaneIntersection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointPlaneIntersection.__dict__ and type(ICrdnPointPlaneIntersection.__dict__[attrname]) == property:
            return ICrdnPointPlaneIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointPlaneIntersection.")
    
    @property
    def DirectionVector(self) -> "ICrdnVectorRefTo":
        """Specify a direction vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "ICrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginPoint(self) -> "ICrdnPointRefTo":
        """Specify the origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}", ICrdnPointPlaneIntersection)
agcls.AgTypeNameMap["ICrdnPointPlaneIntersection"] = ICrdnPointPlaneIntersection

class ICrdnPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""
    _uuid = "{AED0D41F-BB69-4672-A513-17A43B12873D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceType"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointOnSurface = agcom.GUID(ICrdnPointOnSurface._uuid)
        vtable_offset_local = ICrdnPointOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSurfaceType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointOnSurface, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointOnSurface.__dict__ and type(ICrdnPointOnSurface.__dict__[attrname]) == property:
            return ICrdnPointOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointOnSurface.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Specify a reference shape."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def SurfaceType(self) -> "AgECrdnSurfaceType":
        """Specify a surface type."""
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceType.setter
    def SurfaceType(self, surfaceType:"AgECrdnSurfaceType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSurfaceType, surfaceType) as arg_surfaceType:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceType"](arg_surfaceType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AED0D41F-BB69-4672-A513-17A43B12873D}", ICrdnPointOnSurface)
agcls.AgTypeNameMap["ICrdnPointOnSurface"] = ICrdnPointOnSurface

class ICrdnPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    _uuid = "{CFEB5448-9053-44F6-BCB5-35280361131F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_GetUseScale"] = _raise_uninitialized_error
        self.__dict__["_SetUseScale"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointModelAttach = agcom.GUID(ICrdnPointModelAttach._uuid)
        vtable_offset_local = ICrdnPointModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointModelAttach, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUseScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointModelAttach, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointModelAttach, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointModelAttach.__dict__ and type(ICrdnPointModelAttach.__dict__[attrname]) == property:
            return ICrdnPointModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a model attachment point."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))

    @property
    def UseScale(self) -> bool:
        """Specify whether to use the model scale."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScale.setter
    def UseScale(self, useScale:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScale) as arg_useScale:
            agcls.evaluate_hresult(self.__dict__["_SetUseScale"](arg_useScale.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFEB5448-9053-44F6-BCB5-35280361131F}", ICrdnPointModelAttach)
agcls.AgTypeNameMap["ICrdnPointModelAttach"] = ICrdnPointModelAttach

class ICrdnPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    _uuid = "{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEntryName"] = _raise_uninitialized_error
        self.__dict__["_SetEntryName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointSatelliteCollectionEntry._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointSatelliteCollectionEntry from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointSatelliteCollectionEntry = agcom.GUID(ICrdnPointSatelliteCollectionEntry._uuid)
        vtable_offset_local = ICrdnPointSatelliteCollectionEntry._vtable_offset - 1
        self.__dict__["_GetEntryName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSatelliteCollectionEntry, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetEntryName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSatelliteCollectionEntry, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointSatelliteCollectionEntry.__dict__ and type(ICrdnPointSatelliteCollectionEntry.__dict__[attrname]) == property:
            return ICrdnPointSatelliteCollectionEntry.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointSatelliteCollectionEntry.")
    
    @property
    def EntryName(self) -> str:
        """Specify a satellite collection entry name."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEntryName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @EntryName.setter
    def EntryName(self, entryName:str) -> None:
        with agmarshall.BSTR_arg(entryName) as arg_entryName:
            agcls.evaluate_hresult(self.__dict__["_SetEntryName"](arg_entryName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}", ICrdnPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["ICrdnPointSatelliteCollectionEntry"] = ICrdnPointSatelliteCollectionEntry

class ICrdnPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    _uuid = "{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointPlaneProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointPlaneProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointPlaneProjection = agcom.GUID(ICrdnPointPlaneProjection._uuid)
        vtable_offset_local = ICrdnPointPlaneProjection._vtable_offset - 1
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlaneProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlaneProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointPlaneProjection.__dict__ and type(ICrdnPointPlaneProjection.__dict__[attrname]) == property:
            return ICrdnPointPlaneProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointPlaneProjection.")
    
    @property
    def SourcePoint(self) -> "ICrdnPointRefTo":
        """Specify a source point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "ICrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}", ICrdnPointPlaneProjection)
agcls.AgTypeNameMap["ICrdnPointPlaneProjection"] = ICrdnPointPlaneProjection

class ICrdnPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    _uuid = "{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetPointType"] = _raise_uninitialized_error
        self.__dict__["_SetPointType"] = _raise_uninitialized_error
        self.__dict__["_GetSecondaryCentralBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLagrangeLibration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointLagrangeLibration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointLagrangeLibration = agcom.GUID(ICrdnPointLagrangeLibration._uuid)
        vtable_offset_local = ICrdnPointLagrangeLibration._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLagrangeLibration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLagrangeLibration, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_SetPointType"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLagrangeLibration, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetSecondaryCentralBodies"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLagrangeLibration, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointLagrangeLibration.__dict__ and type(ICrdnPointLagrangeLibration.__dict__[attrname]) == property:
            return ICrdnPointLagrangeLibration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointLagrangeLibration.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PointType(self) -> "AgECrdnLagrangeLibrationPointType":
        """Specify a lagrange point (L1, L2, etc.)"""
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointType.setter
    def PointType(self, pointType:"AgECrdnLagrangeLibrationPointType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnLagrangeLibrationPointType, pointType) as arg_pointType:
            agcls.evaluate_hresult(self.__dict__["_SetPointType"](arg_pointType.COM_val))

    @property
    def SecondaryCentralBodies(self) -> "ICrdnCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryCentralBodies"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}", ICrdnPointLagrangeLibration)
agcls.AgTypeNameMap["ICrdnPointLagrangeLibration"] = ICrdnPointLagrangeLibration

class ICrdnPointCommonTasks(object):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{C357C0A5-3F2A-499C-83F3-6824532C969E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateFixedInSystemCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateFixedInSystemCartesian"] = _raise_uninitialized_error
        self.__dict__["_Sample"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointCommonTasks = agcom.GUID(ICrdnPointCommonTasks._uuid)
        vtable_offset_local = ICrdnPointCommonTasks._vtable_offset - 1
        self.__dict__["_CreateFixedInSystemCartographic"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCommonTasks, vtable_offset_local+1, agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateFixedInSystemCartesian"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_Sample"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCommonTasks, vtable_offset_local+3, agcom.PVOID, agcom.PVOID, POINTER(agcom.SAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointCommonTasks.__dict__ and type(ICrdnPointCommonTasks.__dict__[attrname]) == property:
            return ICrdnPointCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointCommonTasks.")
    
    def CreateFixedInSystemCartographic(self, referenceSystem:"ICrdnSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "ICrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartographic"](arg_referenceSystem.COM_val, arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateFixedInSystemCartesian(self, referenceSystem:"ICrdnSystem", x:float, y:float, z:float) -> "ICrdnPointFixedInSystem":
        """Creates a non-persistent point fixed in a specified reference system."""
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem, \
             agmarshall.DOUBLE_arg(x) as arg_x, \
             agmarshall.DOUBLE_arg(y) as arg_y, \
             agmarshall.DOUBLE_arg(z) as arg_z, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateFixedInSystemCartesian"](arg_referenceSystem.COM_val, arg_x.COM_val, arg_y.COM_val, arg_z.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Sample(self, point:"ICrdnPoint", referenceSystem:"ICrdnSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "ICrdnPointSamplingResult":
        """Computes and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point, \
             agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem, \
             agmarshall.SAFEARRAY_arg(intervals) as arg_intervals, \
             agmarshall.DOUBLE_arg(minStep) as arg_minStep, \
             agmarshall.DOUBLE_arg(maxStep) as arg_maxStep, \
             agmarshall.VARIANT_arg(targetRate) as arg_targetRate, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Sample"](arg_point.COM_val, arg_referenceSystem.COM_val, byref(arg_intervals.COM_val), arg_minStep.COM_val, arg_maxStep.COM_val, arg_targetRate.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C357C0A5-3F2A-499C-83F3-6824532C969E}", ICrdnPointCommonTasks)
agcls.AgTypeNameMap["ICrdnPointCommonTasks"] = ICrdnPointCommonTasks

class ICrdnPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""
    _uuid = "{C0F5946B-9467-44AC-B16A-9276CE4EA141}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_SetDirectionVector"] = _raise_uninitialized_error
        self.__dict__["_GetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_SetIntersectionSurface"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_SetUseRangeConstraint"] = _raise_uninitialized_error
        self.__dict__["_GetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinimumRange"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaximumRange"] = _raise_uninitialized_error
        self.__dict__["_SetRange"] = _raise_uninitialized_error
        self.__dict__["_GetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        self.__dict__["_SetAllowIntersectionFromBelow"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointCentBodyIntersect._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointCentBodyIntersect from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointCentBodyIntersect = agcom.GUID(ICrdnPointCentBodyIntersect._uuid)
        vtable_offset_local = ICrdnPointCentBodyIntersect._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetDirectionVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetIntersectionSurface"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseRangeConstraint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinimumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinimumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaximumRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_SetRange"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+21, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_GetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowIntersectionFromBelow"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCentBodyIntersect, vtable_offset_local+23, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointCentBodyIntersect.__dict__ and type(ICrdnPointCentBodyIntersect.__dict__[attrname]) == property:
            return ICrdnPointCentBodyIntersect.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointCentBodyIntersect.")
    
    @property
    def CentralBody(self) -> str:
        """Central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferencePoint(self) -> "ICrdnPoint":
        """A reference point. Can be any point from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, referencePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(referencePoint, ICrdnPoint) as arg_referencePoint:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_referencePoint.COM_val))

    @property
    def DirectionVector(self) -> "ICrdnVector":
        """A direction vector. Can be any vector from VGT."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DirectionVector.setter
    def DirectionVector(self, directionVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(directionVector, ICrdnVector) as arg_directionVector:
            agcls.evaluate_hresult(self.__dict__["_SetDirectionVector"](arg_directionVector.COM_val))

    @property
    def IntersectionSurface(self) -> "AgECrdnIntersectionSurface":
        """An intersection surface."""
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntersectionSurface"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IntersectionSurface.setter
    def IntersectionSurface(self, intersectionSurface:"AgECrdnIntersectionSurface") -> None:
        with agmarshall.AgEnum_arg(AgECrdnIntersectionSurface, intersectionSurface) as arg_intersectionSurface:
            agcls.evaluate_hresult(self.__dict__["_SetIntersectionSurface"](arg_intersectionSurface.COM_val))

    @property
    def Altitude(self) -> float:
        """An altitude."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))

    @property
    def UseRangeConstraint(self) -> bool:
        """Whether to use range constraint."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseRangeConstraint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseRangeConstraint.setter
    def UseRangeConstraint(self, useRangeConstraint:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useRangeConstraint) as arg_useRangeConstraint:
            agcls.evaluate_hresult(self.__dict__["_SetUseRangeConstraint"](arg_useRangeConstraint.COM_val))

    @property
    def MinimumRange(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MinimumRange.setter
    def MinimumRange(self, minimumRange:float) -> None:
        with agmarshall.DOUBLE_arg(minimumRange) as arg_minimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMinimumRange"](arg_minimumRange.COM_val))

    @property
    def MaximumRange(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MaximumRange.setter
    def MaximumRange(self, maximumRange:float) -> None:
        with agmarshall.DOUBLE_arg(maximumRange) as arg_maximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumRange"](arg_maximumRange.COM_val))

    @property
    def UseMinimumRange(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinimumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMinimumRange.setter
    def UseMinimumRange(self, useMinimumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMinimumRange) as arg_useMinimumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinimumRange"](arg_useMinimumRange.COM_val))

    @property
    def UseMaximumRange(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaximumRange"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMaximumRange.setter
    def UseMaximumRange(self, useMaximumRange:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMaximumRange) as arg_useMaximumRange:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaximumRange"](arg_useMaximumRange.COM_val))

    def SetRange(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        with agmarshall.DOUBLE_arg(minimum) as arg_minimum, \
             agmarshall.DOUBLE_arg(maximum) as arg_maximum:
            agcls.evaluate_hresult(self.__dict__["_SetRange"](arg_minimum.COM_val, arg_maximum.COM_val))

    @property
    def AllowIntersectionFromBelow(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowIntersectionFromBelow"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowIntersectionFromBelow.setter
    def AllowIntersectionFromBelow(self, allowIntersectionFromBelow:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowIntersectionFromBelow) as arg_allowIntersectionFromBelow:
            agcls.evaluate_hresult(self.__dict__["_SetAllowIntersectionFromBelow"](arg_allowIntersectionFromBelow.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C0F5946B-9467-44AC-B16A-9276CE4EA141}", ICrdnPointCentBodyIntersect)
agcls.AgTypeNameMap["ICrdnPointCentBodyIntersect"] = ICrdnPointCentBodyIntersect

class ICrdnPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    _uuid = "{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_SetSourcePoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointAtTimeInstant = agcom.GUID(ICrdnPointAtTimeInstant._uuid)
        vtable_offset_local = ICrdnPointAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourcePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointAtTimeInstant.__dict__ and type(ICrdnPointAtTimeInstant.__dict__[attrname]) == property:
            return ICrdnPointAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourcePoint(self) -> "ICrdnPoint":
        """A source point. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourcePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourcePoint.setter
    def SourcePoint(self, sourcePoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(sourcePoint, ICrdnPoint) as arg_sourcePoint:
            agcls.evaluate_hresult(self.__dict__["_SetSourcePoint"](arg_sourcePoint.COM_val))

    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """A reference system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}", ICrdnPointAtTimeInstant)
agcls.AgTypeNameMap["ICrdnPointAtTimeInstant"] = ICrdnPointAtTimeInstant

class ICrdnPointPlugin(object):
    """A VGT point plugin."""
    _uuid = "{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointPlugin = agcom.GUID(ICrdnPointPlugin._uuid)
        vtable_offset_local = ICrdnPointPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointPlugin.__dict__ and type(ICrdnPointPlugin.__dict__[attrname]) == property:
            return ICrdnPointPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}", ICrdnPointPlugin)
agcls.AgTypeNameMap["ICrdnPointPlugin"] = ICrdnPointPlugin

class ICrdnPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""
    _uuid = "{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceShape"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointCBFixedOffset._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointCBFixedOffset from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointCBFixedOffset = agcom.GUID(ICrdnPointCBFixedOffset._uuid)
        vtable_offset_local = ICrdnPointCBFixedOffset._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCBFixedOffset, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCBFixedOffset, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCBFixedOffset, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceShape"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCBFixedOffset, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointCBFixedOffset, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointCBFixedOffset.__dict__ and type(ICrdnPointCBFixedOffset.__dict__[attrname]) == property:
            return ICrdnPointCBFixedOffset.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointCBFixedOffset.")
    
    @property
    def CentralBody(self) -> str:
        """Get the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CentralBody.setter
    def CentralBody(self, centralBody:str) -> None:
        with agmarshall.BSTR_arg(centralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    @property
    def ReferenceShape(self) -> "AgECrdnReferenceShapeType":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceShape"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferenceShape.setter
    def ReferenceShape(self, referenceShape:"AgECrdnReferenceShapeType") -> None:
        with agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceShape"](arg_referenceShape.COM_val))

    @property
    def Position(self) -> "IPosition":
        """A position of the point fixed on the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}", ICrdnPointCBFixedOffset)
agcls.AgTypeNameMap["ICrdnPointCBFixedOffset"] = ICrdnPointCBFixedOffset

class ICrdnSystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""
    _uuid = "{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemAssembled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemAssembled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemAssembled = agcom.GUID(ICrdnSystemAssembled._uuid)
        vtable_offset_local = ICrdnSystemAssembled._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemAssembled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemAssembled, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemAssembled.__dict__ and type(ICrdnSystemAssembled.__dict__[attrname]) == property:
            return ICrdnSystemAssembled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemAssembled.")
    
    @property
    def OriginPoint(self) -> "ICrdnPointRefTo":
        """Specify a point of origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}", ICrdnSystemAssembled)
agcls.AgTypeNameMap["ICrdnSystemAssembled"] = ICrdnSystemAssembled

class ICrdnSystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    _uuid = "{15798E36-1EC0-4A73-A910-FC28CC404082}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuthAngle"] = _raise_uninitialized_error
        self.__dict__["_GetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_SetUseMSL"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemOnSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemOnSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemOnSurface = agcom.GUID(ICrdnSystemOnSurface._uuid)
        vtable_offset_local = ICrdnSystemOnSurface._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzimuthAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMSL"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemOnSurface, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemOnSurface.__dict__ and type(ICrdnSystemOnSurface.__dict__[attrname]) == property:
            return ICrdnSystemOnSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemOnSurface.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AzimuthAngle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuthAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AzimuthAngle.setter
    def AzimuthAngle(self, azimuthAngle:float) -> None:
        with agmarshall.DOUBLE_arg(azimuthAngle) as arg_azimuthAngle:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuthAngle"](arg_azimuthAngle.COM_val))

    @property
    def UseMSL(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMSL"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseMSL.setter
    def UseMSL(self, useMSL:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useMSL) as arg_useMSL:
            agcls.evaluate_hresult(self.__dict__["_SetUseMSL"](arg_useMSL.COM_val))

    @property
    def Position(self) -> "ICrdnLLAPosition":
        """Specify the position of the system's origin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{15798E36-1EC0-4A73-A910-FC28CC404082}", ICrdnSystemOnSurface)
agcls.AgTypeNameMap["ICrdnSystemOnSurface"] = ICrdnSystemOnSurface

class ICrdnLLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""
    _uuid = "{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnLLAPosition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnLLAPosition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnLLAPosition = agcom.GUID(ICrdnLLAPosition._uuid)
        vtable_offset_local = ICrdnLLAPosition._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_ICrdnLLAPosition, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnLLAPosition.__dict__ and type(ICrdnLLAPosition.__dict__[attrname]) == property:
            return ICrdnLLAPosition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnLLAPosition.")
    
    @property
    def Latitude(self) -> float:
        """Specify a latitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Latitude.setter
    def Latitude(self, latitude:float) -> None:
        with agmarshall.DOUBLE_arg(latitude) as arg_latitude:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_latitude.COM_val))

    @property
    def Longitude(self) -> float:
        """Specify a longitude angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Longitude.setter
    def Longitude(self, longitude:float) -> None:
        with agmarshall.DOUBLE_arg(longitude) as arg_longitude:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_longitude.COM_val))

    @property
    def Altitude(self) -> float:
        """Specify an altitude value."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Altitude.setter
    def Altitude(self, altitude:float) -> None:
        with agmarshall.DOUBLE_arg(altitude) as arg_altitude:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_altitude.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}", ICrdnLLAPosition)
agcls.AgTypeNameMap["ICrdnLLAPosition"] = ICrdnLLAPosition

class ICrdnSystemCommonTasks(object):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    _uuid = "{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_CreateEastNorthUpCartographic"] = _raise_uninitialized_error
        self.__dict__["_CreateAssembled"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemCommonTasks._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemCommonTasks from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemCommonTasks = agcom.GUID(ICrdnSystemCommonTasks._uuid)
        vtable_offset_local = ICrdnSystemCommonTasks._vtable_offset - 1
        self.__dict__["_CreateEastNorthUpCartographic"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemCommonTasks, vtable_offset_local+1, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID))
        self.__dict__["_CreateAssembled"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemCommonTasks, vtable_offset_local+2, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemCommonTasks.__dict__ and type(ICrdnSystemCommonTasks.__dict__[attrname]) == property:
            return ICrdnSystemCommonTasks.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemCommonTasks.")
    
    def CreateEastNorthUpCartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "ICrdnSystemAssembled":
        """Creates a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        with agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateEastNorthUpCartographic"](arg_latitude.COM_val, arg_longitude.COM_val, arg_altitude.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAssembled(self, originPoint:"ICrdnPoint", referenceAxes:"ICrdnAxes") -> "ICrdnSystemAssembled":
        """Creates a non-persistent system component assembled from an origin point and a set of reference axes."""
        with agmarshall.AgInterface_in_arg(originPoint, ICrdnPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAssembled"](arg_originPoint.COM_val, arg_referenceAxes.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}", ICrdnSystemCommonTasks)
agcls.AgTypeNameMap["ICrdnSystemCommonTasks"] = ICrdnSystemCommonTasks

class ICrdnVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    _uuid = "{CFC40EEB-A99F-4DAD-A366-1C7908C15128}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorAngleRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorAngleRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorAngleRate = agcom.GUID(ICrdnVectorAngleRate._uuid)
        vtable_offset_local = ICrdnVectorAngleRate._vtable_offset - 1
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngleRate, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngleRate, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngleRate, vtable_offset_local+3, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorAngleRate.__dict__ and type(ICrdnVectorAngleRate.__dict__[attrname]) == property:
            return ICrdnVectorAngleRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorAngleRate.")
    
    @property
    def Angle(self) -> "ICrdnAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CFC40EEB-A99F-4DAD-A366-1C7908C15128}", ICrdnVectorAngleRate)
agcls.AgTypeNameMap["ICrdnVectorAngleRate"] = ICrdnVectorAngleRate

class ICrdnVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{A082FC52-1C33-4D63-B02E-1D163FC2F837}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorApoapsis = agcom.GUID(ICrdnVectorApoapsis._uuid)
        vtable_offset_local = ICrdnVectorApoapsis._vtable_offset - 1
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorApoapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorApoapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorApoapsis.__dict__ and type(ICrdnVectorApoapsis.__dict__[attrname]) == property:
            return ICrdnVectorApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorApoapsis.")
    
    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A082FC52-1C33-4D63-B02E-1D163FC2F837}", ICrdnVectorApoapsis)
agcls.AgTypeNameMap["ICrdnVectorApoapsis"] = ICrdnVectorApoapsis

class ICrdnVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""
    _uuid = "{7F816808-CF9D-434A-82CE-78F4A88BC75D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFixedAtEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFixedAtEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFixedAtEpoch = agcom.GUID(ICrdnVectorFixedAtEpoch._uuid)
        vtable_offset_local = ICrdnVectorFixedAtEpoch._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtEpoch, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtEpoch, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtEpoch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtEpoch, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFixedAtEpoch.__dict__ and type(ICrdnVectorFixedAtEpoch.__dict__[attrname]) == property:
            return ICrdnVectorFixedAtEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFixedAtEpoch.")
    
    @property
    def Epoch(self) -> typing.Any:
        """Specify an epoch."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def SourceVector(self) -> "ICrdnVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7F816808-CF9D-434A-82CE-78F4A88BC75D}", ICrdnVectorFixedAtEpoch)
agcls.AgTypeNameMap["ICrdnVectorFixedAtEpoch"] = ICrdnVectorFixedAtEpoch

class ICrdnVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    _uuid = "{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorAngularVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorAngularVelocity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorAngularVelocity = agcom.GUID(ICrdnVectorAngularVelocity._uuid)
        vtable_offset_local = ICrdnVectorAngularVelocity._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngularVelocity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngularVelocity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngularVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorAngularVelocity, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorAngularVelocity.__dict__ and type(ICrdnVectorAngularVelocity.__dict__[attrname]) == property:
            return ICrdnVectorAngularVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorAngularVelocity.")
    
    @property
    def Axes(self) -> "ICrdnAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}", ICrdnVectorAngularVelocity)
agcls.AgTypeNameMap["ICrdnVectorAngularVelocity"] = ICrdnVectorAngularVelocity

class ICrdnVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    _uuid = "{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAboutVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStartClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_SetStopClockAngle"] = _raise_uninitialized_error
        self.__dict__["_GetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetStartEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_SetClockAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetMode"] = _raise_uninitialized_error
        self.__dict__["_SetMode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorConing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorConing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorConing = agcom.GUID(ICrdnVectorConing._uuid)
        vtable_offset_local = ICrdnVectorConing._vtable_offset - 1
        self.__dict__["_GetAboutVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStartClockAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStopClockAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetStartEpoch"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetClockAngleRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMode"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetMode"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorConing, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorConing.__dict__ and type(ICrdnVectorConing.__dict__[attrname]) == property:
            return ICrdnVectorConing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorConing.")
    
    @property
    def AboutVector(self) -> "ICrdnVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAboutVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """Specify a reference vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def StartClockAngle(self) -> float:
        """Specify a start angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartClockAngle.setter
    def StartClockAngle(self, startClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(startClockAngle) as arg_startClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStartClockAngle"](arg_startClockAngle.COM_val))

    @property
    def StopClockAngle(self) -> float:
        """Specify a stop angle."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopClockAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StopClockAngle.setter
    def StopClockAngle(self, stopClockAngle:float) -> None:
        with agmarshall.DOUBLE_arg(stopClockAngle) as arg_stopClockAngle:
            agcls.evaluate_hresult(self.__dict__["_SetStopClockAngle"](arg_stopClockAngle.COM_val))

    @property
    def StartEpoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStartEpoch"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @StartEpoch.setter
    def StartEpoch(self, startEpoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(startEpoch) as arg_startEpoch:
            agcls.evaluate_hresult(self.__dict__["_SetStartEpoch"](arg_startEpoch.COM_val))

    @property
    def ClockAngleRate(self) -> float:
        """Specify a rotation rate."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ClockAngleRate.setter
    def ClockAngleRate(self, clockAngleRate:float) -> None:
        with agmarshall.DOUBLE_arg(clockAngleRate) as arg_clockAngleRate:
            agcls.evaluate_hresult(self.__dict__["_SetClockAngleRate"](arg_clockAngleRate.COM_val))

    @property
    def Mode(self) -> "AgECrdnSweepMode":
        """Specify either unidirectional or bidirectional mode."""
        with agmarshall.AgEnum_arg(AgECrdnSweepMode) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMode"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Mode.setter
    def Mode(self, mode:"AgECrdnSweepMode") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSweepMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_SetMode"](arg_mode.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}", ICrdnVectorConing)
agcls.AgTypeNameMap["ICrdnVectorConing"] = ICrdnVectorConing

class ICrdnVectorCross(object):
    """The vector cross product of two vectors."""
    _uuid = "{F695FE24-7AE1-4935-837F-D7106A3C99A4}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFrom"] = _raise_uninitialized_error
        self.__dict__["_GetTo"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorCross._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorCross from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorCross = agcom.GUID(ICrdnVectorCross._uuid)
        vtable_offset_local = ICrdnVectorCross._vtable_offset - 1
        self.__dict__["_GetFrom"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetTo"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCross, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorCross.__dict__ and type(ICrdnVectorCross.__dict__[attrname]) == property:
            return ICrdnVectorCross.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorCross.")
    
    @property
    def From(self) -> "ICrdnVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def To(self) -> "ICrdnVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def IsNormalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))

    @property
    def Dimension(self) -> str:
        """Returns a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F695FE24-7AE1-4935-837F-D7106A3C99A4}", ICrdnVectorCross)
agcls.AgTypeNameMap["ICrdnVectorCross"] = ICrdnVectorCross

class ICrdnVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""
    _uuid = "{66756C64-795C-4E24-9D6A-E560851BBDE0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetScriptFile"] = _raise_uninitialized_error
        self.__dict__["_GetInitializationScriptFile"] = _raise_uninitialized_error
        self.__dict__["_SetInitializationScriptFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorCustomScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorCustomScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorCustomScript = agcom.GUID(ICrdnVectorCustomScript._uuid)
        vtable_offset_local = ICrdnVectorCustomScript._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCustomScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCustomScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetScriptFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCustomScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCustomScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetInitializationScriptFile"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorCustomScript, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorCustomScript.__dict__ and type(ICrdnVectorCustomScript.__dict__[attrname]) == property:
            return ICrdnVectorCustomScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorCustomScript.")
    
    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptFile(self) -> str:
        """Specify a script file."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScriptFile.setter
    def ScriptFile(self, scriptFile:str) -> None:
        with agmarshall.BSTR_arg(scriptFile) as arg_scriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetScriptFile"](arg_scriptFile.COM_val))

    @property
    def InitializationScriptFile(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitializationScriptFile"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @InitializationScriptFile.setter
    def InitializationScriptFile(self, initializationScriptFile:str) -> None:
        with agmarshall.BSTR_arg(initializationScriptFile) as arg_initializationScriptFile:
            agcls.evaluate_hresult(self.__dict__["_SetInitializationScriptFile"](arg_initializationScriptFile.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{66756C64-795C-4E24-9D6A-E560851BBDE0}", ICrdnVectorCustomScript)
agcls.AgTypeNameMap["ICrdnVectorCustomScript"] = ICrdnVectorCustomScript

class ICrdnVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""
    _uuid = "{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        self.__dict__["_SetForceUseOfNumericalDifferences"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorDerivative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorDerivative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorDerivative = agcom.GUID(ICrdnVectorDerivative._uuid)
        vtable_offset_local = ICrdnVectorDerivative._vtable_offset - 1
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceUseOfNumericalDifferences"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDerivative, vtable_offset_local+6, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorDerivative.__dict__ and type(ICrdnVectorDerivative.__dict__[attrname]) == property:
            return ICrdnVectorDerivative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorDerivative.")
    
    @property
    def Vector(self) -> "ICrdnVectorRefTo":
        """Specify a base vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))

    @property
    def ForceUseOfNumericalDifferences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceUseOfNumericalDifferences"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceUseOfNumericalDifferences.setter
    def ForceUseOfNumericalDifferences(self, forceUseOfNumericalDifferences:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceUseOfNumericalDifferences) as arg_forceUseOfNumericalDifferences:
            agcls.evaluate_hresult(self.__dict__["_SetForceUseOfNumericalDifferences"](arg_forceUseOfNumericalDifferences.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}", ICrdnVectorDerivative)
agcls.AgTypeNameMap["ICrdnVectorDerivative"] = ICrdnVectorDerivative

class ICrdnVectorDisplacement(object):
    """Vector defined by its start and end points."""
    _uuid = "{457E8D69-0F1F-4C02-A9D6-F48F86F63853}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOrigin"] = _raise_uninitialized_error
        self.__dict__["_GetDestination"] = _raise_uninitialized_error
        self.__dict__["_GetApparent"] = _raise_uninitialized_error
        self.__dict__["_SetApparent"] = _raise_uninitialized_error
        self.__dict__["_GetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_SetIgnoreAberration"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorDisplacement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorDisplacement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorDisplacement = agcom.GUID(ICrdnVectorDisplacement._uuid)
        vtable_offset_local = ICrdnVectorDisplacement._vtable_offset - 1
        self.__dict__["_GetOrigin"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDestination"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetApparent"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetApparent"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIgnoreAberration"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDisplacement, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorDisplacement.__dict__ and type(ICrdnVectorDisplacement.__dict__[attrname]) == property:
            return ICrdnVectorDisplacement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorDisplacement.")
    
    @property
    def Origin(self) -> "ICrdnPointRefTo":
        """Specify the vector's origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrigin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Destination(self) -> "ICrdnPointRefTo":
        """Specify the vector's destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestination"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Apparent(self) -> bool:
        """Controls whether to take a light speed delay into account."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetApparent"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Apparent.setter
    def Apparent(self, apparent:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(apparent) as arg_apparent:
            agcls.evaluate_hresult(self.__dict__["_SetApparent"](arg_apparent.COM_val))

    @property
    def IgnoreAberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIgnoreAberration"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IgnoreAberration.setter
    def IgnoreAberration(self, ignoreAberration:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(ignoreAberration) as arg_ignoreAberration:
            agcls.evaluate_hresult(self.__dict__["_SetIgnoreAberration"](arg_ignoreAberration.COM_val))

    @property
    def SignalSense(self) -> "AgECrdnSignalSense":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        with agmarshall.AgEnum_arg(AgECrdnSignalSense) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SignalSense.setter
    def SignalSense(self, signalSense:"AgECrdnSignalSense") -> None:
        with agmarshall.AgEnum_arg(AgECrdnSignalSense, signalSense) as arg_signalSense:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_signalSense.COM_val))

    @property
    def ReferenceSystem(self) -> "ICrdnSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{457E8D69-0F1F-4C02-A9D6-F48F86F63853}", ICrdnVectorDisplacement)
agcls.AgTypeNameMap["ICrdnVectorDisplacement"] = ICrdnVectorDisplacement

class ICrdnVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""
    _uuid = "{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPlaneA"] = _raise_uninitialized_error
        self.__dict__["_GetPlaneB"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorTwoPlanesIntersection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorTwoPlanesIntersection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorTwoPlanesIntersection = agcom.GUID(ICrdnVectorTwoPlanesIntersection._uuid)
        vtable_offset_local = ICrdnVectorTwoPlanesIntersection._vtable_offset - 1
        self.__dict__["_GetPlaneA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorTwoPlanesIntersection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPlaneB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorTwoPlanesIntersection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorTwoPlanesIntersection.__dict__ and type(ICrdnVectorTwoPlanesIntersection.__dict__[attrname]) == property:
            return ICrdnVectorTwoPlanesIntersection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorTwoPlanesIntersection.")
    
    @property
    def PlaneA(self) -> "ICrdnPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PlaneB(self) -> "ICrdnPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlaneB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}", ICrdnVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["ICrdnVectorTwoPlanesIntersection"] = ICrdnVectorTwoPlanesIntersection

class ICrdnVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    _uuid = "{C4CCEE5C-B053-413F-8456-6A43720BD314}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPointableElementName"] = _raise_uninitialized_error
        self.__dict__["_SetPointableElementName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorModelAttach._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorModelAttach from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorModelAttach = agcom.GUID(ICrdnVectorModelAttach._uuid)
        vtable_offset_local = ICrdnVectorModelAttach._vtable_offset - 1
        self.__dict__["_GetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorModelAttach, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPointableElementName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorModelAttach, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorModelAttach.__dict__ and type(ICrdnVectorModelAttach.__dict__[attrname]) == property:
            return ICrdnVectorModelAttach.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorModelAttach.")
    
    @property
    def PointableElementName(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointableElementName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointableElementName.setter
    def PointableElementName(self, pointableElementName:str) -> None:
        with agmarshall.BSTR_arg(pointableElementName) as arg_pointableElementName:
            agcls.evaluate_hresult(self.__dict__["_SetPointableElementName"](arg_pointableElementName.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C4CCEE5C-B053-413F-8456-6A43720BD314}", ICrdnVectorModelAttach)
agcls.AgTypeNameMap["ICrdnVectorModelAttach"] = ICrdnVectorModelAttach

class ICrdnVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""
    _uuid = "{2050D921-A98C-408C-8170-FDBB23FEA6E5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSource"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePlane"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorProjection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorProjection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorProjection = agcom.GUID(ICrdnVectorProjection._uuid)
        vtable_offset_local = ICrdnVectorProjection._vtable_offset - 1
        self.__dict__["_GetSource"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePlane"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjection, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorProjection.__dict__ and type(ICrdnVectorProjection.__dict__[attrname]) == property:
            return ICrdnVectorProjection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorProjection.")
    
    @property
    def Source(self) -> "ICrdnVectorRefTo":
        """Specify a source vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSource"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePlane(self) -> "ICrdnPlaneRefTo":
        """Specify a reference plane."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePlane"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2050D921-A98C-408C-8170-FDBB23FEA6E5}", ICrdnVectorProjection)
agcls.AgTypeNameMap["ICrdnVectorProjection"] = ICrdnVectorProjection

class ICrdnVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    _uuid = "{7D89412E-17A8-43D2-9153-58F45E7072F6}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceVector"] = _raise_uninitialized_error
        self.__dict__["_GetScale"] = _raise_uninitialized_error
        self.__dict__["_SetScale"] = _raise_uninitialized_error
        self.__dict__["_GetIsNormalized"] = _raise_uninitialized_error
        self.__dict__["_SetIsNormalized"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorScaled = agcom.GUID(ICrdnVectorScaled._uuid)
        vtable_offset_local = ICrdnVectorScaled._vtable_offset - 1
        self.__dict__["_GetReferenceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScaled, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScale"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScaled, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScaled, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIsNormalized"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScaled, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorScaled.__dict__ and type(ICrdnVectorScaled.__dict__[attrname]) == property:
            return ICrdnVectorScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorScaled.")
    
    @property
    def ReferenceVector(self) -> "ICrdnVectorRefTo":
        """A vector being scaled."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Scale(self) -> float:
        """A scaling multiple."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScale"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Scale.setter
    def Scale(self, scale:float) -> None:
        with agmarshall.DOUBLE_arg(scale) as arg_scale:
            agcls.evaluate_hresult(self.__dict__["_SetScale"](arg_scale.COM_val))

    @property
    def IsNormalized(self) -> bool:
        """Controls whether to convert the reference vector to a unit vector before scalling."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsNormalized"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IsNormalized.setter
    def IsNormalized(self, isNormalized:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(isNormalized) as arg_isNormalized:
            agcls.evaluate_hresult(self.__dict__["_SetIsNormalized"](arg_isNormalized.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D89412E-17A8-43D2-9153-58F45E7072F6}", ICrdnVectorScaled)
agcls.AgTypeNameMap["ICrdnVectorScaled"] = ICrdnVectorScaled

class ICrdnVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorEccentricity = agcom.GUID(ICrdnVectorEccentricity._uuid)
        vtable_offset_local = ICrdnVectorEccentricity._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorEccentricity, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorEccentricity, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorEccentricity.__dict__ and type(ICrdnVectorEccentricity.__dict__[attrname]) == property:
            return ICrdnVectorEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorEccentricity.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}", ICrdnVectorEccentricity)
agcls.AgTypeNameMap["ICrdnVectorEccentricity"] = ICrdnVectorEccentricity

class ICrdnVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""
    _uuid = "{912ECDDB-B23C-4B7A-A173-AC22170DA343}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFixedInAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFixedInAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFixedInAxes = agcom.GUID(ICrdnVectorFixedInAxes._uuid)
        vtable_offset_local = ICrdnVectorFixedInAxes._vtable_offset - 1
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedInAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedInAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFixedInAxes.__dict__ and type(ICrdnVectorFixedInAxes.__dict__[attrname]) == property:
            return ICrdnVectorFixedInAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFixedInAxes.")
    
    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Direction(self) -> "IDirection":
        """Specify the vector direction."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{912ECDDB-B23C-4B7A-A173-AC22170DA343}", ICrdnVectorFixedInAxes)
agcls.AgTypeNameMap["ICrdnVectorFixedInAxes"] = ICrdnVectorFixedInAxes

class ICrdnVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    _uuid = "{DC23EB21-198C-4E01-9898-D565E937AFF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorLineOfNodes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorLineOfNodes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorLineOfNodes = agcom.GUID(ICrdnVectorLineOfNodes._uuid)
        vtable_offset_local = ICrdnVectorLineOfNodes._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLineOfNodes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLineOfNodes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorLineOfNodes.__dict__ and type(ICrdnVectorLineOfNodes.__dict__[attrname]) == property:
            return ICrdnVectorLineOfNodes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorLineOfNodes.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Specify a reference point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{DC23EB21-198C-4E01-9898-D565E937AFF1}", ICrdnVectorLineOfNodes)
agcls.AgTypeNameMap["ICrdnVectorLineOfNodes"] = ICrdnVectorLineOfNodes

class ICrdnVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{22C8270A-7B36-40D7-9EC5-44FED3DEE541}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorOrbitAngularMomentum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorOrbitAngularMomentum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorOrbitAngularMomentum = agcom.GUID(ICrdnVectorOrbitAngularMomentum._uuid)
        vtable_offset_local = ICrdnVectorOrbitAngularMomentum._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitAngularMomentum, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitAngularMomentum, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitAngularMomentum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitAngularMomentum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorOrbitAngularMomentum.__dict__ and type(ICrdnVectorOrbitAngularMomentum.__dict__[attrname]) == property:
            return ICrdnVectorOrbitAngularMomentum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorOrbitAngularMomentum.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22C8270A-7B36-40D7-9EC5-44FED3DEE541}", ICrdnVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["ICrdnVectorOrbitAngularMomentum"] = ICrdnVectorOrbitAngularMomentum

class ICrdnVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    _uuid = "{296D4695-53FE-40B7-BA3E-41A3C04A805F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorOrbitNormal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorOrbitNormal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorOrbitNormal = agcom.GUID(ICrdnVectorOrbitNormal._uuid)
        vtable_offset_local = ICrdnVectorOrbitNormal._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitNormal, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitNormal, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitNormal, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorOrbitNormal, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorOrbitNormal.__dict__ and type(ICrdnVectorOrbitNormal.__dict__[attrname]) == property:
            return ICrdnVectorOrbitNormal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorOrbitNormal.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{296D4695-53FE-40B7-BA3E-41A3C04A805F}", ICrdnVectorOrbitNormal)
agcls.AgTypeNameMap["ICrdnVectorOrbitNormal"] = ICrdnVectorOrbitNormal

class ICrdnVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    _uuid = "{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_GetMeanElementType"] = _raise_uninitialized_error
        self.__dict__["_SetMeanElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorPeriapsis = agcom.GUID(ICrdnVectorPeriapsis._uuid)
        vtable_offset_local = ICrdnVectorPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPeriapsis, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPeriapsis, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMeanElementType"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorPeriapsis.__dict__ and type(ICrdnVectorPeriapsis.__dict__[attrname]) == property:
            return ICrdnVectorPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorPeriapsis.")
    
    @property
    def CentralBody(self) -> "ICrdnCentralBodyRefTo":
        """Specify a central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferencePoint(self) -> "ICrdnPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def MeanElementType(self) -> "AgECrdnMeanElementTheory":
        """Specify the mean element theory type for approximating motion."""
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanElementType"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @MeanElementType.setter
    def MeanElementType(self, meanElementType:"AgECrdnMeanElementTheory") -> None:
        with agmarshall.AgEnum_arg(AgECrdnMeanElementTheory, meanElementType) as arg_meanElementType:
            agcls.evaluate_hresult(self.__dict__["_SetMeanElementType"](arg_meanElementType.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}", ICrdnVectorPeriapsis)
agcls.AgTypeNameMap["ICrdnVectorPeriapsis"] = ICrdnVectorPeriapsis

class ICrdnVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    _uuid = "{AF054174-278A-41E6-B8FA-0FC48E19A8BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIncomingVector"] = _raise_uninitialized_error
        self.__dict__["_GetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_SetUseOppositeOfSelectedVector"] = _raise_uninitialized_error
        self.__dict__["_GetNormalVector"] = _raise_uninitialized_error
        self.__dict__["_GetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_SetAllowReflectionsOnBackside"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorReflection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorReflection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorReflection = agcom.GUID(ICrdnVectorReflection._uuid)
        vtable_offset_local = ICrdnVectorReflection._vtable_offset - 1
        self.__dict__["_GetIncomingVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+2, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseOppositeOfSelectedVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+3, agcom.VARIANT_BOOL)
        self.__dict__["_GetNormalVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowReflectionsOnBackside"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorReflection, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorReflection.__dict__ and type(ICrdnVectorReflection.__dict__[attrname]) == property:
            return ICrdnVectorReflection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorReflection.")
    
    @property
    def IncomingVector(self) -> "ICrdnVectorRefTo":
        """The reflecting vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncomingVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseOppositeOfSelectedVector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseOppositeOfSelectedVector"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseOppositeOfSelectedVector.setter
    def UseOppositeOfSelectedVector(self, useOppositeOfSelectedVector:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useOppositeOfSelectedVector) as arg_useOppositeOfSelectedVector:
            agcls.evaluate_hresult(self.__dict__["_SetUseOppositeOfSelectedVector"](arg_useOppositeOfSelectedVector.COM_val))

    @property
    def NormalVector(self) -> "ICrdnVectorRefTo":
        """The vector defines the reflection surface."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AllowReflectionsOnBackside(self) -> bool:
        """Controls whether to reflect the indicent vector on both sides of the plane."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowReflectionsOnBackside"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @AllowReflectionsOnBackside.setter
    def AllowReflectionsOnBackside(self, allowReflectionsOnBackside:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(allowReflectionsOnBackside) as arg_allowReflectionsOnBackside:
            agcls.evaluate_hresult(self.__dict__["_SetAllowReflectionsOnBackside"](arg_allowReflectionsOnBackside.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """The vector's scale factor."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AF054174-278A-41E6-B8FA-0FC48E19A8BC}", ICrdnVectorReflection)
agcls.AgTypeNameMap["ICrdnVectorReflection"] = ICrdnVectorReflection

class ICrdnVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    _uuid = "{2dc152fa-f029-4bc6-bc47-f27d92219a32}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_GetForceMinimumRotation"] = _raise_uninitialized_error
        self.__dict__["_SetForceMinimumRotation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorRotationVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorRotationVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorRotationVector = agcom.GUID(ICrdnVectorRotationVector._uuid)
        vtable_offset_local = ICrdnVectorRotationVector._vtable_offset - 1
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRotationVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRotationVector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRotationVector, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetForceMinimumRotation"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorRotationVector, vtable_offset_local+4, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorRotationVector.__dict__ and type(ICrdnVectorRotationVector.__dict__[attrname]) == property:
            return ICrdnVectorRotationVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorRotationVector.")
    
    @property
    def Axes(self) -> "ICrdnAxesRefTo":
        """Specify the axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ReferenceAxes(self) -> "ICrdnAxesRefTo":
        """Specify a reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ForceMinimumRotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetForceMinimumRotation"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ForceMinimumRotation.setter
    def ForceMinimumRotation(self, forceMinimumRotation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(forceMinimumRotation) as arg_forceMinimumRotation:
            agcls.evaluate_hresult(self.__dict__["_SetForceMinimumRotation"](arg_forceMinimumRotation.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2dc152fa-f029-4bc6-bc47-f27d92219a32}", ICrdnVectorRotationVector)
agcls.AgTypeNameMap["ICrdnVectorRotationVector"] = ICrdnVectorRotationVector

class ICrdnVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    _uuid = "{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSelectedStar"] = _raise_uninitialized_error
        self.__dict__["_SetSelectedStar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorDirectionToStar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorDirectionToStar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorDirectionToStar = agcom.GUID(ICrdnVectorDirectionToStar._uuid)
        vtable_offset_local = ICrdnVectorDirectionToStar._vtable_offset - 1
        self.__dict__["_GetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDirectionToStar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSelectedStar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDirectionToStar, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorDirectionToStar.__dict__ and type(ICrdnVectorDirectionToStar.__dict__[attrname]) == property:
            return ICrdnVectorDirectionToStar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorDirectionToStar.")
    
    @property
    def SelectedStar(self) -> str:
        """A fully qualified path to a Star object."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSelectedStar"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SelectedStar.setter
    def SelectedStar(self, selectedStar:str) -> None:
        with agmarshall.BSTR_arg(selectedStar) as arg_selectedStar:
            agcls.evaluate_hresult(self.__dict__["_SetSelectedStar"](arg_selectedStar.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}", ICrdnVectorDirectionToStar)
agcls.AgTypeNameMap["ICrdnVectorDirectionToStar"] = ICrdnVectorDirectionToStar

class ICrdnVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    _uuid = "{B35CE60F-7CC5-4289-9052-2203B609087E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTimeInstant"] = _raise_uninitialized_error
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAxes"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFixedAtTimeInstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFixedAtTimeInstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFixedAtTimeInstant = agcom.GUID(ICrdnVectorFixedAtTimeInstant._uuid)
        vtable_offset_local = ICrdnVectorFixedAtTimeInstant._vtable_offset - 1
        self.__dict__["_GetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceTimeInstant"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFixedAtTimeInstant, vtable_offset_local+6, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFixedAtTimeInstant.__dict__ and type(ICrdnVectorFixedAtTimeInstant.__dict__[attrname]) == property:
            return ICrdnVectorFixedAtTimeInstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFixedAtTimeInstant.")
    
    @property
    def ReferenceTimeInstant(self) -> "ICrdnEvent":
        """A reference time instant. Can be any Time event."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTimeInstant"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceTimeInstant.setter
    def ReferenceTimeInstant(self, referenceTimeInstant:"ICrdnEvent") -> None:
        with agmarshall.AgInterface_in_arg(referenceTimeInstant, ICrdnEvent) as arg_referenceTimeInstant:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTimeInstant"](arg_referenceTimeInstant.COM_val))

    @property
    def SourceVector(self) -> "ICrdnVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, ICrdnVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def ReferenceAxes(self) -> "ICrdnAxes":
        """A reference axes. Can be any VGT axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceAxes.setter
    def ReferenceAxes(self, referenceAxes:"ICrdnAxes") -> None:
        with agmarshall.AgInterface_in_arg(referenceAxes, ICrdnAxes) as arg_referenceAxes:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAxes"](arg_referenceAxes.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B35CE60F-7CC5-4289-9052-2203B609087E}", ICrdnVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["ICrdnVectorFixedAtTimeInstant"] = ICrdnVectorFixedAtTimeInstant

class ICrdnVectorLinearCombination(object):
    """Linear combination of two input vectors."""
    _uuid = "{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorLinearCombination = agcom.GUID(ICrdnVectorLinearCombination._uuid)
        vtable_offset_local = ICrdnVectorLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+8, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorLinearCombination, vtable_offset_local+16, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorLinearCombination.__dict__ and type(ICrdnVectorLinearCombination.__dict__[attrname]) == property:
            return ICrdnVectorLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorLinearCombination.")
    
    @property
    def VectorA(self) -> "ICrdnVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, ICrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def VectorB(self) -> "ICrdnVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, ICrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}", ICrdnVectorLinearCombination)
agcls.AgTypeNameMap["ICrdnVectorLinearCombination"] = ICrdnVectorLinearCombination

class ICrdnVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""
    _uuid = "{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_SetSourceVector"] = _raise_uninitialized_error
        self.__dict__["_GetAlongVector"] = _raise_uninitialized_error
        self.__dict__["_SetAlongVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorProjectAlongVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorProjectAlongVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorProjectAlongVector = agcom.GUID(ICrdnVectorProjectAlongVector._uuid)
        vtable_offset_local = ICrdnVectorProjectAlongVector._vtable_offset - 1
        self.__dict__["_GetSourceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjectAlongVector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSourceVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjectAlongVector, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjectAlongVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetAlongVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorProjectAlongVector, vtable_offset_local+4, agcom.PVOID)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorProjectAlongVector.__dict__ and type(ICrdnVectorProjectAlongVector.__dict__[attrname]) == property:
            return ICrdnVectorProjectAlongVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorProjectAlongVector.")
    
    @property
    def SourceVector(self) -> "ICrdnVector":
        """A source vector. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSourceVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @SourceVector.setter
    def SourceVector(self, sourceVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(sourceVector, ICrdnVector) as arg_sourceVector:
            agcls.evaluate_hresult(self.__dict__["_SetSourceVector"](arg_sourceVector.COM_val))

    @property
    def AlongVector(self) -> "ICrdnVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAlongVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @AlongVector.setter
    def AlongVector(self, alongVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(alongVector, ICrdnVector) as arg_alongVector:
            agcls.evaluate_hresult(self.__dict__["_SetAlongVector"](arg_alongVector.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}", ICrdnVectorProjectAlongVector)
agcls.AgTypeNameMap["ICrdnVectorProjectAlongVector"] = ICrdnVectorProjectAlongVector

class ICrdnVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""
    _uuid = "{0886A066-8650-4C8D-B234-14D28A175A78}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorA"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetUseScaleFromScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetScalarA"] = _raise_uninitialized_error
        self.__dict__["_SetScalarA"] = _raise_uninitialized_error
        self.__dict__["_GetScalarB"] = _raise_uninitialized_error
        self.__dict__["_SetScalarB"] = _raise_uninitialized_error
        self.__dict__["_GetVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactorB"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizeVectorB"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetOutputDimension"] = _raise_uninitialized_error
        self.__dict__["_SetOutputDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorScalarLinearCombination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorScalarLinearCombination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorScalarLinearCombination = agcom.GUID(ICrdnVectorScalarLinearCombination._uuid)
        vtable_offset_local = ICrdnVectorScalarLinearCombination._vtable_offset - 1
        self.__dict__["_GetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseScaleFromScalarB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetScalarA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarA"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_GetScalarB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_SetScalarB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+14, agcom.PVOID)
        self.__dict__["_GetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_SetVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+16, agcom.PVOID)
        self.__dict__["_GetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalizeVectorB"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_GetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetOutputDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetOutputDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarLinearCombination, vtable_offset_local+24, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorScalarLinearCombination.__dict__ and type(ICrdnVectorScalarLinearCombination.__dict__[attrname]) == property:
            return ICrdnVectorScalarLinearCombination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorScalarLinearCombination.")
    
    @property
    def VectorA(self) -> "ICrdnVector":
        """Vector A can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorA.setter
    def VectorA(self, vectorA:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorA, ICrdnVector) as arg_vectorA:
            agcls.evaluate_hresult(self.__dict__["_SetVectorA"](arg_vectorA.COM_val))

    @property
    def ScaleFactorA(self) -> float:
        """Scale factor for vector A."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorA.setter
    def ScaleFactorA(self, scaleFactorA:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorA) as arg_scaleFactorA:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorA"](arg_scaleFactorA.COM_val))

    @property
    def NormalizeVectorA(self) -> bool:
        """Whether to normalize vector A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorA.setter
    def NormalizeVectorA(self, normalizeVectorA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorA) as arg_normalizeVectorA:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorA"](arg_normalizeVectorA.COM_val))

    @property
    def UseScaleFromScalarA(self) -> bool:
        """Whether to use a scale from scalar A."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarA"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarA.setter
    def UseScaleFromScalarA(self, useScaleFromScalarA:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarA) as arg_useScaleFromScalarA:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarA"](arg_useScaleFromScalarA.COM_val))

    @property
    def UseScaleFromScalarB(self) -> bool:
        """Whether to use a scale from scalar B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseScaleFromScalarB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @UseScaleFromScalarB.setter
    def UseScaleFromScalarB(self, useScaleFromScalarB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(useScaleFromScalarB) as arg_useScaleFromScalarB:
            agcls.evaluate_hresult(self.__dict__["_SetUseScaleFromScalarB"](arg_useScaleFromScalarB.COM_val))

    @property
    def ScalarA(self) -> "ICrdnCalcScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarA"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarA.setter
    def ScalarA(self, scalarA:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarA, ICrdnCalcScalar) as arg_scalarA:
            agcls.evaluate_hresult(self.__dict__["_SetScalarA"](arg_scalarA.COM_val))

    @property
    def ScalarB(self) -> "ICrdnCalcScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ScalarB.setter
    def ScalarB(self, scalarB:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(scalarB, ICrdnCalcScalar) as arg_scalarB:
            agcls.evaluate_hresult(self.__dict__["_SetScalarB"](arg_scalarB.COM_val))

    @property
    def VectorB(self) -> "ICrdnVector":
        """Vector B can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorB"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @VectorB.setter
    def VectorB(self, vectorB:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(vectorB, ICrdnVector) as arg_vectorB:
            agcls.evaluate_hresult(self.__dict__["_SetVectorB"](arg_vectorB.COM_val))

    @property
    def ScaleFactorB(self) -> float:
        """Scale factor for vector B."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactorB.setter
    def ScaleFactorB(self, scaleFactorB:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactorB) as arg_scaleFactorB:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactorB"](arg_scaleFactorB.COM_val))

    @property
    def NormalizeVectorB(self) -> bool:
        """Whether to normalize vector B."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizeVectorB"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @NormalizeVectorB.setter
    def NormalizeVectorB(self, normalizeVectorB:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalizeVectorB) as arg_normalizeVectorB:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizeVectorB"](arg_normalizeVectorB.COM_val))

    @property
    def OutputDimensionInheritance(self) -> "AgECrdnDimensionInheritance":
        """Determines whether the output dimension is inherited or explicitly specified using OutputDimension."""
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimensionInheritance.setter
    def OutputDimensionInheritance(self, outputDimensionInheritance:"AgECrdnDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnDimensionInheritance, outputDimensionInheritance) as arg_outputDimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimensionInheritance"](arg_outputDimensionInheritance.COM_val))

    @property
    def OutputDimension(self) -> str:
        """A dimension to interpret the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOutputDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @OutputDimension.setter
    def OutputDimension(self, outputDimension:str) -> None:
        with agmarshall.BSTR_arg(outputDimension) as arg_outputDimension:
            agcls.evaluate_hresult(self.__dict__["_SetOutputDimension"](arg_outputDimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0886A066-8650-4C8D-B234-14D28A175A78}", ICrdnVectorScalarLinearCombination)
agcls.AgTypeNameMap["ICrdnVectorScalarLinearCombination"] = ICrdnVectorScalarLinearCombination

class ICrdnVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""
    _uuid = "{306C3852-C3E9-43EB-9371-1B9540B52097}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInputVector"] = _raise_uninitialized_error
        self.__dict__["_SetInputVector"] = _raise_uninitialized_error
        self.__dict__["_GetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_SetInputScalar"] = _raise_uninitialized_error
        self.__dict__["_GetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_SetScaleFactor"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        self.__dict__["_GetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_SetDimensionInheritance"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorScalarScaled._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorScalarScaled from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorScalarScaled = agcom.GUID(ICrdnVectorScalarScaled._uuid)
        vtable_offset_local = ICrdnVectorScalarScaled._vtable_offset - 1
        self.__dict__["_GetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetInputVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetInputScalar"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleFactor"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetDimensionInheritance"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorScalarScaled, vtable_offset_local+12, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorScalarScaled.__dict__ and type(ICrdnVectorScalarScaled.__dict__[attrname]) == property:
            return ICrdnVectorScalarScaled.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorScalarScaled.")
    
    @property
    def InputVector(self) -> "ICrdnVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputVector.setter
    def InputVector(self, inputVector:"ICrdnVector") -> None:
        with agmarshall.AgInterface_in_arg(inputVector, ICrdnVector) as arg_inputVector:
            agcls.evaluate_hresult(self.__dict__["_SetInputVector"](arg_inputVector.COM_val))

    @property
    def InputScalar(self) -> "ICrdnCalcScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputScalar"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @InputScalar.setter
    def InputScalar(self, inputScalar:"ICrdnCalcScalar") -> None:
        with agmarshall.AgInterface_in_arg(inputScalar, ICrdnCalcScalar) as arg_inputScalar:
            agcls.evaluate_hresult(self.__dict__["_SetInputScalar"](arg_inputScalar.COM_val))

    @property
    def ScaleFactor(self) -> float:
        """A constant scale applied to the input vector."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleFactor"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ScaleFactor.setter
    def ScaleFactor(self, scaleFactor:float) -> None:
        with agmarshall.DOUBLE_arg(scaleFactor) as arg_scaleFactor:
            agcls.evaluate_hresult(self.__dict__["_SetScaleFactor"](arg_scaleFactor.COM_val))

    @property
    def Normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Normalize.setter
    def Normalize(self, normalize:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(normalize) as arg_normalize:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_normalize.COM_val))

    @property
    def DimensionInheritance(self) -> "AgECrdnVectorScaledDimensionInheritance":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimensionInheritance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DimensionInheritance.setter
    def DimensionInheritance(self, dimensionInheritance:"AgECrdnVectorScaledDimensionInheritance") -> None:
        with agmarshall.AgEnum_arg(AgECrdnVectorScaledDimensionInheritance, dimensionInheritance) as arg_dimensionInheritance:
            agcls.evaluate_hresult(self.__dict__["_SetDimensionInheritance"](arg_dimensionInheritance.COM_val))

    @property
    def Dimension(self) -> str:
        """A dimension assigned to the output vector."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Dimension.setter
    def Dimension(self, dimension:str) -> None:
        with agmarshall.BSTR_arg(dimension) as arg_dimension:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_dimension.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{306C3852-C3E9-43EB-9371-1B9540B52097}", ICrdnVectorScalarScaled)
agcls.AgTypeNameMap["ICrdnVectorScalarScaled"] = ICrdnVectorScalarScaled

class ICrdnVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""
    _uuid = "{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSystem"] = _raise_uninitialized_error
        self.__dict__["_GetPoint"] = _raise_uninitialized_error
        self.__dict__["_SetPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorVelocityAcceleration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorVelocityAcceleration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorVelocityAcceleration = agcom.GUID(ICrdnVectorVelocityAcceleration._uuid)
        vtable_offset_local = ICrdnVectorVelocityAcceleration._vtable_offset - 1
        self.__dict__["_GetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetReferenceSystem"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorVelocityAcceleration, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorVelocityAcceleration.__dict__ and type(ICrdnVectorVelocityAcceleration.__dict__[attrname]) == property:
            return ICrdnVectorVelocityAcceleration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorVelocityAcceleration.")
    
    @property
    def ReferenceSystem(self) -> "ICrdnSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSystem"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @ReferenceSystem.setter
    def ReferenceSystem(self, referenceSystem:"ICrdnSystem") -> None:
        with agmarshall.AgInterface_in_arg(referenceSystem, ICrdnSystem) as arg_referenceSystem:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSystem"](arg_referenceSystem.COM_val))

    @property
    def Point(self) -> "ICrdnPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @Point.setter
    def Point(self, point:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(point, ICrdnPoint) as arg_point:
            agcls.evaluate_hresult(self.__dict__["_SetPoint"](arg_point.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}", ICrdnVectorVelocityAcceleration)
agcls.AgTypeNameMap["ICrdnVectorVelocityAcceleration"] = ICrdnVectorVelocityAcceleration

class ICrdnVectorPlugin(object):
    """A VGT vector plugin."""
    _uuid = "{F889F617-059E-4BC9-9000-206091889FEB}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProgID"] = _raise_uninitialized_error
        self.__dict__["_GetDisplayName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        self.__dict__["_Reset"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorPlugin = agcom.GUID(ICrdnVectorPlugin._uuid)
        vtable_offset_local = ICrdnVectorPlugin._vtable_offset - 1
        self.__dict__["_GetProgID"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Reset"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+4, )
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+5, agcom.BSTR, agcom.BSTR)
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorPlugin, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorPlugin.__dict__ and type(ICrdnVectorPlugin.__dict__[attrname]) == property:
            return ICrdnVectorPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorPlugin.")
    
    @property
    def ProgID(self) -> str:
        """A programmatic ID associated with the component."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProgID"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def DisplayName(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableProperties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Reset(self) -> None:
        """Reset the plugin."""
        agcls.evaluate_hresult(self.__dict__["_Reset"]())

    def SetProperty(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_name.COM_val, arg_value.COM_val))

    def GetProperty(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F889F617-059E-4BC9-9000-206091889FEB}", ICrdnVectorPlugin)
agcls.AgTypeNameMap["ICrdnVectorPlugin"] = ICrdnVectorPlugin

class ICrdnVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    _uuid = "{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_SetOriginPoint"] = _raise_uninitialized_error
        self.__dict__["_GetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_SetDestinationPoint"] = _raise_uninitialized_error
        self.__dict__["_GetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_SetSurfaceCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetDifferencingTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetDifferencingTimeStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorDispSurface._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorDispSurface from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorDispSurface = agcom.GUID(ICrdnVectorDispSurface._uuid)
        vtable_offset_local = ICrdnVectorDispSurface._vtable_offset - 1
        self.__dict__["_GetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetOriginPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetDestinationPoint"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetSurfaceCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDifferencingTimeStep"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorDispSurface, vtable_offset_local+8, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorDispSurface.__dict__ and type(ICrdnVectorDispSurface.__dict__[attrname]) == property:
            return ICrdnVectorDispSurface.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorDispSurface.")
    
    @property
    def OriginPoint(self) -> "ICrdnPoint":
        """An origin point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @OriginPoint.setter
    def OriginPoint(self, originPoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(originPoint, ICrdnPoint) as arg_originPoint:
            agcls.evaluate_hresult(self.__dict__["_SetOriginPoint"](arg_originPoint.COM_val))

    @property
    def DestinationPoint(self) -> "ICrdnPoint":
        """Destination point."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDestinationPoint"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @DestinationPoint.setter
    def DestinationPoint(self, destinationPoint:"ICrdnPoint") -> None:
        with agmarshall.AgInterface_in_arg(destinationPoint, ICrdnPoint) as arg_destinationPoint:
            agcls.evaluate_hresult(self.__dict__["_SetDestinationPoint"](arg_destinationPoint.COM_val))

    @property
    def SurfaceCentralBody(self) -> str:
        """surface central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSurfaceCentralBody"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @SurfaceCentralBody.setter
    def SurfaceCentralBody(self, surfaceCentralBody:str) -> None:
        with agmarshall.BSTR_arg(surfaceCentralBody) as arg_surfaceCentralBody:
            agcls.evaluate_hresult(self.__dict__["_SetSurfaceCentralBody"](arg_surfaceCentralBody.COM_val))

    @property
    def DifferencingTimeStep(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        with agmarshall.DOUBLE_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferencingTimeStep"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @DifferencingTimeStep.setter
    def DifferencingTimeStep(self, differencingTimeStep:float) -> None:
        with agmarshall.DOUBLE_arg(differencingTimeStep) as arg_differencingTimeStep:
            agcls.evaluate_hresult(self.__dict__["_SetDifferencingTimeStep"](arg_differencingTimeStep.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}", ICrdnVectorDispSurface)
agcls.AgTypeNameMap["ICrdnVectorDispSurface"] = ICrdnVectorDispSurface

class ICrdnVectorFactory(object):
    """A Factory object to create vectors."""
    _uuid = "{09F7F253-392A-44D9-9701-51CC0110C033}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_CreateDisplacementVector"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateVectorPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreateCrossProductVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFactory = agcom.GUID(ICrdnVectorFactory._uuid)
        vtable_offset_local = ICrdnVectorFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_CreateDisplacementVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+3, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetAvailableVectorPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+4, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateVectorPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreateCrossProductVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFactory, vtable_offset_local+6, agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFactory.__dict__ and type(ICrdnVectorFactory.__dict__[attrname]) == property:
            return ICrdnVectorFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFactory.")
    
    def Create(self, vectorName:str, description:str, vectorType:"AgECrdnVectorType") -> "ICrdnVector":
        """Creates a VGT vector using specified name, description and type."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnVectorType, vectorType) as arg_vectorType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_vectorName.COM_val, arg_description.COM_val, arg_vectorType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnVectorType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnVectorType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def CreateDisplacementVector(self, vectorName:str, originPoint:"ICrdnPoint", destPoint:"ICrdnPoint") -> "ICrdnVectorDisplacement":
        """Creates a displacement vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(originPoint, ICrdnPoint) as arg_originPoint, \
             agmarshall.AgInterface_in_arg(destPoint, ICrdnPoint) as arg_destPoint, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateDisplacementVector"](arg_vectorName.COM_val, arg_originPoint.COM_val, arg_destPoint.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AvailableVectorPluginDisplayNames(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableVectorPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateVectorPluginFromDisplayName(self, vectorName:str, description:str, displayName:str) -> "ICrdnVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateVectorPluginFromDisplayName"](arg_vectorName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateCrossProductVector(self, vectorName:str, vectorA:"ICrdnVector", vectorB:"ICrdnVector") -> "ICrdnVectorCross":
        """Creates a cross product C = A x B."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName, \
             agmarshall.AgInterface_in_arg(vectorA, ICrdnVector) as arg_vectorA, \
             agmarshall.AgInterface_in_arg(vectorB, ICrdnVector) as arg_vectorB, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateCrossProductVector"](arg_vectorName.COM_val, arg_vectorA.COM_val, arg_vectorB.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{09F7F253-392A-44D9-9701-51CC0110C033}", ICrdnVectorFactory)
agcls.AgTypeNameMap["ICrdnVectorFactory"] = ICrdnVectorFactory

class ICrdnAxesFactory(object):
    """A Factory object to create axes."""
    _uuid = "{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreateAxesPluginFromDisplayName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesFactory = agcom.GUID(ICrdnAxesFactory._uuid)
        vtable_offset_local = ICrdnAxesFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailableAxesPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreateAxesPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesFactory.__dict__ and type(ICrdnAxesFactory.__dict__[attrname]) == property:
            return ICrdnAxesFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesFactory.")
    
    def Create(self, axesName:str, description:str, axesType:"AgECrdnAxesType") -> "ICrdnAxes":
        """Creates a VGT axes using specified name, description and type."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAxesType, axesType) as arg_axesType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_axesName.COM_val, arg_description.COM_val, arg_axesType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAxesType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAxesType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailableAxesPluginDisplayNames(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableAxesPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreateAxesPluginFromDisplayName(self, axesName:str, description:str, displayName:str) -> "ICrdnAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(axesName) as arg_axesName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreateAxesPluginFromDisplayName"](arg_axesName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}", ICrdnAxesFactory)
agcls.AgTypeNameMap["ICrdnAxesFactory"] = ICrdnAxesFactory

class ICrdnSystemFactory(object):
    """A Factory interface to create VGT systems."""
    _uuid = "{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemFactory = agcom.GUID(ICrdnSystemFactory._uuid)
        vtable_offset_local = ICrdnSystemFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemFactory.__dict__ and type(ICrdnSystemFactory.__dict__[attrname]) == property:
            return ICrdnSystemFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemFactory.")
    
    def Create(self, systemName:str, description:str, systemType:"AgECrdnSystemType") -> "ICrdnSystem":
        """Creates a VGT system using the specified name, description and type."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnSystemType, systemType) as arg_systemType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_systemName.COM_val, arg_description.COM_val, arg_systemType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnSystemType") -> bool:
        """Returns true if the specified system type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnSystemType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}", ICrdnSystemFactory)
agcls.AgTypeNameMap["ICrdnSystemFactory"] = ICrdnSystemFactory

class ICrdnPointFactory(object):
    """A Factory object to create points."""
    _uuid = "{18FA11DA-BC93-4467-B53F-4D894739C3A3}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = _raise_uninitialized_error
        self.__dict__["_CreatePointPluginFromDisplayName"] = _raise_uninitialized_error
        self.__dict__["_CreatePointFixedOnCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointFactory = agcom.GUID(ICrdnPointFactory._uuid)
        vtable_offset_local = ICrdnPointFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAvailablePointPluginDisplayNames"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFactory, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_CreatePointPluginFromDisplayName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFactory, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_CreatePointFixedOnCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointFactory, vtable_offset_local+5, agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointFactory.__dict__ and type(ICrdnPointFactory.__dict__[attrname]) == property:
            return ICrdnPointFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointFactory.")
    
    def Create(self, pointName:str, description:str, pointType:"AgECrdnPointType") -> "ICrdnPoint":
        """Creates a VGT point using the specified name, description and type."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPointType, pointType) as arg_pointType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_pointName.COM_val, arg_description.COM_val, arg_pointType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPointType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPointType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AvailablePointPluginDisplayNames(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailablePointPluginDisplayNames"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointPluginFromDisplayName(self, pointName:str, description:str, displayName:str) -> "ICrdnPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see"""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.BSTR_arg(displayName) as arg_displayName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointPluginFromDisplayName"](arg_pointName.COM_val, arg_description.COM_val, arg_displayName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def CreatePointFixedOnCentralBody(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"AgECrdnReferenceShapeType") -> "ICrdnPoint":
        """Creates a point fixed on a central body."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.VARIANT_arg(longitude) as arg_longitude, \
             agmarshall.VARIANT_arg(latitude) as arg_latitude, \
             agmarshall.DOUBLE_arg(altitude) as arg_altitude, \
             agmarshall.AgEnum_arg(AgECrdnReferenceShapeType, referenceShape) as arg_referenceShape, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_CreatePointFixedOnCentralBody"](arg_pointName.COM_val, arg_description.COM_val, arg_longitude.COM_val, arg_latitude.COM_val, arg_altitude.COM_val, arg_referenceShape.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{18FA11DA-BC93-4467-B53F-4D894739C3A3}", ICrdnPointFactory)
agcls.AgTypeNameMap["ICrdnPointFactory"] = ICrdnPointFactory

class ICrdnPlaneFactory(object):
    """A Factory object to create VGT planes."""
    _uuid = "{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneFactory = agcom.GUID(ICrdnPlaneFactory._uuid)
        vtable_offset_local = ICrdnPlaneFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneFactory.__dict__ and type(ICrdnPlaneFactory.__dict__[attrname]) == property:
            return ICrdnPlaneFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneFactory.")
    
    def Create(self, planeName:str, description:str, planeType:"AgECrdnPlaneType") -> "ICrdnPlane":
        """Creates a VGT plane using the specified name, description and type."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnPlaneType, planeType) as arg_planeType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_planeName.COM_val, arg_description.COM_val, arg_planeType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnPlaneType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnPlaneType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}", ICrdnPlaneFactory)
agcls.AgTypeNameMap["ICrdnPlaneFactory"] = ICrdnPlaneFactory

class ICrdnAngleFactory(object):
    """A Factory object to create angles."""
    _uuid = "{703883F3-9716-4D37-8930-184BECDE1461}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Create"] = _raise_uninitialized_error
        self.__dict__["_IsTypeSupported"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFactory._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleFactory from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleFactory = agcom.GUID(ICrdnAngleFactory._uuid)
        vtable_offset_local = ICrdnAngleFactory._vtable_offset - 1
        self.__dict__["_Create"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFactory, vtable_offset_local+1, agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_IsTypeSupported"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFactory, vtable_offset_local+2, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleFactory.__dict__ and type(ICrdnAngleFactory.__dict__[attrname]) == property:
            return ICrdnAngleFactory.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleFactory.")
    
    def Create(self, angleName:str, description:str, angleType:"AgECrdnAngleType") -> "ICrdnAngle":
        """Creates a VGT angle using specified name, description and type."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName, \
             agmarshall.BSTR_arg(description) as arg_description, \
             agmarshall.AgEnum_arg(AgECrdnAngleType, angleType) as arg_angleType, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Create"](arg_angleName.COM_val, arg_description.COM_val, arg_angleType.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def IsTypeSupported(self, type:"AgECrdnAngleType") -> bool:
        """Returns true if the type is supported."""
        with agmarshall.AgEnum_arg(AgECrdnAngleType, type) as arg_type, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_IsTypeSupported"](arg_type.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{703883F3-9716-4D37-8930-184BECDE1461}", ICrdnAngleFactory)
agcls.AgTypeNameMap["ICrdnAngleFactory"] = ICrdnAngleFactory

class ICrdnVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""
    _uuid = "{4412F0DD-2138-4653-8D20-9B4A0CA450D4}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorGroup = agcom.GUID(ICrdnVectorGroup._uuid)
        vtable_offset_local = ICrdnVectorGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorGroup.__dict__ and type(ICrdnVectorGroup.__dict__[attrname]) == property:
            return ICrdnVectorGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnVector":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, vectorName:str) -> None:
        """Removes a specified vector."""
        with agmarshall.BSTR_arg(vectorName) as arg_vectorName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_vectorName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnVectorFactory":
        """Returns a Factory object used to create custom vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnVector":
        """Returns a vector by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnVector":
        """Retrieves a vector from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnVector":
        """Retrieves a vector from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4412F0DD-2138-4653-8D20-9B4A0CA450D4}", ICrdnVectorGroup)
agcls.AgTypeNameMap["ICrdnVectorGroup"] = ICrdnVectorGroup

class ICrdnPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""
    _uuid = "{6FB1415A-EC77-476F-B650-CC6813BE740C}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointGroup = agcom.GUID(ICrdnPointGroup._uuid)
        vtable_offset_local = ICrdnPointGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointGroup.__dict__ and type(ICrdnPointGroup.__dict__[attrname]) == property:
            return ICrdnPointGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnPoint":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, pointName:str) -> None:
        """Removes a specified point by name."""
        with agmarshall.BSTR_arg(pointName) as arg_pointName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_pointName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnPointFactory":
        """Returns a Factory object used to create custom points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnPoint":
        """Returns a point by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "ICrdnPointCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnPoint":
        """Retrieves a point from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnPoint":
        """Retrieves a point from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6FB1415A-EC77-476F-B650-CC6813BE740C}", ICrdnPointGroup)
agcls.AgTypeNameMap["ICrdnPointGroup"] = ICrdnPointGroup

class ICrdnAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""
    _uuid = "{C025A1BA-F856-4B26-9134-BBCC785B6C45}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleGroup = agcom.GUID(ICrdnAngleGroup._uuid)
        vtable_offset_local = ICrdnAngleGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleGroup.__dict__ and type(ICrdnAngleGroup.__dict__[attrname]) == property:
            return ICrdnAngleGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnAngle":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, angleName:str) -> None:
        """Removes a specified Angle."""
        with agmarshall.BSTR_arg(angleName) as arg_angleName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_angleName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnAngleFactory":
        """Returns a Factory object used to create custom angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnAngle":
        """Returns an angle by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnAngle":
        """Retrieves an angle from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnAngle":
        """Retrieves an angle from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C025A1BA-F856-4B26-9134-BBCC785B6C45}", ICrdnAngleGroup)
agcls.AgTypeNameMap["ICrdnAngleGroup"] = ICrdnAngleGroup

class ICrdnAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""
    _uuid = "{21C67E72-992F-481F-B77F-1DFC43B4B705}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesGroup = agcom.GUID(ICrdnAxesGroup._uuid)
        vtable_offset_local = ICrdnAxesGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesGroup.__dict__ and type(ICrdnAxesGroup.__dict__[attrname]) == property:
            return ICrdnAxesGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnAxes":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, axesName:str) -> None:
        """Removes a specified Axes."""
        with agmarshall.BSTR_arg(axesName) as arg_axesName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_axesName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnAxesFactory":
        """Returns a Factory object used to create custom axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnAxes":
        """Returns an axes by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "ICrdnAxesCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnAxes":
        """Retrieves an axes from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnAxes":
        """Retrieves an axes from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{21C67E72-992F-481F-B77F-1DFC43B4B705}", ICrdnAxesGroup)
agcls.AgTypeNameMap["ICrdnAxesGroup"] = ICrdnAxesGroup

class ICrdnPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""
    _uuid = "{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}"
    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneGroup = agcom.GUID(ICrdnPlaneGroup._uuid)
        vtable_offset_local = ICrdnPlaneGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+8, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneGroup, vtable_offset_local+9, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneGroup.__dict__ and type(ICrdnPlaneGroup.__dict__[attrname]) == property:
            return ICrdnPlaneGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnPlane":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, planeName:str) -> None:
        """Removes a specified Plane."""
        with agmarshall.BSTR_arg(planeName) as arg_planeName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_planeName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the group."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnPlaneFactory":
        """Returns a Factory object used to create custom planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnPlane":
        """Returns an Plane by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnPlane":
        """Retrieves a plane from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnPlane":
        """Retrieves a plane from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}", ICrdnPlaneGroup)
agcls.AgTypeNameMap["ICrdnPlaneGroup"] = ICrdnPlaneGroup

class ICrdnSystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""
    _uuid = "{05FF6322-1363-4B66-933E-03EA158B7523}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_GetContext"] = _raise_uninitialized_error
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetFactory"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCommonTasks"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemGroup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemGroup from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemGroup = agcom.GUID(ICrdnSystemGroup._uuid)
        vtable_offset_local = ICrdnSystemGroup._vtable_offset - 1
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetContext"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+3, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetFactory"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+6, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetCommonTasks"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemGroup, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemGroup.__dict__ and type(ICrdnSystemGroup.__dict__[attrname]) == property:
            return ICrdnSystemGroup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemGroup.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnSystem":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Remove(self, systemName:str) -> None:
        """Removes a specified System."""
        with agmarshall.BSTR_arg(systemName) as arg_systemName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_systemName.COM_val))

    @property
    def Context(self) -> "ICrdnContext":
        """Returns a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetContext"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Factory(self) -> "ICrdnSystemFactory":
        """Returns a Factory object used to create custom VGT systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFactory"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdnSystem":
        """Returns a System by name or at a specified position."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CommonTasks(self) -> "ICrdnSystemCommonTasks":
        """Provides access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCommonTasks"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdnSystem":
        """Retrieves a system from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdnSystem":
        """Retrieves a system from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{05FF6322-1363-4B66-933E-03EA158B7523}", ICrdnSystemGroup)
agcls.AgTypeNameMap["ICrdnSystemGroup"] = ICrdnSystemGroup

class ICrdnProvider(object):
    """Allows accessing existing Vector Geometry Tool components."""
    _uuid = "{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectors"] = _raise_uninitialized_error
        self.__dict__["_GetPoints"] = _raise_uninitialized_error
        self.__dict__["_GetAngles"] = _raise_uninitialized_error
        self.__dict__["_GetAxes"] = _raise_uninitialized_error
        self.__dict__["_GetPlanes"] = _raise_uninitialized_error
        self.__dict__["_GetSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        self.__dict__["_GetEvents"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervals"] = _raise_uninitialized_error
        self.__dict__["_GetCalcScalars"] = _raise_uninitialized_error
        self.__dict__["_GetEventArrays"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalLists"] = _raise_uninitialized_error
        self.__dict__["_GetEventIntervalCollections"] = _raise_uninitialized_error
        self.__dict__["_GetParameterSets"] = _raise_uninitialized_error
        self.__dict__["_GetConditions"] = _raise_uninitialized_error
        self.__dict__["_Supports"] = _raise_uninitialized_error
        self.__dict__["_GetConditionSets"] = _raise_uninitialized_error
        self.__dict__["_Import"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeGrids"] = _raise_uninitialized_error
        self.__dict__["_GetVolumes"] = _raise_uninitialized_error
        self.__dict__["_GetVolumeCalcs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnProvider._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnProvider from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnProvider = agcom.GUID(ICrdnProvider._uuid)
        vtable_offset_local = ICrdnProvider._vtable_offset - 1
        self.__dict__["_GetVectors"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetPoints"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAngles"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetPlanes"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetSystems"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetEvents"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetCalcScalars"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetEventArrays"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalLists"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_GetEventIntervalCollections"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_GetParameterSets"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetConditions"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_Supports"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetConditionSets"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_Import"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+19, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeGrids"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+20, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumes"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+21, POINTER(agcom.PVOID))
        self.__dict__["_GetVolumeCalcs"] = IAGFUNCTYPE(pUnk, IID_ICrdnProvider, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnProvider.__dict__ and type(ICrdnProvider.__dict__[attrname]) == property:
            return ICrdnProvider.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnProvider.")
    
    @property
    def Vectors(self) -> "ICrdnVectorGroup":
        """Returns a group of vectors."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectors"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Points(self) -> "ICrdnPointGroup":
        """Returns a group of points."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPoints"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Angles(self) -> "ICrdnAngleGroup":
        """Returns a group of angles."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngles"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Axes(self) -> "ICrdnAxesGroup":
        """Returns a group of axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Planes(self) -> "ICrdnPlaneGroup":
        """Returns a group of planes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlanes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Systems(self) -> "ICrdnSystemGroup":
        """Returns a group of systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "ICrdnWellKnownSystems":
        """Returns well-known systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "ICrdnWellKnownAxes":
        """Returns well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Events(self) -> "ICrdnEventGroup":
        """Returns a group of events."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEvents"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervals(self) -> "ICrdnEventIntervalGroup":
        """Returns a group of event intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcScalars(self) -> "ICrdnCalcScalarGroup":
        """Returns a group of calc scalars."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcScalars"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventArrays(self) -> "ICrdnEventArrayGroup":
        """Returns a group of event arrays."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventArrays"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalLists(self) -> "ICrdnEventIntervalListGroup":
        """Returns a group of event interval lists."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalLists"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def EventIntervalCollections(self) -> "ICrdnEventIntervalCollectionGroup":
        """Returns a group of event interval collections."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEventIntervalCollections"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ParameterSets(self) -> "ICrdnParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParameterSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Conditions(self) -> "ICrdnConditionGroup":
        """Returns a group of condition objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Supports(self, feature:"AgECrdnKind") -> bool:
        """Tests whether the specified VGT feature is supported."""
        with agmarshall.AgEnum_arg(AgECrdnKind, feature) as arg_feature, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Supports"](arg_feature.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ConditionSets(self) -> "ICrdnConditionSetGroup":
        """Returns a group of condition set objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetConditionSets"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Import(self, filename:str) -> "ICrdnCollection":
        """Imports Analysis Workbench components from a file."""
        with agmarshall.BSTR_arg(filename) as arg_filename, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Import"](arg_filename.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeGrids(self) -> "ICrdnVolumeGridGroup":
        """Returns a group of volume grid objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeGrids"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Volumes(self) -> "ICrdnVolumeGroup":
        """Returns a group of volume objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VolumeCalcs(self) -> "ICrdnVolumeCalcGroup":
        """Returns a group of volume calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVolumeCalcs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}", ICrdnProvider)
agcls.AgTypeNameMap["ICrdnProvider"] = ICrdnProvider

class ICrdnRoot(object):
    """Represents a VGT root object."""
    _uuid = "{FEF8B20D-5EEB-4299-8775-038EE30AA30B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTemplateProvider"] = _raise_uninitialized_error
        self.__dict__["_GetProvider"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownSystems"] = _raise_uninitialized_error
        self.__dict__["_GetWellKnownAxes"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnRoot._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnRoot from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnRoot = agcom.GUID(ICrdnRoot._uuid)
        vtable_offset_local = ICrdnRoot._vtable_offset - 1
        self.__dict__["_GetTemplateProvider"] = IAGFUNCTYPE(pUnk, IID_ICrdnRoot, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvider"] = IAGFUNCTYPE(pUnk, IID_ICrdnRoot, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownSystems"] = IAGFUNCTYPE(pUnk, IID_ICrdnRoot, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetWellKnownAxes"] = IAGFUNCTYPE(pUnk, IID_ICrdnRoot, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnRoot.__dict__ and type(ICrdnRoot.__dict__[attrname]) == property:
            return ICrdnRoot.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnRoot.")
    
    def GetTemplateProvider(self, className:str) -> "ICrdnProvider":
        """Returns a template provider. The method takes a class name (i.e. \"Satellite\", \"Facility\", etc.)"""
        with agmarshall.BSTR_arg(className) as arg_className, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTemplateProvider"](arg_className.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetProvider(self, instPath:str) -> "ICrdnProvider":
        """Returns an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. \"Satellite/Satellite1\", \"CentralBody/Earth\", etc.)"""
        with agmarshall.BSTR_arg(instPath) as arg_instPath, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvider"](arg_instPath.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownSystems(self) -> "ICrdnWellKnownSystems":
        """Returns the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownSystems"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def WellKnownAxes(self) -> "ICrdnWellKnownAxes":
        """Returns the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetWellKnownAxes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FEF8B20D-5EEB-4299-8775-038EE30AA30B}", ICrdnRoot)
agcls.AgTypeNameMap["ICrdnRoot"] = ICrdnRoot

class ICrdnWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""
    _uuid = "{230A8949-FB8F-415E-A786-5EED50AEB11B}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownEarthSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownEarthSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownEarthSystems = agcom.GUID(ICrdnWellKnownEarthSystems._uuid)
        vtable_offset_local = ICrdnWellKnownEarthSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownEarthSystems.__dict__ and type(ICrdnWellKnownEarthSystems.__dict__[attrname]) == property:
            return ICrdnWellKnownEarthSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownEarthSystems.")
    
    @property
    def Fixed(self) -> "ICrdnSystem":
        """Earth's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ICrdnSystem":
        """Earth's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ICrdnSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{230A8949-FB8F-415E-A786-5EED50AEB11B}", ICrdnWellKnownEarthSystems)
agcls.AgTypeNameMap["ICrdnWellKnownEarthSystems"] = ICrdnWellKnownEarthSystems

class ICrdnWellKnownEarthAxes(object):
    """Well-known Earth's axes."""
    _uuid = "{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownEarthAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownEarthAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownEarthAxes = agcom.GUID(ICrdnWellKnownEarthAxes._uuid)
        vtable_offset_local = ICrdnWellKnownEarthAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownEarthAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownEarthAxes.__dict__ and type(ICrdnWellKnownEarthAxes.__dict__[attrname]) == property:
            return ICrdnWellKnownEarthAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownEarthAxes.")
    
    @property
    def Fixed(self) -> "ICrdnAxes":
        """Earth's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ICrdnAxes":
        """Earth's ICRF axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ICrdnAxes":
        """Earth's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "ICrdnAxes":
        """The Earth's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}", ICrdnWellKnownEarthAxes)
agcls.AgTypeNameMap["ICrdnWellKnownEarthAxes"] = ICrdnWellKnownEarthAxes

class ICrdnWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""
    _uuid = "{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        self.__dict__["_GetBarycenter"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownSunSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownSunSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownSunSystems = agcom.GUID(ICrdnWellKnownSunSystems._uuid)
        vtable_offset_local = ICrdnWellKnownSunSystems._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunSystems, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunSystems, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetBarycenter"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunSystems, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownSunSystems.__dict__ and type(ICrdnWellKnownSunSystems.__dict__[attrname]) == property:
            return ICrdnWellKnownSunSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownSunSystems.")
    
    @property
    def Fixed(self) -> "ICrdnSystem":
        """The Sun's Fixed coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ICrdnSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ICrdnSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "ICrdnSystem":
        """The Sun's J2000 coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Barycenter(self) -> "ICrdnSystem":
        """The Inertial system at the Sun's barycenter."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBarycenter"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}", ICrdnWellKnownSunSystems)
agcls.AgTypeNameMap["ICrdnWellKnownSunSystems"] = ICrdnWellKnownSunSystems

class ICrdnWellKnownSunAxes(object):
    """Well-known Sun's axes."""
    _uuid = "{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFixed"] = _raise_uninitialized_error
        self.__dict__["_GetICRF"] = _raise_uninitialized_error
        self.__dict__["_GetInertial"] = _raise_uninitialized_error
        self.__dict__["_GetJ2000"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownSunAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownSunAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownSunAxes = agcom.GUID(ICrdnWellKnownSunAxes._uuid)
        vtable_offset_local = ICrdnWellKnownSunAxes._vtable_offset - 1
        self.__dict__["_GetFixed"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetICRF"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInertial"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunAxes, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetJ2000"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSunAxes, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownSunAxes.__dict__ and type(ICrdnWellKnownSunAxes.__dict__[attrname]) == property:
            return ICrdnWellKnownSunAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownSunAxes.")
    
    @property
    def Fixed(self) -> "ICrdnAxes":
        """Sun's Fixed axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixed"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ICRF(self) -> "ICrdnAxes":
        """Sun's ICRF."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetICRF"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Inertial(self) -> "ICrdnAxes":
        """Sun's Inertial axes (as defined in STK)."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertial"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def J2000(self) -> "ICrdnAxes":
        """The Sun's J2000 axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2000"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}", ICrdnWellKnownSunAxes)
agcls.AgTypeNameMap["ICrdnWellKnownSunAxes"] = ICrdnWellKnownSunAxes

class ICrdnWellKnownSystems(object):
    """Well-known coordinate reference systems."""
    _uuid = "{D93C6B6F-D457-4D20-BA7B-960773E3652B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownSystems._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownSystems from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownSystems = agcom.GUID(ICrdnWellKnownSystems._uuid)
        vtable_offset_local = ICrdnWellKnownSystems._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSystems, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownSystems, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownSystems.__dict__ and type(ICrdnWellKnownSystems.__dict__[attrname]) == property:
            return ICrdnWellKnownSystems.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownSystems.")
    
    @property
    def Earth(self) -> "ICrdnWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "ICrdnWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D93C6B6F-D457-4D20-BA7B-960773E3652B}", ICrdnWellKnownSystems)
agcls.AgTypeNameMap["ICrdnWellKnownSystems"] = ICrdnWellKnownSystems

class ICrdnWellKnownAxes(object):
    """Well-known Axes."""
    _uuid = "{B2546963-CC14-4F18-91DE-7091EBEA34C5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEarth"] = _raise_uninitialized_error
        self.__dict__["_GetSun"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnWellKnownAxes._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnWellKnownAxes from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnWellKnownAxes = agcom.GUID(ICrdnWellKnownAxes._uuid)
        vtable_offset_local = ICrdnWellKnownAxes._vtable_offset - 1
        self.__dict__["_GetEarth"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownAxes, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetSun"] = IAGFUNCTYPE(pUnk, IID_ICrdnWellKnownAxes, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnWellKnownAxes.__dict__ and type(ICrdnWellKnownAxes.__dict__[attrname]) == property:
            return ICrdnWellKnownAxes.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnWellKnownAxes.")
    
    @property
    def Earth(self) -> "ICrdnWellKnownEarthAxes":
        """Earth's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarth"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Sun(self) -> "ICrdnWellKnownSunAxes":
        """The Sun's well-known axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSun"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B2546963-CC14-4F18-91DE-7091EBEA34C5}", ICrdnWellKnownAxes)
agcls.AgTypeNameMap["ICrdnWellKnownAxes"] = ICrdnWellKnownAxes

class ICrdnAngleFindAngleResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngle method."""
    _uuid = "{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleFindAngleResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleFindAngleResult = agcom.GUID(ICrdnAngleFindAngleResult._uuid)
        vtable_offset_local = ICrdnAngleFindAngleResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindAngleResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindAngleResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleFindAngleResult.__dict__ and type(ICrdnAngleFindAngleResult.__dict__[attrname]) == property:
            return ICrdnAngleFindAngleResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleFindAngleResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}", ICrdnAngleFindAngleResult)
agcls.AgTypeNameMap["ICrdnAngleFindAngleResult"] = ICrdnAngleFindAngleResult

class ICrdnAngleFindAngleWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindAngleWithRate method."""
    _uuid = "{E46570BA-661C-4974-A780-32DFEAFB9630}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleFindAngleWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleFindAngleWithRateResult = agcom.GUID(ICrdnAngleFindAngleWithRateResult._uuid)
        vtable_offset_local = ICrdnAngleFindAngleWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindAngleWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindAngleWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindAngleWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleFindAngleWithRateResult.__dict__ and type(ICrdnAngleFindAngleWithRateResult.__dict__[attrname]) == property:
            return ICrdnAngleFindAngleWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleFindAngleWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E46570BA-661C-4974-A780-32DFEAFB9630}", ICrdnAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["ICrdnAngleFindAngleWithRateResult"] = ICrdnAngleFindAngleWithRateResult

class ICrdnAngleFindWithRateResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinatesWithRate method."""
    _uuid = "{C4E80CE7-2E38-4364-96D5-004EE425471D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetAngleRate"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleFindWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleFindWithRateResult = agcom.GUID(ICrdnAngleFindWithRateResult._uuid)
        vtable_offset_local = ICrdnAngleFindWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetAngleRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleFindWithRateResult.__dict__ and type(ICrdnAngleFindWithRateResult.__dict__[attrname]) == property:
            return ICrdnAngleFindWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleFindWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngleRate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in \"AngleRateUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleRate"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C4E80CE7-2E38-4364-96D5-004EE425471D}", ICrdnAngleFindWithRateResult)
agcls.AgTypeNameMap["ICrdnAngleFindWithRateResult"] = ICrdnAngleFindWithRateResult

class ICrdnAngleFindResult(object):
    """Contains the results returned with IAgCrdnAngle.FindCoordinates method."""
    _uuid = "{36DD880D-214E-4987-A70A-EA31E7E26B84}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngle"] = _raise_uninitialized_error
        self.__dict__["_GetVectorFrom"] = _raise_uninitialized_error
        self.__dict__["_GetVectorTo"] = _raise_uninitialized_error
        self.__dict__["_GetVectorAbout"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAngleFindResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAngleFindResult = agcom.GUID(ICrdnAngleFindResult._uuid)
        vtable_offset_local = ICrdnAngleFindResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngle"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetVectorFrom"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorTo"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetVectorAbout"] = IAGFUNCTYPE(pUnk, IID_ICrdnAngleFindResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAngleFindResult.__dict__ and type(ICrdnAngleFindResult.__dict__[attrname]) == property:
            return ICrdnAngleFindResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAngleFindResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in \"AngleUnit\" dimension."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def VectorFrom(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorFrom"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorTo(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorTo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VectorAbout(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorAbout"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{36DD880D-214E-4987-A70A-EA31E7E26B84}", ICrdnAngleFindResult)
agcls.AgTypeNameMap["ICrdnAngleFindResult"] = ICrdnAngleFindResult

class ICrdnAxesTransformResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFrom method."""
    _uuid = "{D4EC98BE-0D20-4284-96D0-3C40A3100A06}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesTransformResult = agcom.GUID(ICrdnAxesTransformResult._uuid)
        vtable_offset_local = ICrdnAxesTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesTransformResult.__dict__ and type(ICrdnAxesTransformResult.__dict__[attrname]) == property:
            return ICrdnAxesTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D4EC98BE-0D20-4284-96D0-3C40A3100A06}", ICrdnAxesTransformResult)
agcls.AgTypeNameMap["ICrdnAxesTransformResult"] = ICrdnAxesTransformResult

class ICrdnAxesTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.TransformFromWithRate method."""
    _uuid = "{6434061B-3584-49FF-99C5-2C2D6B385CF1}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesTransformWithRateResult = agcom.GUID(ICrdnAxesTransformWithRateResult._uuid)
        vtable_offset_local = ICrdnAxesTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesTransformWithRateResult.__dict__ and type(ICrdnAxesTransformWithRateResult.__dict__[attrname]) == property:
            return ICrdnAxesTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6434061B-3584-49FF-99C5-2C2D6B385CF1}", ICrdnAxesTransformWithRateResult)
agcls.AgTypeNameMap["ICrdnAxesTransformWithRateResult"] = ICrdnAxesTransformWithRateResult

class ICrdnPlaneFindInAxesResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxes method."""
    _uuid = "{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneFindInAxesResult = agcom.GUID(ICrdnPlaneFindInAxesResult._uuid)
        vtable_offset_local = ICrdnPlaneFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneFindInAxesResult.__dict__ and type(ICrdnPlaneFindInAxesResult.__dict__[attrname]) == property:
            return ICrdnPlaneFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}", ICrdnPlaneFindInAxesResult)
agcls.AgTypeNameMap["ICrdnPlaneFindInAxesResult"] = ICrdnPlaneFindInAxesResult

class ICrdnPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInAxesWithRate method."""
    _uuid = "{CD4424A8-28CF-4AE5-8242-480B6625F0EB}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneFindInAxesWithRateResult = agcom.GUID(ICrdnPlaneFindInAxesWithRateResult._uuid)
        vtable_offset_local = ICrdnPlaneFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInAxesWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneFindInAxesWithRateResult.__dict__ and type(ICrdnPlaneFindInAxesWithRateResult.__dict__[attrname]) == property:
            return ICrdnPlaneFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CD4424A8-28CF-4AE5-8242-480B6625F0EB}", ICrdnPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["ICrdnPlaneFindInAxesWithRateResult"] = ICrdnPlaneFindInAxesWithRateResult

class ICrdnPlaneFindInSystemResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystem method."""
    _uuid = "{85D16885-3BEB-4590-963B-F1CC8D016097}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneFindInSystemResult = agcom.GUID(ICrdnPlaneFindInSystemResult._uuid)
        vtable_offset_local = ICrdnPlaneFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneFindInSystemResult.__dict__ and type(ICrdnPlaneFindInSystemResult.__dict__[attrname]) == property:
            return ICrdnPlaneFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{85D16885-3BEB-4590-963B-F1CC8D016097}", ICrdnPlaneFindInSystemResult)
agcls.AgTypeNameMap["ICrdnPlaneFindInSystemResult"] = ICrdnPlaneFindInSystemResult

class ICrdnPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPlane.FindInSystemWithRate method."""
    _uuid = "{888499CB-4BF7-46A6-A11B-3FFC05EA6804}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOriginPosition"] = _raise_uninitialized_error
        self.__dict__["_GetOriginVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetXAxis"] = _raise_uninitialized_error
        self.__dict__["_GetXAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetYAxisRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPlaneFindInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPlaneFindInSystemWithRateResult = agcom.GUID(ICrdnPlaneFindInSystemWithRateResult._uuid)
        vtable_offset_local = ICrdnPlaneFindInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOriginPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOriginVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetXAxisRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetYAxisRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnPlaneFindInSystemWithRateResult, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPlaneFindInSystemWithRateResult.__dict__ and type(ICrdnPlaneFindInSystemWithRateResult.__dict__[attrname]) == property:
            return ICrdnPlaneFindInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPlaneFindInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def OriginPosition(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def OriginVelocity(self) -> "ICartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def XAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetXAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def YAxisRate(self) -> "ICartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxisRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{888499CB-4BF7-46A6-A11B-3FFC05EA6804}", ICrdnPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["ICrdnPlaneFindInSystemWithRateResult"] = ICrdnPlaneFindInSystemWithRateResult

class ICrdnAxesFindInAxesResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxes method."""
    _uuid = "{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesFindInAxesResult = agcom.GUID(ICrdnAxesFindInAxesResult._uuid)
        vtable_offset_local = ICrdnAxesFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesFindInAxesResult.__dict__ and type(ICrdnAxesFindInAxesResult.__dict__[attrname]) == property:
            return ICrdnAxesFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}", ICrdnAxesFindInAxesResult)
agcls.AgTypeNameMap["ICrdnAxesFindInAxesResult"] = ICrdnAxesFindInAxesResult

class ICrdnAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnAxes.FindInAxesWithRate method."""
    _uuid = "{72644DD0-D129-4D7A-8A81-586E86E639BD}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetAngularVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesFindInAxesWithRateResult = agcom.GUID(ICrdnAxesFindInAxesWithRateResult._uuid)
        vtable_offset_local = ICrdnAxesFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetAngularVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesFindInAxesWithRateResult.__dict__ and type(ICrdnAxesFindInAxesWithRateResult.__dict__[attrname]) == property:
            return ICrdnAxesFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def AngularVelocity(self) -> "ICartesian3Vector":
        """Axes' angular velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngularVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """The axes' orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{72644DD0-D129-4D7A-8A81-586E86E639BD}", ICrdnAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["ICrdnAxesFindInAxesWithRateResult"] = ICrdnAxesFindInAxesWithRateResult

class ICrdnPointLocateInSystemResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystem method."""
    _uuid = "{84453DEC-5D01-4D47-A177-F8A737F0496D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointLocateInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointLocateInSystemResult = agcom.GUID(ICrdnPointLocateInSystemResult._uuid)
        vtable_offset_local = ICrdnPointLocateInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLocateInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLocateInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointLocateInSystemResult.__dict__ and type(ICrdnPointLocateInSystemResult.__dict__[attrname]) == property:
            return ICrdnPointLocateInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointLocateInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{84453DEC-5D01-4D47-A177-F8A737F0496D}", ICrdnPointLocateInSystemResult)
agcls.AgTypeNameMap["ICrdnPointLocateInSystemResult"] = ICrdnPointLocateInSystemResult

class ICrdnPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IAgCrdnPoint.LocateInSystemWithRate method."""
    _uuid = "{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointLocateInSystemWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointLocateInSystemWithRateResult = agcom.GUID(ICrdnPointLocateInSystemWithRateResult._uuid)
        vtable_offset_local = ICrdnPointLocateInSystemWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLocateInSystemWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLocateInSystemWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointLocateInSystemWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointLocateInSystemWithRateResult.__dict__ and type(ICrdnPointLocateInSystemWithRateResult.__dict__[attrname]) == property:
            return ICrdnPointLocateInSystemWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointLocateInSystemWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The point velocity in the specified coordinate system."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}", ICrdnPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["ICrdnPointLocateInSystemWithRateResult"] = ICrdnPointLocateInSystemWithRateResult

class ICrdnSystemTransformResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFrom and IAgCrdnSystem.TransformTo methods."""
    _uuid = "{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemTransformResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemTransformResult = agcom.GUID(ICrdnSystemTransformResult._uuid)
        vtable_offset_local = ICrdnSystemTransformResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemTransformResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemTransformResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemTransformResult.__dict__ and type(ICrdnSystemTransformResult.__dict__[attrname]) == property:
            return ICrdnSystemTransformResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemTransformResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}", ICrdnSystemTransformResult)
agcls.AgTypeNameMap["ICrdnSystemTransformResult"] = ICrdnSystemTransformResult

class ICrdnSystemTransformWithRateResult(object):
    """Contains the results returned with IAgCrdnSystem.TransformFromWithRate and IAgCrdnSystem.TransformToWithRate methods."""
    _uuid = "{A9E92350-230F-45C7-A617-DB684FF89C78}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemTransformWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemTransformWithRateResult = agcom.GUID(ICrdnSystemTransformWithRateResult._uuid)
        vtable_offset_local = ICrdnSystemTransformWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemTransformWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemTransformWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemTransformWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemTransformWithRateResult.__dict__ and type(ICrdnSystemTransformWithRateResult.__dict__[attrname]) == property:
            return ICrdnSystemTransformWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemTransformWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """The vector's velocity."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A9E92350-230F-45C7-A617-DB684FF89C78}", ICrdnSystemTransformWithRateResult)
agcls.AgTypeNameMap["ICrdnSystemTransformWithRateResult"] = ICrdnSystemTransformWithRateResult

class ICrdnSystemFindInSystemResult(object):
    """Contains the results returned with IAgCrdnSystem.FindInSystem method."""
    _uuid = "{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetPosition"] = _raise_uninitialized_error
        self.__dict__["_GetVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemFindInSystemResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnSystemFindInSystemResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnSystemFindInSystemResult = agcom.GUID(ICrdnSystemFindInSystemResult._uuid)
        vtable_offset_local = ICrdnSystemFindInSystemResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFindInSystemResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetPosition"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFindInSystemResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetVelocity"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFindInSystemResult, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFindInSystemResult, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_ICrdnSystemFindInSystemResult, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnSystemFindInSystemResult.__dict__ and type(ICrdnSystemFindInSystemResult.__dict__[attrname]) == property:
            return ICrdnSystemFindInSystemResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnSystemFindInSystemResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Position(self) -> "ICartesian3Vector":
        """A position vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosition"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocity(self) -> "ICartesian3Vector":
        """A velocity vector."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocity"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """Rate of change."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Orientation(self) -> "IOrientation":
        """Orientation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}", ICrdnSystemFindInSystemResult)
agcls.AgTypeNameMap["ICrdnSystemFindInSystemResult"] = ICrdnSystemFindInSystemResult

class ICrdnVectorFindInAxesResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxes method."""
    _uuid = "{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFindInAxesResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFindInAxesResult = agcom.GUID(ICrdnVectorFindInAxesResult._uuid)
        vtable_offset_local = ICrdnVectorFindInAxesResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFindInAxesResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFindInAxesResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFindInAxesResult.__dict__ and type(ICrdnVectorFindInAxesResult.__dict__[attrname]) == property:
            return ICrdnVectorFindInAxesResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFindInAxesResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}", ICrdnVectorFindInAxesResult)
agcls.AgTypeNameMap["ICrdnVectorFindInAxesResult"] = ICrdnVectorFindInAxesResult

class ICrdnVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IAgCrdnVector.FindInAxesWithRate method."""
    _uuid = "{A5EB9B7C-559C-4ABB-839E-47109CDC8446}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetVector"] = _raise_uninitialized_error
        self.__dict__["_GetRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesWithRateResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnVectorFindInAxesWithRateResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnVectorFindInAxesWithRateResult = agcom.GUID(ICrdnVectorFindInAxesWithRateResult._uuid)
        vtable_offset_local = ICrdnVectorFindInAxesWithRateResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFindInAxesWithRateResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVector"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFindInAxesWithRateResult, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetRate"] = IAGFUNCTYPE(pUnk, IID_ICrdnVectorFindInAxesWithRateResult, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnVectorFindInAxesWithRateResult.__dict__ and type(ICrdnVectorFindInAxesWithRateResult.__dict__[attrname]) == property:
            return ICrdnVectorFindInAxesWithRateResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnVectorFindInAxesWithRateResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Rate(self) -> "ICartesian3Vector":
        """The vector rate in a specified axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetRate"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{A5EB9B7C-559C-4ABB-839E-47109CDC8446}", ICrdnVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["ICrdnVectorFindInAxesWithRateResult"] = ICrdnVectorFindInAxesWithRateResult

class ICrdnMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""
    _uuid = "{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnMethodCallResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnMethodCallResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnMethodCallResult = agcom.GUID(ICrdnMethodCallResult._uuid)
        vtable_offset_local = ICrdnMethodCallResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnMethodCallResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnMethodCallResult.__dict__ and type(ICrdnMethodCallResult.__dict__[attrname]) == property:
            return ICrdnMethodCallResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnMethodCallResult.")
    
    @property
    def IsValid(self) -> bool:
        """True indicates the method call was successful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}", ICrdnMethodCallResult)
agcls.AgTypeNameMap["ICrdnMethodCallResult"] = ICrdnMethodCallResult

class ICrdnCentralBody(object):
    """The interface represents a central body."""
    _uuid = "{8742150E-1663-4DCC-A442-278479FF93DC}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCentralBody from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCentralBody = agcom.GUID(ICrdnCentralBody._uuid)
        vtable_offset_local = ICrdnCentralBody._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBody, vtable_offset_local+1, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCentralBody.__dict__ and type(ICrdnCentralBody.__dict__[attrname]) == property:
            return ICrdnCentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCentralBody.")
    
    @property
    def Name(self) -> str:
        """A name of the central body."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8742150E-1663-4DCC-A442-278479FF93DC}", ICrdnCentralBody)
agcls.AgTypeNameMap["ICrdnCentralBody"] = ICrdnCentralBody

class ICrdnCentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""
    _uuid = "{40596A74-4E5F-4406-85FF-70FA79893BFC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetPath"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBody"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCentralBodyRefTo._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCentralBodyRefTo from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCentralBodyRefTo = agcom.GUID(ICrdnCentralBodyRefTo._uuid)
        vtable_offset_local = ICrdnCentralBodyRefTo._vtable_offset - 1
        self.__dict__["_SetPath"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyRefTo, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_SetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyRefTo, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetCentralBody"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyRefTo, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCentralBodyRefTo.__dict__ and type(ICrdnCentralBodyRefTo.__dict__[attrname]) == property:
            return ICrdnCentralBodyRefTo.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCentralBodyRefTo.")
    
    def SetPath(self, path:str) -> None:
        """Sets a new central body using specified path."""
        with agmarshall.BSTR_arg(path) as arg_path:
            agcls.evaluate_hresult(self.__dict__["_SetPath"](arg_path.COM_val))

    def SetCentralBody(self, centralBody:"ICrdnCentralBody") -> None:
        """Sets a new central body."""
        with agmarshall.AgInterface_in_arg(centralBody, ICrdnCentralBody) as arg_centralBody:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBody"](arg_centralBody.COM_val))

    def GetCentralBody(self) -> "ICrdnCentralBody":
        """Returns a central body or null if the central body is invalid."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBody"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{40596A74-4E5F-4406-85FF-70FA79893BFC}", ICrdnCentralBodyRefTo)
agcls.AgTypeNameMap["ICrdnCentralBodyRefTo"] = ICrdnCentralBodyRefTo

class ICrdnCentralBodyCollection(object):
    """A collection of central body names."""
    _uuid = "{FB32C9FA-327D-4AF9-9330-7DE8854F827E}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCentralBodyCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCentralBodyCollection = agcom.GUID(ICrdnCentralBodyCollection._uuid)
        vtable_offset_local = ICrdnCentralBodyCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_ICrdnCentralBodyCollection, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCentralBodyCollection.__dict__ and type(ICrdnCentralBodyCollection.__dict__[attrname]) == property:
            return ICrdnCentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCentralBodyCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> str:
        """Returns a central body name at a specified index."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, centralBodyName:str) -> bool:
        """Adds a central body to the collection of central bodies. True indicates success."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_centralBodyName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Remove(self, centralBodyName:str) -> None:
        """Removes a central body with the specified name from the collection of the central bodies."""
        with agmarshall.BSTR_arg(centralBodyName) as arg_centralBodyName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_centralBodyName.COM_val))

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FB32C9FA-327D-4AF9-9330-7DE8854F827E}", ICrdnCentralBodyCollection)
agcls.AgTypeNameMap["ICrdnCentralBodyCollection"] = ICrdnCentralBodyCollection

class ICrdnCollection(object):
    """A collection of VGT objects."""
    _uuid = "{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Contains"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnCollection = agcom.GUID(ICrdnCollection._uuid)
        vtable_offset_local = ICrdnCollection._vtable_offset - 1
        self.__dict__["_Contains"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+3, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+5, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_ICrdnCollection, vtable_offset_local+6, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnCollection.__dict__ and type(ICrdnCollection.__dict__[attrname]) == property:
            return ICrdnCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdn":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Contains(self, name:str) -> bool:
        """Searches for a an element with a given name. Returns false if the specified element does not exist."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_Contains"](arg_name.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns a number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, indexOrName:typing.Any) -> "ICrdn":
        """Retrieves an element of the collection using the name of the element or a position in the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "ICrdn":
        """Retrieves an item from the crdn collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, name:str) -> "ICrdn":
        """Retrieves an item from the crdn collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}", ICrdnCollection)
agcls.AgTypeNameMap["ICrdnCollection"] = ICrdnCollection

class ICrdnPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    _uuid = "{5131DB47-EFEA-4021-BEC5-DD13A73D9917}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointSamplingResult = agcom.GUID(ICrdnPointSamplingResult._uuid)
        vtable_offset_local = ICrdnPointSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointSamplingResult.__dict__ and type(ICrdnPointSamplingResult.__dict__[attrname]) == property:
            return ICrdnPointSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ICrdnPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5131DB47-EFEA-4021-BEC5-DD13A73D9917}", ICrdnPointSamplingResult)
agcls.AgTypeNameMap["ICrdnPointSamplingResult"] = ICrdnPointSamplingResult

class ICrdnPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""
    _uuid = "{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetPositions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointSamplingInterval = agcom.GUID(ICrdnPointSamplingInterval._uuid)
        vtable_offset_local = ICrdnPointSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetPositions"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointSamplingInterval.__dict__ and type(ICrdnPointSamplingInterval.__dict__[attrname]) == property:
            return ICrdnPointSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPositions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}", ICrdnPointSamplingInterval)
agcls.AgTypeNameMap["ICrdnPointSamplingInterval"] = ICrdnPointSamplingInterval

class ICrdnPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    _uuid = "{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnPointSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnPointSamplingIntervalCollection = agcom.GUID(ICrdnPointSamplingIntervalCollection._uuid)
        vtable_offset_local = ICrdnPointSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnPointSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnPointSamplingIntervalCollection.__dict__ and type(ICrdnPointSamplingIntervalCollection.__dict__[attrname]) == property:
            return ICrdnPointSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnPointSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnPointSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ICrdnPointSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}", ICrdnPointSamplingIntervalCollection)
agcls.AgTypeNameMap["ICrdnPointSamplingIntervalCollection"] = ICrdnPointSamplingIntervalCollection

class ICrdnAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    _uuid = "{F01C2A06-2998-406C-9898-CB60F5711EF1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIsValid"] = _raise_uninitialized_error
        self.__dict__["_GetIntervals"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesSamplingResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesSamplingResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesSamplingResult = agcom.GUID(ICrdnAxesSamplingResult._uuid)
        vtable_offset_local = ICrdnAxesSamplingResult._vtable_offset - 1
        self.__dict__["_GetIsValid"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetIntervals"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingResult, vtable_offset_local+2, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesSamplingResult.__dict__ and type(ICrdnAxesSamplingResult.__dict__[attrname]) == property:
            return ICrdnAxesSamplingResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesSamplingResult.")
    
    @property
    def IsValid(self) -> bool:
        """Indicates whether the result object is valid."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsValid"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Intervals(self) -> "ICrdnAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIntervals"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F01C2A06-2998-406C-9898-CB60F5711EF1}", ICrdnAxesSamplingResult)
agcls.AgTypeNameMap["ICrdnAxesSamplingResult"] = ICrdnAxesSamplingResult

class ICrdnAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    _uuid = "{5BF49282-A56A-48F1-85C9-92CF71C803D0}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimes"] = _raise_uninitialized_error
        self.__dict__["_GetQuaternions"] = _raise_uninitialized_error
        self.__dict__["_GetVelocities"] = _raise_uninitialized_error
        self.__dict__["_GetStart"] = _raise_uninitialized_error
        self.__dict__["_GetStop"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesSamplingInterval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesSamplingInterval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesSamplingInterval = agcom.GUID(ICrdnAxesSamplingInterval._uuid)
        vtable_offset_local = ICrdnAxesSamplingInterval._vtable_offset - 1
        self.__dict__["_GetTimes"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingInterval, vtable_offset_local+1, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetQuaternions"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingInterval, vtable_offset_local+2, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetVelocities"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingInterval, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetStart"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingInterval, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetStop"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingInterval, vtable_offset_local+5, POINTER(agcom.VARIANT))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesSamplingInterval.__dict__ and type(ICrdnAxesSamplingInterval.__dict__[attrname]) == property:
            return ICrdnAxesSamplingInterval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesSamplingInterval.")
    
    @property
    def Times(self) -> list:
        """A time array associated with the interval."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimes"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetQuaternions"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Velocities(self) -> list:
        """An array of angular velocities."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocities"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Start(self) -> typing.Any:
        """The start time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStart"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def Stop(self) -> typing.Any:
        """The stop time of the interval."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetStop"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5BF49282-A56A-48F1-85C9-92CF71C803D0}", ICrdnAxesSamplingInterval)
agcls.AgTypeNameMap["ICrdnAxesSamplingInterval"] = ICrdnAxesSamplingInterval

class ICrdnAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    _uuid = "{F593657B-35A4-4F40-B697-4D14E66195AC}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesSamplingIntervalCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICrdnAxesSamplingIntervalCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICrdnAxesSamplingIntervalCollection = agcom.GUID(ICrdnAxesSamplingIntervalCollection._uuid)
        vtable_offset_local = ICrdnAxesSamplingIntervalCollection._vtable_offset - 1
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingIntervalCollection, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingIntervalCollection, vtable_offset_local+2, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICrdnAxesSamplingIntervalCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICrdnAxesSamplingIntervalCollection.__dict__ and type(ICrdnAxesSamplingIntervalCollection.__dict__[attrname]) == property:
            return ICrdnAxesSamplingIntervalCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICrdnAxesSamplingIntervalCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ICrdnAxesSamplingInterval":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    @property
    def Count(self) -> int:
        """Number of elements in the collection."""
        with agmarshall.LONG_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Item(self, index:int) -> "ICrdnAxesSamplingInterval":
        """Accesses an element at the specified position."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Returns a COM enumerator."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{F593657B-35A4-4F40-B697-4D14E66195AC}", ICrdnAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["ICrdnAxesSamplingIntervalCollection"] = ICrdnAxesSamplingIntervalCollection



class CrdnEvaluateResult(ICrdnEvaluateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        ICrdnEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEvaluateResult._get_property(self, attrname) is not None: found_prop = ICrdnEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}", CrdnEvaluateResult)


class CrdnEvaluateWithRateResult(ICrdnEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""
    def __init__(self, sourceObject=None):
        ICrdnEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = ICrdnEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}", CrdnEvaluateWithRateResult)


class CrdnEventIntervalResult(ICrdnEventIntervalResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalResult._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{ACE6C28C-4664-4B7F-8736-91F55C7962A6}", CrdnEventIntervalResult)


class CrdnEventFindOccurrenceResult(ICrdnEventFindOccurrenceResult):
    """Contains the results returned with IAgCrdnEvent.FindOccurrence method."""
    def __init__(self, sourceObject=None):
        ICrdnEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventFindOccurrenceResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventFindOccurrenceResult._get_property(self, attrname) is not None: found_prop = ICrdnEventFindOccurrenceResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventFindOccurrenceResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}", CrdnEventFindOccurrenceResult)


class CrdnFindTimesResult(ICrdnFindTimesResult):
    """Returns a collection of intervals and an array of times."""
    def __init__(self, sourceObject=None):
        ICrdnFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnFindTimesResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnFindTimesResult._get_property(self, attrname) is not None: found_prop = ICrdnFindTimesResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnFindTimesResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}", CrdnFindTimesResult)


class CrdnIntervalsVectorResult(ICrdnIntervalsVectorResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.FindIntervalCollection method."""
    def __init__(self, sourceObject=None):
        ICrdnIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntervalsVectorResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntervalsVectorResult._get_property(self, attrname) is not None: found_prop = ICrdnIntervalsVectorResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntervalsVectorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{233B8EB4-0B6A-485F-BACB-C678798FDA21}", CrdnIntervalsVectorResult)


class CrdnEventIntervalCollectionOccurredResult(ICrdnEventIntervalCollectionOccurredResult):
    """Contains the results returned with IAgCrdnEventIntervalCollection.Occurred method."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionOccurredResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionOccurredResult._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionOccurredResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionOccurredResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}", CrdnEventIntervalCollectionOccurredResult)


class CrdnIntervalListResult(ICrdnIntervalListResult):
    """Contains the results returned with IAgCrdnEventIntervalList.FindIntervals method."""
    def __init__(self, sourceObject=None):
        ICrdnIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntervalListResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntervalListResult._get_property(self, attrname) is not None: found_prop = ICrdnIntervalListResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntervalListResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}", CrdnIntervalListResult)


class CrdnIntervalVectorCollection(ICrdnIntervalVectorCollection):
    """A collection of interval collections."""
    def __init__(self, sourceObject=None):
        ICrdnIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntervalVectorCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntervalVectorCollection._get_property(self, attrname) is not None: found_prop = ICrdnIntervalVectorCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntervalVectorCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}", CrdnIntervalVectorCollection)


class CrdnEventGroup(ICrdnEventGroup):
    """Access or create VGT events associated with an object."""
    def __init__(self, sourceObject=None):
        ICrdnEventGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventGroup._get_property(self, attrname) is not None: found_prop = ICrdnEventGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D83181-A954-4FA9-886E-A917F135C974}", CrdnEventGroup)


class CrdnEventIntervalGroup(ICrdnEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalGroup._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}", CrdnEventIntervalGroup)


class CrdnEventIntervalListGroup(ICrdnEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListGroup._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B2FDEBA-A2B9-4568-8F48-469F604DB966}", CrdnEventIntervalListGroup)


class CrdnEventArrayGroup(ICrdnEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayGroup._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{365C4A6E-9C2B-4883-96C6-CF689BCC2943}", CrdnEventArrayGroup)


class CrdnCalcScalarGroup(ICrdnCalcScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarGroup._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{DFAD8468-4480-460F-993D-74FFADB567B3}", CrdnCalcScalarGroup)


class CrdnEventIntervalCollectionGroup(ICrdnEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionGroup._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{16E277E2-E306-40E7-B698-B725BDED5739}", CrdnEventIntervalCollectionGroup)


class CrdnParameterSetGroup(ICrdnParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetGroup._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}", CrdnParameterSetGroup)


class CrdnConditionGroup(ICrdnConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnConditionGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionGroup._get_property(self, attrname) is not None: found_prop = ICrdnConditionGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}", CrdnConditionGroup)


class CrdnConditionSetGroup(ICrdnConditionSetGroup):
    """Allows accessing and creating condition set components."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSetGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSetGroup._get_property(self, attrname) is not None: found_prop = ICrdnConditionSetGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSetGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{D82D5C71-102E-4154-9FF6-153C4EDB5A94}", CrdnConditionSetGroup)


class CrdnConditionSetEvaluateResult(ICrdnConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSetEvaluateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSetEvaluateResult._get_property(self, attrname) is not None: found_prop = ICrdnConditionSetEvaluateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSetEvaluateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{13F4EB53-F5AB-487A-BC09-AA186C884744}", CrdnConditionSetEvaluateResult)


class CrdnConditionSetEvaluateWithRateResult(ICrdnConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSetEvaluateWithRateResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSetEvaluateWithRateResult._get_property(self, attrname) is not None: found_prop = ICrdnConditionSetEvaluateWithRateResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSetEvaluateWithRateResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{53051D77-87D0-432C-9044-A2AB1E2104BA}", CrdnConditionSetEvaluateWithRateResult)


class CrdnVolumeGridGroup(ICrdnVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridGroup._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}", CrdnVolumeGridGroup)


class CrdnVolumeGroup(ICrdnVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGroup._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0055B726-654F-446B-82D7-BCDD744F1D8F}", CrdnVolumeGroup)


class CrdnVolumeCalcGroup(ICrdnVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcGroup._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{b10331b7-f8c3-4a59-9e9b-b05dd6599167}", CrdnVolumeCalcGroup)


class CrdnCalcScalar(ICrdnCalcScalar, ICrdn):
    """Any scalar calculation that is not constant by construction."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{440E178B-1B34-4896-A25F-2A4F3AD4848E}", CrdnCalcScalar)


class CrdnCalcScalarAngle(ICrdnCalcScalarAngle, ICrdnCalcScalar, ICrdn):
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarAngle.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarAngle._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarAngle._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarAngle._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E2A940D-2656-4410-86B4-D7314B788E47}", CrdnCalcScalarAngle)


class CrdnCalcScalarConstant(ICrdnCalcScalarConstant, ICrdnCalcScalar, ICrdn):
    """Constant scalar value of specified dimension."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarConstant.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarConstant._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarConstant._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarConstant._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{0725A767-6788-4FF4-B848-EF3D526BD7B0}", CrdnCalcScalarConstant)


class CrdnCalcScalarCustom(ICrdnCalcScalarCustom, ICrdnCalcScalar, ICrdn):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarCustom.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarCustom._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarCustom._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarCustom._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}", CrdnCalcScalarCustom)


class CrdnCalcScalarDataElement(ICrdnCalcScalarDataElement, ICrdnCalcScalar, ICrdn):
    """Any time-dependent data element from STK data providers available for parent STK object."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarDataElement.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarDataElement._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarDataElement._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarDataElement._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarDataElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{260D686F-07E2-49DB-8E88-467EF79EFA54}", CrdnCalcScalarDataElement)


class CrdnCalcScalarDerivative(ICrdnCalcScalarDerivative, ICrdnCalcScalar, ICrdn):
    """Derivative of an input scalar calculation."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarDerivative.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarDerivative._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarDerivative._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarDerivative._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}", CrdnCalcScalarDerivative)


class CrdnCalcScalarDotProduct(ICrdnCalcScalarDotProduct, ICrdnCalcScalar, ICrdn):
    """Dot product between two vectors."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarDotProduct.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarDotProduct._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarDotProduct._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarDotProduct._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarDotProduct.")
        
agcls.AgClassCatalog.add_catalog_entry("{703f009e-faab-4281-8d07-733b1344d42b}", CrdnCalcScalarDotProduct)


class CrdnCalcScalarElapsedTime(ICrdnCalcScalarElapsedTime, ICrdnCalcScalar, ICrdn):
    """Time elapsed since the reference time instant. Negative if in the past."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarElapsedTime.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarElapsedTime._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarElapsedTime._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarElapsedTime._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarElapsedTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}", CrdnCalcScalarElapsedTime)


class CrdnCalcScalarFactory(ICrdnCalcScalarFactory):
    """The factory creates scalar calculation components."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarFactory._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{47235112-821F-4DC2-9A70-57AB9F1F17E8}", CrdnCalcScalarFactory)


class CrdnCalcScalarFile(ICrdnCalcScalarFile, ICrdnCalcScalar, ICrdn):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarFile.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarFile._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarFile._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarFile._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{75F0039F-B789-4771-BD50-9AEF30F6038E}", CrdnCalcScalarFile)


class CrdnCalcScalarFixedAtTimeInstant(ICrdnCalcScalarFixedAtTimeInstant, ICrdnCalcScalar, ICrdn):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarFixedAtTimeInstant.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarFixedAtTimeInstant._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarFixedAtTimeInstant._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}", CrdnCalcScalarFixedAtTimeInstant)


class CrdnCalcScalarFunction(ICrdnCalcScalarFunction, ICrdnCalcScalar, ICrdn):
    """Defined by performing the specified function on the input scalar or time instant."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarFunction.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarFunction._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarFunction._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarFunction._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{40158F99-3146-4167-8BB0-A0046BB08EEB}", CrdnCalcScalarFunction)


class CrdnCalcScalarFunction2Var(ICrdnCalcScalarFunction2Var, ICrdnCalcScalar, ICrdn):
    """Defined by performing a function(x,y) on two scalar arguments."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarFunction2Var.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarFunction2Var._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarFunction2Var._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarFunction2Var._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarFunction2Var.")
        
agcls.AgClassCatalog.add_catalog_entry("{05CA07A4-A36F-44EF-99C4-5E0999E79200}", CrdnCalcScalarFunction2Var)


class CrdnCalcScalarIntegral(ICrdnCalcScalarIntegral, ICrdnCalcScalar, ICrdn):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarIntegral.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarIntegral._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarIntegral._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarIntegral._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarIntegral.")
        
agcls.AgClassCatalog.add_catalog_entry("{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}", CrdnCalcScalarIntegral)


class CrdnCalcScalarPlugin(ICrdnCalcScalarPlugin, ICrdnCalcScalar, ICrdn):
    """Use a scalar calculation plugin."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarPlugin.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarPlugin._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarPlugin._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarPlugin._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E435E30B-EA9B-4EFB-852A-C20427B71484}", CrdnCalcScalarPlugin)


class CrdnCalcScalarSurfaceDistanceBetweenPoints(ICrdnCalcScalarSurfaceDistanceBetweenPoints, ICrdnCalcScalar, ICrdn):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarSurfaceDistanceBetweenPoints._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarSurfaceDistanceBetweenPoints._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarSurfaceDistanceBetweenPoints.")
        
agcls.AgClassCatalog.add_catalog_entry("{DEDCB488-6C70-4BC0-A719-68832FB6D30E}", CrdnCalcScalarSurfaceDistanceBetweenPoints)


class CrdnCalcScalarVectorComponent(ICrdnCalcScalarVectorComponent, ICrdnCalcScalar, ICrdn):
    """The specified component of a vector when resolved in the specified axes."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarVectorComponent.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarVectorComponent._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarVectorComponent._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarVectorComponent._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarVectorComponent.")
        
agcls.AgClassCatalog.add_catalog_entry("{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}", CrdnCalcScalarVectorComponent)


class CrdnCalcScalarVectorMagnitude(ICrdnCalcScalarVectorMagnitude, ICrdnCalcScalar, ICrdn):
    """Scalar equal to the magnitude of a specified vector."""
    def __init__(self, sourceObject=None):
        ICrdnCalcScalarVectorMagnitude.__init__(self, sourceObject)
        ICrdnCalcScalar.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCalcScalarVectorMagnitude._private_init(self, pUnk)
        ICrdnCalcScalar._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCalcScalarVectorMagnitude._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalarVectorMagnitude._get_property(self, attrname)
        if ICrdnCalcScalar._get_property(self, attrname) is not None: found_prop = ICrdnCalcScalar._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCalcScalarVectorMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}", CrdnCalcScalarVectorMagnitude)


class CrdnCondition(ICrdnCondition, ICrdn):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""
    def __init__(self, sourceObject=None):
        ICrdnCondition.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCondition._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCondition._get_property(self, attrname) is not None: found_prop = ICrdnCondition._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1BED244-FFB2-4038-AE76-A9B3194B2E49}", CrdnCondition)


class CrdnConditionCombined(ICrdnConditionCombined, ICrdnCondition, ICrdn):
    """Defines a condition which combines multiple conditions."""
    def __init__(self, sourceObject=None):
        ICrdnConditionCombined.__init__(self, sourceObject)
        ICrdnCondition.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionCombined._private_init(self, pUnk)
        ICrdnCondition._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionCombined._get_property(self, attrname) is not None: found_prop = ICrdnConditionCombined._get_property(self, attrname)
        if ICrdnCondition._get_property(self, attrname) is not None: found_prop = ICrdnCondition._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{92F4488B-3543-4229-B1FB-447D282199B9}", CrdnConditionCombined)


class CrdnConditionFactory(ICrdnConditionFactory):
    """The factory creates condition components."""
    def __init__(self, sourceObject=None):
        ICrdnConditionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionFactory._get_property(self, attrname) is not None: found_prop = ICrdnConditionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{06C627F8-87EA-4552-86E8-7E5049914CDE}", CrdnConditionFactory)


class CrdnConditionPointInVolume(ICrdnConditionPointInVolume, ICrdnCondition, ICrdn):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate"""
    def __init__(self, sourceObject=None):
        ICrdnConditionPointInVolume.__init__(self, sourceObject)
        ICrdnCondition.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionPointInVolume._private_init(self, pUnk)
        ICrdnCondition._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionPointInVolume._get_property(self, attrname) is not None: found_prop = ICrdnConditionPointInVolume._get_property(self, attrname)
        if ICrdnCondition._get_property(self, attrname) is not None: found_prop = ICrdnCondition._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionPointInVolume.")
        
agcls.AgClassCatalog.add_catalog_entry("{41532AD9-B30C-44AE-8581-CE74C24846A8}", CrdnConditionPointInVolume)


class CrdnConditionScalarBounds(ICrdnConditionScalarBounds, ICrdnCondition, ICrdn):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""
    def __init__(self, sourceObject=None):
        ICrdnConditionScalarBounds.__init__(self, sourceObject)
        ICrdnCondition.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionScalarBounds._private_init(self, pUnk)
        ICrdnCondition._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionScalarBounds._get_property(self, attrname) is not None: found_prop = ICrdnConditionScalarBounds._get_property(self, attrname)
        if ICrdnCondition._get_property(self, attrname) is not None: found_prop = ICrdnCondition._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionScalarBounds.")
        
agcls.AgClassCatalog.add_catalog_entry("{452E2178-AFB0-4E61-8187-9C6CB4A704A0}", CrdnConditionScalarBounds)


class CrdnConditionSet(ICrdnConditionSet, ICrdn):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSet._get_property(self, attrname) is not None: found_prop = ICrdnConditionSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6407B1B-6858-49FC-845A-F8A6239162C2}", CrdnConditionSet)


class CrdnConditionSetFactory(ICrdnConditionSetFactory):
    """The factory creates condition set components."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSetFactory._get_property(self, attrname) is not None: found_prop = ICrdnConditionSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D2445C98-9EA1-458F-9B6A-607249BF399A}", CrdnConditionSetFactory)


class CrdnConditionSetScalarThresholds(ICrdnConditionSetScalarThresholds, ICrdnConditionSet, ICrdn):
    """Condition set based on single scalar calculation compared to set of threshold values."""
    def __init__(self, sourceObject=None):
        ICrdnConditionSetScalarThresholds.__init__(self, sourceObject)
        ICrdnConditionSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConditionSetScalarThresholds._private_init(self, pUnk)
        ICrdnConditionSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConditionSetScalarThresholds._get_property(self, attrname) is not None: found_prop = ICrdnConditionSetScalarThresholds._get_property(self, attrname)
        if ICrdnConditionSet._get_property(self, attrname) is not None: found_prop = ICrdnConditionSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConditionSetScalarThresholds.")
        
agcls.AgClassCatalog.add_catalog_entry("{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}", CrdnConditionSetScalarThresholds)


class CrdnConverge(ICrdnConverge, ICrdn):
    """Represents a base class for convergence definitions."""
    def __init__(self, sourceObject=None):
        ICrdnConverge.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConverge._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConverge._get_property(self, attrname) is not None: found_prop = ICrdnConverge._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConverge.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A13D679-1970-43C2-8D4F-174B08AB04DC}", CrdnConverge)


class CrdnConvergeBasic(ICrdnConvergeBasic, ICrdnConverge, ICrdn):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""
    def __init__(self, sourceObject=None):
        ICrdnConvergeBasic.__init__(self, sourceObject)
        ICrdnConverge.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnConvergeBasic._private_init(self, pUnk)
        ICrdnConverge._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnConvergeBasic._get_property(self, attrname) is not None: found_prop = ICrdnConvergeBasic._get_property(self, attrname)
        if ICrdnConverge._get_property(self, attrname) is not None: found_prop = ICrdnConverge._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnConvergeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{808F19C3-0E31-4C89-94C8-BBE01E067DFF}", CrdnConvergeBasic)


class CrdnDerivative(ICrdnDerivative, ICrdn):
    """Represents a base class for derivative definitions."""
    def __init__(self, sourceObject=None):
        ICrdnDerivative.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnDerivative._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnDerivative._get_property(self, attrname) is not None: found_prop = ICrdnDerivative._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}", CrdnDerivative)


class CrdnDerivativeBasic(ICrdnDerivativeBasic, ICrdnDerivative, ICrdn):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""
    def __init__(self, sourceObject=None):
        ICrdnDerivativeBasic.__init__(self, sourceObject)
        ICrdnDerivative.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnDerivativeBasic._private_init(self, pUnk)
        ICrdnDerivative._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnDerivativeBasic._get_property(self, attrname) is not None: found_prop = ICrdnDerivativeBasic._get_property(self, attrname)
        if ICrdnDerivative._get_property(self, attrname) is not None: found_prop = ICrdnDerivative._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnDerivativeBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{3CD084C3-0045-4452-9793-AE8DF4073433}", CrdnDerivativeBasic)


class CrdnEvent(ICrdnEvent, ICrdn):
    """Defines an event (time instant)."""
    def __init__(self, sourceObject=None):
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEvent.")
        
agcls.AgClassCatalog.add_catalog_entry("{A4B75B25-5DAE-4AEC-86EF-512F5E031766}", CrdnEvent)


class CrdnEventArray(ICrdnEventArray, ICrdn):
    """An ordered array of times, which may or may not be evenly spaced."""
    def __init__(self, sourceObject=None):
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArray.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5C87B1A-D519-4A01-8649-AA7560CD503A}", CrdnEventArray)


class CrdnEventArrayConditionCrossings(ICrdnEventArrayConditionCrossings, ICrdnEventArray, ICrdn):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayConditionCrossings.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayConditionCrossings._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayConditionCrossings._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayConditionCrossings._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayConditionCrossings.")
        
agcls.AgClassCatalog.add_catalog_entry("{B6FBC501-3521-4AE3-AFD8-4971F089D14F}", CrdnEventArrayConditionCrossings)


class CrdnEventArrayExtrema(ICrdnEventArrayExtrema, ICrdnEventArray, ICrdn):
    """Determines times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayExtrema.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayExtrema._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayExtrema._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayExtrema._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayExtrema.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}", CrdnEventArrayExtrema)


class CrdnEventArrayFactory(ICrdnEventArrayFactory):
    """The factory creates event arrays."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayFactory._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}", CrdnEventArrayFactory)


class CrdnEventArrayFiltered(ICrdnEventArrayFiltered, ICrdnEventArray, ICrdn):
    """Defined by filtering times from original time array according to specified filtering method."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayFiltered.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayFiltered._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayFiltered._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayFiltered._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}", CrdnEventArrayFiltered)


class CrdnEventArrayFixedStep(ICrdnEventArrayFixedStep, ICrdnEventArray, ICrdn):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayFixedStep.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayFixedStep._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayFixedStep._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayFixedStep._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{CDA379CC-7511-496E-874E-14E10F3E2B1A}", CrdnEventArrayFixedStep)


class CrdnEventArrayFixedTimes(ICrdnEventArrayFixedTimes, ICrdnEventArray, ICrdn):
    """Array defined by time ordered instants each explicitly specified."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayFixedTimes.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayFixedTimes._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayFixedTimes._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayFixedTimes._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayFixedTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{EA73AECA-23AB-4DA1-B297-E80E19C55C15}", CrdnEventArrayFixedTimes)


class CrdnEventArrayMerged(ICrdnEventArrayMerged, ICrdnEventArray, ICrdn):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayMerged.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayMerged._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayMerged._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayMerged._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{44FBC83E-D466-425F-ADF5-2003D754F935}", CrdnEventArrayMerged)


class CrdnEventArraySignaled(ICrdnEventArraySignaled, ICrdnEventArray, ICrdn):
    """Determines what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ICrdnEventArraySignaled.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArraySignaled._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArraySignaled._get_property(self, attrname) is not None: found_prop = ICrdnEventArraySignaled._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArraySignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}", CrdnEventArraySignaled)


class CrdnEventArrayStartStopTimes(ICrdnEventArrayStartStopTimes, ICrdnEventArray, ICrdn):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""
    def __init__(self, sourceObject=None):
        ICrdnEventArrayStartStopTimes.__init__(self, sourceObject)
        ICrdnEventArray.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventArrayStartStopTimes._private_init(self, pUnk)
        ICrdnEventArray._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventArrayStartStopTimes._get_property(self, attrname) is not None: found_prop = ICrdnEventArrayStartStopTimes._get_property(self, attrname)
        if ICrdnEventArray._get_property(self, attrname) is not None: found_prop = ICrdnEventArray._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventArrayStartStopTimes.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}", CrdnEventArrayStartStopTimes)


class CrdnEventEpoch(ICrdnEventEpoch, ICrdnEvent, ICrdn):
    """Event set at specified date/time."""
    def __init__(self, sourceObject=None):
        ICrdnEventEpoch.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventEpoch._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventEpoch._get_property(self, attrname) is not None: found_prop = ICrdnEventEpoch._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{230426D4-438A-4B6E-A9D2-5393F7F87238}", CrdnEventEpoch)


class CrdnEventExtremum(ICrdnEventExtremum, ICrdnEvent, ICrdn):
    """Determines time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ICrdnEventExtremum.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventExtremum._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventExtremum._get_property(self, attrname) is not None: found_prop = ICrdnEventExtremum._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventExtremum.")
        
agcls.AgClassCatalog.add_catalog_entry("{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}", CrdnEventExtremum)


class CrdnEventFactory(ICrdnEventFactory):
    """The factory creates events."""
    def __init__(self, sourceObject=None):
        ICrdnEventFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventFactory._get_property(self, attrname) is not None: found_prop = ICrdnEventFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}", CrdnEventFactory)


class CrdnEventInterval(ICrdnEventInterval, ICrdn):
    """A single time interval."""
    def __init__(self, sourceObject=None):
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{2CDA6DDC-7412-441A-8F94-0671FD57D16A}", CrdnEventInterval)


class CrdnEventIntervalBetweenTimeInstants(ICrdnEventIntervalBetweenTimeInstants, ICrdnEventInterval, ICrdn):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalBetweenTimeInstants._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalBetweenTimeInstants._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalBetweenTimeInstants._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalBetweenTimeInstants.")
        
agcls.AgClassCatalog.add_catalog_entry("{E84D9CAE-E919-4B84-99D7-553CCB97739C}", CrdnEventIntervalBetweenTimeInstants)


class CrdnEventIntervalCollection(ICrdnEventIntervalCollection, ICrdn):
    """A collection of related interval lists."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollection.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollection._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollection._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{892BFFEB-D366-49D5-8220-50AC5E4529A1}", CrdnEventIntervalCollection)


class CrdnEventIntervalCollectionCondition(ICrdnEventIntervalCollectionCondition, ICrdnEventIntervalCollection, ICrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionCondition.__init__(self, sourceObject)
        ICrdnEventIntervalCollection.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionCondition._private_init(self, pUnk)
        ICrdnEventIntervalCollection._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionCondition._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionCondition._get_property(self, attrname)
        if ICrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollection._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}", CrdnEventIntervalCollectionCondition)


class CrdnEventIntervalCollectionFactory(ICrdnEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionFactory._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{C76F8390-6619-47D5-9D33-DD1FBBF19B63}", CrdnEventIntervalCollectionFactory)


class CrdnEventIntervalCollectionLighting(ICrdnEventIntervalCollectionLighting, ICrdnEventIntervalCollection, ICrdn):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionLighting.__init__(self, sourceObject)
        ICrdnEventIntervalCollection.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionLighting._private_init(self, pUnk)
        ICrdnEventIntervalCollection._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionLighting._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionLighting._get_property(self, attrname)
        if ICrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollection._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{5457BFBA-3076-4250-B0E0-81FA79D58F19}", CrdnEventIntervalCollectionLighting)


class CrdnEventIntervalCollectionSignaled(ICrdnEventIntervalCollectionSignaled, ICrdnEventIntervalCollection, ICrdn):
    """Determines what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalCollectionSignaled.__init__(self, sourceObject)
        ICrdnEventIntervalCollection.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalCollectionSignaled._private_init(self, pUnk)
        ICrdnEventIntervalCollection._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalCollectionSignaled._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollectionSignaled._get_property(self, attrname)
        if ICrdnEventIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalCollection._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalCollectionSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1ED3869-B0E3-40F6-967A-C539C5D5D630}", CrdnEventIntervalCollectionSignaled)


class CrdnEventIntervalFactory(ICrdnEventIntervalFactory):
    """The factory creates event intervals."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalFactory._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{D5D195D8-DE6D-4926-B743-556B08A827C8}", CrdnEventIntervalFactory)


class CrdnEventIntervalFixed(ICrdnEventIntervalFixed, ICrdnEventInterval, ICrdn):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalFixed.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalFixed._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalFixed._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalFixed._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}", CrdnEventIntervalFixed)


class CrdnEventIntervalFixedDuration(ICrdnEventIntervalFixedDuration, ICrdnEventInterval, ICrdn):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalFixedDuration.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalFixedDuration._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalFixedDuration._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalFixedDuration._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalFixedDuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{84316F31-A3DB-4DF3-B8E3-352673D4E251}", CrdnEventIntervalFixedDuration)


class CrdnEventIntervalFromIntervalList(ICrdnEventIntervalFromIntervalList, ICrdnEventInterval, ICrdn):
    """Interval created from specified interval list by using one of several selection methods."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalFromIntervalList.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalFromIntervalList._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalFromIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalFromIntervalList._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalFromIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}", CrdnEventIntervalFromIntervalList)


class CrdnEventIntervalList(ICrdnEventIntervalList, ICrdn):
    """An ordered list of time intervals."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalList.")
        
agcls.AgClassCatalog.add_catalog_entry("{050E0A6D-9960-4470-9803-AF58B43FD747}", CrdnEventIntervalList)


class CrdnEventIntervalListCondition(ICrdnEventIntervalListCondition, ICrdnEventIntervalList, ICrdn):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListCondition.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListCondition._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListCondition._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListCondition._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}", CrdnEventIntervalListCondition)


class CrdnEventIntervalListFactory(ICrdnEventIntervalListFactory):
    """The factory creates event interval lists."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListFactory._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}", CrdnEventIntervalListFactory)


class CrdnEventIntervalListFile(ICrdnEventIntervalListFile, ICrdnEventIntervalList, ICrdn):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListFile.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListFile._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListFile._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListFile._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{5A3BC6C1-559F-448D-946E-3D608C0C59B4}", CrdnEventIntervalListFile)


class CrdnEventIntervalListFiltered(ICrdnEventIntervalListFiltered, ICrdnEventIntervalList, ICrdn):
    """Defined by filtering intervals from original interval list using specified filtering method."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListFiltered.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListFiltered._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListFiltered._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListFiltered._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListFiltered.")
        
agcls.AgClassCatalog.add_catalog_entry("{7123DA29-BECE-4032-9A81-77CDA69C5B13}", CrdnEventIntervalListFiltered)


class CrdnEventIntervalListFixed(ICrdnEventIntervalListFixed, ICrdnEventIntervalList, ICrdn):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListFixed.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListFixed._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListFixed._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListFixed._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}", CrdnEventIntervalListFixed)


class CrdnEventIntervalListMerged(ICrdnEventIntervalListMerged, ICrdnEventIntervalList, ICrdn):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListMerged.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListMerged._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListMerged._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListMerged._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListMerged.")
        
agcls.AgClassCatalog.add_catalog_entry("{115C7064-1624-4928-B401-2C2B8DA2A2DC}", CrdnEventIntervalListMerged)


class CrdnEventIntervalListScaled(ICrdnEventIntervalListScaled, ICrdnEventIntervalList, ICrdn):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListScaled.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListScaled._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListScaled._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListScaled._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}", CrdnEventIntervalListScaled)


class CrdnEventIntervalListSignaled(ICrdnEventIntervalListSignaled, ICrdnEventIntervalList, ICrdn):
    """Determines what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListSignaled.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListSignaled._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListSignaled._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListSignaled._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}", CrdnEventIntervalListSignaled)


class CrdnEventIntervalListTimeOffset(ICrdnEventIntervalListTimeOffset, ICrdnEventIntervalList, ICrdn):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalListTimeOffset.__init__(self, sourceObject)
        ICrdnEventIntervalList.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalListTimeOffset._private_init(self, pUnk)
        ICrdnEventIntervalList._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalListTimeOffset._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalListTimeOffset._get_property(self, attrname)
        if ICrdnEventIntervalList._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalList._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalListTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA2C1495-B20E-477A-A995-8B5B879DE84C}", CrdnEventIntervalListTimeOffset)


class CrdnEventIntervalScaled(ICrdnEventIntervalScaled, ICrdnEventInterval, ICrdn):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalScaled.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalScaled._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalScaled._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalScaled._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}", CrdnEventIntervalScaled)


class CrdnEventIntervalSignaled(ICrdnEventIntervalSignaled, ICrdnEventInterval, ICrdn):
    """Determines what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalSignaled.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalSignaled._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalSignaled._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalSignaled._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}", CrdnEventIntervalSignaled)


class CrdnEventIntervalSmartInterval(ICrdnEventIntervalSmartInterval, ICrdnEventInterval, ICrdn):
    """A smart interval."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalSmartInterval.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalSmartInterval._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalSmartInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalSmartInterval._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalSmartInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3D4E2AC-3845-4719-AD57-EE0C715A584D}", CrdnEventIntervalSmartInterval)


class CrdnEventIntervalTimeOffset(ICrdnEventIntervalTimeOffset, ICrdnEventInterval, ICrdn):
    """Interval defined by shifting specified reference interval by fixed time offset."""
    def __init__(self, sourceObject=None):
        ICrdnEventIntervalTimeOffset.__init__(self, sourceObject)
        ICrdnEventInterval.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventIntervalTimeOffset._private_init(self, pUnk)
        ICrdnEventInterval._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventIntervalTimeOffset._get_property(self, attrname) is not None: found_prop = ICrdnEventIntervalTimeOffset._get_property(self, attrname)
        if ICrdnEventInterval._get_property(self, attrname) is not None: found_prop = ICrdnEventInterval._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventIntervalTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{DE89BB00-5A89-4DA4-8730-CA2C3495A867}", CrdnEventIntervalTimeOffset)


class CrdnEventSignaled(ICrdnEventSignaled, ICrdnEvent, ICrdn):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""
    def __init__(self, sourceObject=None):
        ICrdnEventSignaled.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventSignaled._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventSignaled._get_property(self, attrname) is not None: found_prop = ICrdnEventSignaled._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventSignaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}", CrdnEventSignaled)


class CrdnEventSmartEpoch(ICrdnEventSmartEpoch, ICrdnEvent, ICrdn):
    """A smart epoch."""
    def __init__(self, sourceObject=None):
        ICrdnEventSmartEpoch.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventSmartEpoch._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventSmartEpoch._get_property(self, attrname) is not None: found_prop = ICrdnEventSmartEpoch._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventSmartEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{F722C253-92DA-4956-983B-B80AB469F192}", CrdnEventSmartEpoch)


class CrdnEventStartStopTime(ICrdnEventStartStopTime, ICrdnEvent, ICrdn):
    """Event is either start or stop time selected from a reference interval."""
    def __init__(self, sourceObject=None):
        ICrdnEventStartStopTime.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventStartStopTime._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventStartStopTime._get_property(self, attrname) is not None: found_prop = ICrdnEventStartStopTime._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventStartStopTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F0429607-A51C-495C-9902-585429D40D10}", CrdnEventStartStopTime)


class CrdnEventTimeOffset(ICrdnEventTimeOffset, ICrdnEvent, ICrdn):
    """Event at fixed offset from specified reference event."""
    def __init__(self, sourceObject=None):
        ICrdnEventTimeOffset.__init__(self, sourceObject)
        ICrdnEvent.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnEventTimeOffset._private_init(self, pUnk)
        ICrdnEvent._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnEventTimeOffset._get_property(self, attrname) is not None: found_prop = ICrdnEventTimeOffset._get_property(self, attrname)
        if ICrdnEvent._get_property(self, attrname) is not None: found_prop = ICrdnEvent._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnEventTimeOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{EE2C89C8-C148-4044-B0BE-BF137D4B876B}", CrdnEventTimeOffset)


class CrdnFirstIntervalsFilter(ICrdnFirstIntervalsFilter, ICrdnPruneFilter):
    """The filter selects a portion of first intervals."""
    def __init__(self, sourceObject=None):
        ICrdnFirstIntervalsFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnFirstIntervalsFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnFirstIntervalsFilter._get_property(self, attrname) is not None: found_prop = ICrdnFirstIntervalsFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnFirstIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A044590-5063-4331-9FC2-621221CF7EA9}", CrdnFirstIntervalsFilter)


class CrdnGapsFilter(ICrdnGapsFilter, ICrdnPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ICrdnGapsFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGapsFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGapsFilter._get_property(self, attrname) is not None: found_prop = ICrdnGapsFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGapsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{C54D3817-6B48-4436-8E1D-323A38DC2BC0}", CrdnGapsFilter)


class CrdnIntegral(ICrdnIntegral, ICrdn):
    """Represents a base class for integral definitions."""
    def __init__(self, sourceObject=None):
        ICrdnIntegral.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntegral._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntegral._get_property(self, attrname) is not None: found_prop = ICrdnIntegral._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntegral.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C6B1D39-FC48-475A-A888-DA9D459C1906}", CrdnIntegral)


class CrdnIntegralBasic(ICrdnIntegralBasic, ICrdnIntegral, ICrdn):
    """Integral definition determines how scalar calculation is numerically integrated."""
    def __init__(self, sourceObject=None):
        ICrdnIntegralBasic.__init__(self, sourceObject)
        ICrdnIntegral.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntegralBasic._private_init(self, pUnk)
        ICrdnIntegral._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntegralBasic._get_property(self, attrname) is not None: found_prop = ICrdnIntegralBasic._get_property(self, attrname)
        if ICrdnIntegral._get_property(self, attrname) is not None: found_prop = ICrdnIntegral._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntegralBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}", CrdnIntegralBasic)


class CrdnInterp(ICrdnInterp, ICrdn):
    """Represents a base class for interpolation definitions."""
    def __init__(self, sourceObject=None):
        ICrdnInterp.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnInterp._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnInterp._get_property(self, attrname) is not None: found_prop = ICrdnInterp._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnInterp.")
        
agcls.AgClassCatalog.add_catalog_entry("{F73B3675-6FD4-4050-9566-797DCD695107}", CrdnInterp)


class CrdnInterpBasic(ICrdnInterpBasic, ICrdnInterp, ICrdn):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""
    def __init__(self, sourceObject=None):
        ICrdnInterpBasic.__init__(self, sourceObject)
        ICrdnInterp.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnInterpBasic._private_init(self, pUnk)
        ICrdnInterp._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnInterpBasic._get_property(self, attrname) is not None: found_prop = ICrdnInterpBasic._get_property(self, attrname)
        if ICrdnInterp._get_property(self, attrname) is not None: found_prop = ICrdnInterp._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnInterpBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{AB05143F-6997-4F40-BE86-DCF4D723F31E}", CrdnInterpBasic)


class CrdnIntervalsFilter(ICrdnIntervalsFilter, ICrdnPruneFilter):
    """The filter selects intervals of at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ICrdnIntervalsFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntervalsFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntervalsFilter._get_property(self, attrname) is not None: found_prop = ICrdnIntervalsFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}", CrdnIntervalsFilter)


class CrdnLastIntervalsFilter(ICrdnLastIntervalsFilter, ICrdnPruneFilter):
    """The filter selects a portion of last intervals."""
    def __init__(self, sourceObject=None):
        ICrdnLastIntervalsFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnLastIntervalsFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnLastIntervalsFilter._get_property(self, attrname) is not None: found_prop = ICrdnLastIntervalsFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnLastIntervalsFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}", CrdnLastIntervalsFilter)


class CrdnParameterSet(ICrdnParameterSet, ICrdn):
    """Parameter set contains various sets of scalar computations."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{CD1D82FC-08BF-4854-9295-F90AC87FAE68}", CrdnParameterSet)


class CrdnParameterSetAttitude(ICrdnParameterSetAttitude, ICrdnParameterSet, ICrdn):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetAttitude.__init__(self, sourceObject)
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetAttitude._private_init(self, pUnk)
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetAttitude._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetAttitude._get_property(self, attrname)
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{7082CB04-052B-46A2-A051-4FF52D0260B0}", CrdnParameterSetAttitude)


class CrdnParameterSetFactory(ICrdnParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetFactory._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{FF399336-197C-480B-98AC-3F07E76FF3BC}", CrdnParameterSetFactory)


class CrdnParameterSetGroundTrajectory(ICrdnParameterSetGroundTrajectory, ICrdnParameterSet, ICrdn):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetGroundTrajectory.__init__(self, sourceObject)
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetGroundTrajectory._private_init(self, pUnk)
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetGroundTrajectory._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetGroundTrajectory._get_property(self, attrname)
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetGroundTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1972E17-F000-4BFF-80A3-216A91D0E2B1}", CrdnParameterSetGroundTrajectory)


class CrdnParameterSetOrbit(ICrdnParameterSetOrbit, ICrdnParameterSet, ICrdn):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetOrbit.__init__(self, sourceObject)
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetOrbit._private_init(self, pUnk)
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetOrbit._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetOrbit._get_property(self, attrname)
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetOrbit.")
        
agcls.AgClassCatalog.add_catalog_entry("{BF4A60A0-68E5-4000-8843-DD7FD76813A9}", CrdnParameterSetOrbit)


class CrdnParameterSetTrajectory(ICrdnParameterSetTrajectory, ICrdnParameterSet, ICrdn):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetTrajectory.__init__(self, sourceObject)
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetTrajectory._private_init(self, pUnk)
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetTrajectory._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetTrajectory._get_property(self, attrname)
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{542072ED-4073-4F91-8EC8-45F7CC401ED7}", CrdnParameterSetTrajectory)


class CrdnParameterSetVector(ICrdnParameterSetVector, ICrdnParameterSet, ICrdn):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""
    def __init__(self, sourceObject=None):
        ICrdnParameterSetVector.__init__(self, sourceObject)
        ICrdnParameterSet.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnParameterSetVector._private_init(self, pUnk)
        ICrdnParameterSet._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnParameterSetVector._get_property(self, attrname) is not None: found_prop = ICrdnParameterSetVector._get_property(self, attrname)
        if ICrdnParameterSet._get_property(self, attrname) is not None: found_prop = ICrdnParameterSet._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnParameterSetVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC7B40D5-7091-4A24-A698-436D2A274DC8}", CrdnParameterSetVector)


class CrdnPruneFilter(ICrdnPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""
    def __init__(self, sourceObject=None):
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPruneFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{E08D63E9-CC8E-41F8-B3C5-0D062425C025}", CrdnPruneFilter)


class CrdnPruneFilterFactory(ICrdnPruneFilterFactory):
    """The factory creates pruning filters."""
    def __init__(self, sourceObject=None):
        ICrdnPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPruneFilterFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPruneFilterFactory._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilterFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPruneFilterFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{954284C2-3544-4888-9A56-759AA8C7E1F7}", CrdnPruneFilterFactory)


class CrdnRelativeSatisfactionConditionFilter(ICrdnRelativeSatisfactionConditionFilter, ICrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""
    def __init__(self, sourceObject=None):
        ICrdnRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnRelativeSatisfactionConditionFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnRelativeSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = ICrdnRelativeSatisfactionConditionFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnRelativeSatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{93A5C2C0-AABA-4DB3-9359-100604D0BA02}", CrdnRelativeSatisfactionConditionFilter)


class CrdnSampling(ICrdnSampling, ICrdn):
    """Base sampling interface."""
    def __init__(self, sourceObject=None):
        ICrdnSampling.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSampling._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSampling._get_property(self, attrname) is not None: found_prop = ICrdnSampling._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSampling.")
        
agcls.AgClassCatalog.add_catalog_entry("{17FC40E9-EF68-4FFD-8A16-071054486F6A}", CrdnSampling)


class CrdnSamplingBasic(ICrdnSamplingBasic, ICrdnSampling, ICrdn):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingBasic.__init__(self, sourceObject)
        ICrdnSampling.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingBasic._private_init(self, pUnk)
        ICrdnSampling._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingBasic._get_property(self, attrname) is not None: found_prop = ICrdnSamplingBasic._get_property(self, attrname)
        if ICrdnSampling._get_property(self, attrname) is not None: found_prop = ICrdnSampling._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB786C50-8D9C-4333-A985-FFD2ADD20206}", CrdnSamplingBasic)


class CrdnSamplingCurvatureTolerance(ICrdnSamplingCurvatureTolerance, ICrdnSamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingCurvatureTolerance.__init__(self, sourceObject)
        ICrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingCurvatureTolerance._private_init(self, pUnk)
        ICrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingCurvatureTolerance._get_property(self, attrname) is not None: found_prop = ICrdnSamplingCurvatureTolerance._get_property(self, attrname)
        if ICrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = ICrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingCurvatureTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{EF49B404-27D2-4AC5-BB5E-EA223A237922}", CrdnSamplingCurvatureTolerance)


class CrdnSamplingFixedStep(ICrdnSamplingFixedStep, ICrdnSamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingFixedStep.__init__(self, sourceObject)
        ICrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingFixedStep._private_init(self, pUnk)
        ICrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingFixedStep._get_property(self, attrname) is not None: found_prop = ICrdnSamplingFixedStep._get_property(self, attrname)
        if ICrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = ICrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B7D520F-7835-4E84-BCA4-D748C73CB609}", CrdnSamplingFixedStep)


class CrdnSamplingMethod(ICrdnSamplingMethod):
    """A sampling method."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = ICrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}", CrdnSamplingMethod)


class CrdnSamplingMethodFactory(ICrdnSamplingMethodFactory):
    """The factory creates sampling method components."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingMethodFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingMethodFactory._get_property(self, attrname) is not None: found_prop = ICrdnSamplingMethodFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingMethodFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}", CrdnSamplingMethodFactory)


class CrdnSamplingRelativeTolerance(ICrdnSamplingRelativeTolerance, ICrdnSamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""
    def __init__(self, sourceObject=None):
        ICrdnSamplingRelativeTolerance.__init__(self, sourceObject)
        ICrdnSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSamplingRelativeTolerance._private_init(self, pUnk)
        ICrdnSamplingMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSamplingRelativeTolerance._get_property(self, attrname) is not None: found_prop = ICrdnSamplingRelativeTolerance._get_property(self, attrname)
        if ICrdnSamplingMethod._get_property(self, attrname) is not None: found_prop = ICrdnSamplingMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSamplingRelativeTolerance.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}", CrdnSamplingRelativeTolerance)


class CrdnSatisfactionConditionFilter(ICrdnSatisfactionConditionFilter, ICrdnPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""
    def __init__(self, sourceObject=None):
        ICrdnSatisfactionConditionFilter.__init__(self, sourceObject)
        ICrdnPruneFilter.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSatisfactionConditionFilter._private_init(self, pUnk)
        ICrdnPruneFilter._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSatisfactionConditionFilter._get_property(self, attrname) is not None: found_prop = ICrdnSatisfactionConditionFilter._get_property(self, attrname)
        if ICrdnPruneFilter._get_property(self, attrname) is not None: found_prop = ICrdnPruneFilter._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSatisfactionConditionFilter.")
        
agcls.AgClassCatalog.add_catalog_entry("{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}", CrdnSatisfactionConditionFilter)


class CrdnSignalDelay(ICrdnSignalDelay, ICrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        ICrdnSignalDelay.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSignalDelay._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSignalDelay._get_property(self, attrname) is not None: found_prop = ICrdnSignalDelay._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSignalDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{71744841-D938-44BE-8336-2B54F06CF443}", CrdnSignalDelay)


class CrdnSignalDelayBasic(ICrdnSignalDelayBasic, ICrdnSignalDelay, ICrdn):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""
    def __init__(self, sourceObject=None):
        ICrdnSignalDelayBasic.__init__(self, sourceObject)
        ICrdnSignalDelay.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSignalDelayBasic._private_init(self, pUnk)
        ICrdnSignalDelay._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSignalDelayBasic._get_property(self, attrname) is not None: found_prop = ICrdnSignalDelayBasic._get_property(self, attrname)
        if ICrdnSignalDelay._get_property(self, attrname) is not None: found_prop = ICrdnSignalDelay._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSignalDelayBasic.")
        
agcls.AgClassCatalog.add_catalog_entry("{0763A330-475A-4E4E-AB26-8943A8CC1C92}", CrdnSignalDelayBasic)


class CrdnVolumeCalcFactory(ICrdnVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcFactory._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{80956ae5-fb8c-4ce4-930f-56b362d07cec}", CrdnVolumeCalcFactory)


class CrdnVolumeFactory(ICrdnVolumeFactory):
    """The factory is used to create instances of volumes."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeFactory._get_property(self, attrname) is not None: found_prop = ICrdnVolumeFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9497BD8-A985-4054-8ADE-9042DE66125F}", CrdnVolumeFactory)


class CrdnVolumeGridFactory(ICrdnVolumeGridFactory):
    """The factory is used to create instances of volume grids."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridFactory._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6359611-FB48-4B00-9017-01A4BE2B76E5}", CrdnVolumeGridFactory)


class CrdnGridCoordinateDefinition(ICrdnGridCoordinateDefinition):
    """Defines a set of coordinate values."""
    def __init__(self, sourceObject=None):
        ICrdnGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGridCoordinateDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGridCoordinateDefinition._get_property(self, attrname) is not None: found_prop = ICrdnGridCoordinateDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGridCoordinateDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}", CrdnGridCoordinateDefinition)


class CrdnGridValuesCustom(ICrdnGridValuesCustom, ICrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ICrdnGridValuesCustom.__init__(self, sourceObject)
        ICrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGridValuesCustom._private_init(self, pUnk)
        ICrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGridValuesCustom._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesCustom._get_property(self, attrname)
        if ICrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGridValuesCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}", CrdnGridValuesCustom)


class CrdnGridValuesFixedNumberOfSteps(ICrdnGridValuesFixedNumberOfSteps, ICrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ICrdnGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        ICrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGridValuesFixedNumberOfSteps._private_init(self, pUnk)
        ICrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGridValuesFixedNumberOfSteps._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesFixedNumberOfSteps._get_property(self, attrname)
        if ICrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGridValuesFixedNumberOfSteps.")
        
agcls.AgClassCatalog.add_catalog_entry("{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}", CrdnGridValuesFixedNumberOfSteps)


class CrdnGridValuesFixedStep(ICrdnGridValuesFixedStep, ICrdnGridValuesMethod):
    """Fixed step grid values."""
    def __init__(self, sourceObject=None):
        ICrdnGridValuesFixedStep.__init__(self, sourceObject)
        ICrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGridValuesFixedStep._private_init(self, pUnk)
        ICrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGridValuesFixedStep._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesFixedStep._get_property(self, attrname)
        if ICrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGridValuesFixedStep.")
        
agcls.AgClassCatalog.add_catalog_entry("{0942EA2D-33DE-41B5-98BE-E53E659EC81D}", CrdnGridValuesFixedStep)


class CrdnGridValuesMethod(ICrdnGridValuesMethod):
    """A grid values method."""
    def __init__(self, sourceObject=None):
        ICrdnGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnGridValuesMethod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnGridValuesMethod._get_property(self, attrname) is not None: found_prop = ICrdnGridValuesMethod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGridValuesMethod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D1D242BF-73F3-443A-AB46-64EAA02C5F37}", CrdnGridValuesMethod)


class CrdnLightTimeDelay(ICrdnLightTimeDelay):
    """Manage Light Time Delay options.."""
    def __init__(self, sourceObject=None):
        ICrdnLightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnLightTimeDelay._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnLightTimeDelay._get_property(self, attrname) is not None: found_prop = ICrdnLightTimeDelay._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnLightTimeDelay.")
        
agcls.AgClassCatalog.add_catalog_entry("{085E2242-4392-4F35-857E-A46A72EADE70}", CrdnLightTimeDelay)


class CrdnVolume(ICrdnVolume, ICrdn):
    """A volume interface. The methods and properties of the interface provide Volume functions."""
    def __init__(self, sourceObject=None):
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolume.")
        
agcls.AgClassCatalog.add_catalog_entry("{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}", CrdnVolume)


class CrdnVolumeCalc(ICrdnVolumeCalc, ICrdn):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{d014bfd1-130d-4dc4-a841-76c75bc08f9c}", CrdnVolumeCalc)


class CrdnVolumeCalcAltitude(ICrdnVolumeCalcAltitude, ICrdnVolumeCalc, ICrdn):
    """A volume calc altitude interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcAltitude.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcAltitude._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcAltitude._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcAltitude._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcAltitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{4e3c369c-c189-48ce-8e93-f0c6478f0abe}", CrdnVolumeCalcAltitude)


class CrdnVolumeCalcAngleOffVector(ICrdnVolumeCalcAngleOffVector, ICrdnVolumeCalc, ICrdn):
    """A volume calc angle off vector interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcAngleOffVector.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcAngleOffVector._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcAngleOffVector._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcAngleOffVector._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcAngleOffVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}", CrdnVolumeCalcAngleOffVector)


class CrdnVolumeCalcConditionSatMetric(ICrdnVolumeCalcConditionSatMetric, ICrdnVolumeCalc, ICrdn):
    """A volume calc condition satisfaction interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcConditionSatMetric._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcConditionSatMetric._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcConditionSatMetric._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcConditionSatMetric.")
        
agcls.AgClassCatalog.add_catalog_entry("{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}", CrdnVolumeCalcConditionSatMetric)


class CrdnVolumeCalcDelayRange(ICrdnVolumeCalcDelayRange, ICrdnVolumeCalc, ICrdn):
    """A volume calc propagation delay to location interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcDelayRange.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcDelayRange._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcDelayRange._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcDelayRange._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcDelayRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}", CrdnVolumeCalcDelayRange)


class CrdnVolumeCalcFile(ICrdnVolumeCalcFile, ICrdnVolumeCalc, ICrdn):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcFile.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcFile._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcFile._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcFile._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{188f96c6-9568-4609-9944-dfc5fb7247c5}", CrdnVolumeCalcFile)


class CrdnVolumeCalcFromScalar(ICrdnVolumeCalcFromScalar, ICrdnVolumeCalc, ICrdn):
    """A volume calc scalar to location interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcFromScalar.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcFromScalar._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcFromScalar._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcFromScalar._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcFromScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{73219623-93c0-4c6e-961a-7fae5dfe9234}", CrdnVolumeCalcFromScalar)


class CrdnVolumeCalcRange(ICrdnVolumeCalcRange, ICrdnVolumeCalc, ICrdn):
    """A volume calc distance to location interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcRange.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcRange._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcRange._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcRange._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcRange.")
        
agcls.AgClassCatalog.add_catalog_entry("{7f1aa95f-e8d6-4faf-925b-98785243ba67}", CrdnVolumeCalcRange)


class CrdnVolumeCalcSolarIntensity(ICrdnVolumeCalcSolarIntensity, ICrdnVolumeCalc, ICrdn):
    """A volume calc solar intensityn interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCalcSolarIntensity.__init__(self, sourceObject)
        ICrdnVolumeCalc.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCalcSolarIntensity._private_init(self, pUnk)
        ICrdnVolumeCalc._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCalcSolarIntensity._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalcSolarIntensity._get_property(self, attrname)
        if ICrdnVolumeCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCalc._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCalcSolarIntensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{7796e871-d645-4f65-a3dc-de687b6fbcd5}", CrdnVolumeCalcSolarIntensity)


class CrdnVolumeCombined(ICrdnVolumeCombined, ICrdnVolume, ICrdn):
    """A combined volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeCombined.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeCombined._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeCombined._get_property(self, attrname) is not None: found_prop = ICrdnVolumeCombined._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeCombined.")
        
agcls.AgClassCatalog.add_catalog_entry("{7ECD2E89-B432-47C3-A80F-AF6429E66746}", CrdnVolumeCombined)


class CrdnVolumeFromCalc(ICrdnVolumeFromCalc, ICrdnVolume, ICrdn):
    """An volume from calc volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeFromCalc.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeFromCalc._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeFromCalc._get_property(self, attrname) is not None: found_prop = ICrdnVolumeFromCalc._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeFromCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F2AC0BF-4645-4C7F-9660-A894E267FD59}", CrdnVolumeFromCalc)


class CrdnVolumeFromCondition(ICrdnVolumeFromCondition, ICrdnVolume, ICrdn):
    """A volume from conditioninterface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeFromCondition.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeFromCondition._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeFromCondition._get_property(self, attrname) is not None: found_prop = ICrdnVolumeFromCondition._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeFromCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{A2546B12-78BF-4F8F-87C2-31BC73DA265B}", CrdnVolumeFromCondition)


class CrdnVolumeFromGrid(ICrdnVolumeFromGrid, ICrdnVolume, ICrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeFromGrid.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeFromGrid._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeFromGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeFromGrid._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeFromGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{D49FE282-4C05-4097-970C-1282997378E9}", CrdnVolumeFromGrid)


class CrdnVolumeFromTimeSatisfaction(ICrdnVolumeFromTimeSatisfaction, ICrdnVolume, ICrdn):
    """An volume from time satisfaction volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeFromTimeSatisfaction._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeFromTimeSatisfaction._get_property(self, attrname) is not None: found_prop = ICrdnVolumeFromTimeSatisfaction._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeFromTimeSatisfaction.")
        
agcls.AgClassCatalog.add_catalog_entry("{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}", CrdnVolumeFromTimeSatisfaction)


class CrdnVolumeGrid(ICrdnVolumeGrid, ICrdn):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGrid.")
        
agcls.AgClassCatalog.add_catalog_entry("{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}", CrdnVolumeGrid)


class CrdnVolumeGridBearingAlt(ICrdnVolumeGridBearingAlt, ICrdnVolumeGrid, ICrdn):
    """A volume grid bearing alt (Surface Bearing) interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridBearingAlt.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridBearingAlt._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridBearingAlt._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridBearingAlt._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridBearingAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}", CrdnVolumeGridBearingAlt)


class CrdnVolumeGridCartesian(ICrdnVolumeGridCartesian, ICrdnVolumeGrid, ICrdn):
    """A volume grid Cartesian interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridCartesian.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridCartesian._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridCartesian._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridCartesian._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF15D0A4-BB42-4762-A761-9BD11DC948D0}", CrdnVolumeGridCartesian)


class CrdnVolumeGridConstrained(ICrdnVolumeGridConstrained, ICrdnVolumeGrid, ICrdn):
    """A volume grid constrained interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridConstrained.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridConstrained._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridConstrained._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridConstrained._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{253FC52C-5554-4A53-AE3D-624316ECFFFD}", CrdnVolumeGridConstrained)


class CrdnVolumeGridCylindrical(ICrdnVolumeGridCylindrical, ICrdnVolumeGrid, ICrdn):
    """A volume grid cylindrical interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridCylindrical.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridCylindrical._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridCylindrical._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridCylindrical._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridCylindrical.")
        
agcls.AgClassCatalog.add_catalog_entry("{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}", CrdnVolumeGridCylindrical)


class CrdnVolumeGridLatLonAlt(ICrdnVolumeGridLatLonAlt, ICrdnVolumeGrid, ICrdn):
    """A volume grid lat lon alt (Cartogrographic) interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridLatLonAlt.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridLatLonAlt._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridLatLonAlt._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridLatLonAlt._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridLatLonAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{89C10FC4-4031-4B63-9C55-E092DDF3839D}", CrdnVolumeGridLatLonAlt)


class CrdnVolumeGridResult(ICrdnVolumeGridResult):
    """An interface that generates Volume Grid results."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridResult._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}", CrdnVolumeGridResult)


class CrdnVolumeGridSpherical(ICrdnVolumeGridSpherical, ICrdnVolumeGrid, ICrdn):
    """A volume grid spherical interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeGridSpherical.__init__(self, sourceObject)
        ICrdnVolumeGrid.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeGridSpherical._private_init(self, pUnk)
        ICrdnVolumeGrid._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeGridSpherical._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGridSpherical._get_property(self, attrname)
        if ICrdnVolumeGrid._get_property(self, attrname) is not None: found_prop = ICrdnVolumeGrid._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeGridSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{0DFD2937-3181-4895-AB05-A45FFD744964}", CrdnVolumeGridSpherical)


class CrdnVolumeInview(ICrdnVolumeInview, ICrdnVolume, ICrdn):
    """An Inview volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeInview.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeInview._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeInview._get_property(self, attrname) is not None: found_prop = ICrdnVolumeInview._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeInview.")
        
agcls.AgClassCatalog.add_catalog_entry("{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}", CrdnVolumeInview)


class CrdnVolumeLighting(ICrdnVolumeLighting, ICrdnVolume, ICrdn):
    """A lighting volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeLighting.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeLighting._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeLighting._get_property(self, attrname) is not None: found_prop = ICrdnVolumeLighting._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeLighting.")
        
agcls.AgClassCatalog.add_catalog_entry("{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}", CrdnVolumeLighting)


class CrdnVolumeOverTime(ICrdnVolumeOverTime, ICrdnVolume, ICrdn):
    """An over time volume interface."""
    def __init__(self, sourceObject=None):
        ICrdnVolumeOverTime.__init__(self, sourceObject)
        ICrdnVolume.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVolumeOverTime._private_init(self, pUnk)
        ICrdnVolume._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVolumeOverTime._get_property(self, attrname) is not None: found_prop = ICrdnVolumeOverTime._get_property(self, attrname)
        if ICrdnVolume._get_property(self, attrname) is not None: found_prop = ICrdnVolume._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVolumeOverTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}", CrdnVolumeOverTime)


class CrdnGeneric(ICrdn):
    """Generic VGT component."""
    def __init__(self, sourceObject=None):
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnGeneric.")
        
agcls.AgClassCatalog.add_catalog_entry("{2909EDFB-9BE2-4BD2-A678-186C9D136937}", CrdnGeneric)


class CrdnTypeInfo(ICrdnTypeInfo):
    """VGT component info."""
    def __init__(self, sourceObject=None):
        ICrdnTypeInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnTypeInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnTypeInfo._get_property(self, attrname) is not None: found_prop = ICrdnTypeInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnTypeInfo.")
        
agcls.AgClassCatalog.add_catalog_entry("{BA26887C-6DFE-4F18-96D8-5694296568D2}", CrdnTypeInfo)


class CrdnInstance(ICrdnContext, ICrdnInstance):
    """Enables to obtain information about the parent object that owns the VGT component."""
    def __init__(self, sourceObject=None):
        ICrdnContext.__init__(self, sourceObject)
        ICrdnInstance.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnContext._private_init(self, pUnk)
        ICrdnInstance._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnContext._get_property(self, attrname) is not None: found_prop = ICrdnContext._get_property(self, attrname)
        if ICrdnInstance._get_property(self, attrname) is not None: found_prop = ICrdnInstance._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnInstance.")
        
agcls.AgClassCatalog.add_catalog_entry("{28241775-2044-4AD1-BC1D-D5B345437415}", CrdnInstance)


class CrdnTemplate(ICrdnContext, ICrdnTemplate):
    """Enables to obtain information about the STK class that owns the VGT component."""
    def __init__(self, sourceObject=None):
        ICrdnContext.__init__(self, sourceObject)
        ICrdnTemplate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnContext._private_init(self, pUnk)
        ICrdnTemplate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnContext._get_property(self, attrname) is not None: found_prop = ICrdnContext._get_property(self, attrname)
        if ICrdnTemplate._get_property(self, attrname) is not None: found_prop = ICrdnTemplate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnTemplate.")
        
agcls.AgClassCatalog.add_catalog_entry("{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}", CrdnTemplate)


class CrdnPointRefTo(ICrdnPointRefTo, ICrdnRefTo):
    """Represents a reference to a VGT point."""
    def __init__(self, sourceObject=None):
        ICrdnPointRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointRefTo._get_property(self, attrname) is not None: found_prop = ICrdnPointRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}", CrdnPointRefTo)


class CrdnVectorRefTo(ICrdnVectorRefTo, ICrdnRefTo):
    """Represents a vector reference."""
    def __init__(self, sourceObject=None):
        ICrdnVectorRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorRefTo._get_property(self, attrname) is not None: found_prop = ICrdnVectorRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}", CrdnVectorRefTo)


class CrdnAxesRefTo(ICrdnAxesRefTo, ICrdnRefTo):
    """Represents a reference to a VGT axes."""
    def __init__(self, sourceObject=None):
        ICrdnAxesRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesRefTo._get_property(self, attrname) is not None: found_prop = ICrdnAxesRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{ABAD0C95-5570-461A-9DA0-FD800B10DB20}", CrdnAxesRefTo)


class CrdnAngleRefTo(ICrdnAngleRefTo, ICrdnRefTo):
    """Represents a reference to a VGT angle."""
    def __init__(self, sourceObject=None):
        ICrdnAngleRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleRefTo._get_property(self, attrname) is not None: found_prop = ICrdnAngleRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1C8DFF6-65AA-4A6B-B160-7315BD795133}", CrdnAngleRefTo)


class CrdnSystemRefTo(ICrdnSystemRefTo, ICrdnRefTo):
    """Represents a System reference."""
    def __init__(self, sourceObject=None):
        ICrdnSystemRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemRefTo._get_property(self, attrname) is not None: found_prop = ICrdnSystemRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}", CrdnSystemRefTo)


class CrdnPlaneRefTo(ICrdnPlaneRefTo, ICrdnRefTo):
    """Represents a Plane reference."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneRefTo._get_property(self, attrname) is not None: found_prop = ICrdnPlaneRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}", CrdnPlaneRefTo)


class CrdnVector(ICrdnVector, ICrdnTimeProperties, ICrdn):
    """A generic vector class."""
    def __init__(self, sourceObject=None):
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{64392436-52D5-4274-9483-E10C56BBD037}", CrdnVector)


class CrdnAxesLabels(ICrdnAxesLabels):
    """Allows configuring the VGT axes labels."""
    def __init__(self, sourceObject=None):
        ICrdnAxesLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesLabels._get_property(self, attrname) is not None: found_prop = ICrdnAxesLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{AC9F13AD-1E42-4695-AC74-6259D2013E4F}", CrdnAxesLabels)


class CrdnAxes(ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """A generic axes class."""
    def __init__(self, sourceObject=None):
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{50F5DD10-4D83-4603-94ED-BF7514C26282}", CrdnAxes)


class CrdnPoint(ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """A generic VGT point class."""
    def __init__(self, sourceObject=None):
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPoint.")
        
agcls.AgClassCatalog.add_catalog_entry("{0092C129-467E-4B36-B971-C53F65481DA9}", CrdnPoint)


class CrdnSystem(ICrdnSystem, ICrdnTimeProperties, ICrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        ICrdnSystem.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystem._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystem._get_property(self, attrname) is not None: found_prop = ICrdnSystem._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystem.")
        
agcls.AgClassCatalog.add_catalog_entry("{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}", CrdnSystem)


class CrdnAngle(ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{C3F96DA3-00EC-4E20-A66C-B3506100496B}", CrdnAngle)


class CrdnPlaneLabels(ICrdnPlaneLabels):
    """Allows configuring the X and Y axes labels."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneLabels._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneLabels._get_property(self, attrname) is not None: found_prop = ICrdnPlaneLabels._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneLabels.")
        
agcls.AgClassCatalog.add_catalog_entry("{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}", CrdnPlaneLabels)


class CrdnPlane(ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """Base class for VGT axes."""
    def __init__(self, sourceObject=None):
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E6EAA85-8440-4C4E-97FE-76491E05098A}", CrdnPlane)


class CrdnAxesAlignedAndConstrained(ICrdnAxesAlignedAndConstrained, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    def __init__(self, sourceObject=None):
        ICrdnAxesAlignedAndConstrained.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesAlignedAndConstrained._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesAlignedAndConstrained._get_property(self, attrname) is not None: found_prop = ICrdnAxesAlignedAndConstrained._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesAlignedAndConstrained.")
        
agcls.AgClassCatalog.add_catalog_entry("{46BB7D5B-6593-434F-B288-BF1445920A2C}", CrdnAxesAlignedAndConstrained)


class CrdnAxesAngularOffset(ICrdnAxesAngularOffset, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        ICrdnAxesAngularOffset.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesAngularOffset._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesAngularOffset._get_property(self, attrname) is not None: found_prop = ICrdnAxesAngularOffset._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesAngularOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{64503F8B-96E7-455B-B589-2578ADE1214B}", CrdnAxesAngularOffset)


class CrdnAxesFixedAtEpoch(ICrdnAxesFixedAtEpoch, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes based on another set fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        ICrdnAxesFixedAtEpoch.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesFixedAtEpoch._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesFixedAtEpoch._get_property(self, attrname) is not None: found_prop = ICrdnAxesFixedAtEpoch._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}", CrdnAxesFixedAtEpoch)


class CrdnAxesBPlane(ICrdnAxesBPlane, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """B-Plane axes using the selected target body and reference vector."""
    def __init__(self, sourceObject=None):
        ICrdnAxesBPlane.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesBPlane._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesBPlane._get_property(self, attrname) is not None: found_prop = ICrdnAxesBPlane._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0F714EA-31E4-4F92-876F-BDD3183C29B5}", CrdnAxesBPlane)


class CrdnAxesCustomScript(ICrdnAxesCustomScript, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Customized axes offset with respect to a set of reference Axes."""
    def __init__(self, sourceObject=None):
        ICrdnAxesCustomScript.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesCustomScript._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesCustomScript._get_property(self, attrname) is not None: found_prop = ICrdnAxesCustomScript._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC7A87DC-118E-46ED-8657-90DF42B7B101}", CrdnAxesCustomScript)


class CrdnAxesAttitudeFile(ICrdnAxesAttitudeFile, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes specified by data from a file."""
    def __init__(self, sourceObject=None):
        ICrdnAxesAttitudeFile.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesAttitudeFile._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesAttitudeFile._get_property(self, attrname) is not None: found_prop = ICrdnAxesAttitudeFile._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesAttitudeFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{3505D063-9E1B-4964-9865-FFE41F64C8CF}", CrdnAxesAttitudeFile)


class CrdnAxesFixed(ICrdnAxesFixed, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes fixed in reference axes."""
    def __init__(self, sourceObject=None):
        ICrdnAxesFixed.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesFixed._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesFixed._get_property(self, attrname) is not None: found_prop = ICrdnAxesFixed._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesFixed.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}", CrdnAxesFixed)


class CrdnAxesModelAttach(ICrdnAxesModelAttach, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        ICrdnAxesModelAttach.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesModelAttach._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesModelAttach._get_property(self, attrname) is not None: found_prop = ICrdnAxesModelAttach._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{816C612A-13DD-4812-BFDE-E3861F8C39FD}", CrdnAxesModelAttach)


class CrdnAxesSpinning(ICrdnAxesSpinning, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    def __init__(self, sourceObject=None):
        ICrdnAxesSpinning.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesSpinning._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesSpinning._get_property(self, attrname) is not None: found_prop = ICrdnAxesSpinning._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesSpinning.")
        
agcls.AgClassCatalog.add_catalog_entry("{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}", CrdnAxesSpinning)


class CrdnAxesOnSurface(ICrdnAxesOnSurface, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Topocentric axes located at the reference point's projection on the central body."""
    def __init__(self, sourceObject=None):
        ICrdnAxesOnSurface.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesOnSurface._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesOnSurface._get_property(self, attrname) is not None: found_prop = ICrdnAxesOnSurface._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE8C301A-A846-44FD-8871-5AB4CAACEF11}", CrdnAxesOnSurface)


class CrdnAxesTrajectory(ICrdnAxesTrajectory, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    def __init__(self, sourceObject=None):
        ICrdnAxesTrajectory.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesTrajectory._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesTrajectory._get_property(self, attrname) is not None: found_prop = ICrdnAxesTrajectory._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{4038771E-73C1-4989-A9AB-4DC37025FACC}", CrdnAxesTrajectory)


class CrdnAxesLagrangeLibration(ICrdnAxesLagrangeLibration, ICrdnAxes, ICrdnTimeProperties, ICrdn):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    def __init__(self, sourceObject=None):
        ICrdnAxesLagrangeLibration.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesLagrangeLibration._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesLagrangeLibration._get_property(self, attrname) is not None: found_prop = ICrdnAxesLagrangeLibration._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{16315085-7C87-4A20-865C-0F419A5CDA2F}", CrdnAxesLagrangeLibration)


class CrdnAxesCommonTasks(ICrdnAxesCommonTasks):
    """Provides methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        ICrdnAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesCommonTasks._get_property(self, attrname) is not None: found_prop = ICrdnAxesCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{07D4865C-78F1-4B3A-9756-D70050613D4A}", CrdnAxesCommonTasks)


class CrdnAxesAtTimeInstant(ICrdnAxesAtTimeInstant, ICrdn, ICrdnTimeProperties, ICrdnAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        ICrdnAxesAtTimeInstant.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesAtTimeInstant._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICrdnAxesAtTimeInstant._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{3845C20A-A6E2-45A0-A748-10E9B565C48D}", CrdnAxesAtTimeInstant)


class CrdnAxesPlugin(ICrdnAxesPlugin, ICrdn, ICrdnTimeProperties, ICrdnAxes):
    """A VGT axes plugin."""
    def __init__(self, sourceObject=None):
        ICrdnAxesPlugin.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesPlugin._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesPlugin._get_property(self, attrname) is not None: found_prop = ICrdnAxesPlugin._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnAxes._get_property(self, attrname) is not None: found_prop = ICrdnAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}", CrdnAxesPlugin)


class CrdnAngleBetweenVectors(ICrdnAngleBetweenVectors, ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """An angle between two vectors."""
    def __init__(self, sourceObject=None):
        ICrdnAngleBetweenVectors.__init__(self, sourceObject)
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleBetweenVectors._private_init(self, pUnk)
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleBetweenVectors._get_property(self, attrname) is not None: found_prop = ICrdnAngleBetweenVectors._get_property(self, attrname)
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleBetweenVectors.")
        
agcls.AgClassCatalog.add_catalog_entry("{2F0AA430-85D0-4479-9540-B1B64EB3B530}", CrdnAngleBetweenVectors)


class CrdnAngleBetweenPlanes(ICrdnAngleBetweenPlanes, ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """An angle between two planes."""
    def __init__(self, sourceObject=None):
        ICrdnAngleBetweenPlanes.__init__(self, sourceObject)
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleBetweenPlanes._private_init(self, pUnk)
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleBetweenPlanes._get_property(self, attrname) is not None: found_prop = ICrdnAngleBetweenPlanes._get_property(self, attrname)
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleBetweenPlanes.")
        
agcls.AgClassCatalog.add_catalog_entry("{30C2886F-8792-475D-9E42-975308B1B94E}", CrdnAngleBetweenPlanes)


class CrdnAngleDihedral(ICrdnAngleDihedral, ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """An angle between two vectors about an axis."""
    def __init__(self, sourceObject=None):
        ICrdnAngleDihedral.__init__(self, sourceObject)
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleDihedral._private_init(self, pUnk)
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleDihedral._get_property(self, attrname) is not None: found_prop = ICrdnAngleDihedral._get_property(self, attrname)
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleDihedral.")
        
agcls.AgClassCatalog.add_catalog_entry("{550855BB-E8F1-440B-BA5C-024ACE2E2A17}", CrdnAngleDihedral)


class CrdnAngleRotation(ICrdnAngleRotation, ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""
    def __init__(self, sourceObject=None):
        ICrdnAngleRotation.__init__(self, sourceObject)
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleRotation._private_init(self, pUnk)
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleRotation._get_property(self, attrname) is not None: found_prop = ICrdnAngleRotation._get_property(self, attrname)
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleRotation.")
        
agcls.AgClassCatalog.add_catalog_entry("{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}", CrdnAngleRotation)


class CrdnAngleToPlane(ICrdnAngleToPlane, ICrdnAngle, ICrdnTimeProperties, ICrdn):
    """An angle between a vector and a plane."""
    def __init__(self, sourceObject=None):
        ICrdnAngleToPlane.__init__(self, sourceObject)
        ICrdnAngle.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleToPlane._private_init(self, pUnk)
        ICrdnAngle._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleToPlane._get_property(self, attrname) is not None: found_prop = ICrdnAngleToPlane._get_property(self, attrname)
        if ICrdnAngle._get_property(self, attrname) is not None: found_prop = ICrdnAngle._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleToPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}", CrdnAngleToPlane)


class CrdnPlaneNormal(ICrdnPlaneNormal, ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneNormal.__init__(self, sourceObject)
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneNormal._private_init(self, pUnk)
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneNormal._get_property(self, attrname) is not None: found_prop = ICrdnPlaneNormal._get_property(self, attrname)
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{0AED319D-7B6C-462B-882B-D363F7A2A86C}", CrdnPlaneNormal)


class CrdnPlaneQuadrant(ICrdnPlaneQuadrant, ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """A plane based on a selected Quadrant of a reference system."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneQuadrant.__init__(self, sourceObject)
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneQuadrant._private_init(self, pUnk)
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneQuadrant._get_property(self, attrname) is not None: found_prop = ICrdnPlaneQuadrant._get_property(self, attrname)
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneQuadrant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}", CrdnPlaneQuadrant)


class CrdnPlaneTrajectory(ICrdnPlaneTrajectory, ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneTrajectory.__init__(self, sourceObject)
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneTrajectory._private_init(self, pUnk)
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneTrajectory._get_property(self, attrname) is not None: found_prop = ICrdnPlaneTrajectory._get_property(self, attrname)
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneTrajectory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7BD18F79-6788-48B1-AFB5-243D62C01177}", CrdnPlaneTrajectory)


class CrdnPlaneTriad(ICrdnPlaneTriad, ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneTriad.__init__(self, sourceObject)
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneTriad._private_init(self, pUnk)
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneTriad._get_property(self, attrname) is not None: found_prop = ICrdnPlaneTriad._get_property(self, attrname)
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneTriad.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}", CrdnPlaneTriad)


class CrdnPlaneTwoVector(ICrdnPlaneTwoVector, ICrdnPlane, ICrdnTimeProperties, ICrdn):
    """A plane normal to a vector at a given point."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneTwoVector.__init__(self, sourceObject)
        ICrdnPlane.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneTwoVector._private_init(self, pUnk)
        ICrdnPlane._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneTwoVector._get_property(self, attrname) is not None: found_prop = ICrdnPlaneTwoVector._get_property(self, attrname)
        if ICrdnPlane._get_property(self, attrname) is not None: found_prop = ICrdnPlane._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneTwoVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{49a61e7a-baba-48fd-9d9d-61f91c520291}", CrdnPlaneTwoVector)


class CrdnPointBPlane(ICrdnPointBPlane, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """B-Plane point using the selected target body."""
    def __init__(self, sourceObject=None):
        ICrdnPointBPlane.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointBPlane._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointBPlane._get_property(self, attrname) is not None: found_prop = ICrdnPointBPlane._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{E62329EB-83D1-47CE-8B5B-B795995A2270}", CrdnPointBPlane)


class CrdnPointFile(ICrdnPointFile, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """Point specified by data from a file."""
    def __init__(self, sourceObject=None):
        ICrdnPointFile.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointFile._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointFile._get_property(self, attrname) is not None: found_prop = ICrdnPointFile._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{0E71C927-09CA-4A90-95F0-CB87E244CE72}", CrdnPointFile)


class CrdnPointFixedInSystem(ICrdnPointFixedInSystem, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """Point fixed in a reference coordinate system using the selected coordinate type."""
    def __init__(self, sourceObject=None):
        ICrdnPointFixedInSystem.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointFixedInSystem._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointFixedInSystem._get_property(self, attrname) is not None: found_prop = ICrdnPointFixedInSystem._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointFixedInSystem.")
        
agcls.AgClassCatalog.add_catalog_entry("{9FA10E06-094A-446C-BE9A-5BA397776778}", CrdnPointFixedInSystem)


class CrdnPointGrazing(ICrdnPointGrazing, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    def __init__(self, sourceObject=None):
        ICrdnPointGrazing.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointGrazing._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointGrazing._get_property(self, attrname) is not None: found_prop = ICrdnPointGrazing._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}", CrdnPointGrazing)


class CrdnPointGlint(ICrdnPointGlint, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """Point on central body surface that reflects from source to observer."""
    def __init__(self, sourceObject=None):
        ICrdnPointGlint.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointGlint._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointGlint._get_property(self, attrname) is not None: found_prop = ICrdnPointGlint._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointGlint.")
        
agcls.AgClassCatalog.add_catalog_entry("{68F85553-0FA2-459D-93AC-BD4D68A01F6F}", CrdnPointGlint)


class CrdnPointCovarianceGrazing(ICrdnPointCovarianceGrazing, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    def __init__(self, sourceObject=None):
        ICrdnPointCovarianceGrazing.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointCovarianceGrazing._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointCovarianceGrazing._get_property(self, attrname) is not None: found_prop = ICrdnPointCovarianceGrazing._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointCovarianceGrazing.")
        
agcls.AgClassCatalog.add_catalog_entry("{84D91807-716E-46F4-AB70-53C73FA21C20}", CrdnPointCovarianceGrazing)


class CrdnPointPlaneIntersection(ICrdnPointPlaneIntersection, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """Point on a plane located along a given direction looking from a given origin."""
    def __init__(self, sourceObject=None):
        ICrdnPointPlaneIntersection.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointPlaneIntersection._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointPlaneIntersection._get_property(self, attrname) is not None: found_prop = ICrdnPointPlaneIntersection._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointPlaneIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}", CrdnPointPlaneIntersection)


class CrdnPointOnSurface(ICrdnPointOnSurface, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """The detic subpoint of the reference point as projected onto the central body."""
    def __init__(self, sourceObject=None):
        ICrdnPointOnSurface.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointOnSurface._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointOnSurface._get_property(self, attrname) is not None: found_prop = ICrdnPointOnSurface._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{03ECCFD1-B058-4817-826F-EDE2A6880757}", CrdnPointOnSurface)


class CrdnPointModelAttach(ICrdnPointModelAttach, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    def __init__(self, sourceObject=None):
        ICrdnPointModelAttach.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointModelAttach._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointModelAttach._get_property(self, attrname) is not None: found_prop = ICrdnPointModelAttach._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{15958616-F779-4772-9E54-9B134B69BE89}", CrdnPointModelAttach)


class CrdnPointSatelliteCollectionEntry(ICrdnPointSatelliteCollectionEntry, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""
    def __init__(self, sourceObject=None):
        ICrdnPointSatelliteCollectionEntry.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointSatelliteCollectionEntry._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointSatelliteCollectionEntry._get_property(self, attrname) is not None: found_prop = ICrdnPointSatelliteCollectionEntry._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointSatelliteCollectionEntry.")
        
agcls.AgClassCatalog.add_catalog_entry("{d0dacbed-0c16-4de5-b32a-9c7624297014}", CrdnPointSatelliteCollectionEntry)


class CrdnPointPlaneProjection(ICrdnPointPlaneProjection, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""
    def __init__(self, sourceObject=None):
        ICrdnPointPlaneProjection.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointPlaneProjection._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointPlaneProjection._get_property(self, attrname) is not None: found_prop = ICrdnPointPlaneProjection._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointPlaneProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}", CrdnPointPlaneProjection)


class CrdnPointLagrangeLibration(ICrdnPointLagrangeLibration, ICrdnPoint, ICrdnTimeProperties, ICrdn):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""
    def __init__(self, sourceObject=None):
        ICrdnPointLagrangeLibration.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointLagrangeLibration._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointLagrangeLibration._get_property(self, attrname) is not None: found_prop = ICrdnPointLagrangeLibration._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointLagrangeLibration.")
        
agcls.AgClassCatalog.add_catalog_entry("{6BF6D976-775A-445D-AD2B-899892F3127E}", CrdnPointLagrangeLibration)


class CrdnPointCommonTasks(ICrdnPointCommonTasks):
    """Provides methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        ICrdnPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointCommonTasks._get_property(self, attrname) is not None: found_prop = ICrdnPointCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{9866644C-E731-465E-A7AA-3F4667C1729E}", CrdnPointCommonTasks)


class CrdnPointCentBodyIntersect(ICrdnPointCentBodyIntersect, ICrdn, ICrdnTimeProperties, ICrdnPoint):
    """Point on central body surface along direction vector originating at source point."""
    def __init__(self, sourceObject=None):
        ICrdnPointCentBodyIntersect.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointCentBodyIntersect._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointCentBodyIntersect._get_property(self, attrname) is not None: found_prop = ICrdnPointCentBodyIntersect._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointCentBodyIntersect.")
        
agcls.AgClassCatalog.add_catalog_entry("{882047E8-7CB3-489B-B029-33163CBBA583}", CrdnPointCentBodyIntersect)


class CrdnPointAtTimeInstant(ICrdnPointAtTimeInstant, ICrdn, ICrdnTimeProperties, ICrdnPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        ICrdnPointAtTimeInstant.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointAtTimeInstant._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICrdnPointAtTimeInstant._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}", CrdnPointAtTimeInstant)


class CrdnPointPlugin(ICrdnPointPlugin, ICrdn, ICrdnTimeProperties, ICrdnPoint):
    """A VGT point plugin."""
    def __init__(self, sourceObject=None):
        ICrdnPointPlugin.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointPlugin._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointPlugin._get_property(self, attrname) is not None: found_prop = ICrdnPointPlugin._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}", CrdnPointPlugin)


class CrdnPointCBFixedOffset(ICrdnPointCBFixedOffset, ICrdn, ICrdnTimeProperties, ICrdnPoint):
    """Point specified by fixed components with respect to central body."""
    def __init__(self, sourceObject=None):
        ICrdnPointCBFixedOffset.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnPoint.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointCBFixedOffset._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnPoint._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointCBFixedOffset._get_property(self, attrname) is not None: found_prop = ICrdnPointCBFixedOffset._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnPoint._get_property(self, attrname) is not None: found_prop = ICrdnPoint._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointCBFixedOffset.")
        
agcls.AgClassCatalog.add_catalog_entry("{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}", CrdnPointCBFixedOffset)


class CrdnSystemAssembled(ICrdnSystemAssembled, ICrdnSystem, ICrdnTimeProperties, ICrdn):
    """A system assembled from an origin point and a set of reference axes."""
    def __init__(self, sourceObject=None):
        ICrdnSystemAssembled.__init__(self, sourceObject)
        ICrdnSystem.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemAssembled._private_init(self, pUnk)
        ICrdnSystem._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemAssembled._get_property(self, attrname) is not None: found_prop = ICrdnSystemAssembled._get_property(self, attrname)
        if ICrdnSystem._get_property(self, attrname) is not None: found_prop = ICrdnSystem._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemAssembled.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE4E84B1-8CCF-467A-A3ED-274D0943407F}", CrdnSystemAssembled)


class CrdnSystemOnSurface(ICrdnSystemOnSurface, ICrdnSystem, ICrdnTimeProperties, ICrdn):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""
    def __init__(self, sourceObject=None):
        ICrdnSystemOnSurface.__init__(self, sourceObject)
        ICrdnSystem.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemOnSurface._private_init(self, pUnk)
        ICrdnSystem._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemOnSurface._get_property(self, attrname) is not None: found_prop = ICrdnSystemOnSurface._get_property(self, attrname)
        if ICrdnSystem._get_property(self, attrname) is not None: found_prop = ICrdnSystem._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemOnSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{073423F9-A59D-4313-B499-C86A45C63513}", CrdnSystemOnSurface)


class CrdnLLAPosition(ICrdnLLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""
    def __init__(self, sourceObject=None):
        ICrdnLLAPosition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnLLAPosition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnLLAPosition._get_property(self, attrname) is not None: found_prop = ICrdnLLAPosition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnLLAPosition.")
        
agcls.AgClassCatalog.add_catalog_entry("{CB962F51-978A-43F9-A88B-AAB62117F93C}", CrdnLLAPosition)


class CrdnSystemCommonTasks(ICrdnSystemCommonTasks):
    """Provides methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""
    def __init__(self, sourceObject=None):
        ICrdnSystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemCommonTasks._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemCommonTasks._get_property(self, attrname) is not None: found_prop = ICrdnSystemCommonTasks._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemCommonTasks.")
        
agcls.AgClassCatalog.add_catalog_entry("{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}", CrdnSystemCommonTasks)


class CrdnVectorAngleRate(ICrdnVectorAngleRate, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    def __init__(self, sourceObject=None):
        ICrdnVectorAngleRate.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorAngleRate._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorAngleRate._get_property(self, attrname) is not None: found_prop = ICrdnVectorAngleRate._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorAngleRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{5769E079-8E9B-40B2-B2EF-14F202AF5666}", CrdnVectorAngleRate)


class CrdnVectorApoapsis(ICrdnVectorApoapsis, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        ICrdnVectorApoapsis.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorApoapsis._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorApoapsis._get_property(self, attrname) is not None: found_prop = ICrdnVectorApoapsis._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{22E4138C-29C6-4401-91E0-DF0C00422302}", CrdnVectorApoapsis)


class CrdnVectorFixedAtEpoch(ICrdnVectorFixedAtEpoch, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Based on another vector fixed at a specified epoch."""
    def __init__(self, sourceObject=None):
        ICrdnVectorFixedAtEpoch.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorFixedAtEpoch._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorFixedAtEpoch._get_property(self, attrname) is not None: found_prop = ICrdnVectorFixedAtEpoch._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorFixedAtEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{FA8DB5F5-1F28-40E6-9B86-489E06D61523}", CrdnVectorFixedAtEpoch)


class CrdnVectorAngularVelocity(ICrdnVectorAngularVelocity, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    def __init__(self, sourceObject=None):
        ICrdnVectorAngularVelocity.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorAngularVelocity._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorAngularVelocity._get_property(self, attrname) is not None: found_prop = ICrdnVectorAngularVelocity._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorAngularVelocity.")
        
agcls.AgClassCatalog.add_catalog_entry("{2ABC83DB-6F6C-4A91-8597-21BD2715D411}", CrdnVectorAngularVelocity)


class CrdnVectorConing(ICrdnVectorConing, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""
    def __init__(self, sourceObject=None):
        ICrdnVectorConing.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorConing._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorConing._get_property(self, attrname) is not None: found_prop = ICrdnVectorConing._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorConing.")
        
agcls.AgClassCatalog.add_catalog_entry("{74E6F986-E292-4115-84E4-9E9953C163B8}", CrdnVectorConing)


class CrdnVectorCross(ICrdnVectorCross, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """The vector cross product of two vectors."""
    def __init__(self, sourceObject=None):
        ICrdnVectorCross.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorCross._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorCross._get_property(self, attrname) is not None: found_prop = ICrdnVectorCross._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorCross.")
        
agcls.AgClassCatalog.add_catalog_entry("{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}", CrdnVectorCross)


class CrdnVectorCustomScript(ICrdnVectorCustomScript, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Customized vector components defined with respect to reference axes."""
    def __init__(self, sourceObject=None):
        ICrdnVectorCustomScript.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorCustomScript._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorCustomScript._get_property(self, attrname) is not None: found_prop = ICrdnVectorCustomScript._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorCustomScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{D65CDDC6-21DA-419F-BF72-79C2376648E8}", CrdnVectorCustomScript)


class CrdnVectorDerivative(ICrdnVectorDerivative, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """A vector derivative of a vector computed with respect to specified axes."""
    def __init__(self, sourceObject=None):
        ICrdnVectorDerivative.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorDerivative._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorDerivative._get_property(self, attrname) is not None: found_prop = ICrdnVectorDerivative._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorDerivative.")
        
agcls.AgClassCatalog.add_catalog_entry("{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}", CrdnVectorDerivative)


class CrdnVectorDisplacement(ICrdnVectorDisplacement, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector defined by its start and end points."""
    def __init__(self, sourceObject=None):
        ICrdnVectorDisplacement.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorDisplacement._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorDisplacement._get_property(self, attrname) is not None: found_prop = ICrdnVectorDisplacement._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorDisplacement.")
        
agcls.AgClassCatalog.add_catalog_entry("{6CAADA67-7238-4705-9F74-95596344DED0}", CrdnVectorDisplacement)


class CrdnVectorTwoPlanesIntersection(ICrdnVectorTwoPlanesIntersection, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Defined along the intersection of two planes."""
    def __init__(self, sourceObject=None):
        ICrdnVectorTwoPlanesIntersection.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorTwoPlanesIntersection._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorTwoPlanesIntersection._get_property(self, attrname) is not None: found_prop = ICrdnVectorTwoPlanesIntersection._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorTwoPlanesIntersection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B1145553-76CD-4C1E-AE08-E63E29CF4E46}", CrdnVectorTwoPlanesIntersection)


class CrdnVectorModelAttach(ICrdnVectorModelAttach, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    def __init__(self, sourceObject=None):
        ICrdnVectorModelAttach.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorModelAttach._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorModelAttach._get_property(self, attrname) is not None: found_prop = ICrdnVectorModelAttach._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorModelAttach.")
        
agcls.AgClassCatalog.add_catalog_entry("{E95BEEB8-C544-4852-9C82-20080343E585}", CrdnVectorModelAttach)


class CrdnVectorProjection(ICrdnVectorProjection, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """A projection of a vector computed with respect to a reference plane."""
    def __init__(self, sourceObject=None):
        ICrdnVectorProjection.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorProjection._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorProjection._get_property(self, attrname) is not None: found_prop = ICrdnVectorProjection._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorProjection.")
        
agcls.AgClassCatalog.add_catalog_entry("{7306544A-A8B0-477B-B89D-BA711C9ED600}", CrdnVectorProjection)


class CrdnVectorScaled(ICrdnVectorScaled, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""
    def __init__(self, sourceObject=None):
        ICrdnVectorScaled.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorScaled._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorScaled._get_property(self, attrname) is not None: found_prop = ICrdnVectorScaled._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{92D80C29-251B-436B-9DA0-D5BA4B262185}", CrdnVectorScaled)


class CrdnVectorEccentricity(ICrdnVectorEccentricity, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        ICrdnVectorEccentricity.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorEccentricity._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorEccentricity._get_property(self, attrname) is not None: found_prop = ICrdnVectorEccentricity._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7F157D7-11EB-4779-955F-98530B9C2608}", CrdnVectorEccentricity)


class CrdnVectorFixedInAxes(ICrdnVectorFixedInAxes, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector fixed in reference axes."""
    def __init__(self, sourceObject=None):
        ICrdnVectorFixedInAxes.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorFixedInAxes._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorFixedInAxes._get_property(self, attrname) is not None: found_prop = ICrdnVectorFixedInAxes._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorFixedInAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{61E9F963-8CFC-4B24-B583-716A64BAE54C}", CrdnVectorFixedInAxes)


class CrdnVectorLineOfNodes(ICrdnVectorLineOfNodes, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    def __init__(self, sourceObject=None):
        ICrdnVectorLineOfNodes.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorLineOfNodes._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorLineOfNodes._get_property(self, attrname) is not None: found_prop = ICrdnVectorLineOfNodes._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorLineOfNodes.")
        
agcls.AgClassCatalog.add_catalog_entry("{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}", CrdnVectorLineOfNodes)


class CrdnVectorOrbitAngularMomentum(ICrdnVectorOrbitAngularMomentum, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        ICrdnVectorOrbitAngularMomentum.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorOrbitAngularMomentum._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorOrbitAngularMomentum._get_property(self, attrname) is not None: found_prop = ICrdnVectorOrbitAngularMomentum._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorOrbitAngularMomentum.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}", CrdnVectorOrbitAngularMomentum)


class CrdnVectorOrbitNormal(ICrdnVectorOrbitNormal, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    def __init__(self, sourceObject=None):
        ICrdnVectorOrbitNormal.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorOrbitNormal._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorOrbitNormal._get_property(self, attrname) is not None: found_prop = ICrdnVectorOrbitNormal._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorOrbitNormal.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}", CrdnVectorOrbitNormal)


class CrdnVectorPeriapsis(ICrdnVectorPeriapsis, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    def __init__(self, sourceObject=None):
        ICrdnVectorPeriapsis.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorPeriapsis._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorPeriapsis._get_property(self, attrname) is not None: found_prop = ICrdnVectorPeriapsis._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA81B380-6D7C-48F4-8E7F-472035958B44}", CrdnVectorPeriapsis)


class CrdnVectorReflection(ICrdnVectorReflection, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    def __init__(self, sourceObject=None):
        ICrdnVectorReflection.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorReflection._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorReflection._get_property(self, attrname) is not None: found_prop = ICrdnVectorReflection._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorReflection.")
        
agcls.AgClassCatalog.add_catalog_entry("{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}", CrdnVectorReflection)


class CrdnVectorRotationVector(ICrdnVectorRotationVector, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    def __init__(self, sourceObject=None):
        ICrdnVectorRotationVector.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorRotationVector._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorRotationVector._get_property(self, attrname) is not None: found_prop = ICrdnVectorRotationVector._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorRotationVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}", CrdnVectorRotationVector)


class CrdnVectorDirectionToStar(ICrdnVectorDirectionToStar, ICrdnVector, ICrdnTimeProperties, ICrdn):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""
    def __init__(self, sourceObject=None):
        ICrdnVectorDirectionToStar.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorDirectionToStar._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorDirectionToStar._get_property(self, attrname) is not None: found_prop = ICrdnVectorDirectionToStar._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorDirectionToStar.")
        
agcls.AgClassCatalog.add_catalog_entry("{147FDFCC-767A-460C-9833-02A582AFCA9C}", CrdnVectorDirectionToStar)


class CrdnVectorFixedAtTimeInstant(ICrdnVectorFixedAtTimeInstant, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    def __init__(self, sourceObject=None):
        ICrdnVectorFixedAtTimeInstant.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorFixedAtTimeInstant._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorFixedAtTimeInstant._get_property(self, attrname) is not None: found_prop = ICrdnVectorFixedAtTimeInstant._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorFixedAtTimeInstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC8737B3-A94E-4B68-857F-81E780C874FD}", CrdnVectorFixedAtTimeInstant)


class CrdnVectorLinearCombination(ICrdnVectorLinearCombination, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Linear combination of two input vectors."""
    def __init__(self, sourceObject=None):
        ICrdnVectorLinearCombination.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorLinearCombination._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorLinearCombination._get_property(self, attrname) is not None: found_prop = ICrdnVectorLinearCombination._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{59E2764C-7920-4CDC-B5FF-2590154E1ABE}", CrdnVectorLinearCombination)


class CrdnVectorProjectAlongVector(ICrdnVectorProjectAlongVector, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """A projection of a source vector in the direction of another vector."""
    def __init__(self, sourceObject=None):
        ICrdnVectorProjectAlongVector.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorProjectAlongVector._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorProjectAlongVector._get_property(self, attrname) is not None: found_prop = ICrdnVectorProjectAlongVector._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorProjectAlongVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B76B999-135B-4AAF-ADEA-444FD759417D}", CrdnVectorProjectAlongVector)


class CrdnVectorScalarLinearCombination(ICrdnVectorScalarLinearCombination, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Linear combination of two input vectors using scalars."""
    def __init__(self, sourceObject=None):
        ICrdnVectorScalarLinearCombination.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorScalarLinearCombination._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorScalarLinearCombination._get_property(self, attrname) is not None: found_prop = ICrdnVectorScalarLinearCombination._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorScalarLinearCombination.")
        
agcls.AgClassCatalog.add_catalog_entry("{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}", CrdnVectorScalarLinearCombination)


class CrdnVectorScalarScaled(ICrdnVectorScalarScaled, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Scaled version of the input vector using scalar."""
    def __init__(self, sourceObject=None):
        ICrdnVectorScalarScaled.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorScalarScaled._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorScalarScaled._get_property(self, attrname) is not None: found_prop = ICrdnVectorScalarScaled._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorScalarScaled.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C93B992-687F-4311-B339-DE0DA38409AE}", CrdnVectorScalarScaled)


class CrdnVectorVelocityAcceleration(ICrdnVectorVelocityAcceleration, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Velocity vector of a point in a coordinate system."""
    def __init__(self, sourceObject=None):
        ICrdnVectorVelocityAcceleration.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorVelocityAcceleration._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorVelocityAcceleration._get_property(self, attrname) is not None: found_prop = ICrdnVectorVelocityAcceleration._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorVelocityAcceleration.")
        
agcls.AgClassCatalog.add_catalog_entry("{75A62225-C09F-4F08-B7FE-9216B02DECF2}", CrdnVectorVelocityAcceleration)


class CrdnVectorPlugin(ICrdnVectorPlugin, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """A VGT vector plugin."""
    def __init__(self, sourceObject=None):
        ICrdnVectorPlugin.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorPlugin._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorPlugin._get_property(self, attrname) is not None: found_prop = ICrdnVectorPlugin._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{E105429A-489E-47F6-B827-8E5819FCE917}", CrdnVectorPlugin)


class CrdnVectorDispSurface(ICrdnVectorDispSurface, ICrdn, ICrdnTimeProperties, ICrdnVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""
    def __init__(self, sourceObject=None):
        ICrdnVectorDispSurface.__init__(self, sourceObject)
        ICrdn.__init__(self, sourceObject)
        ICrdnTimeProperties.__init__(self, sourceObject)
        ICrdnVector.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorDispSurface._private_init(self, pUnk)
        ICrdn._private_init(self, pUnk)
        ICrdnTimeProperties._private_init(self, pUnk)
        ICrdnVector._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorDispSurface._get_property(self, attrname) is not None: found_prop = ICrdnVectorDispSurface._get_property(self, attrname)
        if ICrdn._get_property(self, attrname) is not None: found_prop = ICrdn._get_property(self, attrname)
        if ICrdnTimeProperties._get_property(self, attrname) is not None: found_prop = ICrdnTimeProperties._get_property(self, attrname)
        if ICrdnVector._get_property(self, attrname) is not None: found_prop = ICrdnVector._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorDispSurface.")
        
agcls.AgClassCatalog.add_catalog_entry("{ccd4af03-78af-47ae-902a-90860a17daa4}", CrdnVectorDispSurface)


class CrdnVectorFactory(ICrdnVectorFactory):
    """A Factory object to create vectors."""
    def __init__(self, sourceObject=None):
        ICrdnVectorFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorFactory._get_property(self, attrname) is not None: found_prop = ICrdnVectorFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}", CrdnVectorFactory)


class CrdnAxesFactory(ICrdnAxesFactory):
    """A Factory object to create axes."""
    def __init__(self, sourceObject=None):
        ICrdnAxesFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesFactory._get_property(self, attrname) is not None: found_prop = ICrdnAxesFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{7B3E2402-1E15-43DC-BB48-6E98D377B107}", CrdnAxesFactory)


class CrdnSystemFactory(ICrdnSystemFactory):
    """A Factory class to create VGT systems."""
    def __init__(self, sourceObject=None):
        ICrdnSystemFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemFactory._get_property(self, attrname) is not None: found_prop = ICrdnSystemFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{01A37414-BA74-4DF3-A007-6A3395C8A859}", CrdnSystemFactory)


class CrdnPointFactory(ICrdnPointFactory):
    """A Factory object to create points."""
    def __init__(self, sourceObject=None):
        ICrdnPointFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointFactory._get_property(self, attrname) is not None: found_prop = ICrdnPointFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6C79F3B2-8AE5-468A-940F-F0988752B309}", CrdnPointFactory)


class CrdnPlaneFactory(ICrdnPlaneFactory):
    """A Factory object to create VGT planes."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneFactory._get_property(self, attrname) is not None: found_prop = ICrdnPlaneFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}", CrdnPlaneFactory)


class CrdnAngleFactory(ICrdnAngleFactory):
    """A Factory object to create angles."""
    def __init__(self, sourceObject=None):
        ICrdnAngleFactory.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleFactory._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleFactory._get_property(self, attrname) is not None: found_prop = ICrdnAngleFactory._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleFactory.")
        
agcls.AgClassCatalog.add_catalog_entry("{0888F89F-9D77-4FCE-9A08-67FCBE870187}", CrdnAngleFactory)


class CrdnVectorGroup(ICrdnVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnVectorGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnVectorGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnVectorGroup._get_property(self, attrname) is not None: found_prop = ICrdnVectorGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnVectorGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}", CrdnVectorGroup)


class CrdnPointGroup(ICrdnPointGroup):
    """Access or create VGT points associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnPointGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointGroup._get_property(self, attrname) is not None: found_prop = ICrdnPointGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}", CrdnPointGroup)


class CrdnAngleGroup(ICrdnAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnAngleGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAngleGroup._get_property(self, attrname) is not None: found_prop = ICrdnAngleGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAngleGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}", CrdnAngleGroup)


class CrdnAxesGroup(ICrdnAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnAxesGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesGroup._get_property(self, attrname) is not None: found_prop = ICrdnAxesGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D792657-9D6E-4B1E-AEAB-B964839C6F94}", CrdnAxesGroup)


class CrdnPlaneGroup(ICrdnPlaneGroup):
    """Represents a VGT Plane component."""
    def __init__(self, sourceObject=None):
        ICrdnPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPlaneGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPlaneGroup._get_property(self, attrname) is not None: found_prop = ICrdnPlaneGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPlaneGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{15117A82-3EE6-483E-A65E-2A44F60DB355}", CrdnPlaneGroup)


class CrdnSystemGroup(ICrdnSystemGroup):
    """Access or create VGT systems associated with an object or a central body."""
    def __init__(self, sourceObject=None):
        ICrdnSystemGroup.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnSystemGroup._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnSystemGroup._get_property(self, attrname) is not None: found_prop = ICrdnSystemGroup._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnSystemGroup.")
        
agcls.AgClassCatalog.add_catalog_entry("{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}", CrdnSystemGroup)


class CrdnProvider(ICrdnProvider):
    """Allows accessing existing Vector Geometry Tool components."""
    def __init__(self, sourceObject=None):
        ICrdnProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnProvider._get_property(self, attrname) is not None: found_prop = ICrdnProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnProvider.")
        
agcls.AgClassCatalog.add_catalog_entry("{D9031FE1-81E1-4818-944D-5F00FC3EC97D}", CrdnProvider)


class CrdnRoot(ICrdnRoot):
    """Represents a VGT root."""
    def __init__(self, sourceObject=None):
        ICrdnRoot.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnRoot._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnRoot._get_property(self, attrname) is not None: found_prop = ICrdnRoot._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnRoot.")
        
agcls.AgClassCatalog.add_catalog_entry("{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}", CrdnRoot)


class CrdnWellKnownEarthSystems(ICrdnWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownEarthSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownEarthSystems._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownEarthSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownEarthSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}", CrdnWellKnownEarthSystems)


class CrdnWellKnownEarthAxes(ICrdnWellKnownEarthAxes):
    """Well-known Earth's axes."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownEarthAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownEarthAxes._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownEarthAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownEarthAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}", CrdnWellKnownEarthAxes)


class CrdnWellKnownSunSystems(ICrdnWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownSunSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownSunSystems._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownSunSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownSunSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{855EB036-E71F-47F9-B27B-57247345282A}", CrdnWellKnownSunSystems)


class CrdnWellKnownSunAxes(ICrdnWellKnownSunAxes):
    """Well-known Sun's axes."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownSunAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownSunAxes._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownSunAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownSunAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F786A33-8851-4FA4-A0CA-DC353170143E}", CrdnWellKnownSunAxes)


class CrdnWellKnownSystems(ICrdnWellKnownSystems):
    """Well-known coordinate reference systems."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownSystems._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownSystems._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownSystems._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownSystems.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C5101B3-3FDD-443D-A59F-B1E801873E0A}", CrdnWellKnownSystems)


class CrdnWellKnownAxes(ICrdnWellKnownAxes):
    """Represents well-known VGT Axes."""
    def __init__(self, sourceObject=None):
        ICrdnWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnWellKnownAxes._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnWellKnownAxes._get_property(self, attrname) is not None: found_prop = ICrdnWellKnownAxes._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnWellKnownAxes.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}", CrdnWellKnownAxes)


class CrdnMethodCallResult(ICrdnAngleFindResult, ICrdnAngleFindWithRateResult, ICrdnAxesTransformResult, ICrdnAxesTransformWithRateResult, ICrdnAxesFindInAxesResult, ICrdnAxesFindInAxesWithRateResult, ICrdnPlaneFindInAxesResult, ICrdnPlaneFindInAxesWithRateResult, ICrdnPlaneFindInSystemResult, ICrdnPlaneFindInSystemWithRateResult, ICrdnPointLocateInSystemResult, ICrdnPointLocateInSystemWithRateResult, ICrdnSystemTransformResult, ICrdnSystemTransformWithRateResult, ICrdnSystemFindInSystemResult, ICrdnVectorFindInAxesResult, ICrdnVectorFindInAxesWithRateResult, ICrdnAngleFindAngleWithRateResult, ICrdnAngleFindAngleResult, ICrdnMethodCallResult):
    """
    Represents a result of a call to a VGT method.
    Some of the inherited interfaces for this class may be disabled at runtime.
    """
    def __init__(self, sourceObject=None):
        ICrdnAngleFindResult.__init__(self, sourceObject)
        ICrdnAngleFindWithRateResult.__init__(self, sourceObject)
        ICrdnAxesTransformResult.__init__(self, sourceObject)
        ICrdnAxesTransformWithRateResult.__init__(self, sourceObject)
        ICrdnAxesFindInAxesResult.__init__(self, sourceObject)
        ICrdnAxesFindInAxesWithRateResult.__init__(self, sourceObject)
        ICrdnPlaneFindInAxesResult.__init__(self, sourceObject)
        ICrdnPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
        ICrdnPlaneFindInSystemResult.__init__(self, sourceObject)
        ICrdnPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
        ICrdnPointLocateInSystemResult.__init__(self, sourceObject)
        ICrdnPointLocateInSystemWithRateResult.__init__(self, sourceObject)
        ICrdnSystemTransformResult.__init__(self, sourceObject)
        ICrdnSystemTransformWithRateResult.__init__(self, sourceObject)
        ICrdnSystemFindInSystemResult.__init__(self, sourceObject)
        ICrdnVectorFindInAxesResult.__init__(self, sourceObject)
        ICrdnVectorFindInAxesWithRateResult.__init__(self, sourceObject)
        ICrdnAngleFindAngleWithRateResult.__init__(self, sourceObject)
        ICrdnAngleFindAngleResult.__init__(self, sourceObject)
        ICrdnMethodCallResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAngleFindResult._private_init(self, pUnk)
        ICrdnAngleFindWithRateResult._private_init(self, pUnk)
        ICrdnAxesTransformResult._private_init(self, pUnk)
        ICrdnAxesTransformWithRateResult._private_init(self, pUnk)
        ICrdnAxesFindInAxesResult._private_init(self, pUnk)
        ICrdnAxesFindInAxesWithRateResult._private_init(self, pUnk)
        ICrdnPlaneFindInAxesResult._private_init(self, pUnk)
        ICrdnPlaneFindInAxesWithRateResult._private_init(self, pUnk)
        ICrdnPlaneFindInSystemResult._private_init(self, pUnk)
        ICrdnPlaneFindInSystemWithRateResult._private_init(self, pUnk)
        ICrdnPointLocateInSystemResult._private_init(self, pUnk)
        ICrdnPointLocateInSystemWithRateResult._private_init(self, pUnk)
        ICrdnSystemTransformResult._private_init(self, pUnk)
        ICrdnSystemTransformWithRateResult._private_init(self, pUnk)
        ICrdnSystemFindInSystemResult._private_init(self, pUnk)
        ICrdnVectorFindInAxesResult._private_init(self, pUnk)
        ICrdnVectorFindInAxesWithRateResult._private_init(self, pUnk)
        ICrdnAngleFindAngleWithRateResult._private_init(self, pUnk)
        ICrdnAngleFindAngleResult._private_init(self, pUnk)
        ICrdnMethodCallResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAngleFindResult.__dict__ and type(ICrdnAngleFindResult.__dict__[attrname]) == property: found_prop = ICrdnAngleFindResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAngleFindWithRateResult.__dict__ and type(ICrdnAngleFindWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnAngleFindWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAxesTransformResult.__dict__ and type(ICrdnAxesTransformResult.__dict__[attrname]) == property: found_prop = ICrdnAxesTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAxesTransformWithRateResult.__dict__ and type(ICrdnAxesTransformWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnAxesTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAxesFindInAxesResult.__dict__ and type(ICrdnAxesFindInAxesResult.__dict__[attrname]) == property: found_prop = ICrdnAxesFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAxesFindInAxesWithRateResult.__dict__ and type(ICrdnAxesFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnAxesFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPlaneFindInAxesResult.__dict__ and type(ICrdnPlaneFindInAxesResult.__dict__[attrname]) == property: found_prop = ICrdnPlaneFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPlaneFindInAxesWithRateResult.__dict__ and type(ICrdnPlaneFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnPlaneFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPlaneFindInSystemResult.__dict__ and type(ICrdnPlaneFindInSystemResult.__dict__[attrname]) == property: found_prop = ICrdnPlaneFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPlaneFindInSystemWithRateResult.__dict__ and type(ICrdnPlaneFindInSystemWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnPlaneFindInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPointLocateInSystemResult.__dict__ and type(ICrdnPointLocateInSystemResult.__dict__[attrname]) == property: found_prop = ICrdnPointLocateInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnPointLocateInSystemWithRateResult.__dict__ and type(ICrdnPointLocateInSystemWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnPointLocateInSystemWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnSystemTransformResult.__dict__ and type(ICrdnSystemTransformResult.__dict__[attrname]) == property: found_prop = ICrdnSystemTransformResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnSystemTransformWithRateResult.__dict__ and type(ICrdnSystemTransformWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnSystemTransformWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemFindInSystemResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnSystemFindInSystemResult.__dict__ and type(ICrdnSystemFindInSystemResult.__dict__[attrname]) == property: found_prop = ICrdnSystemFindInSystemResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnVectorFindInAxesResult.__dict__ and type(ICrdnVectorFindInAxesResult.__dict__[attrname]) == property: found_prop = ICrdnVectorFindInAxesResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnVectorFindInAxesWithRateResult.__dict__ and type(ICrdnVectorFindInAxesWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnVectorFindInAxesWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleWithRateResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAngleFindAngleWithRateResult.__dict__ and type(ICrdnAngleFindAngleWithRateResult.__dict__[attrname]) == property: found_prop = ICrdnAngleFindAngleWithRateResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnAngleFindAngleResult.__dict__ and type(ICrdnAngleFindAngleResult.__dict__[attrname]) == property: found_prop = ICrdnAngleFindAngleResult.__dict__[attrname]
            del(pUnkTest)
        pUnkTest = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnMethodCallResult._uuid))
        if pUnkTest is not None:
            if attrname in ICrdnMethodCallResult.__dict__ and type(ICrdnMethodCallResult.__dict__[attrname]) == property: found_prop = ICrdnMethodCallResult.__dict__[attrname]
            del(pUnkTest)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnMethodCallResult.")
    def __getattr__(self, attrname):
        found_attr = None
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindResult._uuid))
        if pUnk is not None:
            intf = ICrdnAngleFindResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnAngleFindWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformResult._uuid))
        if pUnk is not None:
            intf = ICrdnAxesTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnAxesTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesResult._uuid))
        if pUnk is not None:
            intf = ICrdnAxesFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAxesFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnAxesFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesResult._uuid))
        if pUnk is not None:
            intf = ICrdnPlaneFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnPlaneFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemResult._uuid))
        if pUnk is not None:
            intf = ICrdnPlaneFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPlaneFindInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnPlaneFindInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemResult._uuid))
        if pUnk is not None:
            intf = ICrdnPointLocateInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnPointLocateInSystemWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnPointLocateInSystemWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformResult._uuid))
        if pUnk is not None:
            intf = ICrdnSystemTransformResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemTransformWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnSystemTransformWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnSystemFindInSystemResult._uuid))
        if pUnk is not None:
            intf = ICrdnSystemFindInSystemResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesResult._uuid))
        if pUnk is not None:
            intf = ICrdnVectorFindInAxesResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnVectorFindInAxesWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnVectorFindInAxesWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleWithRateResult._uuid))
        if pUnk is not None:
            intf = ICrdnAngleFindAngleWithRateResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnAngleFindAngleResult._uuid))
        if pUnk is not None:
            intf = ICrdnAngleFindAngleResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        pUnk = self.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICrdnMethodCallResult._uuid))
        if pUnk is not None:
            intf = ICrdnMethodCallResult()
            intf._private_init(pUnk)
            if hasattr(intf, attrname):
                found_attr = getattr(intf, attrname)
            del(intf)
            del(pUnk)
        if found_attr is not None:
            return found_attr
        else:
            raise STKAttributeError(attrname + " is not a valid attribute in this instance of CrdnMethodCallResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{03665183-03A3-4ABE-9954-476CD71C8BB3}", CrdnMethodCallResult)


class CrdnInterval(ICrdnInterval):
    """Represents an interval."""
    def __init__(self, sourceObject=None):
        ICrdnInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnInterval._get_property(self, attrname) is not None: found_prop = ICrdnInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{7825007C-4D30-46EC-A047-EAF6683C4187}", CrdnInterval)


class CrdnIntervalCollection(ICrdnIntervalCollection):
    """Represents a collection of intervals."""
    def __init__(self, sourceObject=None):
        ICrdnIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{908714CE-1D69-4F68-875A-9B584CF8F2A7}", CrdnIntervalCollection)


class CrdnCentralBody(ICrdnCentralBody):
    """Represents an central body."""
    def __init__(self, sourceObject=None):
        ICrdnCentralBody.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCentralBody._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCentralBody._get_property(self, attrname) is not None: found_prop = ICrdnCentralBody._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCentralBody.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A0248DF-B126-4448-A653-CD5C28DC9229}", CrdnCentralBody)


class CrdnCentralBodyRefTo(ICrdnCentralBodyRefTo, ICrdnRefTo):
    """Represents a central body reference."""
    def __init__(self, sourceObject=None):
        ICrdnCentralBodyRefTo.__init__(self, sourceObject)
        ICrdnRefTo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCentralBodyRefTo._private_init(self, pUnk)
        ICrdnRefTo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCentralBodyRefTo._get_property(self, attrname) is not None: found_prop = ICrdnCentralBodyRefTo._get_property(self, attrname)
        if ICrdnRefTo._get_property(self, attrname) is not None: found_prop = ICrdnRefTo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCentralBodyRefTo.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFB22A58-DB60-4A1B-B0D4-44916CACC759}", CrdnCentralBodyRefTo)


class CrdnCentralBodyCollection(ICrdnCentralBodyCollection):
    """A collection of central body names."""
    def __init__(self, sourceObject=None):
        ICrdnCentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCentralBodyCollection._get_property(self, attrname) is not None: found_prop = ICrdnCentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCentralBodyCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E8951B8F-E457-4289-9125-5381515552C4}", CrdnCentralBodyCollection)


class CrdnCollection(ICrdnCollection):
    """A collection of VGT objects."""
    def __init__(self, sourceObject=None):
        ICrdnCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnCollection._get_property(self, attrname) is not None: found_prop = ICrdnCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}", CrdnCollection)


class CrdnPointSamplingResult(ICrdnPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""
    def __init__(self, sourceObject=None):
        ICrdnPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointSamplingResult._get_property(self, attrname) is not None: found_prop = ICrdnPointSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}", CrdnPointSamplingResult)


class CrdnPointSamplingInterval(ICrdnPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        ICrdnPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointSamplingInterval._get_property(self, attrname) is not None: found_prop = ICrdnPointSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B7546E8-0228-4269-92D1-B3C186AF18EF}", CrdnPointSamplingInterval)


class CrdnPointSamplingIntervalCollection(ICrdnPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""
    def __init__(self, sourceObject=None):
        ICrdnPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnPointSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnPointSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnPointSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnPointSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F6CF6B1-7192-4960-927D-1FC328122E59}", CrdnPointSamplingIntervalCollection)


class CrdnAxesSamplingResult(ICrdnAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""
    def __init__(self, sourceObject=None):
        ICrdnAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesSamplingResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesSamplingResult._get_property(self, attrname) is not None: found_prop = ICrdnAxesSamplingResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesSamplingResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{54622168-5440-4C86-9539-A0CA336E554B}", CrdnAxesSamplingResult)


class CrdnAxesSamplingInterval(ICrdnAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        ICrdnAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesSamplingInterval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesSamplingInterval._get_property(self, attrname) is not None: found_prop = ICrdnAxesSamplingInterval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesSamplingInterval.")
        
agcls.AgClassCatalog.add_catalog_entry("{069BCA07-B5AB-4A46-A508-AFE218E21B2F}", CrdnAxesSamplingInterval)


class CrdnAxesSamplingIntervalCollection(ICrdnAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""
    def __init__(self, sourceObject=None):
        ICrdnAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICrdnAxesSamplingIntervalCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICrdnAxesSamplingIntervalCollection._get_property(self, attrname) is not None: found_prop = ICrdnAxesSamplingIntervalCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CrdnAxesSamplingIntervalCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4AD4C296-E643-4CB6-A34A-D33748117EEF}", CrdnAxesSamplingIntervalCollection)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
