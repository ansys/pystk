################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

__all__ = ["AnalysisWorkbenchCentralBody", "AnalysisWorkbenchCentralBodyCollection", "AnalysisWorkbenchCentralBodyRefTo", 
"AnalysisWorkbenchCollection", "AnalysisWorkbenchConverge", "AnalysisWorkbenchDerivative", "AnalysisWorkbenchGeneric", "AnalysisWorkbenchInstance", 
"AnalysisWorkbenchIntegral", "AnalysisWorkbenchInterp", "AnalysisWorkbenchLLAPosition", "AnalysisWorkbenchMethodCallAngleFindAngleResult", 
"AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult", "AnalysisWorkbenchMethodCallAngleFindResult", "AnalysisWorkbenchMethodCallAngleFindWithRateResult", 
"AnalysisWorkbenchMethodCallAxesFindInAxesResult", "AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult", "AnalysisWorkbenchMethodCallAxesTransformResult", 
"AnalysisWorkbenchMethodCallAxesTransformWithRateResult", "AnalysisWorkbenchMethodCallPlaneFindInAxesResult", "AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult", 
"AnalysisWorkbenchMethodCallPlaneFindInSystemResult", "AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult", "AnalysisWorkbenchMethodCallPointLocateInSystemResult", 
"AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult", "AnalysisWorkbenchMethodCallSystemFindInSystemResult", "AnalysisWorkbenchMethodCallSystemTransformResult", 
"AnalysisWorkbenchMethodCallSystemTransformWithRateResult", "AnalysisWorkbenchMethodCallVectorFindInAxesResult", "AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult", 
"AnalysisWorkbenchProvider", "AnalysisWorkbenchRoot", "AnalysisWorkbenchSampling", "AnalysisWorkbenchSignalDelay", "AnalysisWorkbenchTemplate", 
"AnalysisWorkbenchTypeInfo", "CRDN_CALC_SCALAR_TYPE", "CRDN_CONDITION_COMBINED_OPERATION_TYPE", "CRDN_CONDITION_SET_TYPE", 
"CRDN_CONDITION_THRESHOLD_OPTION", "CRDN_CONDITION_TYPE", "CRDN_DIMENSION_INHERITANCE", "CRDN_DIRECTION_TYPE", "CRDN_DISPLAY_AXIS_SELECTOR", 
"CRDN_EVENT_ARRAY_FILTER_TYPE", "CRDN_EVENT_ARRAY_TYPE", "CRDN_EVENT_INTERVAL_COLLECTION_TYPE", "CRDN_EVENT_INTERVAL_LIST_TYPE", 
"CRDN_EVENT_INTERVAL_TYPE", "CRDN_EVENT_LIST_MERGE_OPERATION", "CRDN_EVENT_TYPE", "CRDN_EXTREMUM_CONSTANTS", "CRDN_FILE_INTERPOLATOR_TYPE", 
"CRDN_INTEGRAL_TYPE", "CRDN_INTEGRATION_WINDOW_TYPE", "CRDN_INTERPOLATOR_TYPE", "CRDN_INTERSECTION_SURFACE", "CRDN_INTERVAL_DURATION_KIND", 
"CRDN_INTERVAL_SELECTION", "CRDN_KIND", "CRDN_LAGRANGE_LIBRATION_POINT_TYPE", "CRDN_MEAN_ELEMENT_THEORY", "CRDN_PARAMETER_SET_TYPE", 
"CRDN_PRUNE_FILTER", "CRDN_QUADRANT_TYPE", "CRDN_REFERENCE_SHAPE_TYPE", "CRDN_SAMPLED_REFERENCE_TIME", "CRDN_SAMPLING_METHOD", 
"CRDN_SATISFACTION_CROSSING", "CRDN_SAVE_DATA_OPTION", "CRDN_SIGNAL_PATH_REFERENCE_SYSTEM", "CRDN_SIGNAL_SENSE", "CRDN_SIGNED_ANGLE_TYPE", 
"CRDN_SMART_EPOCH_STATE", "CRDN_SMART_INTERVAL_STATE", "CRDN_SPEED_OPTIONS", "CRDN_START_STOP_OPTION", "CRDN_SURFACE_TYPE", 
"CRDN_SWEEP_MODE", "CRDN_SYSTEM_TYPE", "CRDN_THRESH_CONVERGE_SENSE", "CRDN_TRAJECTORY_AXES_TYPE", "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE", 
"CRDN_VOLUME_ABERRATION_TYPE", "CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE", "CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE", "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE", 
"CRDN_VOLUME_CALC_RANGE_SPEED_TYPE", "CRDN_VOLUME_CALC_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE", 
"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE", "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE", 
"CRDN_VOLUME_CLOCK_HOST_TYPE", "CRDN_VOLUME_COMBINED_OPERATION_TYPE", "CRDN_VOLUME_FROM_GRID_EDGE_TYPE", "CRDN_VOLUME_GRID_TYPE", 
"CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE", "CRDN_VOLUME_OVER_TIME_DURATION_TYPE", "CRDN_VOLUME_RESULT_VECTOR_REQUEST", "CRDN_VOLUME_TIME_SENSE_TYPE", 
"CRDN_VOLUME_TYPE", "CalculationToolCondition", "CalculationToolConditionCombined", "CalculationToolConditionFactory", "CalculationToolConditionGroup", 
"CalculationToolConditionPointInVolume", "CalculationToolConditionScalarBounds", "CalculationToolConditionSet", "CalculationToolConditionSetEvaluateResult", 
"CalculationToolConditionSetEvaluateWithRateResult", "CalculationToolConditionSetFactory", "CalculationToolConditionSetGroup", 
"CalculationToolConditionSetScalarThresholds", "CalculationToolConvergeBasic", "CalculationToolDerivativeBasic", "CalculationToolEvaluateResult", 
"CalculationToolEvaluateWithRateResult", "CalculationToolIntegralBasic", "CalculationToolInterpBasic", "CalculationToolParameterSet", 
"CalculationToolParameterSetAttitude", "CalculationToolParameterSetFactory", "CalculationToolParameterSetGroundTrajectory", 
"CalculationToolParameterSetGroup", "CalculationToolParameterSetOrbit", "CalculationToolParameterSetTrajectory", "CalculationToolParameterSetVector", 
"CalculationToolSamplingBasic", "CalculationToolSamplingCurvatureTolerance", "CalculationToolSamplingFixedStep", "CalculationToolSamplingMethod", 
"CalculationToolSamplingMethodFactory", "CalculationToolSamplingRelativeTolerance", "CalculationToolScalar", "CalculationToolScalarAngle", 
"CalculationToolScalarConstant", "CalculationToolScalarCustom", "CalculationToolScalarDataElement", "CalculationToolScalarDerivative", 
"CalculationToolScalarDotProduct", "CalculationToolScalarElapsedTime", "CalculationToolScalarFactory", "CalculationToolScalarFile", 
"CalculationToolScalarFixedAtTimeInstant", "CalculationToolScalarFunction", "CalculationToolScalarFunction2Var", "CalculationToolScalarGroup", 
"CalculationToolScalarIntegral", "CalculationToolScalarPlugin", "CalculationToolScalarSurfaceDistanceBetweenPoints", "CalculationToolScalarVectorComponent", 
"CalculationToolScalarVectorMagnitude", "IAnalysisWorkbenchCentralBody", "IAnalysisWorkbenchCentralBodyCollection", "IAnalysisWorkbenchCentralBodyRefTo", 
"IAnalysisWorkbenchCollection", "IAnalysisWorkbenchComponent", "IAnalysisWorkbenchContext", "IAnalysisWorkbenchConverge", 
"IAnalysisWorkbenchDerivative", "IAnalysisWorkbenchInstance", "IAnalysisWorkbenchIntegral", "IAnalysisWorkbenchInterp", 
"IAnalysisWorkbenchLLAPosition", "IAnalysisWorkbenchMethodCallResult", "IAnalysisWorkbenchProvider", "IAnalysisWorkbenchRefTo", 
"IAnalysisWorkbenchRoot", "IAnalysisWorkbenchSampling", "IAnalysisWorkbenchSignalDelay", "IAnalysisWorkbenchTemplate", "IAnalysisWorkbenchTypeInfo", 
"ICalculationToolCondition", "ICalculationToolConditionCombined", "ICalculationToolConditionFactory", "ICalculationToolConditionGroup", 
"ICalculationToolConditionPointInVolume", "ICalculationToolConditionScalarBounds", "ICalculationToolConditionSet", "ICalculationToolConditionSetEvaluateResult", 
"ICalculationToolConditionSetEvaluateWithRateResult", "ICalculationToolConditionSetFactory", "ICalculationToolConditionSetGroup", 
"ICalculationToolConditionSetScalarThresholds", "ICalculationToolConvergeBasic", "ICalculationToolDerivativeBasic", "ICalculationToolEvaluateResult", 
"ICalculationToolEvaluateWithRateResult", "ICalculationToolIntegralBasic", "ICalculationToolInterpBasic", "ICalculationToolParameterSet", 
"ICalculationToolParameterSetAttitude", "ICalculationToolParameterSetFactory", "ICalculationToolParameterSetGroundTrajectory", 
"ICalculationToolParameterSetGroup", "ICalculationToolParameterSetOrbit", "ICalculationToolParameterSetTrajectory", "ICalculationToolParameterSetVector", 
"ICalculationToolSamplingBasic", "ICalculationToolSamplingCurvatureTolerance", "ICalculationToolSamplingFixedStep", "ICalculationToolSamplingMethod", 
"ICalculationToolSamplingMethodFactory", "ICalculationToolSamplingRelativeTolerance", "ICalculationToolScalar", "ICalculationToolScalarAngle", 
"ICalculationToolScalarConstant", "ICalculationToolScalarCustom", "ICalculationToolScalarDataElement", "ICalculationToolScalarDerivative", 
"ICalculationToolScalarDotProduct", "ICalculationToolScalarElapsedTime", "ICalculationToolScalarFactory", "ICalculationToolScalarFile", 
"ICalculationToolScalarFixedAtTimeInstant", "ICalculationToolScalarFunction", "ICalculationToolScalarFunction2Var", "ICalculationToolScalarGroup", 
"ICalculationToolScalarIntegral", "ICalculationToolScalarPlugin", "ICalculationToolScalarSurfaceDistanceBetweenPoints", 
"ICalculationToolScalarVectorComponent", "ICalculationToolScalarVectorMagnitude", "ISpatialAnalysisToolGridCoordinateDefinition", 
"ISpatialAnalysisToolGridValuesCustom", "ISpatialAnalysisToolGridValuesFixedNumberOfSteps", "ISpatialAnalysisToolGridValuesFixedStep", 
"ISpatialAnalysisToolGridValuesMethod", "ISpatialAnalysisToolVolume", "ISpatialAnalysisToolVolumeCalc", "ISpatialAnalysisToolVolumeCalcAltitude", 
"ISpatialAnalysisToolVolumeCalcAngleOffVector", "ISpatialAnalysisToolVolumeCalcConditionSatMetric", "ISpatialAnalysisToolVolumeCalcDelayRange", 
"ISpatialAnalysisToolVolumeCalcFactory", "ISpatialAnalysisToolVolumeCalcFile", "ISpatialAnalysisToolVolumeCalcFromScalar", 
"ISpatialAnalysisToolVolumeCalcGroup", "ISpatialAnalysisToolVolumeCalcRange", "ISpatialAnalysisToolVolumeCalcSolarIntensity", 
"ISpatialAnalysisToolVolumeCombined", "ISpatialAnalysisToolVolumeFactory", "ISpatialAnalysisToolVolumeFromCalc", "ISpatialAnalysisToolVolumeFromCondition", 
"ISpatialAnalysisToolVolumeFromGrid", "ISpatialAnalysisToolVolumeFromTimeSatisfaction", "ISpatialAnalysisToolVolumeGrid", 
"ISpatialAnalysisToolVolumeGridBearingAlt", "ISpatialAnalysisToolVolumeGridCartesian", "ISpatialAnalysisToolVolumeGridConstrained", 
"ISpatialAnalysisToolVolumeGridCylindrical", "ISpatialAnalysisToolVolumeGridFactory", "ISpatialAnalysisToolVolumeGridGroup", 
"ISpatialAnalysisToolVolumeGridLatLonAlt", "ISpatialAnalysisToolVolumeGridResult", "ISpatialAnalysisToolVolumeGridSpherical", 
"ISpatialAnalysisToolVolumeGroup", "ISpatialAnalysisToolVolumeInview", "ISpatialAnalysisToolVolumeLighting", "ISpatialAnalysisToolVolumeOverTime", 
"ITimeToolAxesSamplingInterval", "ITimeToolAxesSamplingIntervalCollection", "ITimeToolAxesSamplingResult", "ITimeToolEvent", 
"ITimeToolEventArray", "ITimeToolEventArrayConditionCrossings", "ITimeToolEventArrayExtrema", "ITimeToolEventArrayFactory", 
"ITimeToolEventArrayFiltered", "ITimeToolEventArrayFixedStep", "ITimeToolEventArrayFixedTimes", "ITimeToolEventArrayGroup", 
"ITimeToolEventArrayMerged", "ITimeToolEventArraySignaled", "ITimeToolEventArrayStartStopTimes", "ITimeToolEventEpoch", 
"ITimeToolEventExtremum", "ITimeToolEventFactory", "ITimeToolEventFindOccurrenceResult", "ITimeToolEventGroup", "ITimeToolEventInterval", 
"ITimeToolEventIntervalBetweenTimeInstants", "ITimeToolEventIntervalCollection", "ITimeToolEventIntervalCollectionCondition", 
"ITimeToolEventIntervalCollectionFactory", "ITimeToolEventIntervalCollectionGroup", "ITimeToolEventIntervalCollectionLighting", 
"ITimeToolEventIntervalCollectionOccurredResult", "ITimeToolEventIntervalCollectionSignaled", "ITimeToolEventIntervalFactory", 
"ITimeToolEventIntervalFixed", "ITimeToolEventIntervalFixedDuration", "ITimeToolEventIntervalFromIntervalList", "ITimeToolEventIntervalGroup", 
"ITimeToolEventIntervalList", "ITimeToolEventIntervalListCondition", "ITimeToolEventIntervalListFactory", "ITimeToolEventIntervalListFile", 
"ITimeToolEventIntervalListFiltered", "ITimeToolEventIntervalListFixed", "ITimeToolEventIntervalListGroup", "ITimeToolEventIntervalListMerged", 
"ITimeToolEventIntervalListScaled", "ITimeToolEventIntervalListSignaled", "ITimeToolEventIntervalListTimeOffset", "ITimeToolEventIntervalResult", 
"ITimeToolEventIntervalScaled", "ITimeToolEventIntervalSignaled", "ITimeToolEventIntervalSmartInterval", "ITimeToolEventIntervalTimeOffset", 
"ITimeToolEventSignaled", "ITimeToolEventSmartEpoch", "ITimeToolEventStartStopTime", "ITimeToolEventTimeOffset", "ITimeToolFindTimesResult", 
"ITimeToolFirstIntervalsFilter", "ITimeToolGapsFilter", "ITimeToolInterval", "ITimeToolIntervalCollection", "ITimeToolIntervalListResult", 
"ITimeToolIntervalVectorCollection", "ITimeToolIntervalsFilter", "ITimeToolIntervalsVectorResult", "ITimeToolLastIntervalsFilter", 
"ITimeToolLightTimeDelay", "ITimeToolPointSamplingInterval", "ITimeToolPointSamplingIntervalCollection", "ITimeToolPointSamplingResult", 
"ITimeToolPruneFilter", "ITimeToolPruneFilterFactory", "ITimeToolRelativeSatisfactionConditionFilter", "ITimeToolSatisfactionConditionFilter", 
"ITimeToolSignalDelayBasic", "ITimeToolTimeProperties", "IVectorGeometryToolAngle", "IVectorGeometryToolAngleBetweenPlanes", 
"IVectorGeometryToolAngleBetweenVectors", "IVectorGeometryToolAngleDihedral", "IVectorGeometryToolAngleFactory", "IVectorGeometryToolAngleFindAngleResult", 
"IVectorGeometryToolAngleFindAngleWithRateResult", "IVectorGeometryToolAngleFindResult", "IVectorGeometryToolAngleFindWithRateResult", 
"IVectorGeometryToolAngleGroup", "IVectorGeometryToolAngleRefTo", "IVectorGeometryToolAngleRotation", "IVectorGeometryToolAngleToPlane", 
"IVectorGeometryToolAxes", "IVectorGeometryToolAxesAlignedAndConstrained", "IVectorGeometryToolAxesAngularOffset", "IVectorGeometryToolAxesAtTimeInstant", 
"IVectorGeometryToolAxesAttitudeFile", "IVectorGeometryToolAxesBPlane", "IVectorGeometryToolAxesCommonTasks", "IVectorGeometryToolAxesCustomScript", 
"IVectorGeometryToolAxesFactory", "IVectorGeometryToolAxesFindInAxesResult", "IVectorGeometryToolAxesFindInAxesWithRateResult", 
"IVectorGeometryToolAxesFixed", "IVectorGeometryToolAxesFixedAtEpoch", "IVectorGeometryToolAxesGroup", "IVectorGeometryToolAxesLabels", 
"IVectorGeometryToolAxesLagrangeLibration", "IVectorGeometryToolAxesModelAttach", "IVectorGeometryToolAxesOnSurface", "IVectorGeometryToolAxesPlugin", 
"IVectorGeometryToolAxesRefTo", "IVectorGeometryToolAxesSpinning", "IVectorGeometryToolAxesTrajectory", "IVectorGeometryToolAxesTransformResult", 
"IVectorGeometryToolAxesTransformWithRateResult", "IVectorGeometryToolPlane", "IVectorGeometryToolPlaneFactory", "IVectorGeometryToolPlaneFindInAxesResult", 
"IVectorGeometryToolPlaneFindInAxesWithRateResult", "IVectorGeometryToolPlaneFindInSystemResult", "IVectorGeometryToolPlaneFindInSystemWithRateResult", 
"IVectorGeometryToolPlaneGroup", "IVectorGeometryToolPlaneLabels", "IVectorGeometryToolPlaneNormal", "IVectorGeometryToolPlaneQuadrant", 
"IVectorGeometryToolPlaneRefTo", "IVectorGeometryToolPlaneTrajectory", "IVectorGeometryToolPlaneTriad", "IVectorGeometryToolPlaneTwoVector", 
"IVectorGeometryToolPoint", "IVectorGeometryToolPointAtTimeInstant", "IVectorGeometryToolPointBPlane", "IVectorGeometryToolPointCBFixedOffset", 
"IVectorGeometryToolPointCentBodyIntersect", "IVectorGeometryToolPointCommonTasks", "IVectorGeometryToolPointCovarianceGrazing", 
"IVectorGeometryToolPointFactory", "IVectorGeometryToolPointFile", "IVectorGeometryToolPointFixedInSystem", "IVectorGeometryToolPointGlint", 
"IVectorGeometryToolPointGrazing", "IVectorGeometryToolPointGroup", "IVectorGeometryToolPointLagrangeLibration", "IVectorGeometryToolPointLocateInSystemResult", 
"IVectorGeometryToolPointLocateInSystemWithRateResult", "IVectorGeometryToolPointModelAttach", "IVectorGeometryToolPointOnSurface", 
"IVectorGeometryToolPointPlaneIntersection", "IVectorGeometryToolPointPlaneProjection", "IVectorGeometryToolPointPlugin", 
"IVectorGeometryToolPointRefTo", "IVectorGeometryToolPointSatelliteCollectionEntry", "IVectorGeometryToolSystem", "IVectorGeometryToolSystemAssembled", 
"IVectorGeometryToolSystemCommonTasks", "IVectorGeometryToolSystemFactory", "IVectorGeometryToolSystemFindInSystemResult", 
"IVectorGeometryToolSystemGroup", "IVectorGeometryToolSystemOnSurface", "IVectorGeometryToolSystemRefTo", "IVectorGeometryToolSystemTransformResult", 
"IVectorGeometryToolSystemTransformWithRateResult", "IVectorGeometryToolVector", "IVectorGeometryToolVectorAngleRate", "IVectorGeometryToolVectorAngularVelocity", 
"IVectorGeometryToolVectorApoapsis", "IVectorGeometryToolVectorConing", "IVectorGeometryToolVectorCross", "IVectorGeometryToolVectorCustomScript", 
"IVectorGeometryToolVectorDerivative", "IVectorGeometryToolVectorDirectionToStar", "IVectorGeometryToolVectorDispSurface", 
"IVectorGeometryToolVectorDisplacement", "IVectorGeometryToolVectorEccentricity", "IVectorGeometryToolVectorFactory", "IVectorGeometryToolVectorFindInAxesResult", 
"IVectorGeometryToolVectorFindInAxesWithRateResult", "IVectorGeometryToolVectorFixedAtEpoch", "IVectorGeometryToolVectorFixedAtTimeInstant", 
"IVectorGeometryToolVectorFixedInAxes", "IVectorGeometryToolVectorGroup", "IVectorGeometryToolVectorLineOfNodes", "IVectorGeometryToolVectorLinearCombination", 
"IVectorGeometryToolVectorModelAttach", "IVectorGeometryToolVectorOrbitAngularMomentum", "IVectorGeometryToolVectorOrbitNormal", 
"IVectorGeometryToolVectorPeriapsis", "IVectorGeometryToolVectorPlugin", "IVectorGeometryToolVectorProjectAlongVector", 
"IVectorGeometryToolVectorProjection", "IVectorGeometryToolVectorRefTo", "IVectorGeometryToolVectorReflection", "IVectorGeometryToolVectorRotationVector", 
"IVectorGeometryToolVectorScalarLinearCombination", "IVectorGeometryToolVectorScalarScaled", "IVectorGeometryToolVectorScaled", 
"IVectorGeometryToolVectorTwoPlanesIntersection", "IVectorGeometryToolVectorVelocityAcceleration", "IVectorGeometryToolWellKnownAxes", 
"IVectorGeometryToolWellKnownEarthAxes", "IVectorGeometryToolWellKnownEarthSystems", "IVectorGeometryToolWellKnownSunAxes", 
"IVectorGeometryToolWellKnownSunSystems", "IVectorGeometryToolWellKnownSystems", "SpatialAnalysisToolGridCoordinateDefinition", 
"SpatialAnalysisToolGridValuesCustom", "SpatialAnalysisToolGridValuesFixedNumberOfSteps", "SpatialAnalysisToolGridValuesFixedStep", 
"SpatialAnalysisToolGridValuesMethod", "SpatialAnalysisToolVolume", "SpatialAnalysisToolVolumeCalc", "SpatialAnalysisToolVolumeCalcAltitude", 
"SpatialAnalysisToolVolumeCalcAngleOffVector", "SpatialAnalysisToolVolumeCalcConditionSatMetric", "SpatialAnalysisToolVolumeCalcDelayRange", 
"SpatialAnalysisToolVolumeCalcFactory", "SpatialAnalysisToolVolumeCalcFile", "SpatialAnalysisToolVolumeCalcFromScalar", 
"SpatialAnalysisToolVolumeCalcGroup", "SpatialAnalysisToolVolumeCalcRange", "SpatialAnalysisToolVolumeCalcSolarIntensity", 
"SpatialAnalysisToolVolumeCombined", "SpatialAnalysisToolVolumeFactory", "SpatialAnalysisToolVolumeFromCalc", "SpatialAnalysisToolVolumeFromCondition", 
"SpatialAnalysisToolVolumeFromGrid", "SpatialAnalysisToolVolumeFromTimeSatisfaction", "SpatialAnalysisToolVolumeGrid", "SpatialAnalysisToolVolumeGridBearingAlt", 
"SpatialAnalysisToolVolumeGridCartesian", "SpatialAnalysisToolVolumeGridConstrained", "SpatialAnalysisToolVolumeGridCylindrical", 
"SpatialAnalysisToolVolumeGridFactory", "SpatialAnalysisToolVolumeGridGroup", "SpatialAnalysisToolVolumeGridLatLonAlt", 
"SpatialAnalysisToolVolumeGridResult", "SpatialAnalysisToolVolumeGridSpherical", "SpatialAnalysisToolVolumeGroup", "SpatialAnalysisToolVolumeInview", 
"SpatialAnalysisToolVolumeLighting", "SpatialAnalysisToolVolumeOverTime", "TimeToolAxesSamplingInterval", "TimeToolAxesSamplingIntervalCollection", 
"TimeToolAxesSamplingResult", "TimeToolEvent", "TimeToolEventArray", "TimeToolEventArrayConditionCrossings", "TimeToolEventArrayExtrema", 
"TimeToolEventArrayFactory", "TimeToolEventArrayFiltered", "TimeToolEventArrayFixedStep", "TimeToolEventArrayFixedTimes", 
"TimeToolEventArrayGroup", "TimeToolEventArrayMerged", "TimeToolEventArraySignaled", "TimeToolEventArrayStartStopTimes", 
"TimeToolEventEpoch", "TimeToolEventExtremum", "TimeToolEventFactory", "TimeToolEventFindOccurrenceResult", "TimeToolEventGroup", 
"TimeToolEventInterval", "TimeToolEventIntervalBetweenTimeInstants", "TimeToolEventIntervalCollection", "TimeToolEventIntervalCollectionCondition", 
"TimeToolEventIntervalCollectionFactory", "TimeToolEventIntervalCollectionGroup", "TimeToolEventIntervalCollectionLighting", 
"TimeToolEventIntervalCollectionOccurredResult", "TimeToolEventIntervalCollectionSignaled", "TimeToolEventIntervalFactory", 
"TimeToolEventIntervalFixed", "TimeToolEventIntervalFixedDuration", "TimeToolEventIntervalFromIntervalList", "TimeToolEventIntervalGroup", 
"TimeToolEventIntervalList", "TimeToolEventIntervalListCondition", "TimeToolEventIntervalListFactory", "TimeToolEventIntervalListFile", 
"TimeToolEventIntervalListFiltered", "TimeToolEventIntervalListFixed", "TimeToolEventIntervalListGroup", "TimeToolEventIntervalListMerged", 
"TimeToolEventIntervalListScaled", "TimeToolEventIntervalListSignaled", "TimeToolEventIntervalListTimeOffset", "TimeToolEventIntervalResult", 
"TimeToolEventIntervalScaled", "TimeToolEventIntervalSignaled", "TimeToolEventIntervalSmartInterval", "TimeToolEventIntervalTimeOffset", 
"TimeToolEventSignaled", "TimeToolEventSmartEpoch", "TimeToolEventStartStopTime", "TimeToolEventTimeOffset", "TimeToolFindTimesResult", 
"TimeToolFirstIntervalsFilter", "TimeToolGapsFilter", "TimeToolInterval", "TimeToolIntervalCollection", "TimeToolIntervalListResult", 
"TimeToolIntervalVectorCollection", "TimeToolIntervalsFilter", "TimeToolIntervalsVectorResult", "TimeToolLastIntervalsFilter", 
"TimeToolLightTimeDelay", "TimeToolPointSamplingInterval", "TimeToolPointSamplingIntervalCollection", "TimeToolPointSamplingResult", 
"TimeToolPruneFilter", "TimeToolPruneFilterFactory", "TimeToolRelativeSatisfactionConditionFilter", "TimeToolSatisfactionConditionFilter", 
"TimeToolSignalDelayBasic", "VECTOR_GEOMETRY_TOOL_ANGLE_TYPE", "VECTOR_GEOMETRY_TOOL_AXES_TYPE", "VECTOR_GEOMETRY_TOOL_PLANE_TYPE", 
"VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE", "VECTOR_GEOMETRY_TOOL_POINT_TYPE", "VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE", 
"VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE", "VECTOR_GEOMETRY_TOOL_VECTOR_TYPE", "VectorGeometryToolAngle", 
"VectorGeometryToolAngleBetweenPlanes", "VectorGeometryToolAngleBetweenVectors", "VectorGeometryToolAngleDihedral", "VectorGeometryToolAngleFactory", 
"VectorGeometryToolAngleGroup", "VectorGeometryToolAngleRefTo", "VectorGeometryToolAngleRotation", "VectorGeometryToolAngleToPlane", 
"VectorGeometryToolAxes", "VectorGeometryToolAxesAlignedAndConstrained", "VectorGeometryToolAxesAngularOffset", "VectorGeometryToolAxesAtTimeInstant", 
"VectorGeometryToolAxesAttitudeFile", "VectorGeometryToolAxesBPlane", "VectorGeometryToolAxesCommonTasks", "VectorGeometryToolAxesCustomScript", 
"VectorGeometryToolAxesFactory", "VectorGeometryToolAxesFixed", "VectorGeometryToolAxesFixedAtEpoch", "VectorGeometryToolAxesGroup", 
"VectorGeometryToolAxesLabels", "VectorGeometryToolAxesLagrangeLibration", "VectorGeometryToolAxesModelAttach", "VectorGeometryToolAxesOnSurface", 
"VectorGeometryToolAxesPlugin", "VectorGeometryToolAxesRefTo", "VectorGeometryToolAxesSpinning", "VectorGeometryToolAxesTrajectory", 
"VectorGeometryToolPlane", "VectorGeometryToolPlaneFactory", "VectorGeometryToolPlaneGroup", "VectorGeometryToolPlaneLabels", 
"VectorGeometryToolPlaneNormal", "VectorGeometryToolPlaneQuadrant", "VectorGeometryToolPlaneRefTo", "VectorGeometryToolPlaneTrajectory", 
"VectorGeometryToolPlaneTriad", "VectorGeometryToolPlaneTwoVector", "VectorGeometryToolPoint", "VectorGeometryToolPointAtTimeInstant", 
"VectorGeometryToolPointBPlane", "VectorGeometryToolPointCBFixedOffset", "VectorGeometryToolPointCentBodyIntersect", "VectorGeometryToolPointCommonTasks", 
"VectorGeometryToolPointCovarianceGrazing", "VectorGeometryToolPointFactory", "VectorGeometryToolPointFile", "VectorGeometryToolPointFixedInSystem", 
"VectorGeometryToolPointGlint", "VectorGeometryToolPointGrazing", "VectorGeometryToolPointGroup", "VectorGeometryToolPointLagrangeLibration", 
"VectorGeometryToolPointModelAttach", "VectorGeometryToolPointOnSurface", "VectorGeometryToolPointPlaneIntersection", "VectorGeometryToolPointPlaneProjection", 
"VectorGeometryToolPointPlugin", "VectorGeometryToolPointRefTo", "VectorGeometryToolPointSatelliteCollectionEntry", "VectorGeometryToolSystem", 
"VectorGeometryToolSystemAssembled", "VectorGeometryToolSystemCommonTasks", "VectorGeometryToolSystemFactory", "VectorGeometryToolSystemGroup", 
"VectorGeometryToolSystemOnSurface", "VectorGeometryToolSystemRefTo", "VectorGeometryToolVector", "VectorGeometryToolVectorAngleRate", 
"VectorGeometryToolVectorAngularVelocity", "VectorGeometryToolVectorApoapsis", "VectorGeometryToolVectorConing", "VectorGeometryToolVectorCross", 
"VectorGeometryToolVectorCustomScript", "VectorGeometryToolVectorDerivative", "VectorGeometryToolVectorDirectionToStar", 
"VectorGeometryToolVectorDispSurface", "VectorGeometryToolVectorDisplacement", "VectorGeometryToolVectorEccentricity", "VectorGeometryToolVectorFactory", 
"VectorGeometryToolVectorFixedAtEpoch", "VectorGeometryToolVectorFixedAtTimeInstant", "VectorGeometryToolVectorFixedInAxes", 
"VectorGeometryToolVectorGroup", "VectorGeometryToolVectorLineOfNodes", "VectorGeometryToolVectorLinearCombination", "VectorGeometryToolVectorModelAttach", 
"VectorGeometryToolVectorOrbitAngularMomentum", "VectorGeometryToolVectorOrbitNormal", "VectorGeometryToolVectorPeriapsis", 
"VectorGeometryToolVectorPlugin", "VectorGeometryToolVectorProjectAlongVector", "VectorGeometryToolVectorProjection", "VectorGeometryToolVectorRefTo", 
"VectorGeometryToolVectorReflection", "VectorGeometryToolVectorRotationVector", "VectorGeometryToolVectorScalarLinearCombination", 
"VectorGeometryToolVectorScalarScaled", "VectorGeometryToolVectorScaled", "VectorGeometryToolVectorTwoPlanesIntersection", 
"VectorGeometryToolVectorVelocityAcceleration", "VectorGeometryToolWellKnownAxes", "VectorGeometryToolWellKnownEarthAxes", 
"VectorGeometryToolWellKnownEarthSystems", "VectorGeometryToolWellKnownSunAxes", "VectorGeometryToolWellKnownSunSystems", 
"VectorGeometryToolWellKnownSystems"]

import typing

from ctypes   import POINTER
from enum     import IntEnum, IntFlag

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .internal.comutil     import IUnknown, IDispatch
from .internal.apiutil     import (interface_proxy, enumerator_proxy, out_arg, 
    initialize_from_source_object, get_interface_property, set_interface_attribute, 
    set_class_attribute)
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class CRDN_CALC_SCALAR_TYPE(IntEnum):
    """Defines available calculation scalar types."""
   
    UNKNOWN = -1
    """Unknown or unsupported calculation scalar types."""
    ANGLE = 0
    """Scalar equal to angular displacement obtained from any angle in VGT."""
    FIXED_AT_TIME_INSTANT = 1
    """Constant scalar created by evaluating input scalar calculation at specified reference time instant."""
    CONSTANT = 2
    """Constant scalar value of specified dimension."""
    DATA_ELEMENT = 3
    """Any time-dependent data element from STK data providers available for parent STK object."""
    DERIVATIVE = 4
    """Derivative of input scalar calculation."""
    ELAPSED_TIME = 5
    """Time elapsed since reference time instant."""
    FILE = 6
    """Tabulated scalar calculation data loaded from specified file."""
    FUNCTION = 7
    """Defined by performing one of specified functions on input scalar."""
    INTEGRAL = 8
    """Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."""
    FUNCTION2_VAR = 9
    """Defined by performing one of specified binary operations on two scalar arguments."""
    VECTOR_MAGNITUDE = 10
    """Scalar equal to magnitude of specified vector."""
    PLUGIN = 11
    """A calc scalar plugin based on a COM object."""
    CUSTOM_SCRIPT = 12
    """A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
    SURFACE_DISTANCE_BETWEEN_POINTS = 13
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
    DOT_PRODUCT = 14
    """Scalar equal to the dot product between two vectors."""
    VECTOR_COMPONENT = 15
    """Scalar equal to the specified component of a vector when resolved in the specified axes."""

CRDN_CALC_SCALAR_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported calculation scalar types."
CRDN_CALC_SCALAR_TYPE.ANGLE.__doc__ = "Scalar equal to angular displacement obtained from any angle in VGT."
CRDN_CALC_SCALAR_TYPE.FIXED_AT_TIME_INSTANT.__doc__ = "Constant scalar created by evaluating input scalar calculation at specified reference time instant."
CRDN_CALC_SCALAR_TYPE.CONSTANT.__doc__ = "Constant scalar value of specified dimension."
CRDN_CALC_SCALAR_TYPE.DATA_ELEMENT.__doc__ = "Any time-dependent data element from STK data providers available for parent STK object."
CRDN_CALC_SCALAR_TYPE.DERIVATIVE.__doc__ = "Derivative of input scalar calculation."
CRDN_CALC_SCALAR_TYPE.ELAPSED_TIME.__doc__ = "Time elapsed since reference time instant."
CRDN_CALC_SCALAR_TYPE.FILE.__doc__ = "Tabulated scalar calculation data loaded from specified file."
CRDN_CALC_SCALAR_TYPE.FUNCTION.__doc__ = "Defined by performing one of specified functions on input scalar."
CRDN_CALC_SCALAR_TYPE.INTEGRAL.__doc__ = "Integral of input scalar computed with respect to time using one of specified numerical methods and using one of specified accumulation types."
CRDN_CALC_SCALAR_TYPE.FUNCTION2_VAR.__doc__ = "Defined by performing one of specified binary operations on two scalar arguments."
CRDN_CALC_SCALAR_TYPE.VECTOR_MAGNITUDE.__doc__ = "Scalar equal to magnitude of specified vector."
CRDN_CALC_SCALAR_TYPE.PLUGIN.__doc__ = "A calc scalar plugin based on a COM object."
CRDN_CALC_SCALAR_TYPE.CUSTOM_SCRIPT.__doc__ = "A calc scalar uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."
CRDN_CALC_SCALAR_TYPE.SURFACE_DISTANCE_BETWEEN_POINTS.__doc__ = "Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."
CRDN_CALC_SCALAR_TYPE.DOT_PRODUCT.__doc__ = "Scalar equal to the dot product between two vectors."
CRDN_CALC_SCALAR_TYPE.VECTOR_COMPONENT.__doc__ = "Scalar equal to the specified component of a vector when resolved in the specified axes."

agcls.AgTypeNameMap["CRDN_CALC_SCALAR_TYPE"] = CRDN_CALC_SCALAR_TYPE

class CRDN_CONDITION_COMBINED_OPERATION_TYPE(IntEnum):
    """Defines scalar condition combined operation types."""
   
    AND = 1
    """Scalar condition combined AND operation."""
    OR = 2
    """Scalar condition combined OR operation."""
    XOR = 3
    """Scalar condition combined XOR operation."""
    MINUS = 4
    """Scalar condition combined MINUS operation."""

CRDN_CONDITION_COMBINED_OPERATION_TYPE.AND.__doc__ = "Scalar condition combined AND operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.OR.__doc__ = "Scalar condition combined OR operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.XOR.__doc__ = "Scalar condition combined XOR operation."
CRDN_CONDITION_COMBINED_OPERATION_TYPE.MINUS.__doc__ = "Scalar condition combined MINUS operation."

agcls.AgTypeNameMap["CRDN_CONDITION_COMBINED_OPERATION_TYPE"] = CRDN_CONDITION_COMBINED_OPERATION_TYPE

class CRDN_CONDITION_SET_TYPE(IntEnum):
    """Defines available condition set types."""
   
    UNKNOWN = -1
    """Unknown or unsupported condition set types."""
    SCALAR_THRESHOLDS = 0
    """Condition set placing multiple thresholds on specified scalar."""

CRDN_CONDITION_SET_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported condition set types."
CRDN_CONDITION_SET_TYPE.SCALAR_THRESHOLDS.__doc__ = "Condition set placing multiple thresholds on specified scalar."

agcls.AgTypeNameMap["CRDN_CONDITION_SET_TYPE"] = CRDN_CONDITION_SET_TYPE

class CRDN_CONDITION_THRESHOLD_OPTION(IntEnum):
    """Operations for Scalar Bounds Condition."""
   
    ABOVE_MIN = 1
    """Bound is above a minimum value."""
    BELOW_MAX = 2
    """Bound is below a maximum value."""
    INSIDE_MIN_MAX = 3
    """Bound is between a minimum and maximum value."""
    OUTSIDE_MIN_MAX = 4
    """Bound is outside a minimum and maximum value."""

CRDN_CONDITION_THRESHOLD_OPTION.ABOVE_MIN.__doc__ = "Bound is above a minimum value."
CRDN_CONDITION_THRESHOLD_OPTION.BELOW_MAX.__doc__ = "Bound is below a maximum value."
CRDN_CONDITION_THRESHOLD_OPTION.INSIDE_MIN_MAX.__doc__ = "Bound is between a minimum and maximum value."
CRDN_CONDITION_THRESHOLD_OPTION.OUTSIDE_MIN_MAX.__doc__ = "Bound is outside a minimum and maximum value."

agcls.AgTypeNameMap["CRDN_CONDITION_THRESHOLD_OPTION"] = CRDN_CONDITION_THRESHOLD_OPTION

class CRDN_CONDITION_TYPE(IntEnum):
    """Defines available condition types."""
   
    UNKNOWN = -1
    """Unknown or unsupported condition type."""
    SCALAR_BOUNDS = 0
    """Condition placing bounds on specified scalar."""
    COMBINED = 1
    """Multiple conditiones on specified scalar."""
    POINT_IN_VOLUME = 2
    """Condition placing point in volume."""

CRDN_CONDITION_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported condition type."
CRDN_CONDITION_TYPE.SCALAR_BOUNDS.__doc__ = "Condition placing bounds on specified scalar."
CRDN_CONDITION_TYPE.COMBINED.__doc__ = "Multiple conditiones on specified scalar."
CRDN_CONDITION_TYPE.POINT_IN_VOLUME.__doc__ = "Condition placing point in volume."

agcls.AgTypeNameMap["CRDN_CONDITION_TYPE"] = CRDN_CONDITION_TYPE

class CRDN_DIMENSION_INHERITANCE(IntEnum):
    """Defines how dimension is inherited."""
   
    NONE = 0
    """Do not inherit dimension."""
    FROM_X = 1
    """Inherit dimension from X scalar."""
    FROM_Y = 2
    """Inherit dimension from Y scalar."""

CRDN_DIMENSION_INHERITANCE.NONE.__doc__ = "Do not inherit dimension."
CRDN_DIMENSION_INHERITANCE.FROM_X.__doc__ = "Inherit dimension from X scalar."
CRDN_DIMENSION_INHERITANCE.FROM_Y.__doc__ = "Inherit dimension from Y scalar."

agcls.AgTypeNameMap["CRDN_DIMENSION_INHERITANCE"] = CRDN_DIMENSION_INHERITANCE

class CRDN_EVENT_ARRAY_FILTER_TYPE(IntEnum):
    """Event array filter types."""
   
    SKIP_TIME_STEP = 0
    """Skip time step."""
    SKIP_COUNT = 1
    """Skip count."""
    INTERVALS = 2
    """Intervals."""

CRDN_EVENT_ARRAY_FILTER_TYPE.SKIP_TIME_STEP.__doc__ = "Skip time step."
CRDN_EVENT_ARRAY_FILTER_TYPE.SKIP_COUNT.__doc__ = "Skip count."
CRDN_EVENT_ARRAY_FILTER_TYPE.INTERVALS.__doc__ = "Intervals."

agcls.AgTypeNameMap["CRDN_EVENT_ARRAY_FILTER_TYPE"] = CRDN_EVENT_ARRAY_FILTER_TYPE

class CRDN_EVENT_ARRAY_TYPE(IntEnum):
    """Defines available time array types."""
   
    UNKNOWN = -1
    """Unknown or unsupported time array types."""
    EXTREMA = 0
    """Determine time of local minimum and/or maximum of specified scalar calculation."""
    START_STOP_TIMES = 1
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."""
    MERGED = 2
    """Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."""
    FILTERED = 3
    """Defined by filtering times from original time array according to specified filtering method."""
    FIXED_STEP = 4
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
    CONDITION_CROSSINGS = 5
    """Time array containing times at which specified condition changes its satisfaction status."""
    SIGNALED = 6
    """Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
    FIXED_TIMES = 7
    """Time array containing specific times."""

CRDN_EVENT_ARRAY_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported time array types."
CRDN_EVENT_ARRAY_TYPE.EXTREMA.__doc__ = "Determine time of local minimum and/or maximum of specified scalar calculation."
CRDN_EVENT_ARRAY_TYPE.START_STOP_TIMES.__doc__ = "Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array."
CRDN_EVENT_ARRAY_TYPE.MERGED.__doc__ = "Defined by merging times from two other arrays by creating union of bounding intervals from two constituent arrays."
CRDN_EVENT_ARRAY_TYPE.FILTERED.__doc__ = "Defined by filtering times from original time array according to specified filtering method."
CRDN_EVENT_ARRAY_TYPE.FIXED_STEP.__doc__ = "Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."
CRDN_EVENT_ARRAY_TYPE.CONDITION_CROSSINGS.__doc__ = "Time array containing times at which specified condition changes its satisfaction status."
CRDN_EVENT_ARRAY_TYPE.SIGNALED.__doc__ = "Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations."
CRDN_EVENT_ARRAY_TYPE.FIXED_TIMES.__doc__ = "Time array containing specific times."

agcls.AgTypeNameMap["CRDN_EVENT_ARRAY_TYPE"] = CRDN_EVENT_ARRAY_TYPE

class CRDN_EVENT_INTERVAL_COLLECTION_TYPE(IntEnum):
    """Defines available interval collection types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval collection types."""
    LIGHTING = 0
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
    SIGNALED = 1
    """Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
    CONDITION = 2
    """Interval collection containing intervals during which condition set is satisfied."""

CRDN_EVENT_INTERVAL_COLLECTION_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval collection types."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.LIGHTING.__doc__ = "Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.SIGNALED.__doc__ = "Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."
CRDN_EVENT_INTERVAL_COLLECTION_TYPE.CONDITION.__doc__ = "Interval collection containing intervals during which condition set is satisfied."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_COLLECTION_TYPE"] = CRDN_EVENT_INTERVAL_COLLECTION_TYPE

class CRDN_EVENT_INTERVAL_LIST_TYPE(IntEnum):
    """Defines available interval list types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval list types."""
    MERGED = 1
    """Interval list created by merging two constituent interval lists using specified logical operation."""
    FILTERED = 2
    """Defined by filtering intervals from original interval list using specified filtering method."""
    CONDITION = 3
    """Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."""
    SCALED = 4
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale."""
    SIGNALED = 5
    """Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."""
    TIME_OFFSET = 6
    """Interval List defined by shifting specified reference interval list by fixed time offset."""
    FILE = 0
    """Interval list loaded from specified interval file."""
    FIXED = 7
    """Interval list with individual intervals defined between explicitly specified start and stop times."""

CRDN_EVENT_INTERVAL_LIST_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval list types."
CRDN_EVENT_INTERVAL_LIST_TYPE.MERGED.__doc__ = "Interval list created by merging two constituent interval lists using specified logical operation."
CRDN_EVENT_INTERVAL_LIST_TYPE.FILTERED.__doc__ = "Defined by filtering intervals from original interval list using specified filtering method."
CRDN_EVENT_INTERVAL_LIST_TYPE.CONDITION.__doc__ = "Interval list containing intervals during which specified condition is satisfied (UI type name is Satisfaction)."
CRDN_EVENT_INTERVAL_LIST_TYPE.SCALED.__doc__ = "Interval List defined by scaling every interval in original interval list using either absolute or relative scale."
CRDN_EVENT_INTERVAL_LIST_TYPE.SIGNALED.__doc__ = "Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations."
CRDN_EVENT_INTERVAL_LIST_TYPE.TIME_OFFSET.__doc__ = "Interval List defined by shifting specified reference interval list by fixed time offset."
CRDN_EVENT_INTERVAL_LIST_TYPE.FILE.__doc__ = "Interval list loaded from specified interval file."
CRDN_EVENT_INTERVAL_LIST_TYPE.FIXED.__doc__ = "Interval list with individual intervals defined between explicitly specified start and stop times."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_LIST_TYPE"] = CRDN_EVENT_INTERVAL_LIST_TYPE

class CRDN_EVENT_INTERVAL_TYPE(IntEnum):
    """Defines available interval types."""
   
    UNKNOWN = -1
    """Unknown or unsupported interval types."""
    FIXED = 0
    """Interval defined between two explicitly specified start and stop times."""
    FIXED_DURATION = 1
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
    BETWEEN_TIME_INSTANTS = 2
    """Interval between specified start and stop time instants."""
    FROM_INTERVAL_LIST = 3
    """Interval created from specified interval list by using one of several selection methods."""
    SCALED = 4
    """Interval defined by scaling original interval using either absolute or relative scale."""
    SIGNALED = 5
    """Determine an interval recorded at a target clock location by performing signal transmission."""
    TIME_OFFSET = 6
    """Interval defined by shifting specified reference interval by fixed time offset."""
    SMART_INTERVAL = 7
    """A smart interval."""

CRDN_EVENT_INTERVAL_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported interval types."
CRDN_EVENT_INTERVAL_TYPE.FIXED.__doc__ = "Interval defined between two explicitly specified start and stop times."
CRDN_EVENT_INTERVAL_TYPE.FIXED_DURATION.__doc__ = "Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."
CRDN_EVENT_INTERVAL_TYPE.BETWEEN_TIME_INSTANTS.__doc__ = "Interval between specified start and stop time instants."
CRDN_EVENT_INTERVAL_TYPE.FROM_INTERVAL_LIST.__doc__ = "Interval created from specified interval list by using one of several selection methods."
CRDN_EVENT_INTERVAL_TYPE.SCALED.__doc__ = "Interval defined by scaling original interval using either absolute or relative scale."
CRDN_EVENT_INTERVAL_TYPE.SIGNALED.__doc__ = "Determine an interval recorded at a target clock location by performing signal transmission."
CRDN_EVENT_INTERVAL_TYPE.TIME_OFFSET.__doc__ = "Interval defined by shifting specified reference interval by fixed time offset."
CRDN_EVENT_INTERVAL_TYPE.SMART_INTERVAL.__doc__ = "A smart interval."

agcls.AgTypeNameMap["CRDN_EVENT_INTERVAL_TYPE"] = CRDN_EVENT_INTERVAL_TYPE

class CRDN_EVENT_LIST_MERGE_OPERATION(IntEnum):
    """Defines merge operations for interval lists."""
   
    AND = 0
    """Intervals both in A and B."""
    OR = 1
    """Intervals in A or B."""
    XOR = 2
    """Intervals in A or B but not in both."""
    MINUS = 3
    """Intervals in A and not in B."""

CRDN_EVENT_LIST_MERGE_OPERATION.AND.__doc__ = "Intervals both in A and B."
CRDN_EVENT_LIST_MERGE_OPERATION.OR.__doc__ = "Intervals in A or B."
CRDN_EVENT_LIST_MERGE_OPERATION.XOR.__doc__ = "Intervals in A or B but not in both."
CRDN_EVENT_LIST_MERGE_OPERATION.MINUS.__doc__ = "Intervals in A and not in B."

agcls.AgTypeNameMap["CRDN_EVENT_LIST_MERGE_OPERATION"] = CRDN_EVENT_LIST_MERGE_OPERATION

class CRDN_EVENT_TYPE(IntEnum):
    """Defines available time instant types."""
   
    UNKNOWN = -1
    """Unknown or unsupported time instant types."""
    EPOCH = 0
    """Time instant set at specified date/time."""
    EXTREMUM = 1
    """Determine time of global minimum or maximum of specified scalar calculation."""
    FROM_INTERVAL = 2
    """Start or stop time of selected reference interval."""
    SIGNALED = 3
    """Determine what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."""
    TIME_OFFSET = 4
    """Time instant at fixed offset from specified reference time instant."""
    SMART_EPOCH = 5
    """A smart epoch."""

CRDN_EVENT_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported time instant types."
CRDN_EVENT_TYPE.EPOCH.__doc__ = "Time instant set at specified date/time."
CRDN_EVENT_TYPE.EXTREMUM.__doc__ = "Determine time of global minimum or maximum of specified scalar calculation."
CRDN_EVENT_TYPE.FROM_INTERVAL.__doc__ = "Start or stop time of selected reference interval."
CRDN_EVENT_TYPE.SIGNALED.__doc__ = "Determine what time is recorded at target clock location by performing signal transmission of original time instant between base and target clock locations."
CRDN_EVENT_TYPE.TIME_OFFSET.__doc__ = "Time instant at fixed offset from specified reference time instant."
CRDN_EVENT_TYPE.SMART_EPOCH.__doc__ = "A smart epoch."

agcls.AgTypeNameMap["CRDN_EVENT_TYPE"] = CRDN_EVENT_TYPE

class CRDN_EXTREMUM_CONSTANTS(IntFlag):
    """These constants are utilized when finding a local or global minimum or maximum, or the threshold crossing."""
   
    MINIMUM = 1
    """Find the minimum value."""
    MAXIMUM = 2
    """Find the maximum value."""

CRDN_EXTREMUM_CONSTANTS.MINIMUM.__doc__ = "Find the minimum value."
CRDN_EXTREMUM_CONSTANTS.MAXIMUM.__doc__ = "Find the maximum value."

agcls.AgTypeNameMap["CRDN_EXTREMUM_CONSTANTS"] = CRDN_EXTREMUM_CONSTANTS

class CRDN_FILE_INTERPOLATOR_TYPE(IntEnum):
    """Interpolator types."""
   
    INVALID = -1
    """Unknown or invalid interpolator."""
    LAGRANGE = 1
    """Lagrange interpolation."""
    HERMITE = 2
    """Hermite interpolation."""
    HOLD_PREVIOUS = 3
    """Holds the value at the closest previous sample time to any requested time."""
    HOLD_NEXT = 4
    """Holds the value at the closest next sample time to any requested time."""
    HOLD_NEAREST = 5
    """Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."""

CRDN_FILE_INTERPOLATOR_TYPE.INVALID.__doc__ = "Unknown or invalid interpolator."
CRDN_FILE_INTERPOLATOR_TYPE.LAGRANGE.__doc__ = "Lagrange interpolation."
CRDN_FILE_INTERPOLATOR_TYPE.HERMITE.__doc__ = "Hermite interpolation."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_PREVIOUS.__doc__ = "Holds the value at the closest previous sample time to any requested time."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_NEXT.__doc__ = "Holds the value at the closest next sample time to any requested time."
CRDN_FILE_INTERPOLATOR_TYPE.HOLD_NEAREST.__doc__ = "Holds the value at the closest sample time (either the previous sample or the next sample) to any requested time."

agcls.AgTypeNameMap["CRDN_FILE_INTERPOLATOR_TYPE"] = CRDN_FILE_INTERPOLATOR_TYPE

class CRDN_INTEGRAL_TYPE(IntEnum):
    """Integral types."""
   
    FIXED_STEP_SIMPSON = 2
    """Simpson integral method."""
    FIXED_STEP_TRAPZ = 1
    """Trapezoidal integral method."""
    ADAPTIVE_STEP = 3
    """Adaptive Lobatto integral method."""

CRDN_INTEGRAL_TYPE.FIXED_STEP_SIMPSON.__doc__ = "Simpson integral method."
CRDN_INTEGRAL_TYPE.FIXED_STEP_TRAPZ.__doc__ = "Trapezoidal integral method."
CRDN_INTEGRAL_TYPE.ADAPTIVE_STEP.__doc__ = "Adaptive Lobatto integral method."

agcls.AgTypeNameMap["CRDN_INTEGRAL_TYPE"] = CRDN_INTEGRAL_TYPE

class CRDN_INTEGRATION_WINDOW_TYPE(IntEnum):
    """Defines the interval of times during which an integral is evaluated."""
   
    TOTAL = 0
    """Define the integral's window as the entire available interval list which effectively makes the value of the integral constant."""
    CUMULATIVE_TO_CURRENT = 1
    """Define the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."""
    CUMULATIVE_FROM_CURRENT = 2
    """Define the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."""
    SLIDING_WINDOW = 3
    """Define the integral's window as the interval of times centered around the current time with the specified front and back durations."""

CRDN_INTEGRATION_WINDOW_TYPE.TOTAL.__doc__ = "Define the integral's window as the entire available interval list which effectively makes the value of the integral constant."
CRDN_INTEGRATION_WINDOW_TYPE.CUMULATIVE_TO_CURRENT.__doc__ = "Define the integral's window as the window of time from the beginning of the available interval until the current time, i.e. window duration grows over time."
CRDN_INTEGRATION_WINDOW_TYPE.CUMULATIVE_FROM_CURRENT.__doc__ = "Define the integral's window as window of time from the current time until the end of the available interval, i.e. window duration decreases over time."
CRDN_INTEGRATION_WINDOW_TYPE.SLIDING_WINDOW.__doc__ = "Define the integral's window as the interval of times centered around the current time with the specified front and back durations."

agcls.AgTypeNameMap["CRDN_INTEGRATION_WINDOW_TYPE"] = CRDN_INTEGRATION_WINDOW_TYPE

class CRDN_INTERPOLATOR_TYPE(IntEnum):
    """Interpolator types."""
   
    INVALID = -1
    """Unknown or invalid interpolator."""
    LAGRANGE = 1
    """Lagrange interpolation."""
    HERMITE = 2
    """Hermite interpolation."""

CRDN_INTERPOLATOR_TYPE.INVALID.__doc__ = "Unknown or invalid interpolator."
CRDN_INTERPOLATOR_TYPE.LAGRANGE.__doc__ = "Lagrange interpolation."
CRDN_INTERPOLATOR_TYPE.HERMITE.__doc__ = "Hermite interpolation."

agcls.AgTypeNameMap["CRDN_INTERPOLATOR_TYPE"] = CRDN_INTERPOLATOR_TYPE

class CRDN_INTERVAL_DURATION_KIND(IntEnum):
    """Duration for filtering intervals or gaps from interval lists or time arrays."""
   
    AT_LEAST = 0
    """Filter by at least a specified number of seconds."""
    AT_MOST = 1
    """Filter by at most a specified number of seconds."""

CRDN_INTERVAL_DURATION_KIND.AT_LEAST.__doc__ = "Filter by at least a specified number of seconds."
CRDN_INTERVAL_DURATION_KIND.AT_MOST.__doc__ = "Filter by at most a specified number of seconds."

agcls.AgTypeNameMap["CRDN_INTERVAL_DURATION_KIND"] = CRDN_INTERVAL_DURATION_KIND

class CRDN_INTERVAL_SELECTION(IntEnum):
    """Select the method to choose an interval from an interval list."""
   
    FROM_START = 1
    """Select an interval by counting a specified number from the first interval."""
    FROM_END = 2
    """Select an interval by counting a specified number back from the last interval."""
    MAX_DURATION = 4
    """Select the interval with the largest duration."""
    MIN_DURATION = 5
    """Select the interval with the smallest duration."""
    MAX_GAP = 9
    """Select the largest gap between intervals."""
    MIN_GAP = 10
    """Select the largest gap between intervals."""
    SPAN = 100
    """Select the interval that is the span of the interval list."""

CRDN_INTERVAL_SELECTION.FROM_START.__doc__ = "Select an interval by counting a specified number from the first interval."
CRDN_INTERVAL_SELECTION.FROM_END.__doc__ = "Select an interval by counting a specified number back from the last interval."
CRDN_INTERVAL_SELECTION.MAX_DURATION.__doc__ = "Select the interval with the largest duration."
CRDN_INTERVAL_SELECTION.MIN_DURATION.__doc__ = "Select the interval with the smallest duration."
CRDN_INTERVAL_SELECTION.MAX_GAP.__doc__ = "Select the largest gap between intervals."
CRDN_INTERVAL_SELECTION.MIN_GAP.__doc__ = "Select the largest gap between intervals."
CRDN_INTERVAL_SELECTION.SPAN.__doc__ = "Select the interval that is the span of the interval list."

agcls.AgTypeNameMap["CRDN_INTERVAL_SELECTION"] = CRDN_INTERVAL_SELECTION

class CRDN_PARAMETER_SET_TYPE(IntEnum):
    """Defines parameter set types."""
   
    UNKNOWN = -1
    """Unknown or unsupported parameter set."""
    ATTITUDE = 0
    """A parameter set type is defined by identifying one set of axes in reference to another."""
    GROUND_TRAJECTORY = 1
    """A parameter set type is defined by identifying location in reference central body."""
    TRAJECTORY = 2
    """A parameter set type is defined by identifying location in reference coordinate system."""
    ORBIT = 3
    """A parameter set type is defined by identifying orbiting point and its central body."""
    VECTOR = 4
    """A parameter set type is defined by identifying vector in reference axes."""

CRDN_PARAMETER_SET_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported parameter set."
CRDN_PARAMETER_SET_TYPE.ATTITUDE.__doc__ = "A parameter set type is defined by identifying one set of axes in reference to another."
CRDN_PARAMETER_SET_TYPE.GROUND_TRAJECTORY.__doc__ = "A parameter set type is defined by identifying location in reference central body."
CRDN_PARAMETER_SET_TYPE.TRAJECTORY.__doc__ = "A parameter set type is defined by identifying location in reference coordinate system."
CRDN_PARAMETER_SET_TYPE.ORBIT.__doc__ = "A parameter set type is defined by identifying orbiting point and its central body."
CRDN_PARAMETER_SET_TYPE.VECTOR.__doc__ = "A parameter set type is defined by identifying vector in reference axes."

agcls.AgTypeNameMap["CRDN_PARAMETER_SET_TYPE"] = CRDN_PARAMETER_SET_TYPE

class CRDN_PRUNE_FILTER(IntEnum):
    """Specify the filter for filtering interval lists or time arrays."""
   
    UNKNOWN = 0
    """Unknown or unsupported prune filter."""
    FIRST_INTERVALS = 1
    """Select specified number of first intervals from original list."""
    LAST_INTERVALS = 2
    """Select specified number of last intervals from original list."""
    INTERVALS = 3
    """Select intervals which satisfy additional duration condition."""
    GAPS = 4
    """Select gaps between intervals which satisfy additional duration condition."""
    SATISFACTION_INTERVALS = 5
    """Satisfaction Intervals selects intervals which satisfy additional condition and duration."""
    RELATIVE_SATISFACTION_INTERVALS = 6
    """Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."""

CRDN_PRUNE_FILTER.UNKNOWN.__doc__ = "Unknown or unsupported prune filter."
CRDN_PRUNE_FILTER.FIRST_INTERVALS.__doc__ = "Select specified number of first intervals from original list."
CRDN_PRUNE_FILTER.LAST_INTERVALS.__doc__ = "Select specified number of last intervals from original list."
CRDN_PRUNE_FILTER.INTERVALS.__doc__ = "Select intervals which satisfy additional duration condition."
CRDN_PRUNE_FILTER.GAPS.__doc__ = "Select gaps between intervals which satisfy additional duration condition."
CRDN_PRUNE_FILTER.SATISFACTION_INTERVALS.__doc__ = "Satisfaction Intervals selects intervals which satisfy additional condition and duration."
CRDN_PRUNE_FILTER.RELATIVE_SATISFACTION_INTERVALS.__doc__ = "Relative Satisfaction Intervals selects intervals which satisfy additional condition and duration."

agcls.AgTypeNameMap["CRDN_PRUNE_FILTER"] = CRDN_PRUNE_FILTER

class CRDN_SAMPLED_REFERENCE_TIME(IntEnum):
    """Event array reference type."""
   
    REFERENCE_EVENT = 0
    """Use a Time Instant as the reference time."""
    START_OF_EACH_INTERVAL = 1
    """Use the start of each interval as the reference time."""
    STOP_OF_EACH_INTERVAL = 2
    """Use the stop of each interval as the reference time."""
    START_OF_INTERVAL_LIST = 3
    """Use the start of each interval list as the reference time."""
    STOP_OF_INTERVAL_LIST = 4
    """Use the stop of each interval list as the reference time."""

CRDN_SAMPLED_REFERENCE_TIME.REFERENCE_EVENT.__doc__ = "Use a Time Instant as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.START_OF_EACH_INTERVAL.__doc__ = "Use the start of each interval as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.STOP_OF_EACH_INTERVAL.__doc__ = "Use the stop of each interval as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.START_OF_INTERVAL_LIST.__doc__ = "Use the start of each interval list as the reference time."
CRDN_SAMPLED_REFERENCE_TIME.STOP_OF_INTERVAL_LIST.__doc__ = "Use the stop of each interval list as the reference time."

agcls.AgTypeNameMap["CRDN_SAMPLED_REFERENCE_TIME"] = CRDN_SAMPLED_REFERENCE_TIME

class CRDN_SAMPLING_METHOD(IntEnum):
    """Defines the Sampling Method."""
   
    UNKNOWN = 0
    """Unknown or unsupported sampling method."""
    FIXED_STEP = 1
    """Fixed step sampling method."""
    RELATIVE_TOLERANCE = 2
    """Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."""
    CURVATURE_TOLERANCE = 3
    """Curvature tolerance also uses changes in slope between samples."""

CRDN_SAMPLING_METHOD.UNKNOWN.__doc__ = "Unknown or unsupported sampling method."
CRDN_SAMPLING_METHOD.FIXED_STEP.__doc__ = "Fixed step sampling method."
CRDN_SAMPLING_METHOD.RELATIVE_TOLERANCE.__doc__ = "Relative tolerance method uses a combination of relative and absolute tolerance changes in scalar values between samples."
CRDN_SAMPLING_METHOD.CURVATURE_TOLERANCE.__doc__ = "Curvature tolerance also uses changes in slope between samples."

agcls.AgTypeNameMap["CRDN_SAMPLING_METHOD"] = CRDN_SAMPLING_METHOD

class CRDN_SATISFACTION_CROSSING(IntEnum):
    """Direction crossing flags."""
   
    NONE = 0
    """Use either off-to-on or on-to-off condition to determine satisfaction."""
    IN = 1
    """Satisfaction occurs when crossing from off to on condition."""
    OUT = 2
    """Satisfaction occurs when crossing from on to off condition."""

CRDN_SATISFACTION_CROSSING.NONE.__doc__ = "Use either off-to-on or on-to-off condition to determine satisfaction."
CRDN_SATISFACTION_CROSSING.IN.__doc__ = "Satisfaction occurs when crossing from off to on condition."
CRDN_SATISFACTION_CROSSING.OUT.__doc__ = "Satisfaction occurs when crossing from on to off condition."

agcls.AgTypeNameMap["CRDN_SATISFACTION_CROSSING"] = CRDN_SATISFACTION_CROSSING

class CRDN_SAVE_DATA_OPTION(IntEnum):
    """Method for saving computed data."""
   
    APPLICATION_SETTINGS = -1
    """Use the application setting to determine whether computed data should be saved/loaded."""
    YES = 100
    """Save/load computed data."""
    NO = 10
    """Don't save computed data, recompute data on load."""

CRDN_SAVE_DATA_OPTION.APPLICATION_SETTINGS.__doc__ = "Use the application setting to determine whether computed data should be saved/loaded."
CRDN_SAVE_DATA_OPTION.YES.__doc__ = "Save/load computed data."
CRDN_SAVE_DATA_OPTION.NO.__doc__ = "Don't save computed data, recompute data on load."

agcls.AgTypeNameMap["CRDN_SAVE_DATA_OPTION"] = CRDN_SAVE_DATA_OPTION

class CRDN_SIGNAL_PATH_REFERENCE_SYSTEM(IntEnum):
    """Signal path reference system types."""
   
    USE_ACCESS_DEFAULT = -1
    """Use Access default system."""
    CENTRAL_BODY_INERTIAL = 0
    """Use central body inertial system."""
    SOLAR_SYSTEM_BARYCENTER = 1
    """Use solar system barycenter system."""
    CUSTOM = 2
    """User will specify a system."""

CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.USE_ACCESS_DEFAULT.__doc__ = "Use Access default system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.CENTRAL_BODY_INERTIAL.__doc__ = "Use central body inertial system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.SOLAR_SYSTEM_BARYCENTER.__doc__ = "Use solar system barycenter system."
CRDN_SIGNAL_PATH_REFERENCE_SYSTEM.CUSTOM.__doc__ = "User will specify a system."

agcls.AgTypeNameMap["CRDN_SIGNAL_PATH_REFERENCE_SYSTEM"] = CRDN_SIGNAL_PATH_REFERENCE_SYSTEM

class CRDN_SMART_EPOCH_STATE(IntEnum):
    """Smart epoch states."""
   
    EXPLICIT = 0
    """Smart epoch is specified explicitly using a time."""
    IMPLICIT = 3
    """Smart epoch is specified implicitly."""

CRDN_SMART_EPOCH_STATE.EXPLICIT.__doc__ = "Smart epoch is specified explicitly using a time."
CRDN_SMART_EPOCH_STATE.IMPLICIT.__doc__ = "Smart epoch is specified implicitly."

agcls.AgTypeNameMap["CRDN_SMART_EPOCH_STATE"] = CRDN_SMART_EPOCH_STATE

class CRDN_SMART_INTERVAL_STATE(IntEnum):
    """Smart interval states."""
   
    EXPLICIT = 0
    """Smart interval is specified explicitly using start/stop times."""
    IMPLICIT = 1
    """Smart interval is specified implicitly using start/stop times."""
    START_STOP = 2
    """Smart interval is specified using smart epochs."""
    START_DURATION = 4
    """Smart interval is specified using a start epoch and duration."""
    EXPLICIT_DURATION = 3
    """Smart interval is specified using a start time and explicit duration."""

CRDN_SMART_INTERVAL_STATE.EXPLICIT.__doc__ = "Smart interval is specified explicitly using start/stop times."
CRDN_SMART_INTERVAL_STATE.IMPLICIT.__doc__ = "Smart interval is specified implicitly using start/stop times."
CRDN_SMART_INTERVAL_STATE.START_STOP.__doc__ = "Smart interval is specified using smart epochs."
CRDN_SMART_INTERVAL_STATE.START_DURATION.__doc__ = "Smart interval is specified using a start epoch and duration."
CRDN_SMART_INTERVAL_STATE.EXPLICIT_DURATION.__doc__ = "Smart interval is specified using a start time and explicit duration."

agcls.AgTypeNameMap["CRDN_SMART_INTERVAL_STATE"] = CRDN_SMART_INTERVAL_STATE

class CRDN_SPEED_OPTIONS(IntEnum):
    """Defines various speed options."""
   
    LIGHT_TRANSMISSION_SPEED = 1
    """Light transmission speed."""
    CUSTOM_TRANSMISSION_SPEED = 2
    """Custom transmission speed."""

CRDN_SPEED_OPTIONS.LIGHT_TRANSMISSION_SPEED.__doc__ = "Light transmission speed."
CRDN_SPEED_OPTIONS.CUSTOM_TRANSMISSION_SPEED.__doc__ = "Custom transmission speed."

agcls.AgTypeNameMap["CRDN_SPEED_OPTIONS"] = CRDN_SPEED_OPTIONS

class CRDN_START_STOP_OPTION(IntEnum):
    """Start/stop options."""
   
    COUNT_START_ONLY = 1
    """Use the start time of the interval."""
    COUNT_STOP_ONLY = 2
    """Use the stop time of the interval."""
    COUNT_START_STOP = 3
    """Use the start time and stop time of the interval."""

CRDN_START_STOP_OPTION.COUNT_START_ONLY.__doc__ = "Use the start time of the interval."
CRDN_START_STOP_OPTION.COUNT_STOP_ONLY.__doc__ = "Use the stop time of the interval."
CRDN_START_STOP_OPTION.COUNT_START_STOP.__doc__ = "Use the start time and stop time of the interval."

agcls.AgTypeNameMap["CRDN_START_STOP_OPTION"] = CRDN_START_STOP_OPTION

class CRDN_THRESH_CONVERGE_SENSE(IntEnum):
    """Specifies the desired sense of the results from threshold crossing computations."""
   
    SIMPLE = 0
    """Just converge within tolerance."""
    ABOVE = 1
    """Result above or at threshold."""
    BELOW = 2
    """Result below or at threshold."""

CRDN_THRESH_CONVERGE_SENSE.SIMPLE.__doc__ = "Just converge within tolerance."
CRDN_THRESH_CONVERGE_SENSE.ABOVE.__doc__ = "Result above or at threshold."
CRDN_THRESH_CONVERGE_SENSE.BELOW.__doc__ = "Result below or at threshold."

agcls.AgTypeNameMap["CRDN_THRESH_CONVERGE_SENSE"] = CRDN_THRESH_CONVERGE_SENSE

class VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE(IntEnum):
    """Defines component directions for a vector."""
   
    X = 0
    """X component."""
    Y = 1
    """Y component."""
    Z = 2
    """Z component."""
    MINUS_X = 3
    """-X component."""
    MINUS_Y = 4
    """-Y component."""
    MINUS_Z = 5
    """-Z component."""

VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.X.__doc__ = "X component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.Y.__doc__ = "Y component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.Z.__doc__ = "Z component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_X.__doc__ = "-X component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_Y.__doc__ = "-Y component."
VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE.MINUS_Z.__doc__ = "-Z component."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE"] = VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE

class CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE(IntEnum):
    """Defines volume calc altitude reference types."""
   
    ELLIPSOID = 0
    """Volume calc altitude above reference ellipsoid."""
    TERRAIN = 1
    """Volume calc altitude reference above terrain."""
    MSL = 2
    """Volume calc altitude reference above mean sea level."""

CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.ELLIPSOID.__doc__ = "Volume calc altitude above reference ellipsoid."
CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.TERRAIN.__doc__ = "Volume calc altitude reference above terrain."
CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE.MSL.__doc__ = "Volume calc altitude reference above mean sea level."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE"] = CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE

class CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE(IntEnum):
    """Defines volume calc angle off vector reference types."""
   
    PLANE_SIGNED = 1
    """Volume calc angle off plane signed."""
    PLANE_UNSIGNED = 2
    """Volume calc angle off plane unsigned."""
    ABOUT_VECTOR_SIGNED = 4
    """Volume calc angle about vector signed."""
    ABOUT_VECTOR_UNSIGNED = 8
    """Volume calc angle about vector unsigned."""
    VECTOR = 16
    """Volume calc angle off vector."""

CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.PLANE_SIGNED.__doc__ = "Volume calc angle off plane signed."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.PLANE_UNSIGNED.__doc__ = "Volume calc angle off plane unsigned."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.ABOUT_VECTOR_SIGNED.__doc__ = "Volume calc angle about vector signed."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.ABOUT_VECTOR_UNSIGNED.__doc__ = "Volume calc angle about vector unsigned."
CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE.VECTOR.__doc__ = "Volume calc angle off vector."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE"] = CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE

class CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE(IntEnum):
    """Defines volume calc range distance types."""
   
    FROM_POINT = 0
    """Volume calc range distance type from point."""
    ALONG_VECTOR_SIGNED = 1
    """Volume calc range distance type from point."""
    ALONG_VECTOR_UNSIGNED = 2
    """Volume calc range distance type along vector unsigned."""
    PLANE_SIGNED = 4
    """Volume calc range distance type plane signed."""
    PLANE_UNSIGNED = 8
    """Volume calc range distance type plane signed."""

CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.FROM_POINT.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.ALONG_VECTOR_SIGNED.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.ALONG_VECTOR_UNSIGNED.__doc__ = "Volume calc range distance type along vector unsigned."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.PLANE_SIGNED.__doc__ = "Volume calc range distance type plane signed."
CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE.PLANE_UNSIGNED.__doc__ = "Volume calc range distance type plane signed."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE"] = CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE

class CRDN_VOLUME_CALC_RANGE_SPEED_TYPE(IntEnum):
    """Defines volume calc range distance types."""
   
    LIGHT = 1
    """Volume calc range distance type from point."""
    CUSTOM = 2
    """Volume calc range distance type from point."""

CRDN_VOLUME_CALC_RANGE_SPEED_TYPE.LIGHT.__doc__ = "Volume calc range distance type from point."
CRDN_VOLUME_CALC_RANGE_SPEED_TYPE.CUSTOM.__doc__ = "Volume calc range distance type from point."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_RANGE_SPEED_TYPE"] = CRDN_VOLUME_CALC_RANGE_SPEED_TYPE

class CRDN_VOLUME_CALC_TYPE(IntEnum):
    """Defines volume calc types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume calc."""
    ALTITUDE = 0
    """volume calc type altitude to location."""
    ANGLE_OFF_VECTOR = 1
    """volume calc type angle to location."""
    FILE = 2
    """volume calc type File."""
    FROM_SCALAR = 3
    """volume calc type scalar at location."""
    SOLAR_INTENSITY = 4
    """volume calc type Solar Intensity."""
    VOLUME_SATISFACTION_METRIC = 5
    """volume calc type Spatial Condition Satisfaction Metric."""
    RANGE = 6
    """volume calc type Distance to Location."""
    DELAY_RANGE = 7
    """volume calc type Propagation Delay to Location."""

CRDN_VOLUME_CALC_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume calc."
CRDN_VOLUME_CALC_TYPE.ALTITUDE.__doc__ = "volume calc type altitude to location."
CRDN_VOLUME_CALC_TYPE.ANGLE_OFF_VECTOR.__doc__ = "volume calc type angle to location."
CRDN_VOLUME_CALC_TYPE.FILE.__doc__ = "volume calc type File."
CRDN_VOLUME_CALC_TYPE.FROM_SCALAR.__doc__ = "volume calc type scalar at location."
CRDN_VOLUME_CALC_TYPE.SOLAR_INTENSITY.__doc__ = "volume calc type Solar Intensity."
CRDN_VOLUME_CALC_TYPE.VOLUME_SATISFACTION_METRIC.__doc__ = "volume calc type Spatial Condition Satisfaction Metric."
CRDN_VOLUME_CALC_TYPE.RANGE.__doc__ = "volume calc type Distance to Location."
CRDN_VOLUME_CALC_TYPE.DELAY_RANGE.__doc__ = "volume calc type Propagation Delay to Location."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_TYPE"] = CRDN_VOLUME_CALC_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE(IntEnum):
    """Defines volume calc spatial condition accumulation types."""
   
    UP_TO_CURRENT_TIME = -1
    """Volume calc spatial condition satisfaction accumulation type up to current time."""
    CURRENT_TIME = 0
    """Volume calc spatial condition satisfaction accumulation type current time."""
    FROM_CURRENT_TIME = 1
    """Volume calc spatial condition satisfaction accumulation type from current time."""
    TOTAL = 10
    """Volume calc spatial condition satisfaction accumulation type total."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.UP_TO_CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type up to current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.FROM_CURRENT_TIME.__doc__ = "Volume calc spatial condition satisfaction accumulation type from current time."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE.TOTAL.__doc__ = "Volume calc spatial condition satisfaction accumulation type total."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE(IntEnum):
    """Defines volume calc spatial condition duration types."""
   
    MIN = -1
    """Volume calc spatial condition satisfaction duration type minimum."""
    SUM = 0
    """Volume calc spatial condition satisfaction duration type sum."""
    MAX = 1
    """Volume calc spatial condition satisfaction duration type maximum."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.MIN.__doc__ = "Volume calc spatial condition satisfaction duration type minimum."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.SUM.__doc__ = "Volume calc spatial condition satisfaction duration type sum."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE.MAX.__doc__ = "Volume calc spatial condition satisfaction duration type maximum."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE(IntEnum):
    """Defines volume calc spatial condition filter types."""
   
    FIRST_INTERVALS = -10
    """Volume calc spatial condition satisfaction filter type first intervals."""
    LAST_INTERVALS = -20
    """Volume calc spatial condition satisfaction filter type last intervals."""
    NONE = 0
    """Volume calc spatial condition satisfaction filter type none."""
    GAP_DURATION = 1
    """Volume calc spatial condition satisfaction filter type gap duration."""
    INTERVAL_DURATION = 2
    """Volume calc spatial condition satisfaction filter type interval duration."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.FIRST_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction filter type first intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.LAST_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction filter type last intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.NONE.__doc__ = "Volume calc spatial condition satisfaction filter type none."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.GAP_DURATION.__doc__ = "Volume calc spatial condition satisfaction filter type gap duration."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE.INTERVAL_DURATION.__doc__ = "Volume calc spatial condition satisfaction filter type interval duration."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE

class CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE(IntEnum):
    """Defines volume calc spatial condition satisfaction metric types."""
   
    NUMBER_OF_GAPS = -2
    """Volume calc spatial condition satisfaction metric type number of gaps."""
    NUMBER_OF_INTERVALS = -1
    """Volume calc spatial condition satisfaction metric type number of intervals."""
    TIME_SINCE_LAST_SATISFACTION = 1
    """Volume calc spatial condition satisfaction metric type time since last satisfaction."""
    TIME_UNTIL_NEXT_SATISFACTION = 2
    """Volume calc spatial condition satisfaction metric type time until next satisfaction."""
    INTERVAL_DURATION = 10
    """Volume calc spatial condition satisfaction metric type interbnal duration."""
    GAP_DURATION = 20
    """Volume calc spatial condition satisfaction metric type gap duration."""

CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.NUMBER_OF_GAPS.__doc__ = "Volume calc spatial condition satisfaction metric type number of gaps."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.NUMBER_OF_INTERVALS.__doc__ = "Volume calc spatial condition satisfaction metric type number of intervals."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.TIME_SINCE_LAST_SATISFACTION.__doc__ = "Volume calc spatial condition satisfaction metric type time since last satisfaction."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.TIME_UNTIL_NEXT_SATISFACTION.__doc__ = "Volume calc spatial condition satisfaction metric type time until next satisfaction."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.INTERVAL_DURATION.__doc__ = "Volume calc spatial condition satisfaction metric type interbnal duration."
CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE.GAP_DURATION.__doc__ = "Volume calc spatial condition satisfaction metric type gap duration."

agcls.AgTypeNameMap["CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE"] = CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE

class CRDN_VOLUME_GRID_TYPE(IntEnum):
    """Defines volume grid types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume grid."""
    CARTESIAN = 0
    """volume grid type cartesian."""
    CYLINDRICAL = 1
    """volume grid type Cylindrical."""
    SPHERICAL = 2
    """volume grid type Spherical."""
    CONSTRAINED = 3
    """volume grid type Constrained."""
    LAT_LON_ALTITUDE = 4
    """volume grid type LatLonAlt (Cartographic)."""
    BEARING_ALTITUDE = 5
    """volume grid type BearingAlt (Surface Bearing)."""

CRDN_VOLUME_GRID_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume grid."
CRDN_VOLUME_GRID_TYPE.CARTESIAN.__doc__ = "volume grid type cartesian."
CRDN_VOLUME_GRID_TYPE.CYLINDRICAL.__doc__ = "volume grid type Cylindrical."
CRDN_VOLUME_GRID_TYPE.SPHERICAL.__doc__ = "volume grid type Spherical."
CRDN_VOLUME_GRID_TYPE.CONSTRAINED.__doc__ = "volume grid type Constrained."
CRDN_VOLUME_GRID_TYPE.LAT_LON_ALTITUDE.__doc__ = "volume grid type LatLonAlt (Cartographic)."
CRDN_VOLUME_GRID_TYPE.BEARING_ALTITUDE.__doc__ = "volume grid type BearingAlt (Surface Bearing)."

agcls.AgTypeNameMap["CRDN_VOLUME_GRID_TYPE"] = CRDN_VOLUME_GRID_TYPE

class CRDN_VOLUME_RESULT_VECTOR_REQUEST(IntEnum):
    """Defines volume result vector request types."""
   
    POSITION = 1
    """volume result vector request pos type."""
    NATIVE_POSITION = 2
    """volume result vector request native pos type."""
    METRIC = 16
    """volume result vector request metric type."""
    SATISFACTION = 32
    """volume result vector request satisfaction type."""
    GRADIENT = 256
    """volume result vector request gradient type."""

CRDN_VOLUME_RESULT_VECTOR_REQUEST.POSITION.__doc__ = "volume result vector request pos type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.NATIVE_POSITION.__doc__ = "volume result vector request native pos type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.METRIC.__doc__ = "volume result vector request metric type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.SATISFACTION.__doc__ = "volume result vector request satisfaction type."
CRDN_VOLUME_RESULT_VECTOR_REQUEST.GRADIENT.__doc__ = "volume result vector request gradient type."

agcls.AgTypeNameMap["CRDN_VOLUME_RESULT_VECTOR_REQUEST"] = CRDN_VOLUME_RESULT_VECTOR_REQUEST

class CRDN_VOLUME_TYPE(IntEnum):
    """Defines volume grid types."""
   
    UNKNOWN = -1
    """Unknown or unsupported volume."""
    COMBINED = 0
    """volume type combined."""
    LIGHTING = 1
    """volume type lighting."""
    OVER_TIME = 2
    """volume type over time."""
    FROM_GRID = 3
    """volume type from grid (Grid Bounding Volume)."""
    FROM_CALC = 4
    """volume type from calc (Spatial Calculation Bounds)."""
    FROM_TIME_SATISFACTION = 5
    """volume type from time satisfaction (Valid Time At Location)."""
    FROM_CONDITION = 6
    """volume type from condition (Condition At Location)."""
    INVIEW = 7
    """volume type Inview (Access To Location)."""

CRDN_VOLUME_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported volume."
CRDN_VOLUME_TYPE.COMBINED.__doc__ = "volume type combined."
CRDN_VOLUME_TYPE.LIGHTING.__doc__ = "volume type lighting."
CRDN_VOLUME_TYPE.OVER_TIME.__doc__ = "volume type over time."
CRDN_VOLUME_TYPE.FROM_GRID.__doc__ = "volume type from grid (Grid Bounding Volume)."
CRDN_VOLUME_TYPE.FROM_CALC.__doc__ = "volume type from calc (Spatial Calculation Bounds)."
CRDN_VOLUME_TYPE.FROM_TIME_SATISFACTION.__doc__ = "volume type from time satisfaction (Valid Time At Location)."
CRDN_VOLUME_TYPE.FROM_CONDITION.__doc__ = "volume type from condition (Condition At Location)."
CRDN_VOLUME_TYPE.INVIEW.__doc__ = "volume type Inview (Access To Location)."

agcls.AgTypeNameMap["CRDN_VOLUME_TYPE"] = CRDN_VOLUME_TYPE

class CRDN_VOLUME_ABERRATION_TYPE(IntEnum):
    """Defines the model of aberration to use."""
   
    UNKNOWN = -1
    """Aberration type unknown."""
    TOTAL = 0
    """Aberration type total."""
    ANNUAL = 1
    """SAberration type annual."""
    NONE = 2
    """Aberration type none."""

CRDN_VOLUME_ABERRATION_TYPE.UNKNOWN.__doc__ = "Aberration type unknown."
CRDN_VOLUME_ABERRATION_TYPE.TOTAL.__doc__ = "Aberration type total."
CRDN_VOLUME_ABERRATION_TYPE.ANNUAL.__doc__ = "SAberration type annual."
CRDN_VOLUME_ABERRATION_TYPE.NONE.__doc__ = "Aberration type none."

agcls.AgTypeNameMap["CRDN_VOLUME_ABERRATION_TYPE"] = CRDN_VOLUME_ABERRATION_TYPE

class CRDN_VOLUME_CLOCK_HOST_TYPE(IntEnum):
    """Defines whether base or target of an Access instance holds the clock for Access times."""
   
    UNKNOWN = -1
    """Unknown."""
    BASE = 0
    """Base object holds time instance."""
    TARGET = 1
    """Target object holds time instance."""

CRDN_VOLUME_CLOCK_HOST_TYPE.UNKNOWN.__doc__ = "Unknown."
CRDN_VOLUME_CLOCK_HOST_TYPE.BASE.__doc__ = "Base object holds time instance."
CRDN_VOLUME_CLOCK_HOST_TYPE.TARGET.__doc__ = "Target object holds time instance."

agcls.AgTypeNameMap["CRDN_VOLUME_CLOCK_HOST_TYPE"] = CRDN_VOLUME_CLOCK_HOST_TYPE

class CRDN_VOLUME_COMBINED_OPERATION_TYPE(IntEnum):
    """Defines spatial condition combined operation types."""
   
    AND = 1
    """Spatial condition combined AND operation."""
    OR = 2
    """Spatial condition combined OR operation."""
    XOR = 3
    """Spatial condition combined XOR operation."""
    MINUS = 4
    """Spatial condition combined MINUS operation."""

CRDN_VOLUME_COMBINED_OPERATION_TYPE.AND.__doc__ = "Spatial condition combined AND operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.OR.__doc__ = "Spatial condition combined OR operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.XOR.__doc__ = "Spatial condition combined XOR operation."
CRDN_VOLUME_COMBINED_OPERATION_TYPE.MINUS.__doc__ = "Spatial condition combined MINUS operation."

agcls.AgTypeNameMap["CRDN_VOLUME_COMBINED_OPERATION_TYPE"] = CRDN_VOLUME_COMBINED_OPERATION_TYPE

class CRDN_VOLUME_FROM_GRID_EDGE_TYPE(IntEnum):
    """Defines spatial condition from grid edge type."""
   
    MASK_POINTS = 16
    """Spatial condition over time from grid edge type mask points."""
    MASK_VOXELS = 32
    """Spatial condition over time from grid edge type mask voxels."""

CRDN_VOLUME_FROM_GRID_EDGE_TYPE.MASK_POINTS.__doc__ = "Spatial condition over time from grid edge type mask points."
CRDN_VOLUME_FROM_GRID_EDGE_TYPE.MASK_VOXELS.__doc__ = "Spatial condition over time from grid edge type mask voxels."

agcls.AgTypeNameMap["CRDN_VOLUME_FROM_GRID_EDGE_TYPE"] = CRDN_VOLUME_FROM_GRID_EDGE_TYPE

class CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE(IntFlag):
    """Defines spatial condition lighting conditions types."""
   
    TYPE_UNDEFINED = 0
    """Spatial condition lighting undefined."""
    TYPE_SUNLIGHT = 1
    """Spatial condition lighting sun light."""
    TYPE_PENUMBRA = 2
    """Spatial condition lighting penumbra."""
    TYPE_UMBRA = 4
    """Spatial condition lighting umbra."""

CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_UNDEFINED.__doc__ = "Spatial condition lighting undefined."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_SUNLIGHT.__doc__ = "Spatial condition lighting sun light."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_PENUMBRA.__doc__ = "Spatial condition lighting penumbra."
CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE.TYPE_UMBRA.__doc__ = "Spatial condition lighting umbra."

agcls.AgTypeNameMap["CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE"] = CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE

class CRDN_VOLUME_OVER_TIME_DURATION_TYPE(IntEnum):
    """Defines spatial condition over time duration type."""
   
    STATIC = 0
    """Spatial condition over time duration type Static."""
    CUMULATIVE_TO_CURRENT = 1
    """Spatial condition over time duration type CumulativeToCurrent."""
    CUMULATIVE_FROM_CURRENT = 2
    """Spatial condition over time duration type CumulativeFromCurrent."""
    SLIDING_WINDOW = 3
    """Spatial condition over time duration type SlidingWindow."""

CRDN_VOLUME_OVER_TIME_DURATION_TYPE.STATIC.__doc__ = "Spatial condition over time duration type Static."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.CUMULATIVE_TO_CURRENT.__doc__ = "Spatial condition over time duration type CumulativeToCurrent."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.CUMULATIVE_FROM_CURRENT.__doc__ = "Spatial condition over time duration type CumulativeFromCurrent."
CRDN_VOLUME_OVER_TIME_DURATION_TYPE.SLIDING_WINDOW.__doc__ = "Spatial condition over time duration type SlidingWindow."

agcls.AgTypeNameMap["CRDN_VOLUME_OVER_TIME_DURATION_TYPE"] = CRDN_VOLUME_OVER_TIME_DURATION_TYPE

class CRDN_VOLUME_TIME_SENSE_TYPE(IntEnum):
    """Defines whether object1 or object2 of an Access instance holds the clock for Access times."""
   
    UNKNOWN = -1
    """Unklnown."""
    TRANSMIT = 0
    """Position is computed in Time Sense."""
    RECEIVE = 1
    """Position is computed in Receive Sense."""

CRDN_VOLUME_TIME_SENSE_TYPE.UNKNOWN.__doc__ = "Unklnown."
CRDN_VOLUME_TIME_SENSE_TYPE.TRANSMIT.__doc__ = "Position is computed in Time Sense."
CRDN_VOLUME_TIME_SENSE_TYPE.RECEIVE.__doc__ = "Position is computed in Receive Sense."

agcls.AgTypeNameMap["CRDN_VOLUME_TIME_SENSE_TYPE"] = CRDN_VOLUME_TIME_SENSE_TYPE

class CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE(IntEnum):
    """Defines volumetric grid values method types."""
   
    METHOD_UNKNOWN = -1
    """Unknown or unsupportedgrid values method."""
    METHOD_FIXED_NUM_STEPS = 0
    """Fixed number steps grid values method for volumetric grid."""
    METHOD_FIXED_STEP_SIZE = 1
    """Fixed step size grid values method for volumetric grid."""
    METHOD_CUSTOM_VALUES = 2
    """Custom grid values method for volumetric grid."""

CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_UNKNOWN.__doc__ = "Unknown or unsupportedgrid values method."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_FIXED_NUM_STEPS.__doc__ = "Fixed number steps grid values method for volumetric grid."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_FIXED_STEP_SIZE.__doc__ = "Fixed step size grid values method for volumetric grid."
CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE.METHOD_CUSTOM_VALUES.__doc__ = "Custom grid values method for volumetric grid."

agcls.AgTypeNameMap["CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE"] = CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE

class CRDN_KIND(IntEnum):
    """Represents kinds of vectory geometry components."""
   
    UNKNOWN = -1
    """Unsupported component kind."""
    INVALID = 0
    """Invalid component."""
    AXES = 1
    """Axes component."""
    ANGLE = 2
    """Angle component."""
    VECTOR = 3
    """Vector component."""
    POINT = 4
    """Point component."""
    PLANE = 5
    """Plane component."""
    SYSTEM = 6
    """System component."""
    EVENT = 7
    """An event."""
    EVENT_ARRAY = 8
    """An event array."""
    EVENT_INTERVAL = 9
    """An event interval."""
    EVENT_INTERVAL_COLLECTION = 10
    """An event interval collection."""
    EVENT_INTERVAL_LIST = 11
    """A list of event intervals."""
    PARAMETER_SET = 12
    """A parameter set."""
    CALC_SCALAR = 13
    """A scalar."""
    CONDITION = 14
    """A condition."""
    CONDITION_SET = 15
    """A condition set."""
    VOLUME_GRID = 16
    """A volume grid."""
    VOLUME = 17
    """A volume."""
    VOLUME_CALC = 18
    """A volume calc."""

CRDN_KIND.UNKNOWN.__doc__ = "Unsupported component kind."
CRDN_KIND.INVALID.__doc__ = "Invalid component."
CRDN_KIND.AXES.__doc__ = "Axes component."
CRDN_KIND.ANGLE.__doc__ = "Angle component."
CRDN_KIND.VECTOR.__doc__ = "Vector component."
CRDN_KIND.POINT.__doc__ = "Point component."
CRDN_KIND.PLANE.__doc__ = "Plane component."
CRDN_KIND.SYSTEM.__doc__ = "System component."
CRDN_KIND.EVENT.__doc__ = "An event."
CRDN_KIND.EVENT_ARRAY.__doc__ = "An event array."
CRDN_KIND.EVENT_INTERVAL.__doc__ = "An event interval."
CRDN_KIND.EVENT_INTERVAL_COLLECTION.__doc__ = "An event interval collection."
CRDN_KIND.EVENT_INTERVAL_LIST.__doc__ = "A list of event intervals."
CRDN_KIND.PARAMETER_SET.__doc__ = "A parameter set."
CRDN_KIND.CALC_SCALAR.__doc__ = "A scalar."
CRDN_KIND.CONDITION.__doc__ = "A condition."
CRDN_KIND.CONDITION_SET.__doc__ = "A condition set."
CRDN_KIND.VOLUME_GRID.__doc__ = "A volume grid."
CRDN_KIND.VOLUME.__doc__ = "A volume."
CRDN_KIND.VOLUME_CALC.__doc__ = "A volume calc."

agcls.AgTypeNameMap["CRDN_KIND"] = CRDN_KIND

class VECTOR_GEOMETRY_TOOL_ANGLE_TYPE(IntEnum):
    """Represents angle types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    BETWEEN_VECTORS = 0
    """An angle between two vectors."""
    BETWEEN_PLANES = 1
    """An angle between two planes."""
    DIHEDRAL_ANGLE = 2
    """An angle between two vectors about an axis."""
    ROTATION = 3
    """Angle of the shortest rotation between the two specified axes."""
    TO_PLANE = 4
    """An angle between a vector and a plane."""
    TEMPLATE = 5
    """Represents a VGT angle created from a template. This type of angle is not creatable."""

VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.BETWEEN_VECTORS.__doc__ = "An angle between two vectors."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.BETWEEN_PLANES.__doc__ = "An angle between two planes."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.DIHEDRAL_ANGLE.__doc__ = "An angle between two vectors about an axis."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.ROTATION.__doc__ = "Angle of the shortest rotation between the two specified axes."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.TO_PLANE.__doc__ = "An angle between a vector and a plane."
VECTOR_GEOMETRY_TOOL_ANGLE_TYPE.TEMPLATE.__doc__ = "Represents a VGT angle created from a template. This type of angle is not creatable."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_ANGLE_TYPE"] = VECTOR_GEOMETRY_TOOL_ANGLE_TYPE

class VECTOR_GEOMETRY_TOOL_AXES_TYPE(IntEnum):
    """Represents vector types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    LAGRANGE_LIBRATION = 0
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""
    ANGULAR_OFFSET = 1
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""
    FIXED_AT_EPOCH = 2
    """Axes based on another set fixed at a specified epoch."""
    B_PLANE = 3
    """B-Plane axes using the selected target body and reference vector."""
    CUSTOM_SCRIPT = 4
    """Customized axes offset with respect to a set of reference Axes."""
    FIXED = 6
    """Axes fixed in reference axes."""
    ALIGNED_AND_CONSTRAINED = 7
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""
    MODEL_ATTACHMENT = 8
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""
    SPINNING = 9
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""
    ON_SURFACE = 10
    """Projection of the reference point onto the central body."""
    TRAJECTORY = 11
    """Axes based on trajectory of the point relative to the reference coordinate system."""
    TEMPLATE = 12
    """Represents a VGT axes created from a template. This type of axes is not creatable."""
    AT_TIME_INSTANT = 13
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""
    PLUGIN = 14
    """An axes plugin point."""
    FILE = 5
    """Axes specified by data from a file."""

VECTOR_GEOMETRY_TOOL_AXES_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.LAGRANGE_LIBRATION.__doc__ = "Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ANGULAR_OFFSET.__doc__ = "Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FIXED_AT_EPOCH.__doc__ = "Axes based on another set fixed at a specified epoch."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.B_PLANE.__doc__ = "B-Plane axes using the selected target body and reference vector."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.CUSTOM_SCRIPT.__doc__ = "Customized axes offset with respect to a set of reference Axes."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FIXED.__doc__ = "Axes fixed in reference axes."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ALIGNED_AND_CONSTRAINED.__doc__ = "Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.MODEL_ATTACHMENT.__doc__ = "Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.SPINNING.__doc__ = "Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.ON_SURFACE.__doc__ = "Projection of the reference point onto the central body."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.TRAJECTORY.__doc__ = "Axes based on trajectory of the point relative to the reference coordinate system."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.TEMPLATE.__doc__ = "Represents a VGT axes created from a template. This type of axes is not creatable."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.AT_TIME_INSTANT.__doc__ = "Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.PLUGIN.__doc__ = "An axes plugin point."
VECTOR_GEOMETRY_TOOL_AXES_TYPE.FILE.__doc__ = "Axes specified by data from a file."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_AXES_TYPE"] = VECTOR_GEOMETRY_TOOL_AXES_TYPE

class VECTOR_GEOMETRY_TOOL_PLANE_TYPE(IntEnum):
    """Represents plane types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    NORMAL = 0
    """A plane normal to a vector at a given point."""
    QUADRANT = 1
    """A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."""
    TRAJECTORY = 2
    """A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."""
    TRIAD = 3
    """A plane is defined by the three points."""
    TEMPLATE = 4
    """Represents a VGT plane created from a template. This type of plane is not creatable."""
    TWO_VECTOR = 5
    """A plane passing through point and containing two given vectors."""

VECTOR_GEOMETRY_TOOL_PLANE_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.NORMAL.__doc__ = "A plane normal to a vector at a given point."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.QUADRANT.__doc__ = "A plane is defined by the quadrant from a Reference System (e.g., XY, XZ, YZ, YX, ZX, ZY). The reference point in all cases is the origin of the coordinate system."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TRAJECTORY.__doc__ = "A plane is defined on the basis of a trajectory of a selected point with respect to a reference point."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TRIAD.__doc__ = "A plane is defined by the three points."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TEMPLATE.__doc__ = "Represents a VGT plane created from a template. This type of plane is not creatable."
VECTOR_GEOMETRY_TOOL_PLANE_TYPE.TWO_VECTOR.__doc__ = "A plane passing through point and containing two given vectors."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_PLANE_TYPE"] = VECTOR_GEOMETRY_TOOL_PLANE_TYPE

class VECTOR_GEOMETRY_TOOL_POINT_TYPE(IntEnum):
    """Represents point types."""
   
    UNKNOWN = -1
    """Unknown or unsupported type."""
    B_PLANE = 0
    """B-Plane point using the selected target body."""
    GRAZING = 1
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""
    COVARIANCE_GRAZING = 2
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""
    FIXED_IN_SYSTEM = 4
    """Point fixed in a reference coordinate system."""
    GLINT = 5
    """Point on central body surface that reflects from source to observer."""
    PLANE_INTERSECTION = 6
    """Point on a plane located along a given direction looking from a given origin."""
    MODEL_ATTACHMENT = 7
    """Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""
    PLANE_PROJECTION = 8
    """The projection of a point onto a reference plane."""
    ON_SURFACE = 9
    """The detic subpoint of the reference point as projected onto the central body."""
    LAGRANGE_LIBRATION = 10
    """Libration point using one primary and multiple secondary central bodies."""
    TEMPLATE = 11
    """Represents a VGT point created from a template. This type of point is not creatable."""
    CENTRAL_BODY_INTERSECT = 12
    """Point on central body surface along direction vector originating at source point."""
    AT_TIME_INSTANT = 13
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""
    PLUGIN = 14
    """A point plugin point."""
    FILE = 3
    """Point specified by data from a file."""
    FIXED_ON_CENTRAL_BODY = 15
    """Point fixed on a central body."""
    SATELLITE_COLLECTION_ENTRY = 16
    """A point placed at the center of mass of a specified satellite of the satellite collection."""

VECTOR_GEOMETRY_TOOL_POINT_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported type."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.B_PLANE.__doc__ = "B-Plane point using the selected target body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.GRAZING.__doc__ = "The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.COVARIANCE_GRAZING.__doc__ = "The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FIXED_IN_SYSTEM.__doc__ = "Point fixed in a reference coordinate system."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.GLINT.__doc__ = "Point on central body surface that reflects from source to observer."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLANE_INTERSECTION.__doc__ = "Point on a plane located along a given direction looking from a given origin."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.MODEL_ATTACHMENT.__doc__ = "Point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLANE_PROJECTION.__doc__ = "The projection of a point onto a reference plane."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.ON_SURFACE.__doc__ = "The detic subpoint of the reference point as projected onto the central body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.LAGRANGE_LIBRATION.__doc__ = "Libration point using one primary and multiple secondary central bodies."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.TEMPLATE.__doc__ = "Represents a VGT point created from a template. This type of point is not creatable."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.CENTRAL_BODY_INTERSECT.__doc__ = "Point on central body surface along direction vector originating at source point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.AT_TIME_INSTANT.__doc__ = "Point fixed relative to reference system based on another point evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.PLUGIN.__doc__ = "A point plugin point."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FILE.__doc__ = "Point specified by data from a file."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.FIXED_ON_CENTRAL_BODY.__doc__ = "Point fixed on a central body."
VECTOR_GEOMETRY_TOOL_POINT_TYPE.SATELLITE_COLLECTION_ENTRY.__doc__ = "A point placed at the center of mass of a specified satellite of the satellite collection."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_POINT_TYPE"] = VECTOR_GEOMETRY_TOOL_POINT_TYPE

class CRDN_SYSTEM_TYPE(IntEnum):
    """Represents system types."""
   
    UNKNOWN = -1
    """Unknown or unsupported system type."""
    ASSEMBLED = 0
    """A system assembled from an origin point and a set of reference axes."""
    ON_SURFACE = 1
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."""
    TEMPLATE = 2
    """Represents a VGT system created from a template. This type of system is not creatable."""

CRDN_SYSTEM_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported system type."
CRDN_SYSTEM_TYPE.ASSEMBLED.__doc__ = "A system assembled from an origin point and a set of reference axes."
CRDN_SYSTEM_TYPE.ON_SURFACE.__doc__ = "A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle."
CRDN_SYSTEM_TYPE.TEMPLATE.__doc__ = "Represents a VGT system created from a template. This type of system is not creatable."

agcls.AgTypeNameMap["CRDN_SYSTEM_TYPE"] = CRDN_SYSTEM_TYPE

class VECTOR_GEOMETRY_TOOL_VECTOR_TYPE(IntEnum):
    """Represents vector types."""
   
    UNKNOWN = -1
    """Unknown or unsupported vector type."""
    DISPLACEMENT = 0
    """Vector defined by its start and end points."""
    APOAPSIS = 1
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""
    FIXED_AT_EPOCH = 2
    """Based on another vector fixed at a specified epoch."""
    ANGULAR_VELOCITY = 3
    """Angular velocity vector of one set of axes computed with respect to the reference set."""
    CONING = 4
    """Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."""
    CROSS_PRODUCT = 5
    """The vector cross product of two vectors."""
    CUSTOM_SCRIPT = 6
    """Customized vector components defined with respect to reference axes."""
    DERIVATIVE = 7
    """Derivative of a vector computed with respect to specified axes."""
    ANGLE_RATE = 8
    """Angle rate vector perpendicular to the plane in which the angle is defined."""
    ECCENTRICITY = 9
    """Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""
    FIXED_IN_AXES = 10
    """Vector fixed in reference axes."""
    TWO_PLANES_INTERSECTION = 12
    """Defined along the intersection of two planes."""
    LINE_OF_NODES = 13
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""
    MODEL_ATTACHMENT = 14
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""
    ORBIT_ANGULAR_MOMENTUM = 15
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    ORBIT_NORMAL = 16
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""
    PERIAPSIS = 17
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""
    PROJECTION = 18
    """A projection of a vector computed with respect to a reference plane."""
    REFLECTION = 19
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""
    SCALED = 20
    """Scaled version of the input vector."""
    DIRECTION_TO_STAR = 21
    """Defined with respect to a star object."""
    TEMPLATE = 22
    """Represents a VGT vector created from a template. This type of vector is not creatable."""
    AT_TIME_INSTANT = 23
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""
    LINEAR_COMBINATION = 24
    """Linear combination of two input vectors."""
    PROJECT_ALONG = 25
    """A projection of a source vector in the direction of another vector."""
    SCALAR_LINEAR_COMBINATION = 26
    """Linear combination of two input vectors using scalars."""
    SCALAR_SCALED = 27
    """Scaled version of the input vector using scalar."""
    VELOCITY = 28
    """Velocity vector of a point in a coordinate system."""
    PLUGIN = 29
    """A vector plugin point."""
    ROTATION_VECTOR = 30
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""
    DISPLACEMENT_ON_SURFACE = 31
    """Displacement between origin and destination points using surface distance and altitude difference."""

VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.UNKNOWN.__doc__ = "Unknown or unsupported vector type."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DISPLACEMENT.__doc__ = "Vector defined by its start and end points."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.APOAPSIS.__doc__ = "Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.FIXED_AT_EPOCH.__doc__ = "Based on another vector fixed at a specified epoch."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ANGULAR_VELOCITY.__doc__ = "Angular velocity vector of one set of axes computed with respect to the reference set."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CONING.__doc__ = "Vector created by revolving the Reference vector around the About vector with the specified rate. The vector is aligned with Reference vector at specified epoch. After that it revolves between start/stop angles using either uni- or bi-directional mode."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CROSS_PRODUCT.__doc__ = "The vector cross product of two vectors."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.CUSTOM_SCRIPT.__doc__ = "Customized vector components defined with respect to reference axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DERIVATIVE.__doc__ = "Derivative of a vector computed with respect to specified axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ANGLE_RATE.__doc__ = "Angle rate vector perpendicular to the plane in which the angle is defined."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ECCENTRICITY.__doc__ = "Vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.FIXED_IN_AXES.__doc__ = "Vector fixed in reference axes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.TWO_PLANES_INTERSECTION.__doc__ = "Defined along the intersection of two planes."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.LINE_OF_NODES.__doc__ = "Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.MODEL_ATTACHMENT.__doc__ = "Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ORBIT_ANGULAR_MOMENTUM.__doc__ = "Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ORBIT_NORMAL.__doc__ = "Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PERIAPSIS.__doc__ = "Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PROJECTION.__doc__ = "A projection of a vector computed with respect to a reference plane."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.REFLECTION.__doc__ = "Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALED.__doc__ = "Scaled version of the input vector."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DIRECTION_TO_STAR.__doc__ = "Defined with respect to a star object."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.TEMPLATE.__doc__ = "Represents a VGT vector created from a template. This type of vector is not creatable."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.AT_TIME_INSTANT.__doc__ = "Vector fixed relative to reference axes based on another vector evaluated at specified time instant."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.LINEAR_COMBINATION.__doc__ = "Linear combination of two input vectors."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PROJECT_ALONG.__doc__ = "A projection of a source vector in the direction of another vector."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALAR_LINEAR_COMBINATION.__doc__ = "Linear combination of two input vectors using scalars."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.SCALAR_SCALED.__doc__ = "Scaled version of the input vector using scalar."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.VELOCITY.__doc__ = "Velocity vector of a point in a coordinate system."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.PLUGIN.__doc__ = "A vector plugin point."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.ROTATION_VECTOR.__doc__ = "Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."
VECTOR_GEOMETRY_TOOL_VECTOR_TYPE.DISPLACEMENT_ON_SURFACE.__doc__ = "Displacement between origin and destination points using surface distance and altitude difference."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_TYPE"] = VECTOR_GEOMETRY_TOOL_VECTOR_TYPE

class CRDN_MEAN_ELEMENT_THEORY(IntEnum):
    """Mean element theory types for approximating motion."""
   
    OSCULATING = 1
    """Osculating elements (six standard Keplerian orbital elements)."""
    KOZAI = 2
    """The Kozai-Iszak (KI) mean elements are based upon the paper \"The Motion of a Close earth satellite,\" Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."""
    BROUWER_LYDDANE_LONG = 3
    """Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."""
    BROUWER_LYDDANE_SHORT = 4
    """Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."""

CRDN_MEAN_ELEMENT_THEORY.OSCULATING.__doc__ = "Osculating elements (six standard Keplerian orbital elements)."
CRDN_MEAN_ELEMENT_THEORY.KOZAI.__doc__ = "The Kozai-Iszak (KI) mean elements are based upon the paper ``The Motion of a Close earth satellite,`` Y. Kozai, The Astronomical Journal, Nov 1959, pp.367-377."
CRDN_MEAN_ELEMENT_THEORY.BROUWER_LYDDANE_LONG.__doc__ = "Refers to the BL mean elements considering both the short and long period terms (resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
CRDN_MEAN_ELEMENT_THEORY.BROUWER_LYDDANE_SHORT.__doc__ = "Refers to the BL mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."

agcls.AgTypeNameMap["CRDN_MEAN_ELEMENT_THEORY"] = CRDN_MEAN_ELEMENT_THEORY

class CRDN_DIRECTION_TYPE(IntEnum):
    """Direction options."""
   
    INCOMING_ASYMPTOTE = 1
    """Incoming direction."""
    OUTGOING_ASYMPTOTE = 2
    """Outgoing direction."""

CRDN_DIRECTION_TYPE.INCOMING_ASYMPTOTE.__doc__ = "Incoming direction."
CRDN_DIRECTION_TYPE.OUTGOING_ASYMPTOTE.__doc__ = "Outgoing direction."

agcls.AgTypeNameMap["CRDN_DIRECTION_TYPE"] = CRDN_DIRECTION_TYPE

class CRDN_LAGRANGE_LIBRATION_POINT_TYPE(IntEnum):
    """Types of the Lagrange points, also known as libration points. Lagrange points are points in space where gravitational forces and the orbital motion of a body balance each other."""
   
    L1 = 1
    """A point between the Sun and Earth."""
    L2 = 2
    """Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."""
    L3 = 3
    """L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."""
    L4 = 4
    """The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."""
    L5 = 5
    """The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are \"stable\" points."""

CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L1.__doc__ = "A point between the Sun and Earth."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L2.__doc__ = "Similar to L2, but on the night side of Earth, further away from the Sun, but about the same distane from Earth."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L3.__doc__ = "L3 lies on a line defined by the Sun and Earth, on the opposite side of the Sun, just outside the orbit of Earth. L3 remains hidden behind the Sun at all times."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L4.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."
CRDN_LAGRANGE_LIBRATION_POINT_TYPE.L5.__doc__ = "The L4 and L5 points lie at 60 degrees ahead of and behind Earth in its orbit as seen from the Sun. L4 and L5 are ``stable`` points."

agcls.AgTypeNameMap["CRDN_LAGRANGE_LIBRATION_POINT_TYPE"] = CRDN_LAGRANGE_LIBRATION_POINT_TYPE

class CRDN_QUADRANT_TYPE(IntEnum):
    """Quadrants from a reference system (e.g., XY, XZ, YZ, YX, ZX, ZY)."""
   
    XY = 1
    """XY quadrant."""
    YX = 2
    """YX quadrant."""
    XZ = 3
    """XZ quadrant."""
    ZX = 4
    """ZX quadrant."""
    YZ = 5
    """YZ quadrant."""
    ZY = 6
    """ZY quadrant."""

CRDN_QUADRANT_TYPE.XY.__doc__ = "XY quadrant."
CRDN_QUADRANT_TYPE.YX.__doc__ = "YX quadrant."
CRDN_QUADRANT_TYPE.XZ.__doc__ = "XZ quadrant."
CRDN_QUADRANT_TYPE.ZX.__doc__ = "ZX quadrant."
CRDN_QUADRANT_TYPE.YZ.__doc__ = "YZ quadrant."
CRDN_QUADRANT_TYPE.ZY.__doc__ = "ZY quadrant."

agcls.AgTypeNameMap["CRDN_QUADRANT_TYPE"] = CRDN_QUADRANT_TYPE

class CRDN_TRAJECTORY_AXES_TYPE(IntEnum):
    """Trajectory axes coordinate types."""
   
    ICR = 0
    """Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."""
    VNC = 1
    """Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."""
    RIC = 2
    """Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."""
    LVLH = 3
    """Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."""
    VVLH = 4
    """Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."""
    BBR = 5
    """Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."""
    EQUINOCTIAL = 6
    """Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."""
    NTC = 7
    """Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."""

CRDN_TRAJECTORY_AXES_TYPE.ICR.__doc__ = "Intrack Crosstrack Radial Axes. The Z axis is outward along the position vector (radial); the Y axis is along the cross product of the position and velocity (crosstrack); the X axis is in the direction of motion and constructed as Y x Z (intrack)."
CRDN_TRAJECTORY_AXES_TYPE.VNC.__doc__ = "Velocity - Normal - Co-normal Axes. The X axis is along the velocity vector; the Y axis is along the cross product of the position and velocity (normal); the Z axis is constructed as X x Y (co-normal)."
CRDN_TRAJECTORY_AXES_TYPE.RIC.__doc__ = "Radial Intrack Crosstrack Axes. The X axis is outward along the position vector (radial); the Z axis is along the cross product of the position and velocity (crosstrack); the Y axis is in the direction of motion and is constructed as Z x X (intrack)."
CRDN_TRAJECTORY_AXES_TYPE.LVLH.__doc__ = "Local Vertical, Local Horizontal Axes. The X axis is along the position vector (local vertical); the Z axis is along the cross product of the position and velocity; the Y axis is in the direction of motion and constructed as Z x X (local horizontal)."
CRDN_TRAJECTORY_AXES_TYPE.VVLH.__doc__ = "Vehicle Velocity, Local Horizontal Axes. The Z axis is along the negative position vector; the Y axis is along the negative cross product of the position and velocity (local horizontal); the X axis is constructed as Z x Y (toward velocity)."
CRDN_TRAJECTORY_AXES_TYPE.BBR.__doc__ = "Body-to-body Rotating Axes. The X axis is along the negative position vector; the Z axis is along the cross product of the position and velocity; the Y axis is constructed as Z x X."
CRDN_TRAJECTORY_AXES_TYPE.EQUINOCTIAL.__doc__ = "Equinoctial Axes. The Z axis is along the orbit normal; the X axis is along the fiducial direction located by rotating about Z-axis by negative of RAAN value; the Y axis is constructed as Z x X."
CRDN_TRAJECTORY_AXES_TYPE.NTC.__doc__ = "Normal - Tangential - Crosstrack Axes. The Y axis is along the velocity vector (tangential); the Z axis is along the cross product of the position and velocity (crosstrack); the X axis is constructed as Y x Z (normal)."

agcls.AgTypeNameMap["CRDN_TRAJECTORY_AXES_TYPE"] = CRDN_TRAJECTORY_AXES_TYPE

class CRDN_DISPLAY_AXIS_SELECTOR(IntEnum):
    """Rotation directions."""
   
    X = 0
    """Rotate about Axis X."""
    Y = 1
    """Rotate about Axis Y."""
    Z = 2
    """Rotate about Axis Z."""

CRDN_DISPLAY_AXIS_SELECTOR.X.__doc__ = "Rotate about Axis X."
CRDN_DISPLAY_AXIS_SELECTOR.Y.__doc__ = "Rotate about Axis Y."
CRDN_DISPLAY_AXIS_SELECTOR.Z.__doc__ = "Rotate about Axis Z."

agcls.AgTypeNameMap["CRDN_DISPLAY_AXIS_SELECTOR"] = CRDN_DISPLAY_AXIS_SELECTOR

class CRDN_SIGNED_ANGLE_TYPE(IntEnum):
    """Defines options for computing an angle."""
   
    NONE = 0
    """Choose the option to use unsigned angle."""
    POSITIVE = 1
    """Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."""
    NEGATIVE = 2
    """Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."""

CRDN_SIGNED_ANGLE_TYPE.NONE.__doc__ = "Choose the option to use unsigned angle."
CRDN_SIGNED_ANGLE_TYPE.POSITIVE.__doc__ = "Choose the option to measure angles as positive when the reference Vector is directed toward the plane's normal."
CRDN_SIGNED_ANGLE_TYPE.NEGATIVE.__doc__ = "Choose the option to measure angles as negative when the reference Vector is directed toward the plane's normal."

agcls.AgTypeNameMap["CRDN_SIGNED_ANGLE_TYPE"] = CRDN_SIGNED_ANGLE_TYPE

class VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE(IntEnum):
    """B-Plane point types."""
   
    ASYMPTOTE = 1
    """Asymptote."""
    A_TWO_BODY = 2
    """Two body."""

VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE.ASYMPTOTE.__doc__ = "Asymptote."
VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE.A_TWO_BODY.__doc__ = "Two body."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE"] = VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE

class CRDN_REFERENCE_SHAPE_TYPE(IntEnum):
    """Surface shape types."""
   
    ELLIPSOID = 1
    """An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."""
    TERRAIN = 2
    """Terrain as the terrain reference."""
    MSL = 3
    """Mean Sea Level as the terrain reference."""

CRDN_REFERENCE_SHAPE_TYPE.ELLIPSOID.__doc__ = "An ellipsoid reference shape as defined by the central body (by default, it is WSG84)."
CRDN_REFERENCE_SHAPE_TYPE.TERRAIN.__doc__ = "Terrain as the terrain reference."
CRDN_REFERENCE_SHAPE_TYPE.MSL.__doc__ = "Mean Sea Level as the terrain reference."

agcls.AgTypeNameMap["CRDN_REFERENCE_SHAPE_TYPE"] = CRDN_REFERENCE_SHAPE_TYPE

class CRDN_SURFACE_TYPE(IntEnum):
    """Surface types."""
   
    DETIC = 1
    """Detic surface model."""
    CENTRIC = 2
    """Centric surface model."""

CRDN_SURFACE_TYPE.DETIC.__doc__ = "Detic surface model."
CRDN_SURFACE_TYPE.CENTRIC.__doc__ = "Centric surface model."

agcls.AgTypeNameMap["CRDN_SURFACE_TYPE"] = CRDN_SURFACE_TYPE

class CRDN_SWEEP_MODE(IntEnum):
    """The rotation sweeping modes."""
   
    BIDIRECTIONAL = 1
    """Bidirectional sweeping mode."""
    UNIDIRECTIONAL = 2
    """Unidirectional sweeping mode."""

CRDN_SWEEP_MODE.BIDIRECTIONAL.__doc__ = "Bidirectional sweeping mode."
CRDN_SWEEP_MODE.UNIDIRECTIONAL.__doc__ = "Unidirectional sweeping mode."

agcls.AgTypeNameMap["CRDN_SWEEP_MODE"] = CRDN_SWEEP_MODE

class CRDN_SIGNAL_SENSE(IntEnum):
    """Signal sense transmission options."""
   
    RECEIVE = 1
    """Signal receive."""
    TRANSMIT = 2
    """Signal transmit."""

CRDN_SIGNAL_SENSE.RECEIVE.__doc__ = "Signal receive."
CRDN_SIGNAL_SENSE.TRANSMIT.__doc__ = "Signal transmit."

agcls.AgTypeNameMap["CRDN_SIGNAL_SENSE"] = CRDN_SIGNAL_SENSE

class CRDN_INTERSECTION_SURFACE(IntEnum):
    """Intersection surface flags."""
   
    AT_CENTRAL_BODY_ELLIPSOID = 0
    """Intersection with central body ellipsoid."""
    AT_ALTITUDE_ABOVE_ELLIPSOID = 1
    """Intersection at altitude."""
    AT_TERRAIN = 2
    """Use terrain as intersection surface."""

CRDN_INTERSECTION_SURFACE.AT_CENTRAL_BODY_ELLIPSOID.__doc__ = "Intersection with central body ellipsoid."
CRDN_INTERSECTION_SURFACE.AT_ALTITUDE_ABOVE_ELLIPSOID.__doc__ = "Intersection at altitude."
CRDN_INTERSECTION_SURFACE.AT_TERRAIN.__doc__ = "Use terrain as intersection surface."

agcls.AgTypeNameMap["CRDN_INTERSECTION_SURFACE"] = CRDN_INTERSECTION_SURFACE

class VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE(IntEnum):
    """Dimension inheritance constants used to configure the dimension inheritance of a vector scaled by a scalar."""
   
    NONE = 0
    """Do not inherit dimension."""
    FROM_SCALAR = 1
    """Inherit dimension from scalar."""
    FROM_VECTOR = 2
    """Inherit dimension from vector."""

VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.NONE.__doc__ = "Do not inherit dimension."
VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.FROM_SCALAR.__doc__ = "Inherit dimension from scalar."
VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE.FROM_VECTOR.__doc__ = "Inherit dimension from vector."

agcls.AgTypeNameMap["VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE"] = VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE


class ITimeToolIntervalCollection(object):
    """The interface represents a collection of intervals."""

    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DAE5D702-43F1-4544-8039-97E746D019AB}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolIntervalCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolIntervalCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolIntervalCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(ITimeToolIntervalCollection._metadata, ITimeToolIntervalCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "TimeToolInterval":
        """Return an interval at a specified index."""
        return self._intf.invoke(ITimeToolIntervalCollection._metadata, ITimeToolIntervalCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolIntervalCollection._metadata, ITimeToolIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{DAE5D702-43F1-4544-8039-97E746D019AB}", ITimeToolIntervalCollection)
agcls.AgTypeNameMap["ITimeToolIntervalCollection"] = ITimeToolIntervalCollection

class ITimeToolInterval(object):
    """The interface represents an interval."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A5031BC-45C0-4E75-9190-31F1802C173D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start" : 1,
                             "get_stop" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolInterval)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolInterval)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolInterval, None)
    
    _get_start_metadata = { "name" : "start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start(self) -> typing.Any:
        """The interval's start time."""
        return self._intf.get_property(ITimeToolInterval._metadata, ITimeToolInterval._get_start_metadata)

    _get_stop_metadata = { "name" : "stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop(self) -> typing.Any:
        """The interval's stop time."""
        return self._intf.get_property(ITimeToolInterval._metadata, ITimeToolInterval._get_stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{4A5031BC-45C0-4E75-9190-31F1802C173D}", ITimeToolInterval)
agcls.AgTypeNameMap["ITimeToolInterval"] = ITimeToolInterval

class IVectorGeometryToolPoint(object):
    """The interface defines methods and properties common to all points."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{086D1AA7-D85D-402D-9347-0B51EB552537}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "locate_in_system_with_rate" : 2,
                             "locate_in_system" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPoint)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPoint)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPoint, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_POINT_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_POINT_TYPE":
        """Return a type of the point object."""
        return self._intf.get_property(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._get_type_metadata)

    _locate_in_system_with_rate_metadata = { "name" : "locate_in_system_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_out_arg,) }
    def locate_in_system_with_rate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult":
        """Locates the point's position and velocity in a specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._locate_in_system_with_rate_metadata, epoch, system, out_arg())

    _locate_in_system_metadata = { "name" : "locate_in_system",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_out_arg,) }
    def locate_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "AnalysisWorkbenchMethodCallPointLocateInSystemResult":
        """Locates the point's position in a specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPoint._metadata, IVectorGeometryToolPoint._locate_in_system_metadata, epoch, system, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{086D1AA7-D85D-402D-9347-0B51EB552537}", IVectorGeometryToolPoint)
agcls.AgTypeNameMap["IVectorGeometryToolPoint"] = IVectorGeometryToolPoint

class IVectorGeometryToolVector(object):
    """The interface defines methods and properties common to all vectors."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_in_axes" : 2,
                             "find_in_axes_with_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVector, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_TYPE":
        """Return a type of the vector object."""
        return self._intf.get_property(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._get_type_metadata)

    _find_in_axes_metadata = { "name" : "find_in_axes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallVectorFindInAxesResult":
        """Compute the vector in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._find_in_axes_metadata, epoch, axes, out_arg())

    _find_in_axes_with_rate_metadata = { "name" : "find_in_axes_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult":
        """Compute the vector and its rate in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolVector._metadata, IVectorGeometryToolVector._find_in_axes_with_rate_metadata, epoch, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{79DDC17E-EDA2-454F-96A4-B4CC8AADB470}", IVectorGeometryToolVector)
agcls.AgTypeNameMap["IVectorGeometryToolVector"] = IVectorGeometryToolVector

class IVectorGeometryToolSystem(object):
    """The interface contains methods and properties shared by all VGT systems."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{14687421-5E90-4275-9DE5-21295EC14F65}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_in_system" : 2,
                             "transform" : 3,
                             "transform_with_rate" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystem)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystem)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystem, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SYSTEM_TYPE),) }
    @property
    def type(self) -> "CRDN_SYSTEM_TYPE":
        """Return a type of the system object."""
        return self._intf.get_property(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._get_type_metadata)

    _find_in_system_metadata = { "name" : "find_in_system",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_out_arg,) }
    def find_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "AnalysisWorkbenchMethodCallSystemFindInSystemResult":
        """Find position, velocity, rate and orientation using the specified system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._find_in_system_metadata, epoch, system, out_arg())

    _transform_metadata = { "name" : "transform",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def transform(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector") -> "AnalysisWorkbenchMethodCallSystemTransformResult":
        """Translate the position vector from this system into the output system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._transform_metadata, epoch, outputSystem, positionInMySystem, out_arg())

    _transform_with_rate_metadata = { "name" : "transform_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def transform_with_rate(self, epoch:typing.Any, outputSystem:"IVectorGeometryToolSystem", positionInMySystem:"ICartesian3Vector", velocityInMySystem:"ICartesian3Vector") -> "AnalysisWorkbenchMethodCallSystemTransformWithRateResult":
        """Translate the position and rate vectors from this system into the output system."""
        return self._intf.invoke(IVectorGeometryToolSystem._metadata, IVectorGeometryToolSystem._transform_with_rate_metadata, epoch, outputSystem, positionInMySystem, velocityInMySystem, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{14687421-5E90-4275-9DE5-21295EC14F65}", IVectorGeometryToolSystem)
agcls.AgTypeNameMap["IVectorGeometryToolSystem"] = IVectorGeometryToolSystem

class IVectorGeometryToolAxes(object):
    """The interface defines methods and properties common to all axes."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EE2FCF98-9315-406A-835C-40C56428C888}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_in_axes_with_rate" : 2,
                             "find_in_axes" : 3,
                             "get_labels" : 4,
                             "get_x" : 5,
                             "get_y" : 6,
                             "get_z" : 7,
                             "transform" : 8,
                             "transform_with_rate" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxes, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_AXES_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_AXES_TYPE":
        """Return a type of the axes object."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_type_metadata)

    _find_in_axes_with_rate_metadata = { "name" : "find_in_axes_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult":
        """Find an angular velocity and orientation in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._find_in_axes_with_rate_metadata, epoch, axes, out_arg())

    _find_in_axes_metadata = { "name" : "find_in_axes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallAxesFindInAxesResult":
        """Find an orientation in the specified axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._find_in_axes_metadata, epoch, axes, out_arg())

    _get_labels_metadata = { "name" : "labels",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def labels(self) -> "VectorGeometryToolAxesLabels":
        """Return an object that allows modifying the axes labels."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_labels_metadata)

    _get_x_metadata = { "name" : "x",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x(self) -> "IVectorGeometryToolVector":
        """Return the X axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_x_metadata)

    _get_y_metadata = { "name" : "y",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y(self) -> "IVectorGeometryToolVector":
        """Return the Y axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_y_metadata)

    _get_z_metadata = { "name" : "z",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def z(self) -> "IVectorGeometryToolVector":
        """Return the Z axis of the component."""
        return self._intf.get_property(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._get_z_metadata)

    _transform_metadata = { "name" : "transform",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def transform(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector") -> "AnalysisWorkbenchMethodCallAxesTransformResult":
        """Transform the input vector from this axes into the output axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._transform_metadata, epoch, outputAxes, vectorInMyAxes, out_arg())

    _transform_with_rate_metadata = { "name" : "transform_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_in_arg("ICartesian3Vector"), agmarshall.AgInterface_out_arg,) }
    def transform_with_rate(self, epoch:typing.Any, outputAxes:"IVectorGeometryToolAxes", vectorInMyAxes:"ICartesian3Vector", rateInMyAxes:"ICartesian3Vector") -> "AnalysisWorkbenchMethodCallAxesTransformWithRateResult":
        """Transform the input vector and vector's rate from this axes into the output axes."""
        return self._intf.invoke(IVectorGeometryToolAxes._metadata, IVectorGeometryToolAxes._transform_with_rate_metadata, epoch, outputAxes, vectorInMyAxes, rateInMyAxes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EE2FCF98-9315-406A-835C-40C56428C888}", IVectorGeometryToolAxes)
agcls.AgTypeNameMap["IVectorGeometryToolAxes"] = IVectorGeometryToolAxes

class IVectorGeometryToolAngle(object):
    """The interface defines methods and properties common to all angles."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_angle" : 2,
                             "find_angle_with_rate" : 3,
                             "find_coordinates" : 4,
                             "find_coordinates_with_rate" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngle)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngle)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngle, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_ANGLE_TYPE":
        """Return a type of the angle object."""
        return self._intf.get_property(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._get_type_metadata)

    _find_angle_metadata = { "name" : "find_angle",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def find_angle(self, epoch:typing.Any) -> "AnalysisWorkbenchMethodCallAngleFindAngleResult":
        """Find an angle at the specified epoch."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_angle_metadata, epoch, out_arg())

    _find_angle_with_rate_metadata = { "name" : "find_angle_with_rate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def find_angle_with_rate(self, epoch:typing.Any) -> "AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult":
        """Find an angle and angle rate."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_angle_with_rate_metadata, epoch, out_arg())

    _find_coordinates_metadata = { "name" : "find_coordinates",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_coordinates(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallAngleFindResult":
        """Find the angle value and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_coordinates_metadata, epoch, axes, out_arg())

    _find_coordinates_with_rate_metadata = { "name" : "find_coordinates_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_coordinates_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallAngleFindWithRateResult":
        """Find the angle value, the angle rate and three vectors that define the angle in a specified input axes."""
        return self._intf.invoke(IVectorGeometryToolAngle._metadata, IVectorGeometryToolAngle._find_coordinates_with_rate_metadata, epoch, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C826DABC-B4B0-4D63-8DE4-E6EBB60A1D2D}", IVectorGeometryToolAngle)
agcls.AgTypeNameMap["IVectorGeometryToolAngle"] = IVectorGeometryToolAngle

class IVectorGeometryToolPlane(object):
    """The interface defines methods and properties common to all VGT planes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_in_axes" : 2,
                             "find_in_axes_with_rate" : 3,
                             "find_in_system" : 4,
                             "find_in_system_with_rate" : 5,
                             "get_labels" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlane)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlane)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlane, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE),) }
    @property
    def type(self) -> "VECTOR_GEOMETRY_TOOL_PLANE_TYPE":
        """Return a type of the plane object."""
        return self._intf.get_property(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._get_type_metadata)

    _find_in_axes_metadata = { "name" : "find_in_axes",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallPlaneFindInAxesResult":
        """Compute the plane's axes vectors in a specified reference axes."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_axes_metadata, epoch, axes, out_arg())

    _find_in_axes_with_rate_metadata = { "name" : "find_in_axes_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def find_in_axes_with_rate(self, epoch:typing.Any, axes:"IVectorGeometryToolAxes") -> "AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult":
        """Compute the plane's axes vectors and their rates in a specified reference axes."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_axes_with_rate_metadata, epoch, axes, out_arg())

    _find_in_system_metadata = { "name" : "find_in_system",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_out_arg,) }
    def find_in_system(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "AnalysisWorkbenchMethodCallPlaneFindInSystemResult":
        """Compute the position and X and Y axes in the specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_system_metadata, epoch, system, out_arg())

    _find_in_system_with_rate_metadata = { "name" : "find_in_system_with_rate",
            "arg_types" : (agcom.VARIANT, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.AgInterface_out_arg,) }
    def find_in_system_with_rate(self, epoch:typing.Any, system:"IVectorGeometryToolSystem") -> "AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult":
        """Compute the position, X and Y axes and their rates of change in the specified coordinate system."""
        return self._intf.invoke(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._find_in_system_with_rate_metadata, epoch, system, out_arg())

    _get_labels_metadata = { "name" : "labels",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def labels(self) -> "VectorGeometryToolPlaneLabels":
        """Allow configuring the plane's X and Y axes labels."""
        return self._intf.get_property(IVectorGeometryToolPlane._metadata, IVectorGeometryToolPlane._get_labels_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6AA11A5E-EBAC-4087-9362-1E4F2738B1CE}", IVectorGeometryToolPlane)
agcls.AgTypeNameMap["IVectorGeometryToolPlane"] = IVectorGeometryToolPlane

class IAnalysisWorkbenchContext(object):
    """The interface represents a context associated with a VGT component. All VGT components are associated with a valid context. A context can represent a VGT instance or a VGT template."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1003D700-A64E-438C-954A-AD3AA9EA9773}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_template" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchContext)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchContext)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchContext, None)
    
    _get_is_template_metadata = { "name" : "is_template",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_template(self) -> bool:
        """Return whether the current instance is a VGT template."""
        return self._intf.get_property(IAnalysisWorkbenchContext._metadata, IAnalysisWorkbenchContext._get_is_template_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1003D700-A64E-438C-954A-AD3AA9EA9773}", IAnalysisWorkbenchContext)
agcls.AgTypeNameMap["IAnalysisWorkbenchContext"] = IAnalysisWorkbenchContext

class IAnalysisWorkbenchComponent(object):
    """A base interface implemented by all VGT components. The methods and properties of the interface provide type information about the VGT component."""

    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_kind" : 1,
                             "get_category" : 2,
                             "set_category" : 3,
                             "get_name" : 4,
                             "get_description" : 5,
                             "get_path" : 6,
                             "get_is_duplicable" : 7,
                             "get_context" : 8,
                             "get_type_info" : 9,
                             "get_qualified_path" : 10,
                             "get_is_valid" : 11,
                             "get_is_ready" : 12,
                             "get_is_read_only" : 13,
                             "duplicate" : 14,
                             "anonymous_duplicate" : 15,
                             "depends_on" : 16,
                             "get_embedded_components" : 17,
                             "export" : 18,
                             "rename" : 19, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchComponent)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchComponent)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchComponent, None)
    
    _get_kind_metadata = { "name" : "kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_KIND),) }
    @property
    def kind(self) -> "CRDN_KIND":
        """Return the component kind."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_kind_metadata)

    _get_category_metadata = { "name" : "category",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def category(self) -> str:
        """Allow the user to access or change the component category (Folder)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_category_metadata)

    _set_category_metadata = { "name" : "category",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @category.setter
    def category(self, category:str) -> None:
        return self._intf.set_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._set_category_metadata, category)

    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """Return the component name."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_name_metadata)

    _get_description_metadata = { "name" : "description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def description(self) -> str:
        """Return the component description."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_description_metadata)

    _get_path_metadata = { "name" : "path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def path(self) -> str:
        """Return the component's fully qualified path (ie. ``CentralBody/Earth Body``, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_path_metadata)

    _get_is_duplicable_metadata = { "name" : "is_duplicable",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_duplicable(self) -> bool:
        """Return whether the VGT component can be duplicated."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_duplicable_metadata)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return the context object associated with the instance. The returned object is either an instance of AnalysisWorkbenchInstance or IAnalysisWorkbenchComponentTemplate interface."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_context_metadata)

    _get_type_info_metadata = { "name" : "type_info",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def type_info(self) -> "AnalysisWorkbenchTypeInfo":
        """Return the component type information."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_type_info_metadata)

    _get_qualified_path_metadata = { "name" : "qualified_path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def qualified_path(self) -> str:
        """An STK-conformant path to the VGT component that can be used to visualize the VGT components in 3D (i.e. ``CentralBody/Earth Body Vector``, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_qualified_path_metadata)

    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Return whether the component is valid."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_valid_metadata)

    _get_is_ready_metadata = { "name" : "is_ready",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_ready(self) -> bool:
        """Return whether the component is ready. The component is ready if it's been fully initialized."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_ready_metadata)

    _get_is_read_only_metadata = { "name" : "is_read_only",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_read_only(self) -> bool:
        """Return whether the component is modifiable."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_is_read_only_metadata)

    _duplicate_metadata = { "name" : "duplicate",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def duplicate(self, newName:str, description:str) -> "IAnalysisWorkbenchComponent":
        """Create a copy of the instance of a VGT component. The new component is automatically registered and will be persisted or restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._duplicate_metadata, newName, description, out_arg())

    _anonymous_duplicate_metadata = { "name" : "anonymous_duplicate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def anonymous_duplicate(self) -> "IAnalysisWorkbenchComponent":
        """Create an anonymous copy of the instance of a VGT component. The new component is not registered and will not be persisted nor restored when a scenario is saved or loaded."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._anonymous_duplicate_metadata, out_arg())

    _depends_on_metadata = { "name" : "depends_on",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchComponent"), agmarshall.VARIANT_BOOL_arg,) }
    def depends_on(self, component:"IAnalysisWorkbenchComponent") -> bool:
        """Test if the instance depends on another component."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._depends_on_metadata, component, out_arg())

    _get_embedded_components_metadata = { "name" : "embedded_components",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def embedded_components(self) -> "AnalysisWorkbenchCollection":
        """Return a collection of embedded components."""
        return self._intf.get_property(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._get_embedded_components_metadata)

    _export_metadata = { "name" : "export",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def export(self, filename:str, comments:str) -> None:
        """Export the component to a file."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._export_metadata, filename, comments)

    _rename_metadata = { "name" : "rename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def rename(self, newName:str) -> None:
        """Rename the component."""
        return self._intf.invoke(IAnalysisWorkbenchComponent._metadata, IAnalysisWorkbenchComponent._rename_metadata, newName)


agcls.AgClassCatalog.add_catalog_entry("{5FBDAC10-66FA-4EA2-9F9E-B5D6C0BA3281}", IAnalysisWorkbenchComponent)
agcls.AgTypeNameMap["IAnalysisWorkbenchComponent"] = IAnalysisWorkbenchComponent

class ICalculationToolEvaluateResult(object):
    """Represents the results of evaluating a scalar component using ICalculationToolScalar.Evaluate method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_value" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolEvaluateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolEvaluateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolEvaluateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ICalculationToolEvaluateResult._metadata, ICalculationToolEvaluateResult._get_is_valid_metadata)

    _get_value_metadata = { "name" : "value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def value(self) -> float:
        """The scalar value."""
        return self._intf.get_property(ICalculationToolEvaluateResult._metadata, ICalculationToolEvaluateResult._get_value_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6021FC44-7BB4-4DE9-A8C4-1630AB2A7F52}", ICalculationToolEvaluateResult)
agcls.AgTypeNameMap["ICalculationToolEvaluateResult"] = ICalculationToolEvaluateResult

class ICalculationToolEvaluateWithRateResult(object):
    """Represents the results of evaluating a scalar component using ICalculationToolScalar.Evaluate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E9B2DA30-1317-43E2-8D47-9D675A28F748}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_value" : 2,
                             "get_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolEvaluateWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolEvaluateWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolEvaluateWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ICalculationToolEvaluateWithRateResult._metadata, ICalculationToolEvaluateWithRateResult._get_is_valid_metadata)

    _get_value_metadata = { "name" : "value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def value(self) -> float:
        """Computed scalar value."""
        return self._intf.get_property(ICalculationToolEvaluateWithRateResult._metadata, ICalculationToolEvaluateWithRateResult._get_value_metadata)

    _get_rate_metadata = { "name" : "rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rate(self) -> float:
        """A rate of change of the computed scalar value."""
        return self._intf.get_property(ICalculationToolEvaluateWithRateResult._metadata, ICalculationToolEvaluateWithRateResult._get_rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E9B2DA30-1317-43E2-8D47-9D675A28F748}", ICalculationToolEvaluateWithRateResult)
agcls.AgTypeNameMap["ICalculationToolEvaluateWithRateResult"] = ICalculationToolEvaluateWithRateResult

class ITimeToolEventIntervalResult(object):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_interval" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolEventIntervalResult._metadata, ITimeToolEventIntervalResult._get_is_valid_metadata)

    _get_interval_metadata = { "name" : "interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interval(self) -> "TimeToolInterval":
        """An interval."""
        return self._intf.get_property(ITimeToolEventIntervalResult._metadata, ITimeToolEventIntervalResult._get_interval_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EB80DC8E-368B-41DE-B2B6-E37041B45AAF}", ITimeToolEventIntervalResult)
agcls.AgTypeNameMap["ITimeToolEventIntervalResult"] = ITimeToolEventIntervalResult

class ITimeToolEventFindOccurrenceResult(object):
    """Contains the results returned with ITimeToolEvent.FindOccurrence method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{20F964F0-8466-415E-9344-D6FBA53AF8B0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_epoch" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventFindOccurrenceResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventFindOccurrenceResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventFindOccurrenceResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolEventFindOccurrenceResult._metadata, ITimeToolEventFindOccurrenceResult._get_is_valid_metadata)

    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """The epoch at which the event occurs."""
        return self._intf.get_property(ITimeToolEventFindOccurrenceResult._metadata, ITimeToolEventFindOccurrenceResult._get_epoch_metadata)


agcls.AgClassCatalog.add_catalog_entry("{20F964F0-8466-415E-9344-D6FBA53AF8B0}", ITimeToolEventFindOccurrenceResult)
agcls.AgTypeNameMap["ITimeToolEventFindOccurrenceResult"] = ITimeToolEventFindOccurrenceResult

class ITimeToolFindTimesResult(object):
    """Return a collection of intervals and an array of times."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F7B644F0-0728-434D-8C86-C6267B625860}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_intervals" : 2,
                             "get_start" : 3,
                             "get_stop" : 4,
                             "get_times" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolFindTimesResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolFindTimesResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolFindTimesResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolFindTimesResult._metadata, ITimeToolFindTimesResult._get_is_valid_metadata)

    _get_intervals_metadata = { "name" : "intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def intervals(self) -> "TimeToolIntervalCollection":
        """A collection of found intervals."""
        return self._intf.get_property(ITimeToolFindTimesResult._metadata, ITimeToolFindTimesResult._get_intervals_metadata)

    _get_start_metadata = { "name" : "start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the entire interval span."""
        return self._intf.get_property(ITimeToolFindTimesResult._metadata, ITimeToolFindTimesResult._get_start_metadata)

    _get_stop_metadata = { "name" : "stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the entire interval span."""
        return self._intf.get_property(ITimeToolFindTimesResult._metadata, ITimeToolFindTimesResult._get_stop_metadata)

    _get_times_metadata = { "name" : "times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def times(self) -> list:
        """An array of found times."""
        return self._intf.get_property(ITimeToolFindTimesResult._metadata, ITimeToolFindTimesResult._get_times_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F7B644F0-0728-434D-8C86-C6267B625860}", ITimeToolFindTimesResult)
agcls.AgTypeNameMap["ITimeToolFindTimesResult"] = ITimeToolFindTimesResult

class ITimeToolIntervalsVectorResult(object):
    """Contains the results returned with ITimeToolEventIntervalCollection.FindIntervalCollection method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{87F76F41-61FB-4DFF-A76E-25270023BE34}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_interval_collections" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolIntervalsVectorResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolIntervalsVectorResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolIntervalsVectorResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolIntervalsVectorResult._metadata, ITimeToolIntervalsVectorResult._get_is_valid_metadata)

    _get_interval_collections_metadata = { "name" : "interval_collections",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interval_collections(self) -> "TimeToolIntervalVectorCollection":
        """A collection of interval collections."""
        return self._intf.get_property(ITimeToolIntervalsVectorResult._metadata, ITimeToolIntervalsVectorResult._get_interval_collections_metadata)


agcls.AgClassCatalog.add_catalog_entry("{87F76F41-61FB-4DFF-A76E-25270023BE34}", ITimeToolIntervalsVectorResult)
agcls.AgTypeNameMap["ITimeToolIntervalsVectorResult"] = ITimeToolIntervalsVectorResult

class ITimeToolEventIntervalCollectionOccurredResult(object):
    """Contains the results returned with ITimeToolEventIntervalCollection.Occurred method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A829181E-A9CD-452D-AC81-19C2DA96C490}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_index" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionOccurredResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionOccurredResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionOccurredResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionOccurredResult._metadata, ITimeToolEventIntervalCollectionOccurredResult._get_is_valid_metadata)

    _get_index_metadata = { "name" : "index",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def index(self) -> int:
        """Index of an interval in the collection."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionOccurredResult._metadata, ITimeToolEventIntervalCollectionOccurredResult._get_index_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A829181E-A9CD-452D-AC81-19C2DA96C490}", ITimeToolEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionOccurredResult"] = ITimeToolEventIntervalCollectionOccurredResult

class ITimeToolIntervalListResult(object):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D0FDA46F-8B86-4052-8EC7-1448284EABCF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolIntervalListResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolIntervalListResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolIntervalListResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolIntervalListResult._metadata, ITimeToolIntervalListResult._get_is_valid_metadata)

    _get_intervals_metadata = { "name" : "intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def intervals(self) -> "TimeToolIntervalCollection":
        """A list of intervals."""
        return self._intf.get_property(ITimeToolIntervalListResult._metadata, ITimeToolIntervalListResult._get_intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D0FDA46F-8B86-4052-8EC7-1448284EABCF}", ITimeToolIntervalListResult)
agcls.AgTypeNameMap["ITimeToolIntervalListResult"] = ITimeToolIntervalListResult

class ITimeToolIntervalVectorCollection(object):
    """A collection of interval collections."""

    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolIntervalVectorCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolIntervalVectorCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolIntervalVectorCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolIntervalCollection":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(ITimeToolIntervalVectorCollection._metadata, ITimeToolIntervalVectorCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "TimeToolIntervalCollection":
        """Access an element at the specified position."""
        return self._intf.invoke(ITimeToolIntervalVectorCollection._metadata, ITimeToolIntervalVectorCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolIntervalVectorCollection._metadata, ITimeToolIntervalVectorCollection._get__NewEnum_metadata)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{A327DA61-FFA8-4D5E-AEC6-88231B093FF8}", ITimeToolIntervalVectorCollection)
agcls.AgTypeNameMap["ITimeToolIntervalVectorCollection"] = ITimeToolIntervalVectorCollection

class ITimeToolEventGroup(object):
    """Access or create VGT events associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEvent":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ITimeToolEventGroup._metadata, ITimeToolEventGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ITimeToolEventGroup._metadata, ITimeToolEventGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "TimeToolEventFactory":
        """Return a Factory object used to create custom events."""
        return self._intf.get_property(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEvent":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ITimeToolEventGroup._metadata, ITimeToolEventGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEvent":
        """Retrieve an event from the collection by index."""
        return self._intf.invoke(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEvent":
        """Retrieve an event from the collection by name."""
        return self._intf.invoke(ITimeToolEventGroup._metadata, ITimeToolEventGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{3D5A156F-70B5-4FB4-A441-5B7E0BA6AEBD}", ITimeToolEventGroup)
agcls.AgTypeNameMap["ITimeToolEventGroup"] = ITimeToolEventGroup

class ITimeToolEventIntervalGroup(object):
    """Access or create VGT event intervals associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventIntervalName:str) -> None:
        """Remove an element by name."""
        return self._intf.invoke(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._remove_metadata, eventIntervalName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalFactory":
        """Return a Factory object used to create custom event intervals."""
        return self._intf.get_property(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventInterval":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventInterval":
        """Retrieve an event interval from the collection by index."""
        return self._intf.invoke(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventInterval":
        """Retrieve an event interval from the collection by name."""
        return self._intf.invoke(ITimeToolEventIntervalGroup._metadata, ITimeToolEventIntervalGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{61E294E9-54F9-475F-ADBB-5D3A0D4CCBA5}", ITimeToolEventIntervalGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalGroup"] = ITimeToolEventIntervalGroup

class ITimeToolEventIntervalListGroup(object):
    """Access or create VGT event interval lists associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{E5721039-AE57-448A-9891-048ECB8BDC63}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalList":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalListFactory":
        """Return a factory object used to create custom event interval lists."""
        return self._intf.get_property(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalList":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventIntervalList":
        """Retrieve an event interval list from the collection by index."""
        return self._intf.invoke(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventIntervalList":
        """Retrieve an event interval list from the collection by name."""
        return self._intf.invoke(ITimeToolEventIntervalListGroup._metadata, ITimeToolEventIntervalListGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{E5721039-AE57-448A-9891-048ECB8BDC63}", ITimeToolEventIntervalListGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalListGroup"] = ITimeToolEventIntervalListGroup

class ITimeToolEventArrayGroup(object):
    """Access or create VGT event arrays associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{37A14DB3-3A49-4A6B-B238-922B59737548}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventArray":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "TimeToolEventArrayFactory":
        """Return a Factory object used to create event arrays."""
        return self._intf.get_property(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventArray":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventArray":
        """Retrieve an event array from the collection by index."""
        return self._intf.invoke(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventArray":
        """Retrieve an event array from the collection by name."""
        return self._intf.invoke(ITimeToolEventArrayGroup._metadata, ITimeToolEventArrayGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{37A14DB3-3A49-4A6B-B238-922B59737548}", ITimeToolEventArrayGroup)
agcls.AgTypeNameMap["ITimeToolEventArrayGroup"] = ITimeToolEventArrayGroup

class ICalculationToolScalarGroup(object):
    """Access or create VGT calculation scalars associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolScalar":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "CalculationToolScalarFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolScalar":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolScalar":
        """Retrieve an element from the collection by index."""
        return self._intf.invoke(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolScalar":
        """Retrieve an element from the collection by name."""
        return self._intf.invoke(ICalculationToolScalarGroup._metadata, ICalculationToolScalarGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{9A0EDFAF-E242-40AA-AC36-EA50449AD7B1}", ICalculationToolScalarGroup)
agcls.AgTypeNameMap["ICalculationToolScalarGroup"] = ICalculationToolScalarGroup

class ITimeToolEventIntervalCollectionGroup(object):
    """Access or create VGT event interval collections associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{0166467D-9328-4E1B-A982-D9B1396A025E}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolEventIntervalCollection":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "TimeToolEventIntervalCollectionFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ITimeToolEventIntervalCollection":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ITimeToolEventIntervalCollection":
        """Retrieve an event interval from the collection by index."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ITimeToolEventIntervalCollection":
        """Retrieve an event interval from the collection by name."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionGroup._metadata, ITimeToolEventIntervalCollectionGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{0166467D-9328-4E1B-A982-D9B1396A025E}", ITimeToolEventIntervalCollectionGroup)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionGroup"] = ITimeToolEventIntervalCollectionGroup

class ICalculationToolParameterSetGroup(object):
    """Access or create VGT parameter sets associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolParameterSet":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "CalculationToolParameterSetFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolParameterSet":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolParameterSet":
        """Retrieve an element from the collection by index."""
        return self._intf.invoke(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolParameterSet":
        """Retrieve an element from the collection by name."""
        return self._intf.invoke(ICalculationToolParameterSetGroup._metadata, ICalculationToolParameterSetGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{DCEC1D09-0F8F-4E12-95BB-EC2CD4FDD348}", ICalculationToolParameterSetGroup)
agcls.AgTypeNameMap["ICalculationToolParameterSetGroup"] = ICalculationToolParameterSetGroup

class ICalculationToolConditionGroup(object):
    """Access or create VGT conditions associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolCondition":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "CalculationToolConditionFactory":
        """Return a factory object used to create calc scalar components."""
        return self._intf.get_property(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolCondition":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolCondition":
        """Retrieve a condition from the collection by index."""
        return self._intf.invoke(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolCondition":
        """Retrieve a condition from the collection by name."""
        return self._intf.invoke(ICalculationToolConditionGroup._metadata, ICalculationToolConditionGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{2FDD4ECB-A5E0-4F7B-A16F-2DBDE7C9B3C0}", ICalculationToolConditionGroup)
agcls.AgTypeNameMap["ICalculationToolConditionGroup"] = ICalculationToolConditionGroup

class ICalculationToolConditionSetGroup(object):
    """Allow accessing and creating condition set components."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSetGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSetGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSetGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ICalculationToolConditionSet":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "CalculationToolConditionSetFactory":
        """Return a factory object used to create condition set components."""
        return self._intf.get_property(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ICalculationToolConditionSet":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ICalculationToolConditionSet":
        """Retrieve a condition set from the collection by index."""
        return self._intf.invoke(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ICalculationToolConditionSet":
        """Retrieve a condition set from the collection by name."""
        return self._intf.invoke(ICalculationToolConditionSetGroup._metadata, ICalculationToolConditionSetGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{8E12C9C7-3649-4DE1-A981-5E09DE2F27E6}", ICalculationToolConditionSetGroup)
agcls.AgTypeNameMap["ICalculationToolConditionSetGroup"] = ICalculationToolConditionSetGroup

class ICalculationToolConditionSetEvaluateResult(object):
    """Represents the results returned by ConditionSet.Evaluate."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_values" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSetEvaluateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSetEvaluateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSetEvaluateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ICalculationToolConditionSetEvaluateResult._metadata, ICalculationToolConditionSetEvaluateResult._get_is_valid_metadata)

    _get_values_metadata = { "name" : "values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def values(self) -> list:
        """Computed values."""
        return self._intf.get_property(ICalculationToolConditionSetEvaluateResult._metadata, ICalculationToolConditionSetEvaluateResult._get_values_metadata)


agcls.AgClassCatalog.add_catalog_entry("{33AE2CD0-41E6-4B51-A19C-697AC96A5B32}", ICalculationToolConditionSetEvaluateResult)
agcls.AgTypeNameMap["ICalculationToolConditionSetEvaluateResult"] = ICalculationToolConditionSetEvaluateResult

class ICalculationToolConditionSetEvaluateWithRateResult(object):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{39814D49-3CF5-42B0-A46C-766781F45AB7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_values" : 2,
                             "get_rates" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSetEvaluateWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSetEvaluateWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSetEvaluateWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ICalculationToolConditionSetEvaluateWithRateResult._metadata, ICalculationToolConditionSetEvaluateWithRateResult._get_is_valid_metadata)

    _get_values_metadata = { "name" : "values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def values(self) -> list:
        """Computed values."""
        return self._intf.get_property(ICalculationToolConditionSetEvaluateWithRateResult._metadata, ICalculationToolConditionSetEvaluateWithRateResult._get_values_metadata)

    _get_rates_metadata = { "name" : "rates",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def rates(self) -> list:
        """Computed rates."""
        return self._intf.get_property(ICalculationToolConditionSetEvaluateWithRateResult._metadata, ICalculationToolConditionSetEvaluateWithRateResult._get_rates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{39814D49-3CF5-42B0-A46C-766781F45AB7}", ICalculationToolConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["ICalculationToolConditionSetEvaluateWithRateResult"] = ICalculationToolConditionSetEvaluateWithRateResult

class ISpatialAnalysisToolVolumeGridGroup(object):
    """Access or create VGT volume grids associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeGrid":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeGridFactory":
        """Return a factory object used to create volume grid components."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeGrid":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieve a volume grid from the collection by index."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Retrieve a volume grid from the collection by name."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridGroup._metadata, ISpatialAnalysisToolVolumeGridGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{50F1EDD0-CB76-4E72-8AC3-6E79364D74D0}", ISpatialAnalysisToolVolumeGridGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridGroup"] = ISpatialAnalysisToolVolumeGridGroup

class ISpatialAnalysisToolVolumeGroup(object):
    """Access or create spatial conditions associated with a volume grid."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolume":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeFactory":
        """Return a factory object used to create spatial condition components."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolume":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolume":
        """Retrieve an volume from the collection by index."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolume":
        """Retrieve volume from the collection by name."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGroup._metadata, ISpatialAnalysisToolVolumeGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{FF32CF5A-A31E-46D8-AAEB-7A621A294E0C}", ISpatialAnalysisToolVolumeGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGroup"] = ISpatialAnalysisToolVolumeGroup

class ISpatialAnalysisToolVolumeCalcGroup(object):
    """Access or create VGT volume calcs associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{02991465-35ec-486a-913d-bf204afc9fb6}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ISpatialAnalysisToolVolumeCalc":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, eventName:str) -> None:
        """Remove a specified element."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._remove_metadata, eventName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "SpatialAnalysisToolVolumeCalcFactory":
        """Return a factory object used to create volume calc components."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "ISpatialAnalysisToolVolumeCalc":
        """Return an element by name or at a specified position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieve a volume calculation from the collection by index."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Retrieve a volume calculation from the collection by name."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcGroup._metadata, ISpatialAnalysisToolVolumeCalcGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{02991465-35ec-486a-913d-bf204afc9fb6}", ISpatialAnalysisToolVolumeCalcGroup)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcGroup"] = ISpatialAnalysisToolVolumeCalcGroup

class ICalculationToolScalar(object):
    """Any scalar calculation that is not constant by construction."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{55A75307-E283-4146-A456-732D08E47070}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "evaluate" : 2,
                             "quick_evaluate" : 3,
                             "evaluate_with_rate" : 4,
                             "quick_evaluate_with_rate" : 5,
                             "get_availability" : 6,
                             "get_unit_of_measure" : 7,
                             "quick_evaluate_array" : 8,
                             "quick_evaluate_with_rate_array" : 9,
                             "quick_evaluate_event_array" : 10,
                             "quick_evaluate_with_rate_event_array" : 11, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalar)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalar)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalar, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CALC_SCALAR_TYPE),) }
    @property
    def type(self) -> "CRDN_CALC_SCALAR_TYPE":
        """Return the scalar calculation type."""
        return self._intf.get_property(ICalculationToolScalar._metadata, ICalculationToolScalar._get_type_metadata)

    _evaluate_metadata = { "name" : "evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolEvaluateResult":
        """Evaluate the scalar calculation at the specified time instant."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._evaluate_metadata, epoch, out_arg())

    _quick_evaluate_metadata = { "name" : "quick_evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate(self, epoch:typing.Any) -> list:
        """Evaluate the scalar calculation at the specified time instant and returns the results as an array with two elements, the first element being of boolean type indicating whether the computation succeeded, followed by a double-precision value representing..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_metadata, epoch, out_arg())

    _evaluate_with_rate_metadata = { "name" : "evaluate_with_rate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolEvaluateWithRateResult":
        """Evaluate the scalar calculation at the specified time instant. The result is a scalar value and its rate of change."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._evaluate_with_rate_metadata, epoch, out_arg())

    _quick_evaluate_with_rate_metadata = { "name" : "quick_evaluate_with_rate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate_with_rate(self, epoch:typing.Any) -> list:
        """Evaluate the scalar calculation at the specified time instant and returns the results as an array with three elements, the first element being of boolean type indicating whether the computation succeeded, followed by two double-precision values one rep..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_metadata, epoch, out_arg())

    _get_availability_metadata = { "name" : "get_availability",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_availability(self) -> "TimeToolIntervalCollection":
        """Return a list of availability intervals."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._get_availability_metadata, out_arg())

    _get_unit_of_measure_metadata = { "name" : "unit_of_measure",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def unit_of_measure(self) -> str:
        """Return calc scalar's unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(ICalculationToolScalar._metadata, ICalculationToolScalar._get_unit_of_measure_metadata)

    _quick_evaluate_array_metadata = { "name" : "quick_evaluate_array",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate_array(self, times:list) -> list:
        """Evaluate the scalar calculation, and rate, over an array of times, entered as strings in the Scenario date unit. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_array_metadata, times, out_arg())

    _quick_evaluate_with_rate_array_metadata = { "name" : "quick_evaluate_with_rate_array",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate_with_rate_array(self, times:list) -> list:
        """Evaluate the scalar calculation over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_array_metadata, times, out_arg())

    _quick_evaluate_event_array_metadata = { "name" : "quick_evaluate_event_array",
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"), agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate_event_array(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluate the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_event_array_metadata, refArray, out_arg())

    _quick_evaluate_with_rate_event_array_metadata = { "name" : "quick_evaluate_with_rate_event_array",
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"), agmarshall.LPSAFEARRAY_arg,) }
    def quick_evaluate_with_rate_event_array(self, refArray:"ITimeToolEventArray") -> list:
        """Evaluate the scalar calculation, and rate, over the array of times provided by an Event Array component. It returns an array corresponding to the input times..."""
        return self._intf.invoke(ICalculationToolScalar._metadata, ICalculationToolScalar._quick_evaluate_with_rate_event_array_metadata, refArray, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{55A75307-E283-4146-A456-732D08E47070}", ICalculationToolScalar)
agcls.AgTypeNameMap["ICalculationToolScalar"] = ICalculationToolScalar

class ICalculationToolScalarAngle(object):
    """Scalar equal to angular displacement obtained from any angle in VGT."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{52FB9533-9332-44D2-92B2-8AA2D8633112}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_angle" : 1,
                             "set_input_angle" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarAngle)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarAngle)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarAngle, None)
    
    _get_input_angle_metadata = { "name" : "input_angle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_angle(self) -> "IVectorGeometryToolAngle":
        """The input angle, which is a VGT angle component. Note angle computation in VGT may involve more than just angular displacement value: in VGT angles may be drawn in 3D which requires knowledge and evaluation of supporting vectors."""
        return self._intf.get_property(ICalculationToolScalarAngle._metadata, ICalculationToolScalarAngle._get_input_angle_metadata)

    _set_input_angle_metadata = { "name" : "input_angle",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAngle"),) }
    @input_angle.setter
    def input_angle(self, inputAngle:"IVectorGeometryToolAngle") -> None:
        return self._intf.set_property(ICalculationToolScalarAngle._metadata, ICalculationToolScalarAngle._set_input_angle_metadata, inputAngle)


agcls.AgClassCatalog.add_catalog_entry("{52FB9533-9332-44D2-92B2-8AA2D8633112}", ICalculationToolScalarAngle)
agcls.AgTypeNameMap["ICalculationToolScalarAngle"] = ICalculationToolScalarAngle

class ICalculationToolScalarConstant(object):
    """Constant scalar value of specified dimension."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96A1ABA9-663C-4CCC-A066-0166E285C3C2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_value" : 1,
                             "set_value" : 2,
                             "get_dimension" : 3,
                             "set_dimension" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarConstant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarConstant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarConstant, None)
    
    _get_value_metadata = { "name" : "value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def value(self) -> float:
        """A value which can be in any STK supported unit available for selected dimension."""
        return self._intf.get_property(ICalculationToolScalarConstant._metadata, ICalculationToolScalarConstant._get_value_metadata)

    _set_value_metadata = { "name" : "value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @value.setter
    def value(self, value:float) -> None:
        return self._intf.set_property(ICalculationToolScalarConstant._metadata, ICalculationToolScalarConstant._set_value_metadata, value)

    _get_dimension_metadata = { "name" : "dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def dimension(self) -> str:
        """The dimension of the constant value, this can be any of the STK supported dimensions."""
        return self._intf.get_property(ICalculationToolScalarConstant._metadata, ICalculationToolScalarConstant._get_dimension_metadata)

    _set_dimension_metadata = { "name" : "dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(ICalculationToolScalarConstant._metadata, ICalculationToolScalarConstant._set_dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{96A1ABA9-663C-4CCC-A066-0166E285C3C2}", ICalculationToolScalarConstant)
agcls.AgTypeNameMap["ICalculationToolScalarConstant"] = ICalculationToolScalarConstant

class ICalculationToolScalarCustom(object):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6267B685-4486-4B11-A2CA-056D6A9B558C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2,
                             "reload" : 3,
                             "get_invalidate_on_exec_error" : 4,
                             "set_invalidate_on_exec_error" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarCustom)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarCustom)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarCustom, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """A path to MATLAB (.m or .dll), Perl or VBScript file."""
        return self._intf.get_property(ICalculationToolScalarCustom._metadata, ICalculationToolScalarCustom._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(ICalculationToolScalarCustom._metadata, ICalculationToolScalarCustom._set_filename_metadata, filename)

    _reload_metadata = { "name" : "reload",
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(ICalculationToolScalarCustom._metadata, ICalculationToolScalarCustom._reload_metadata, )

    _get_invalidate_on_exec_error_metadata = { "name" : "invalidate_on_exec_error",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def invalidate_on_exec_error(self) -> bool:
        """Specify InvalidOnExecError flag for a custom scalar."""
        return self._intf.get_property(ICalculationToolScalarCustom._metadata, ICalculationToolScalarCustom._get_invalidate_on_exec_error_metadata)

    _set_invalidate_on_exec_error_metadata = { "name" : "invalidate_on_exec_error",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @invalidate_on_exec_error.setter
    def invalidate_on_exec_error(self, invalidateOnExecError:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarCustom._metadata, ICalculationToolScalarCustom._set_invalidate_on_exec_error_metadata, invalidateOnExecError)


agcls.AgClassCatalog.add_catalog_entry("{6267B685-4486-4B11-A2CA-056D6A9B558C}", ICalculationToolScalarCustom)
agcls.AgTypeNameMap["ICalculationToolScalarCustom"] = ICalculationToolScalarCustom

class ICalculationToolScalarDataElement(object):
    """Any time-dependent data element from STK data providers available for parent STK object."""

    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_data_provider" : 1,
                             "get_element_name" : 2,
                             "get_group" : 3,
                             "get_interpolation" : 4,
                             "set_interpolation" : 5,
                             "get_sampling" : 6,
                             "set_sampling" : 7,
                             "get_use_samples" : 8,
                             "set_use_samples" : 9,
                             "get_save_data_option" : 10,
                             "set_save_data_option" : 11,
                             "set" : 12,
                             "set_with_group" : 13,
                             "get_invalid_data_indicator" : 14,
                             "set_invalid_data_indicator" : 15, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarDataElement)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarDataElement)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarDataElement, None)
    
    _get_data_provider_metadata = { "name" : "data_provider",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def data_provider(self) -> str:
        """The name of the data provider."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_data_provider_metadata)

    _get_element_name_metadata = { "name" : "element_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def element_name(self) -> str:
        """The name of the data element within the data provider."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_element_name_metadata)

    _get_group_metadata = { "name" : "group",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def group(self) -> str:
        """A group name the data element is a part of. If the element is not a part of a group, the property will return an empty string."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_group_metadata)

    _get_interpolation_metadata = { "name" : "interpolation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_interpolation_metadata)

    _set_interpolation_metadata = { "name" : "interpolation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """Relative tolerance uses a combination of relative and absolute changes in scalar values between samples. Curvature tolerance also uses changes in slope between samples."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_sampling_metadata, sampling)

    _get_use_samples_metadata = { "name" : "use_samples",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_samples(self) -> bool:
        """If set to true, selected data provider is presampled over its entire availability span using sampling method specified in Advanced options..."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_use_samples_metadata)

    _set_use_samples_metadata = { "name" : "use_samples",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_samples.setter
    def use_samples(self, useSamples:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_use_samples_metadata, useSamples)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed samples are saved/loaded, otherwise if using samples they are recomputed on load."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_save_data_option_metadata, saveDataOption)

    _set_metadata = { "name" : "set",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set(self, dataProvider:str, elementName:str) -> None:
        """Set the data provider and the element name."""
        return self._intf.invoke(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_metadata, dataProvider, elementName)

    _set_with_group_metadata = { "name" : "set_with_group",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_with_group(self, dataProvider:str, typeName:str, elementName:str) -> None:
        """Set the data provider name, the element name, and data provider type name."""
        return self._intf.invoke(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_with_group_metadata, dataProvider, typeName, elementName)

    _get_invalid_data_indicator_metadata = { "name" : "invalid_data_indicator",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def invalid_data_indicator(self) -> float:
        """Set the value to display in a report or graph when the actual value is not a valid real number."""
        return self._intf.get_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._get_invalid_data_indicator_metadata)

    _set_invalid_data_indicator_metadata = { "name" : "invalid_data_indicator",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @invalid_data_indicator.setter
    def invalid_data_indicator(self, invalidDataIndicator:float) -> None:
        return self._intf.set_property(ICalculationToolScalarDataElement._metadata, ICalculationToolScalarDataElement._set_invalid_data_indicator_metadata, invalidDataIndicator)


agcls.AgClassCatalog.add_catalog_entry("{DC828DD6-378B-4EE2-BEFF-B7FA5BF610CE}", ICalculationToolScalarDataElement)
agcls.AgTypeNameMap["ICalculationToolScalarDataElement"] = ICalculationToolScalarDataElement

class ICalculationToolScalarDerivative(object):
    """Derivative of an input scalar calculation."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_scalar" : 1,
                             "set_scalar" : 2,
                             "get_differencing_time_step" : 3,
                             "set_differencing_time_step" : 4,
                             "get_force_use_of_numerical_differences" : 5,
                             "set_force_use_of_numerical_differences" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarDerivative)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarDerivative)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarDerivative, None)
    
    _get_scalar_metadata = { "name" : "scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The input scalar component used to compute the derivative."""
        return self._intf.get_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._get_scalar_metadata)

    _set_scalar_metadata = { "name" : "scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._set_scalar_metadata, scalar)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """The time step used, if necessary, in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._set_differencing_time_step_metadata, differencingTimeStep)

    _get_force_use_of_numerical_differences_metadata = { "name" : "force_use_of_numerical_differences",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def force_use_of_numerical_differences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._get_force_use_of_numerical_differences_metadata)

    _set_force_use_of_numerical_differences_metadata = { "name" : "force_use_of_numerical_differences",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @force_use_of_numerical_differences.setter
    def force_use_of_numerical_differences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarDerivative._metadata, ICalculationToolScalarDerivative._set_force_use_of_numerical_differences_metadata, forceUseOfNumericalDifferences)


agcls.AgClassCatalog.add_catalog_entry("{C50A8D6F-A8C1-4B7C-B2DB-26D538E68AE5}", ICalculationToolScalarDerivative)
agcls.AgTypeNameMap["ICalculationToolScalarDerivative"] = ICalculationToolScalarDerivative

class ICalculationToolScalarDotProduct(object):
    """Dot product between two vectors."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ffb69fa2-d123-413e-bb34-db750b7775ea}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vector_a" : 1,
                             "set_vector_a" : 2,
                             "get_normalize_vector_a" : 3,
                             "set_normalize_vector_a" : 4,
                             "get_vector_b" : 5,
                             "set_vector_b" : 6,
                             "get_normalize_vector_b" : 7,
                             "set_normalize_vector_b" : 8,
                             "get_dimension" : 9,
                             "set_dimension" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarDotProduct)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarDotProduct)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarDotProduct, None)
    
    _get_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """First vector."""
        return self._intf.get_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._get_vector_a_metadata)

    _set_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._set_vector_a_metadata, vectorA)

    _get_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Second vector."""
        return self._intf.get_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._get_vector_b_metadata)

    _set_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._set_vector_b_metadata, vectorB)

    _get_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_dimension_metadata = { "name" : "dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def dimension(self) -> str:
        """Return a unit of measure, i.e. 'Angle', 'Distance', etc."""
        return self._intf.get_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._get_dimension_metadata)

    _set_dimension_metadata = { "name" : "dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(ICalculationToolScalarDotProduct._metadata, ICalculationToolScalarDotProduct._set_dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{ffb69fa2-d123-413e-bb34-db750b7775ea}", ICalculationToolScalarDotProduct)
agcls.AgTypeNameMap["ICalculationToolScalarDotProduct"] = ICalculationToolScalarDotProduct

class ICalculationToolScalarElapsedTime(object):
    """Time elapsed since the reference time instant. Negative if in the past."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{81238610-6A1B-499A-8C43-12337F64BC42}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarElapsedTime)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarElapsedTime)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarElapsedTime, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(ICalculationToolScalarElapsedTime._metadata, ICalculationToolScalarElapsedTime._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ICalculationToolScalarElapsedTime._metadata, ICalculationToolScalarElapsedTime._set_reference_time_instant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{81238610-6A1B-499A-8C43-12337F64BC42}", ICalculationToolScalarElapsedTime)
agcls.AgTypeNameMap["ICalculationToolScalarElapsedTime"] = ICalculationToolScalarElapsedTime

class ICalculationToolScalarFactory(object):
    """The factory creates scalar calculation components."""

    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_available_calc_scalar_plugin_display_names" : 1,
                             "create" : 2,
                             "create_calc_scalar_angle" : 3,
                             "create_calc_scalar_fixed_at_time_instant" : 4,
                             "create_calc_scalar_constant" : 5,
                             "create_calc_scalar_data_element" : 6,
                             "create_calc_scalar_data_element_with_group" : 7,
                             "create_calc_scalar_derivative" : 8,
                             "create_calc_scalar_elapsed_time" : 9,
                             "create_calc_scalar_file" : 10,
                             "create_calc_scalar_function" : 11,
                             "create_calc_scalar_integral" : 12,
                             "create_calc_scalar_function2_var" : 13,
                             "create_calc_scalar_vector_magnitude" : 14,
                             "create_calc_scalar_plugin_from_display_name" : 15,
                             "is_type_supported" : 16,
                             "create_calc_scalar_from_custom_script" : 17,
                             "create_calc_scalar_surface_distance_between_points" : 18,
                             "create_calc_scalar_dot_product" : 19,
                             "create_calc_scalar_vector_component" : 20, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarFactory, None)
    
    _get_available_calc_scalar_plugin_display_names_metadata = { "name" : "available_calc_scalar_plugin_display_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_calc_scalar_plugin_display_names(self) -> list:
        """An array of display names associated with available scalar calculation plugins. The elements of the array are strings. Display names are used to create Calc scalars based on COM plugins using CreateCalcScalarPluginFromDisplayName method."""
        return self._intf.get_property(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._get_available_calc_scalar_plugin_display_names_metadata)

    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_CALC_SCALAR_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_CALC_SCALAR_TYPE") -> "ICalculationToolScalar":
        """Create and registers a scalar calculation using specified name, description, and type."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_metadata, name, description, type, out_arg())

    _create_calc_scalar_angle_metadata = { "name" : "create_calc_scalar_angle",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_angle(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to angular displacement obtained from any angle in VGT."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_angle_metadata, name, description, out_arg())

    _create_calc_scalar_fixed_at_time_instant_metadata = { "name" : "create_calc_scalar_fixed_at_time_instant",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_fixed_at_time_instant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined by evaluating the input scalar calculation at the specified reference time instant."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_fixed_at_time_instant_metadata, name, description, out_arg())

    _create_calc_scalar_constant_metadata = { "name" : "create_calc_scalar_constant",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_constant(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation of constant value of the specified dimension."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_constant_metadata, name, description, out_arg())

    _create_calc_scalar_data_element_metadata = { "name" : "create_calc_scalar_data_element",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_data_element(self, name:str, description:str, dataProvider:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_data_element_metadata, name, description, dataProvider, elementName, out_arg())

    _create_calc_scalar_data_element_with_group_metadata = { "name" : "create_calc_scalar_data_element_with_group",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_data_element_with_group(self, name:str, description:str, dataProvider:str, groupName:str, elementName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation defined from a time-dependent data element from STK data providers available for parent STK object."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_data_element_with_group_metadata, name, description, dataProvider, groupName, elementName, out_arg())

    _create_calc_scalar_derivative_metadata = { "name" : "create_calc_scalar_derivative",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_derivative(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the derivative of an input scalar calculation."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_derivative_metadata, name, description, out_arg())

    _create_calc_scalar_elapsed_time_metadata = { "name" : "create_calc_scalar_elapsed_time",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_elapsed_time(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the time elapsed since a reference time instant."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_elapsed_time_metadata, name, description, out_arg())

    _create_calc_scalar_file_metadata = { "name" : "create_calc_scalar_file",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_file(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create scalar calculation specified by external data file."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_file_metadata, name, description, filepath, out_arg())

    _create_calc_scalar_function_metadata = { "name" : "create_calc_scalar_function",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_function(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing the specified function on the input scalar or time instant."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_function_metadata, name, description, out_arg())

    _create_calc_scalar_integral_metadata = { "name" : "create_calc_scalar_integral",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_integral(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is the integral of an input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_integral_metadata, name, description, out_arg())

    _create_calc_scalar_function2_var_metadata = { "name" : "create_calc_scalar_function2_var",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_function2_var(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by performing a function(x,y) on two scalar arguments."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_function2_var_metadata, name, description, out_arg())

    _create_calc_scalar_vector_magnitude_metadata = { "name" : "create_calc_scalar_vector_magnitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_vector_magnitude(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation equal to the magnitude of a specified vector."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_vector_magnitude_metadata, name, description, out_arg())

    _create_calc_scalar_plugin_from_display_name_metadata = { "name" : "create_calc_scalar_plugin_from_display_name",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_plugin_from_display_name(self, name:str, description:str, displayName:str) -> "ICalculationToolScalar":
        """Create a scalar calculation based on a COM plugin. For information how to implement and register VGT plugins, see <topic name='Engine Plugins: COM-based Engine Plugin Components'>COM-based Engine Plugins.</topic>."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_plugin_from_display_name_metadata, name, description, displayName, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CALC_SCALAR_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_CALC_SCALAR_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._is_type_supported_metadata, eType, out_arg())

    _create_calc_scalar_from_custom_script_metadata = { "name" : "create_calc_scalar_from_custom_script",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_from_custom_script(self, name:str, description:str, filepath:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that uses scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_from_custom_script_metadata, name, description, filepath, out_arg())

    _create_calc_scalar_surface_distance_between_points_metadata = { "name" : "create_calc_scalar_surface_distance_between_points",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_surface_distance_between_points(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a calc scalar calculation that is surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_surface_distance_between_points_metadata, name, description, out_arg())

    _create_calc_scalar_dot_product_metadata = { "name" : "create_calc_scalar_dot_product",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_dot_product(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a dot product between two vectors."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_dot_product_metadata, name, description, out_arg())

    _create_calc_scalar_vector_component_metadata = { "name" : "create_calc_scalar_vector_component",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_calc_scalar_vector_component(self, name:str, description:str) -> "ICalculationToolScalar":
        """Create a scalar calculation that is defined by a specified component of a vector when resolved in specified axes."""
        return self._intf.invoke(ICalculationToolScalarFactory._metadata, ICalculationToolScalarFactory._create_calc_scalar_vector_component_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C8627C38-9FD6-4C51-A7EA-84C87BBCC662}", ICalculationToolScalarFactory)
agcls.AgTypeNameMap["ICalculationToolScalarFactory"] = ICalculationToolScalarFactory

class ICalculationToolScalarFile(object):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{98BC97CE-DA0B-4783-BB98-A988CA16447A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2,
                             "reload" : 3,
                             "get_file_span" : 4,
                             "get_file_interpolation_type" : 5,
                             "set_file_interpolation_type" : 6,
                             "get_file_interpolation_order" : 7,
                             "set_file_interpolation_order" : 8,
                             "get_use_native_file_interpolation_settings" : 9,
                             "set_use_native_file_interpolation_settings" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarFile)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarFile)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarFile, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """The path to an ASCII file with .csc extension."""
        return self._intf.get_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._set_filename_metadata, filename)

    _reload_metadata = { "name" : "reload",
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the file specified with Filename property."""
        return self._intf.invoke(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._reload_metadata, )

    _get_file_span_metadata = { "name" : "get_file_span",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_file_span(self) -> "TimeToolEventIntervalResult":
        """Compute the interval time span of the file."""
        return self._intf.invoke(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._get_file_span_metadata, out_arg())

    _get_file_interpolation_type_metadata = { "name" : "file_interpolation_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_FILE_INTERPOLATOR_TYPE),) }
    @property
    def file_interpolation_type(self) -> "CRDN_FILE_INTERPOLATOR_TYPE":
        """The interpolation method used with the data."""
        return self._intf.get_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._get_file_interpolation_type_metadata)

    _set_file_interpolation_type_metadata = { "name" : "file_interpolation_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_FILE_INTERPOLATOR_TYPE),) }
    @file_interpolation_type.setter
    def file_interpolation_type(self, fileInterpolationType:"CRDN_FILE_INTERPOLATOR_TYPE") -> None:
        return self._intf.set_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._set_file_interpolation_type_metadata, fileInterpolationType)

    _get_file_interpolation_order_metadata = { "name" : "file_interpolation_order",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def file_interpolation_order(self) -> int:
        """The interpolation order used with the interpolation method to interrogate the data."""
        return self._intf.get_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._get_file_interpolation_order_metadata)

    _set_file_interpolation_order_metadata = { "name" : "file_interpolation_order",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @file_interpolation_order.setter
    def file_interpolation_order(self, fileInterpolationOrder:int) -> None:
        return self._intf.set_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._set_file_interpolation_order_metadata, fileInterpolationOrder)

    _get_use_native_file_interpolation_settings_metadata = { "name" : "use_native_file_interpolation_settings",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_native_file_interpolation_settings(self) -> bool:
        """Flag indicating whether the interpolation method and order settings specified within the file, if any, will be honored."""
        return self._intf.get_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._get_use_native_file_interpolation_settings_metadata)

    _set_use_native_file_interpolation_settings_metadata = { "name" : "use_native_file_interpolation_settings",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_native_file_interpolation_settings.setter
    def use_native_file_interpolation_settings(self, useNativeFileInterpolationSettings:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarFile._metadata, ICalculationToolScalarFile._set_use_native_file_interpolation_settings_metadata, useNativeFileInterpolationSettings)


agcls.AgClassCatalog.add_catalog_entry("{98BC97CE-DA0B-4783-BB98-A988CA16447A}", ICalculationToolScalarFile)
agcls.AgTypeNameMap["ICalculationToolScalarFile"] = ICalculationToolScalarFile

class ICalculationToolScalarFixedAtTimeInstant(object):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_scalar" : 1,
                             "set_input_scalar" : 2,
                             "get_reference_time_instant" : 3,
                             "set_reference_time_instant" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarFixedAtTimeInstant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarFixedAtTimeInstant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarFixedAtTimeInstant, None)
    
    _get_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar component."""
        return self._intf.get_property(ICalculationToolScalarFixedAtTimeInstant._metadata, ICalculationToolScalarFixedAtTimeInstant._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarFixedAtTimeInstant._metadata, ICalculationToolScalarFixedAtTimeInstant._set_input_scalar_metadata, inputScalar)

    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(ICalculationToolScalarFixedAtTimeInstant._metadata, ICalculationToolScalarFixedAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ICalculationToolScalarFixedAtTimeInstant._metadata, ICalculationToolScalarFixedAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{2ED6C69F-2AE0-4703-A99F-6931BC3B93C6}", ICalculationToolScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["ICalculationToolScalarFixedAtTimeInstant"] = ICalculationToolScalarFixedAtTimeInstant

class ICalculationToolScalarFunction(object):
    """Defined by performing the specified function on the input scalar or time instant."""

    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_scalar" : 1,
                             "set_use_scalar" : 2,
                             "get_input_scalar" : 3,
                             "set_input_scalar" : 4,
                             "get_input_time" : 5,
                             "set_input_time" : 6,
                             "get_input_unit" : 7,
                             "set_input_unit" : 8,
                             "get_a" : 9,
                             "set_a" : 10,
                             "get_b" : 11,
                             "set_b" : 12,
                             "get_c" : 13,
                             "set_c" : 14,
                             "get_d" : 15,
                             "set_d" : 16,
                             "get_coefficients" : 17,
                             "set_coefficients" : 18,
                             "get_selected_function" : 19,
                             "set_selected_function" : 20,
                             "get_available_functions" : 21,
                             "get_inherit_dimension_from_input" : 22,
                             "set_inherit_dimension_from_input" : 23,
                             "get_output_dimension" : 24,
                             "set_output_dimension" : 25,
                             "get_output_unit" : 26,
                             "set_output_unit" : 27,
                             "get_sampling" : 28,
                             "set_sampling" : 29,
                             "get_convergence" : 30,
                             "set_convergence" : 31, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarFunction)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarFunction)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarFunction, None)
    
    _get_use_scalar_metadata = { "name" : "use_scalar",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_scalar(self) -> bool:
        """Specify whether to use the input scalar calculation or the time elapsed from the input time instant. Set to true to use the scalar."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_use_scalar_metadata)

    _set_use_scalar_metadata = { "name" : "use_scalar",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_scalar.setter
    def use_scalar(self, useScalar:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_use_scalar_metadata, useScalar)

    _get_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation (used if UseScalar is true). The UseScalar property should be set to true before this property can be set."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_input_scalar_metadata, inputScalar)

    _get_input_time_metadata = { "name" : "input_time",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_time(self) -> "ITimeToolEvent":
        """The input time instant (used if UseScalar is false)."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_input_time_metadata)

    _set_input_time_metadata = { "name" : "input_time",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @input_time.setter
    def input_time(self, inputTime:"ITimeToolEvent") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_input_time_metadata, inputTime)

    _get_input_unit_metadata = { "name" : "input_unit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def input_unit(self) -> str:
        """The input time unit to interpret input time."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_input_unit_metadata)

    _set_input_unit_metadata = { "name" : "input_unit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @input_unit.setter
    def input_unit(self, inputUnit:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_input_unit_metadata, inputUnit)

    _get_a_metadata = { "name" : "a",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def a(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_a_metadata)

    _set_a_metadata = { "name" : "a",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @a.setter
    def a(self, a:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_a_metadata, a)

    _get_b_metadata = { "name" : "b",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def b(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_b_metadata)

    _set_b_metadata = { "name" : "b",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @b.setter
    def b(self, b:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_b_metadata, b)

    _get_c_metadata = { "name" : "c",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def c(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_c_metadata)

    _set_c_metadata = { "name" : "c",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @c.setter
    def c(self, c:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_c_metadata, c)

    _get_d_metadata = { "name" : "d",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def d(self) -> float:
        """The constant coefficient D."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_d_metadata)

    _set_d_metadata = { "name" : "d",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @d.setter
    def d(self, d:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_d_metadata, d)

    _get_coefficients_metadata = { "name" : "coefficients",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def coefficients(self) -> list:
        """The array of constant coefficients, whose dimension and units are determined by those of input and output."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_coefficients_metadata)

    _set_coefficients_metadata = { "name" : "coefficients",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @coefficients.setter
    def coefficients(self, coefficients:list) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_coefficients_metadata, coefficients)

    _get_selected_function_metadata = { "name" : "selected_function",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def selected_function(self) -> str:
        """The function which will use the input scalar or time instant in some combination with the constant coefficients A, B, C, D."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_selected_function_metadata)

    _set_selected_function_metadata = { "name" : "selected_function",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @selected_function.setter
    def selected_function(self, selectedFunction:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_selected_function_metadata, selectedFunction)

    _get_available_functions_metadata = { "name" : "available_functions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_functions(self) -> list:
        """Get the available function names."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_available_functions_metadata)

    _get_inherit_dimension_from_input_metadata = { "name" : "inherit_dimension_from_input",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def inherit_dimension_from_input(self) -> bool:
        """Specify whether to inherit the output dimension from the input scalar or time instant."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_inherit_dimension_from_input_metadata)

    _set_inherit_dimension_from_input_metadata = { "name" : "inherit_dimension_from_input",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @inherit_dimension_from_input.setter
    def inherit_dimension_from_input(self, inheritDimensionFromInput:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_inherit_dimension_from_input_metadata, inheritDimensionFromInput)

    _get_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_dimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if InheritDimensionFromInput is false. The InheritDimensionFromInput property should be set to false before this property can be fixed."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_output_dimension_metadata, outputDimension)

    _get_output_unit_metadata = { "name" : "output_unit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_unit(self) -> str:
        """Specify a unit for the selected output dimension. This is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_output_unit_metadata)

    _set_output_unit_metadata = { "name" : "output_unit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_unit.setter
    def output_unit(self, outputUnit:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_output_unit_metadata, outputUnit)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction._metadata, ICalculationToolScalarFunction._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{7FA307A8-7A76-496A-B2D6-B341F4DE84F2}", ICalculationToolScalarFunction)
agcls.AgTypeNameMap["ICalculationToolScalarFunction"] = ICalculationToolScalarFunction

class ICalculationToolScalarFunction2Var(object):
    """Defined by performing a function(x,y) on two scalar arguments."""

    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E56D021E-AD96-4ABE-857E-708CDCC4FF14}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_x" : 1,
                             "set_x" : 2,
                             "get_unit_x" : 3,
                             "set_unit_x" : 4,
                             "get_a" : 5,
                             "set_a" : 6,
                             "get_y" : 7,
                             "set_y" : 8,
                             "get_unit_y" : 9,
                             "set_unit_y" : 10,
                             "get_b" : 11,
                             "set_b" : 12,
                             "get_c" : 13,
                             "set_c" : 14,
                             "get_output_dimension_inheritance" : 15,
                             "set_output_dimension_inheritance" : 16,
                             "get_output_dimension" : 17,
                             "set_output_dimension" : 18,
                             "get_available_functions" : 19,
                             "get_selected_function" : 20,
                             "set_selected_function" : 21,
                             "get_output_unit" : 22,
                             "set_output_unit" : 23, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarFunction2Var)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarFunction2Var)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarFunction2Var, None)
    
    _get_x_metadata = { "name" : "x",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x(self) -> "ICalculationToolScalar":
        """The scalar argument X."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_x_metadata)

    _set_x_metadata = { "name" : "x",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @x.setter
    def x(self, x:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_x_metadata, x)

    _get_unit_x_metadata = { "name" : "unit_x",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def unit_x(self) -> str:
        """The unit used to interpret numerical values of scalar argument X."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_unit_x_metadata)

    _set_unit_x_metadata = { "name" : "unit_x",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @unit_x.setter
    def unit_x(self, unitX:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_unit_x_metadata, unitX)

    _get_a_metadata = { "name" : "a",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def a(self) -> float:
        """The constant coefficient A."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_a_metadata)

    _set_a_metadata = { "name" : "a",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @a.setter
    def a(self, a:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_a_metadata, a)

    _get_y_metadata = { "name" : "y",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y(self) -> "ICalculationToolScalar":
        """The scalar argument Y."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_y_metadata)

    _set_y_metadata = { "name" : "y",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @y.setter
    def y(self, y:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_y_metadata, y)

    _get_unit_y_metadata = { "name" : "unit_y",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def unit_y(self) -> str:
        """The unit used to interpret numerical values of scalar argument Y."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_unit_y_metadata)

    _set_unit_y_metadata = { "name" : "unit_y",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @unit_y.setter
    def unit_y(self, unitY:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_unit_y_metadata, unitY)

    _get_b_metadata = { "name" : "b",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def b(self) -> float:
        """The constant coefficient B."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_b_metadata)

    _set_b_metadata = { "name" : "b",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @b.setter
    def b(self, b:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_b_metadata, b)

    _get_c_metadata = { "name" : "c",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def c(self) -> float:
        """The constant coefficient C."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_c_metadata)

    _set_c_metadata = { "name" : "c",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @c.setter
    def c(self, c:float) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_c_metadata, c)

    _get_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Specify whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_dimension(self) -> str:
        """The output dimension. Use any of STK supported dimensions. This value will be used if OutputDimensionInheritance is false."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_output_dimension_metadata, outputDimension)

    _get_available_functions_metadata = { "name" : "available_functions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_functions(self) -> list:
        """The available functions. A function(x,y) uses some combination of two scalar arguments x and y as well as one to three constant coefficients a, b, c."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_available_functions_metadata)

    _get_selected_function_metadata = { "name" : "selected_function",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def selected_function(self) -> str:
        """The selected function."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_selected_function_metadata)

    _set_selected_function_metadata = { "name" : "selected_function",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @selected_function.setter
    def selected_function(self, selectedFunction:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_selected_function_metadata, selectedFunction)

    _get_output_unit_metadata = { "name" : "output_unit",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_unit(self) -> str:
        """The unit for the selected dimension. The unit is not used for internal computations or reporting/graphing but is needed to unambiguously interpret units of associated coefficients."""
        return self._intf.get_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._get_output_unit_metadata)

    _set_output_unit_metadata = { "name" : "output_unit",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_unit.setter
    def output_unit(self, outputUnit:str) -> None:
        return self._intf.set_property(ICalculationToolScalarFunction2Var._metadata, ICalculationToolScalarFunction2Var._set_output_unit_metadata, outputUnit)


agcls.AgClassCatalog.add_catalog_entry("{E56D021E-AD96-4ABE-857E-708CDCC4FF14}", ICalculationToolScalarFunction2Var)
agcls.AgTypeNameMap["ICalculationToolScalarFunction2Var"] = ICalculationToolScalarFunction2Var

class ICalculationToolScalarIntegral(object):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""

    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_scalar" : 1,
                             "set_input_scalar" : 2,
                             "get_compute_as_average" : 3,
                             "set_compute_as_average" : 4,
                             "get_integration_window_type" : 5,
                             "set_integration_window_type" : 6,
                             "get_start_offset" : 7,
                             "set_start_offset" : 8,
                             "get_stop_offset" : 9,
                             "set_stop_offset" : 10,
                             "get_use_custom_time_limits" : 11,
                             "set_use_custom_time_limits" : 12,
                             "get_custom_time_limits" : 13,
                             "set_custom_time_limits" : 14,
                             "get_save_data_option" : 15,
                             "set_save_data_option" : 16,
                             "get_interpolation" : 17,
                             "set_interpolation" : 18,
                             "get_sampling" : 19,
                             "set_sampling" : 20,
                             "get_integral" : 21,
                             "set_integral" : 22,
                             "get_keep_constant_outside_time_limits" : 23,
                             "set_keep_constant_outside_time_limits" : 24,
                             "set_offsets" : 25, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarIntegral)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarIntegral)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarIntegral, None)
    
    _get_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_input_scalar_metadata, inputScalar)

    _get_compute_as_average_metadata = { "name" : "compute_as_average",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def compute_as_average(self) -> bool:
        """Specify whether the resulting integral value is divided by its time span to generate average value instead of integral."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_compute_as_average_metadata)

    _set_compute_as_average_metadata = { "name" : "compute_as_average",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @compute_as_average.setter
    def compute_as_average(self, computeAsAverage:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_compute_as_average_metadata, computeAsAverage)

    _get_integration_window_type_metadata = { "name" : "integration_window_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @property
    def integration_window_type(self) -> "CRDN_INTEGRATION_WINDOW_TYPE":
        """The integration window, or accumulation, type."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_integration_window_type_metadata)

    _set_integration_window_type_metadata = { "name" : "integration_window_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTEGRATION_WINDOW_TYPE),) }
    @integration_window_type.setter
    def integration_window_type(self, integrationWindowType:"CRDN_INTEGRATION_WINDOW_TYPE") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_integration_window_type_metadata, integrationWindowType)

    _get_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_start_offset_metadata)

    _set_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_stop_offset_metadata, stopOffset)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use custom interval list (CustomTimeLimits)."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_custom_time_limits_metadata, customTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Set the value to determine if computed time of extremum is saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_save_data_option_metadata, saveDataOption)

    _get_interpolation_metadata = { "name" : "interpolation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interpolation(self) -> "IAnalysisWorkbenchInterp":
        """Specify whether to use Lagrange or Hermite interpolation. See STK help on interpolation."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_interpolation_metadata)

    _set_interpolation_metadata = { "name" : "interpolation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchInterp"),) }
    @interpolation.setter
    def interpolation(self, interpolation:"IAnalysisWorkbenchInterp") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_interpolation_metadata, interpolation)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_sampling_metadata, sampling)

    _get_integral_metadata = { "name" : "integral",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def integral(self) -> "IAnalysisWorkbenchIntegral":
        """The numerical integration method."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_integral_metadata)

    _set_integral_metadata = { "name" : "integral",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchIntegral"),) }
    @integral.setter
    def integral(self, integral:"IAnalysisWorkbenchIntegral") -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_integral_metadata, integral)

    _get_keep_constant_outside_time_limits_metadata = { "name" : "keep_constant_outside_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def keep_constant_outside_time_limits(self) -> bool:
        """If true, the integral's integrand value is replaced by a constant 0 so that the integral remains constant over the gaps in integration."""
        return self._intf.get_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._get_keep_constant_outside_time_limits_metadata)

    _set_keep_constant_outside_time_limits_metadata = { "name" : "keep_constant_outside_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @keep_constant_outside_time_limits.setter
    def keep_constant_outside_time_limits(self, keepConstantOutsideTimeLimits:bool) -> None:
        return self._intf.set_property(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_keep_constant_outside_time_limits_metadata, keepConstantOutsideTimeLimits)

    _set_offsets_metadata = { "name" : "set_offsets",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_offsets(self, startOffset:float, stopOffset:float) -> None:
        """Set the offsets with respect to current time to define the start and stop of the sliding window, used when IntegrationWindowType is set to Sliding Window."""
        return self._intf.invoke(ICalculationToolScalarIntegral._metadata, ICalculationToolScalarIntegral._set_offsets_metadata, startOffset, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{9D7AEB38-6E1E-462B-BC34-BC1EBB81CC1E}", ICalculationToolScalarIntegral)
agcls.AgTypeNameMap["ICalculationToolScalarIntegral"] = ICalculationToolScalarIntegral

class ICalculationToolScalarPlugin(object):
    """Use a scalar calculation plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1459313C-59BD-42FF-9F0D-AF4604F13D4C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prog_id" : 1,
                             "get_display_name" : 2,
                             "get_available_properties" : 3,
                             "reset" : 4,
                             "set_property" : 5,
                             "get_property" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarPlugin)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarPlugin)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarPlugin, None)
    
    _get_prog_id_metadata = { "name" : "prog_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "name" : "display_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def display_name(self) -> str:
        """The plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "name" : "available_properties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._get_available_properties_metadata)

    _reset_metadata = { "name" : "reset",
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._reset_metadata, )

    _set_property_metadata = { "name" : "set_property",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_property(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, an invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "name" : "get_property",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def get_property(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(ICalculationToolScalarPlugin._metadata, ICalculationToolScalarPlugin._get_property_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1459313C-59BD-42FF-9F0D-AF4604F13D4C}", ICalculationToolScalarPlugin)
agcls.AgTypeNameMap["ICalculationToolScalarPlugin"] = ICalculationToolScalarPlugin

class ICalculationToolScalarSurfaceDistanceBetweenPoints(object):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC5C0166-111F-4E8A-9650-012CE6A57911}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_point1" : 1,
                             "set_point1" : 2,
                             "get_point2" : 3,
                             "set_point2" : 4,
                             "get_surface_central_body" : 5,
                             "set_surface_central_body" : 6,
                             "get_differencing_time_step" : 7,
                             "set_differencing_time_step" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarSurfaceDistanceBetweenPoints)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarSurfaceDistanceBetweenPoints)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarSurfaceDistanceBetweenPoints, None)
    
    _get_point1_metadata = { "name" : "point1",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point1(self) -> "IVectorGeometryToolPoint":
        """Starting point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._get_point1_metadata)

    _set_point1_metadata = { "name" : "point1",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @point1.setter
    def point1(self, point1:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._set_point1_metadata, point1)

    _get_point2_metadata = { "name" : "point2",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point2(self) -> "IVectorGeometryToolPoint":
        """Terminating point on the central body ellipsoid (or projection of point at altitude onto the ellipsoid)."""
        return self._intf.get_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._get_point2_metadata)

    _set_point2_metadata = { "name" : "point2",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @point2.setter
    def point2(self, point2:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._set_point2_metadata, point2)

    _get_surface_central_body_metadata = { "name" : "surface_central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def surface_central_body(self) -> str:
        """Central body on which the surface distance between points is to be calculated."""
        return self._intf.get_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._get_surface_central_body_metadata)

    _set_surface_central_body_metadata = { "name" : "surface_central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @surface_central_body.setter
    def surface_central_body(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._set_surface_central_body_metadata, surfaceCentralBody)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of scalar calculation time rate of change (derivatives using central differencing)."""
        return self._intf.get_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolScalarSurfaceDistanceBetweenPoints._metadata, ICalculationToolScalarSurfaceDistanceBetweenPoints._set_differencing_time_step_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{DC5C0166-111F-4E8A-9650-012CE6A57911}", ICalculationToolScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["ICalculationToolScalarSurfaceDistanceBetweenPoints"] = ICalculationToolScalarSurfaceDistanceBetweenPoints

class ICalculationToolScalarVectorComponent(object):
    """The specified component of a vector when resolved in the specified axes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2adb8ac1-7836-45af-b7f1-77b13a9db586}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_vector" : 1,
                             "set_input_vector" : 2,
                             "get_reference_axes" : 3,
                             "set_reference_axes" : 4,
                             "get_component" : 5,
                             "set_component" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarVectorComponent)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarVectorComponent)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarVectorComponent, None)
    
    _get_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """Vector."""
        return self._intf.get_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._get_input_vector_metadata)

    _set_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._set_input_vector_metadata, inputVector)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Axes used to resolve the vector's components."""
        return self._intf.get_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._set_reference_axes_metadata, referenceAxes)

    _get_component_metadata = { "name" : "component",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE),) }
    @property
    def component(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE":
        """The component of the vector to return as the value of the scalar."""
        return self._intf.get_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._get_component_metadata)

    _set_component_metadata = { "name" : "component",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE),) }
    @component.setter
    def component(self, component:"VECTOR_GEOMETRY_TOOL_VECTOR_COMPONENT_TYPE") -> None:
        return self._intf.set_property(ICalculationToolScalarVectorComponent._metadata, ICalculationToolScalarVectorComponent._set_component_metadata, component)


agcls.AgClassCatalog.add_catalog_entry("{2adb8ac1-7836-45af-b7f1-77b13a9db586}", ICalculationToolScalarVectorComponent)
agcls.AgTypeNameMap["ICalculationToolScalarVectorComponent"] = ICalculationToolScalarVectorComponent

class ICalculationToolScalarVectorMagnitude(object):
    """Scalar equal to the magnitude of a specified vector."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{57FC76A1-A63F-4A25-A3A6-3953275A15E4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_vector" : 1,
                             "set_input_vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolScalarVectorMagnitude)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolScalarVectorMagnitude)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolScalarVectorMagnitude, None)
    
    _get_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """Specify any vector in VGT. Note that its magnitude is reference axes independent which is why it is not specified."""
        return self._intf.get_property(ICalculationToolScalarVectorMagnitude._metadata, ICalculationToolScalarVectorMagnitude._get_input_vector_metadata)

    _set_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ICalculationToolScalarVectorMagnitude._metadata, ICalculationToolScalarVectorMagnitude._set_input_vector_metadata, inputVector)


agcls.AgClassCatalog.add_catalog_entry("{57FC76A1-A63F-4A25-A3A6-3953275A15E4}", ICalculationToolScalarVectorMagnitude)
agcls.AgTypeNameMap["ICalculationToolScalarVectorMagnitude"] = ICalculationToolScalarVectorMagnitude

class ICalculationToolCondition(object):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8CA43B7E-6345-4F97-97B2-A4C4517739C8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "evaluate" : 2,
                             "evaluate_with_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolCondition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolCondition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolCondition, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_TYPE),) }
    @property
    def type(self) -> "CRDN_CONDITION_TYPE":
        """Return the type of condition."""
        return self._intf.get_property(ICalculationToolCondition._metadata, ICalculationToolCondition._get_type_metadata)

    _evaluate_metadata = { "name" : "evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolEvaluateResult":
        """Return result of evaluating continuously varying condition metric at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolCondition._metadata, ICalculationToolCondition._evaluate_metadata, epoch, out_arg())

    _evaluate_with_rate_metadata = { "name" : "evaluate_with_rate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolEvaluateWithRateResult":
        """Return result of evaluating continuously varying condition metric and its rate of change at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolCondition._metadata, ICalculationToolCondition._evaluate_with_rate_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{8CA43B7E-6345-4F97-97B2-A4C4517739C8}", ICalculationToolCondition)
agcls.AgTypeNameMap["ICalculationToolCondition"] = ICalculationToolCondition

class ICalculationToolConditionCombined(object):
    """Define a condition which combines multiple conditions."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB19E942-0C28-4AB9-B2C0-D31693564C99}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_combine_operation" : 1,
                             "set_combine_operation" : 2,
                             "get_condition_count" : 3,
                             "get_all_conditions" : 4,
                             "set_all_conditions" : 5,
                             "get_condition" : 6,
                             "set_condition" : 7,
                             "remove_condition" : 8,
                             "add_condition" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionCombined)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionCombined)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionCombined, None)
    
    _get_combine_operation_metadata = { "name" : "combine_operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_COMBINED_OPERATION_TYPE),) }
    @property
    def combine_operation(self) -> "CRDN_CONDITION_COMBINED_OPERATION_TYPE":
        """Get the operation from the condition that determines how the conditions are combined. The operation can be set to AND, OR, XOR, MINUS."""
        return self._intf.get_property(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._get_combine_operation_metadata)

    _set_combine_operation_metadata = { "name" : "combine_operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_COMBINED_OPERATION_TYPE),) }
    @combine_operation.setter
    def combine_operation(self, combineOperation:"CRDN_CONDITION_COMBINED_OPERATION_TYPE") -> None:
        return self._intf.set_property(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._set_combine_operation_metadata, combineOperation)

    _get_condition_count_metadata = { "name" : "condition_count",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def condition_count(self) -> int:
        """Get the number of conditions in the combined condition."""
        return self._intf.get_property(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._get_condition_count_metadata)

    _get_all_conditions_metadata = { "name" : "get_all_conditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_conditions(self) -> list:
        """Get all conditions that are being combined."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._get_all_conditions_metadata, out_arg())

    _set_all_conditions_metadata = { "name" : "set_all_conditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def set_all_conditions(self, conditions:list) -> None:
        """Set all conditions to be combined."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._set_all_conditions_metadata, conditions)

    _get_condition_metadata = { "name" : "get_condition",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_condition(self, pos:int) -> "ICalculationToolCondition":
        """Get the condition at the position specified."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._get_condition_metadata, pos, out_arg())

    _set_condition_metadata = { "name" : "set_condition",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"), agmarshall.INT_arg,) }
    def set_condition(self, ref:"ICalculationToolCondition", pos:int) -> None:
        """Set the condition at the position specified."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._set_condition_metadata, ref, pos)

    _remove_condition_metadata = { "name" : "remove_condition",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def remove_condition(self, pos:int) -> None:
        """Remove the condition at the position specified."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._remove_condition_metadata, pos)

    _add_condition_metadata = { "name" : "add_condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    def add_condition(self, ref:"ICalculationToolCondition") -> None:
        """Add a condition at the end of the list."""
        return self._intf.invoke(ICalculationToolConditionCombined._metadata, ICalculationToolConditionCombined._add_condition_metadata, ref)


agcls.AgClassCatalog.add_catalog_entry("{EB19E942-0C28-4AB9-B2C0-D31693564C99}", ICalculationToolConditionCombined)
agcls.AgTypeNameMap["ICalculationToolConditionCombined"] = ICalculationToolConditionCombined

class ICalculationToolConditionFactory(object):
    """The factory creates condition components."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_condition_scalar_bounds" : 2,
                             "is_type_supported" : 3,
                             "create_condition_combined" : 4,
                             "create_condition_point_in_volume" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_CONDITION_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_CONDITION_TYPE") -> "ICalculationToolCondition":
        """Create and registers a condition using specified name, description and type."""
        return self._intf.invoke(ICalculationToolConditionFactory._metadata, ICalculationToolConditionFactory._create_metadata, name, description, type, out_arg())

    _create_condition_scalar_bounds_metadata = { "name" : "create_condition_scalar_bounds",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_condition_scalar_bounds(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition placing bounds on specified scalar."""
        return self._intf.invoke(ICalculationToolConditionFactory._metadata, ICalculationToolConditionFactory._create_condition_scalar_bounds_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_CONDITION_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ICalculationToolConditionFactory._metadata, ICalculationToolConditionFactory._is_type_supported_metadata, eType, out_arg())

    _create_condition_combined_metadata = { "name" : "create_condition_combined",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_condition_combined(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition which combines multiple conditions."""
        return self._intf.invoke(ICalculationToolConditionFactory._metadata, ICalculationToolConditionFactory._create_condition_combined_metadata, name, description, out_arg())

    _create_condition_point_in_volume_metadata = { "name" : "create_condition_point_in_volume",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_condition_point_in_volume(self, name:str, description:str) -> "ICalculationToolCondition":
        """Create a condition for point in volume."""
        return self._intf.invoke(ICalculationToolConditionFactory._metadata, ICalculationToolConditionFactory._create_condition_point_in_volume_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F6A542D2-82B8-441D-8CA8-7823A01FF5BA}", ICalculationToolConditionFactory)
agcls.AgTypeNameMap["ICalculationToolConditionFactory"] = ICalculationToolConditionFactory

class ICalculationToolConditionPointInVolume(object):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3C354DF9-E914-4542-9E21-F70A637C4EA4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_point" : 1,
                             "set_point" : 2,
                             "get_constraint" : 3,
                             "set_constraint" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionPointInVolume)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionPointInVolume)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionPointInVolume, None)
    
    _get_point_metadata = { "name" : "point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """Get the trajectory point from the condition."""
        return self._intf.get_property(ICalculationToolConditionPointInVolume._metadata, ICalculationToolConditionPointInVolume._get_point_metadata)

    _set_point_metadata = { "name" : "point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolConditionPointInVolume._metadata, ICalculationToolConditionPointInVolume._set_point_metadata, point)

    _get_constraint_metadata = { "name" : "constraint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on trajectory point."""
        return self._intf.get_property(ICalculationToolConditionPointInVolume._metadata, ICalculationToolConditionPointInVolume._get_constraint_metadata)

    _set_constraint_metadata = { "name" : "constraint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolume"),) }
    @constraint.setter
    def constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(ICalculationToolConditionPointInVolume._metadata, ICalculationToolConditionPointInVolume._set_constraint_metadata, constraint)


agcls.AgClassCatalog.add_catalog_entry("{3C354DF9-E914-4542-9E21-F70A637C4EA4}", ICalculationToolConditionPointInVolume)
agcls.AgTypeNameMap["ICalculationToolConditionPointInVolume"] = ICalculationToolConditionPointInVolume

class ICalculationToolConditionScalarBounds(object):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE3FB52B-9784-4707-8266-28F1E13B79D1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_scalar" : 1,
                             "set_scalar" : 2,
                             "get_operation" : 3,
                             "set_operation" : 4,
                             "get_minimum" : 5,
                             "set_minimum" : 6,
                             "get_maximum" : 7,
                             "set_maximum" : 8,
                             "set" : 9,
                             "get_minimum_unitless" : 10,
                             "set_minimum_unitless" : 11,
                             "get_maximum_unitless" : 12,
                             "set_maximum_unitless" : 13,
                             "set_unitless" : 14, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionScalarBounds)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionScalarBounds)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionScalarBounds, None)
    
    _get_scalar_metadata = { "name" : "scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """Get the scalar calculation from the condition."""
        return self._intf.get_property(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_scalar_metadata)

    _set_scalar_metadata = { "name" : "scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_scalar_metadata, scalar)

    _get_operation_metadata = { "name" : "operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @property
    def operation(self) -> "CRDN_CONDITION_THRESHOLD_OPTION":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_operation_metadata)

    _set_operation_metadata = { "name" : "operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @operation.setter
    def operation(self, operation:"CRDN_CONDITION_THRESHOLD_OPTION") -> None:
        return self._intf.set_property(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_operation_metadata, operation)

    _get_minimum_metadata = { "name" : "get_minimum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_minimum(self) -> "IQuantity":
        """Get the minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_minimum_metadata, out_arg())

    _set_minimum_metadata = { "name" : "set_minimum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set_minimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the condition."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_minimum_metadata, value)

    _get_maximum_metadata = { "name" : "get_maximum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_maximum(self) -> "IQuantity":
        """Get the maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_maximum_metadata, out_arg())

    _set_maximum_metadata = { "name" : "set_maximum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set_maximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_maximum_metadata, value)

    _set_metadata = { "name" : "set",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"), agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_metadata, min, max)

    _get_minimum_unitless_metadata = { "name" : "get_minimum_unitless",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_minimum_unitless(self) -> float:
        """Get the unitless minimum bound value from the condition. Call SetMinimum to apply changes."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_minimum_unitless_metadata, out_arg())

    _set_minimum_unitless_metadata = { "name" : "set_minimum_unitless",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_minimum_unitless(self, value:float) -> None:
        """Set the unitless minimum bound value for the condition."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_minimum_unitless_metadata, value)

    _get_maximum_unitless_metadata = { "name" : "get_maximum_unitless",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def get_maximum_unitless(self) -> float:
        """Get the unitless maximum bound value from the condition. Call SetMaximum to apply changes."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._get_maximum_unitless_metadata, out_arg())

    _set_maximum_unitless_metadata = { "name" : "set_maximum_unitless",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    def set_maximum_unitless(self, value:float) -> None:
        """Set the unitless maximum bound value for the condition."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_maximum_unitless_metadata, value)

    _set_unitless_metadata = { "name" : "set_unitless",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_unitless(self, min:float, max:float) -> None:
        """Set the unitless min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(ICalculationToolConditionScalarBounds._metadata, ICalculationToolConditionScalarBounds._set_unitless_metadata, min, max)


agcls.AgClassCatalog.add_catalog_entry("{FE3FB52B-9784-4707-8266-28F1E13B79D1}", ICalculationToolConditionScalarBounds)
agcls.AgTypeNameMap["ICalculationToolConditionScalarBounds"] = ICalculationToolConditionScalarBounds

class ICalculationToolConditionSet(object):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "evaluate" : 2,
                             "evaluate_with_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSet)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSet)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSet, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_SET_TYPE),) }
    @property
    def type(self) -> "CRDN_CONDITION_SET_TYPE":
        """Return the type of condition set."""
        return self._intf.get_property(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._get_type_metadata)

    _evaluate_metadata = { "name" : "evaluate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate(self, epoch:typing.Any) -> "CalculationToolConditionSetEvaluateResult":
        """Return an array of results of evaluating continuously varying condition metrics, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._evaluate_metadata, epoch, out_arg())

    _evaluate_with_rate_metadata = { "name" : "evaluate_with_rate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def evaluate_with_rate(self, epoch:typing.Any) -> "CalculationToolConditionSetEvaluateWithRateResult":
        """Return an array of results of evaluating continuously varying condition metrics and their rates of change, one for each condition in the set, at the specified time, used for detecting condition crossings."""
        return self._intf.invoke(ICalculationToolConditionSet._metadata, ICalculationToolConditionSet._evaluate_with_rate_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C9F4C8FF-431E-409A-AF80-2DB4049E40CA}", ICalculationToolConditionSet)
agcls.AgTypeNameMap["ICalculationToolConditionSet"] = ICalculationToolConditionSet

class ICalculationToolConditionSetFactory(object):
    """The factory creates condition set components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{698D592C-B264-426D-8577-AC7087E3EE44}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_scalar_thresholds" : 2,
                             "is_type_supported" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSetFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSetFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSetFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_CONDITION_SET_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_CONDITION_SET_TYPE") -> "ICalculationToolConditionSet":
        """Create and registers a condition set using specified name, description, and type."""
        return self._intf.invoke(ICalculationToolConditionSetFactory._metadata, ICalculationToolConditionSetFactory._create_metadata, name, description, type, out_arg())

    _create_scalar_thresholds_metadata = { "name" : "create_scalar_thresholds",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_scalar_thresholds(self, name:str, description:str) -> "ICalculationToolConditionSet":
        """Create a scalar thresholds condition set."""
        return self._intf.invoke(ICalculationToolConditionSetFactory._metadata, ICalculationToolConditionSetFactory._create_scalar_thresholds_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_SET_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_CONDITION_SET_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ICalculationToolConditionSetFactory._metadata, ICalculationToolConditionSetFactory._is_type_supported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{698D592C-B264-426D-8577-AC7087E3EE44}", ICalculationToolConditionSetFactory)
agcls.AgTypeNameMap["ICalculationToolConditionSetFactory"] = ICalculationToolConditionSetFactory

class ICalculationToolConditionSetScalarThresholds(object):
    """Condition set based on single scalar calculation compared to set of threshold values."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{57392078-7821-4910-B734-76B5C70CB6D9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_scalar" : 1,
                             "set_scalar" : 2,
                             "get_thresholds" : 3,
                             "get_threshold_labels" : 4,
                             "get_include_above_highest_threshold" : 5,
                             "set_include_above_highest_threshold" : 6,
                             "get_include_below_lowest_threshold" : 7,
                             "set_include_below_lowest_threshold" : 8,
                             "set_thresholds_and_labels" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConditionSetScalarThresholds)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConditionSetScalarThresholds)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConditionSetScalarThresholds, None)
    
    _get_scalar_metadata = { "name" : "scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The input scalar calculation."""
        return self._intf.get_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._get_scalar_metadata)

    _set_scalar_metadata = { "name" : "scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._set_scalar_metadata, scalar)

    _get_thresholds_metadata = { "name" : "thresholds",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def thresholds(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._get_thresholds_metadata)

    _get_threshold_labels_metadata = { "name" : "threshold_labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def threshold_labels(self) -> list:
        """The input threshold values, flags indicating whether to include conditions above the highest and below the lowest threhsolds, and corresponding labels."""
        return self._intf.get_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._get_threshold_labels_metadata)

    _get_include_above_highest_threshold_metadata = { "name" : "include_above_highest_threshold",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def include_above_highest_threshold(self) -> bool:
        """The threshold indicates whether to include conditions above the highest threhsold."""
        return self._intf.get_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._get_include_above_highest_threshold_metadata)

    _set_include_above_highest_threshold_metadata = { "name" : "include_above_highest_threshold",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @include_above_highest_threshold.setter
    def include_above_highest_threshold(self, includeAboveHighestThreshold:bool) -> None:
        return self._intf.set_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._set_include_above_highest_threshold_metadata, includeAboveHighestThreshold)

    _get_include_below_lowest_threshold_metadata = { "name" : "include_below_lowest_threshold",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def include_below_lowest_threshold(self) -> bool:
        """The threshold indicates whether to include conditions below the lowest threhsolds."""
        return self._intf.get_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._get_include_below_lowest_threshold_metadata)

    _set_include_below_lowest_threshold_metadata = { "name" : "include_below_lowest_threshold",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @include_below_lowest_threshold.setter
    def include_below_lowest_threshold(self, includeBelowLowestThreshold:bool) -> None:
        return self._intf.set_property(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._set_include_below_lowest_threshold_metadata, includeBelowLowestThreshold)

    _set_thresholds_and_labels_metadata = { "name" : "set_thresholds_and_labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.LPSAFEARRAY_arg,) }
    def set_thresholds_and_labels(self, thresholds:list, thresholdLabels:list) -> None:
        """Set thresholds and threshold labels."""
        return self._intf.invoke(ICalculationToolConditionSetScalarThresholds._metadata, ICalculationToolConditionSetScalarThresholds._set_thresholds_and_labels_metadata, thresholds, thresholdLabels)


agcls.AgClassCatalog.add_catalog_entry("{57392078-7821-4910-B734-76B5C70CB6D9}", ICalculationToolConditionSetScalarThresholds)
agcls.AgTypeNameMap["ICalculationToolConditionSetScalarThresholds"] = ICalculationToolConditionSetScalarThresholds

class IAnalysisWorkbenchConverge(object):
    """Represents a base class for convergence definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{28B17124-9BE6-4437-A7ED-0DDC24353430}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchConverge)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchConverge)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchConverge, None)
    

agcls.AgClassCatalog.add_catalog_entry("{28B17124-9BE6-4437-A7ED-0DDC24353430}", IAnalysisWorkbenchConverge)
agcls.AgTypeNameMap["IAnalysisWorkbenchConverge"] = IAnalysisWorkbenchConverge

class ICalculationToolConvergeBasic(object):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_sense" : 1,
                             "set_sense" : 2,
                             "get_time_tolerance" : 3,
                             "set_time_tolerance" : 4,
                             "get_absolute_tolerance" : 5,
                             "set_absolute_tolerance" : 6,
                             "get_relative_tolerance" : 7,
                             "set_relative_tolerance" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolConvergeBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolConvergeBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolConvergeBasic, None)
    
    _get_sense_metadata = { "name" : "sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_THRESH_CONVERGE_SENSE),) }
    @property
    def sense(self) -> "CRDN_THRESH_CONVERGE_SENSE":
        """Get the convergence sense which determines whether the converged value should be limited to just within or just outside of condition boundaries."""
        return self._intf.get_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._get_sense_metadata)

    _set_sense_metadata = { "name" : "sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_THRESH_CONVERGE_SENSE),) }
    @sense.setter
    def sense(self, sense:"CRDN_THRESH_CONVERGE_SENSE") -> None:
        return self._intf.set_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._set_sense_metadata, sense)

    _get_time_tolerance_metadata = { "name" : "time_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_tolerance(self) -> float:
        """Get the time tolerance which determines the time accuracy of the converged value."""
        return self._intf.get_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._get_time_tolerance_metadata)

    _set_time_tolerance_metadata = { "name" : "time_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_tolerance.setter
    def time_tolerance(self, timeTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._set_time_tolerance_metadata, timeTolerance)

    _get_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines the distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._set_absolute_tolerance_metadata, absoluteTolerance)

    _get_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines the relative distance between the value and the boundaries within which the value is considered converged."""
        return self._intf.get_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolConvergeBasic._metadata, ICalculationToolConvergeBasic._set_relative_tolerance_metadata, relativeTolerance)


agcls.AgClassCatalog.add_catalog_entry("{125C9FCD-9D41-4694-B299-5A9EAD8D1BC0}", ICalculationToolConvergeBasic)
agcls.AgTypeNameMap["ICalculationToolConvergeBasic"] = ICalculationToolConvergeBasic

class IAnalysisWorkbenchDerivative(object):
    """Represents a base class for derivative definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{737042BD-D873-4CF6-B5D5-6769849156FD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchDerivative)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchDerivative)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchDerivative, None)
    

agcls.AgClassCatalog.add_catalog_entry("{737042BD-D873-4CF6-B5D5-6769849156FD}", IAnalysisWorkbenchDerivative)
agcls.AgTypeNameMap["IAnalysisWorkbenchDerivative"] = IAnalysisWorkbenchDerivative

class ICalculationToolDerivativeBasic(object):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CD450BBA-9F54-4F15-B067-C5A80C970FA9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_time_step" : 1,
                             "set_time_step" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolDerivativeBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolDerivativeBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolDerivativeBasic, None)
    
    _get_time_step_metadata = { "name" : "time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_step(self) -> float:
        """Get the time step used for numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(ICalculationToolDerivativeBasic._metadata, ICalculationToolDerivativeBasic._get_time_step_metadata)

    _set_time_step_metadata = { "name" : "time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_step.setter
    def time_step(self, timeStep:float) -> None:
        return self._intf.set_property(ICalculationToolDerivativeBasic._metadata, ICalculationToolDerivativeBasic._set_time_step_metadata, timeStep)


agcls.AgClassCatalog.add_catalog_entry("{CD450BBA-9F54-4F15-B067-C5A80C970FA9}", ICalculationToolDerivativeBasic)
agcls.AgTypeNameMap["ICalculationToolDerivativeBasic"] = ICalculationToolDerivativeBasic

class ITimeToolEvent(object):
    """Define an event (time instant)."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "get_today" : 2,
                             "get_tomorrow" : 3,
                             "get_noon_today" : 4,
                             "get_noon_tomorrow" : 5,
                             "find_occurrence" : 6,
                             "occurs_before" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEvent)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEvent)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEvent, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_TYPE":
        """Return the type of time instant."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_type_metadata)

    _get_today_metadata = { "name" : "today",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def today(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT midnight."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_today_metadata)

    _get_tomorrow_metadata = { "name" : "tomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def tomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT midnight."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_tomorrow_metadata)

    _get_noon_today_metadata = { "name" : "noon_today",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def noon_today(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to today's GMT noon."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_noon_today_metadata)

    _get_noon_tomorrow_metadata = { "name" : "noon_tomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def noon_tomorrow(self) -> "ITimeToolEvent":
        """Return time instant that corresponds to tomorrow's GMT noon."""
        return self._intf.get_property(ITimeToolEvent._metadata, ITimeToolEvent._get_noon_tomorrow_metadata)

    _find_occurrence_metadata = { "name" : "find_occurrence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def find_occurrence(self) -> "TimeToolEventFindOccurrenceResult":
        """Return computed time instance if it occurs."""
        return self._intf.invoke(ITimeToolEvent._metadata, ITimeToolEvent._find_occurrence_metadata, out_arg())

    _occurs_before_metadata = { "name" : "occurs_before",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def occurs_before(self, epoch:typing.Any) -> bool:
        """Return true if computed time instance occurs before or at specified time, return false otherwise."""
        return self._intf.invoke(ITimeToolEvent._metadata, ITimeToolEvent._occurs_before_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E9C2A250-1D43-461D-B3B4-FAA475AB8E20}", ITimeToolEvent)
agcls.AgTypeNameMap["ITimeToolEvent"] = ITimeToolEvent

class ITimeToolEventArray(object):
    """An ordered array of times, which may or may not be evenly spaced."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "find_times" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArray)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArray)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArray, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_ARRAY_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_ARRAY_TYPE":
        """Return the type of time array."""
        return self._intf.get_property(ITimeToolEventArray._metadata, ITimeToolEventArray._get_type_metadata)

    _find_times_metadata = { "name" : "find_times",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def find_times(self) -> "TimeToolFindTimesResult":
        """Return computed array of times."""
        return self._intf.invoke(ITimeToolEventArray._metadata, ITimeToolEventArray._find_times_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{902D7BD2-E6AF-4EC6-A689-2C1ED5C8EB8B}", ITimeToolEventArray)
agcls.AgTypeNameMap["ITimeToolEventArray"] = ITimeToolEventArray

class ITimeToolEventArrayConditionCrossings(object):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_satisfaction_crossing" : 1,
                             "set_satisfaction_crossing" : 2,
                             "get_condition" : 3,
                             "set_condition" : 4,
                             "get_custom_time_limits" : 5,
                             "set_custom_time_limits" : 6,
                             "get_use_custom_time_limits" : 7,
                             "set_use_custom_time_limits" : 8,
                             "get_save_data_option" : 9,
                             "set_save_data_option" : 10,
                             "get_sampling" : 11,
                             "set_sampling" : 12,
                             "get_convergence" : 13,
                             "set_convergence" : 14, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayConditionCrossings)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayConditionCrossings)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayConditionCrossings, None)
    
    _get_satisfaction_crossing_metadata = { "name" : "satisfaction_crossing",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SATISFACTION_CROSSING),) }
    @property
    def satisfaction_crossing(self) -> "CRDN_SATISFACTION_CROSSING":
        """The direction of interest for satisfaction crossing."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_satisfaction_crossing_metadata)

    _set_satisfaction_crossing_metadata = { "name" : "satisfaction_crossing",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SATISFACTION_CROSSING),) }
    @satisfaction_crossing.setter
    def satisfaction_crossing(self, satisfactionCrossing:"CRDN_SATISFACTION_CROSSING") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_satisfaction_crossing_metadata, satisfactionCrossing)

    _get_condition_metadata = { "name" : "condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_condition_metadata)

    _set_condition_metadata = { "name" : "condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_condition_metadata, condition)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """Specify the interval list within which satisfaction crossing times are sought. The default is set to overall availability of host object. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed satisfaction crossing times are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when crossing times are found."""
        return self._intf.get_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ITimeToolEventArrayConditionCrossings._metadata, ITimeToolEventArrayConditionCrossings._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{EB34F16B-8AAF-4DE8-B5FB-7468FD2881D5}", ITimeToolEventArrayConditionCrossings)
agcls.AgTypeNameMap["ITimeToolEventArrayConditionCrossings"] = ITimeToolEventArrayConditionCrossings

class ITimeToolEventArrayExtrema(object):
    """Determine times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{664C3048-BB87-4841-988A-0580F2976C0D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_extremum_type" : 1,
                             "set_extremum_type" : 2,
                             "get_is_global" : 3,
                             "set_is_global" : 4,
                             "get_calculation" : 5,
                             "set_calculation" : 6,
                             "get_custom_time_limits" : 7,
                             "set_custom_time_limits" : 8,
                             "get_use_custom_time_limits" : 9,
                             "set_use_custom_time_limits" : 10,
                             "get_save_data_option" : 11,
                             "set_save_data_option" : 12,
                             "get_sampling" : 13,
                             "set_sampling" : 14,
                             "get_convergence" : 15,
                             "set_convergence" : 16, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayExtrema)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayExtrema)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayExtrema, None)
    
    _get_extremum_type_metadata = { "name" : "extremum_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EXTREMUM_CONSTANTS),) }
    @property
    def extremum_type(self) -> "CRDN_EXTREMUM_CONSTANTS":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_extremum_type_metadata)

    _set_extremum_type_metadata = { "name" : "extremum_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EXTREMUM_CONSTANTS),) }
    @extremum_type.setter
    def extremum_type(self, extremumType:"CRDN_EXTREMUM_CONSTANTS") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_extremum_type_metadata, extremumType)

    _get_is_global_metadata = { "name" : "is_global",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_global(self) -> bool:
        """Indicate whether to perform local or global search. The default is false."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_is_global_metadata)

    _set_is_global_metadata = { "name" : "is_global",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @is_global.setter
    def is_global(self, isGlobal:bool) -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_is_global_metadata, isGlobal)

    _get_calculation_metadata = { "name" : "calculation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_calculation_metadata)

    _set_calculation_metadata = { "name" : "calculation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @calculation.setter
    def calculation(self, calculation:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_calculation_metadata, calculation)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Specify whether computed times of extrema are saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ITimeToolEventArrayExtrema._metadata, ITimeToolEventArrayExtrema._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{664C3048-BB87-4841-988A-0580F2976C0D}", ITimeToolEventArrayExtrema)
agcls.AgTypeNameMap["ITimeToolEventArrayExtrema"] = ITimeToolEventArrayExtrema

class ITimeToolEventArrayFactory(object):
    """The factory creates event arrays."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE43C07E-4626-4CEA-A625-C42052111CDE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_event_array_extrema" : 2,
                             "create_event_array_start_stop_times" : 3,
                             "create_event_array_merged" : 4,
                             "create_event_array_filtered" : 5,
                             "create_event_array_fixed_step" : 6,
                             "create_event_array_condition_crossings" : 7,
                             "create_event_array_signaled" : 8,
                             "is_type_supported" : 9,
                             "create_event_array_fixed_times" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_EVENT_ARRAY_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_ARRAY_TYPE") -> "ITimeToolEventArray":
        """Create and register an event array using specified name, description, and type."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_metadata, name, description, type, out_arg())

    _create_event_array_extrema_metadata = { "name" : "create_event_array_extrema",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_extrema(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by determining times of local minimum and/or maximum of specified scalar calculation."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_extrema_metadata, name, description, out_arg())

    _create_event_array_start_stop_times_metadata = { "name" : "create_event_array_start_stop_times",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_start_stop_times(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by taking start and/or stop times of every interval in the specified reference interval list and adding them to array."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_start_stop_times_metadata, name, description, out_arg())

    _create_event_array_merged_metadata = { "name" : "create_event_array_merged",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_merged(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_merged_metadata, name, description, out_arg())

    _create_event_array_filtered_metadata = { "name" : "create_event_array_filtered",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_filtered(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array by filtering times from an original time array according to specified filtering method."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_filtered_metadata, name, description, out_arg())

    _create_event_array_fixed_step_metadata = { "name" : "create_event_array_fixed_step",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_fixed_step(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using fixed time steps from the specified time reference and adding sampled times to array if they fall within specified bounding interval list."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_fixed_step_metadata, name, description, out_arg())

    _create_event_array_condition_crossings_metadata = { "name" : "create_event_array_condition_crossings",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_condition_crossings(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array containing times at which the specified condition will change its satisfaction status."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_condition_crossings_metadata, name, description, out_arg())

    _create_event_array_signaled_metadata = { "name" : "create_event_array_signaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_signaled(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array recorded at target clock location by performing signal transmission of original time array between base and target clock locations."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_signaled_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_ARRAY_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_ARRAY_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._is_type_supported_metadata, eType, out_arg())

    _create_event_array_fixed_times_metadata = { "name" : "create_event_array_fixed_times",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_array_fixed_times(self, name:str, description:str) -> "ITimeToolEventArray":
        """Create an event array using specified times."""
        return self._intf.invoke(ITimeToolEventArrayFactory._metadata, ITimeToolEventArrayFactory._create_event_array_fixed_times_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CE43C07E-4626-4CEA-A625-C42052111CDE}", ITimeToolEventArrayFactory)
agcls.AgTypeNameMap["ITimeToolEventArrayFactory"] = ITimeToolEventArrayFactory

class ITimeToolEventArrayFiltered(object):
    """Defined by filtering times from original time array according to specified filtering method."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_time_array" : 1,
                             "set_original_time_array" : 2,
                             "get_filter_type" : 3,
                             "set_filter_type" : 4,
                             "get_count" : 5,
                             "set_count" : 6,
                             "get_step" : 7,
                             "set_step" : 8,
                             "get_include_interval_stop_times" : 9,
                             "set_include_interval_stop_times" : 10,
                             "get_filter_interval_list" : 11,
                             "set_filter_interval_list" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayFiltered)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayFiltered)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayFiltered, None)
    
    _get_original_time_array_metadata = { "name" : "original_time_array",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_time_array(self) -> "ITimeToolEventArray":
        """The original time array."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_original_time_array_metadata)

    _set_original_time_array_metadata = { "name" : "original_time_array",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"),) }
    @original_time_array.setter
    def original_time_array(self, originalTimeArray:"ITimeToolEventArray") -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_original_time_array_metadata, originalTimeArray)

    _get_filter_type_metadata = { "name" : "filter_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_ARRAY_FILTER_TYPE),) }
    @property
    def filter_type(self) -> "CRDN_EVENT_ARRAY_FILTER_TYPE":
        """Skip Time Steps filter type omits from filtered time array any times that fall within specified time step of last accepted time sample. Skip Count filter type omits specified number of time samples since last accepted time sample..."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_filter_type_metadata)

    _set_filter_type_metadata = { "name" : "filter_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_ARRAY_FILTER_TYPE),) }
    @filter_type.setter
    def filter_type(self, filterType:"CRDN_EVENT_ARRAY_FILTER_TYPE") -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_filter_type_metadata, filterType)

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def count(self) -> int:
        """Specify the number of times skipped between accepted samples when FilterType is set to Skip Count..."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_count_metadata)

    _set_count_metadata = { "name" : "count",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @count.setter
    def count(self, count:int) -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_count_metadata, count)

    _get_step_metadata = { "name" : "step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def step(self) -> float:
        """The number of steps skipped between accepted samples when FilterType is set to Skip Time Steps."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_step_metadata)

    _set_step_metadata = { "name" : "step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @step.setter
    def step(self, step:float) -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_step_metadata, step)

    _get_include_interval_stop_times_metadata = { "name" : "include_interval_stop_times",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def include_interval_stop_times(self) -> bool:
        """If set to true, includes stop times of each interval from original time array."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_include_interval_stop_times_metadata)

    _set_include_interval_stop_times_metadata = { "name" : "include_interval_stop_times",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @include_interval_stop_times.setter
    def include_interval_stop_times(self, includeIntervalStopTimes:bool) -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_include_interval_stop_times_metadata, includeIntervalStopTimes)

    _get_filter_interval_list_metadata = { "name" : "filter_interval_list",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def filter_interval_list(self) -> "ITimeToolEventIntervalList":
        """The interval list used to filter samples when FilterType is set to Skip Intervals."""
        return self._intf.get_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._get_filter_interval_list_metadata)

    _set_filter_interval_list_metadata = { "name" : "filter_interval_list",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @filter_interval_list.setter
    def filter_interval_list(self, filterIntervalList:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventArrayFiltered._metadata, ITimeToolEventArrayFiltered._set_filter_interval_list_metadata, filterIntervalList)


agcls.AgClassCatalog.add_catalog_entry("{059DDDC0-4E0C-42B8-A813-0D68124BD1C1}", ITimeToolEventArrayFiltered)
agcls.AgTypeNameMap["ITimeToolEventArrayFiltered"] = ITimeToolEventArrayFiltered

class ITimeToolEventArrayFixedStep(object):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_bounding_interval_list" : 1,
                             "set_bounding_interval_list" : 2,
                             "get_sampling_time_step" : 3,
                             "set_sampling_time_step" : 4,
                             "get_include_interval_edges" : 5,
                             "set_include_interval_edges" : 6,
                             "get_reference_type" : 7,
                             "set_reference_type" : 8,
                             "get_reference_time_instant" : 9,
                             "set_reference_time_instant" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayFixedStep)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayFixedStep)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayFixedStep, None)
    
    _get_bounding_interval_list_metadata = { "name" : "bounding_interval_list",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def bounding_interval_list(self) -> "ITimeToolEventIntervalList":
        """The bounding interval list."""
        return self._intf.get_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._get_bounding_interval_list_metadata)

    _set_bounding_interval_list_metadata = { "name" : "bounding_interval_list",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @bounding_interval_list.setter
    def bounding_interval_list(self, boundingIntervalList:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._set_bounding_interval_list_metadata, boundingIntervalList)

    _get_sampling_time_step_metadata = { "name" : "sampling_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def sampling_time_step(self) -> float:
        """The sampling time step."""
        return self._intf.get_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._get_sampling_time_step_metadata)

    _set_sampling_time_step_metadata = { "name" : "sampling_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @sampling_time_step.setter
    def sampling_time_step(self, samplingTimeStep:float) -> None:
        return self._intf.set_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._set_sampling_time_step_metadata, samplingTimeStep)

    _get_include_interval_edges_metadata = { "name" : "include_interval_edges",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def include_interval_edges(self) -> bool:
        """Specify whether to include interval edges."""
        return self._intf.get_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._get_include_interval_edges_metadata)

    _set_include_interval_edges_metadata = { "name" : "include_interval_edges",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @include_interval_edges.setter
    def include_interval_edges(self, includeIntervalEdges:bool) -> None:
        return self._intf.set_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._set_include_interval_edges_metadata, includeIntervalEdges)

    _get_reference_type_metadata = { "name" : "reference_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAMPLED_REFERENCE_TIME),) }
    @property
    def reference_type(self) -> "CRDN_SAMPLED_REFERENCE_TIME":
        """Specify the time reference from which fixed sampling time steps are taken. Note: selecting Start/Stop of each Interval resets the time reference for each interval, whereas other types maintain single reference for entire array."""
        return self._intf.get_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._get_reference_type_metadata)

    _set_reference_type_metadata = { "name" : "reference_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAMPLED_REFERENCE_TIME),) }
    @reference_type.setter
    def reference_type(self, referenceType:"CRDN_SAMPLED_REFERENCE_TIME") -> None:
        return self._intf.set_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._set_reference_type_metadata, referenceType)

    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant. Only applicable if the ReferenceType is set to time instant."""
        return self._intf.get_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventArrayFixedStep._metadata, ITimeToolEventArrayFixedStep._set_reference_time_instant_metadata, referenceTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{72E47D3D-D54C-4840-BA0C-D6DCB27D964F}", ITimeToolEventArrayFixedStep)
agcls.AgTypeNameMap["ITimeToolEventArrayFixedStep"] = ITimeToolEventArrayFixedStep

class ITimeToolEventArrayFixedTimes(object):
    """Array defined by time ordered instants each explicitly specified."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_array_times" : 1,
                             "set_array_times" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayFixedTimes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayFixedTimes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayFixedTimes, None)
    
    _get_array_times_metadata = { "name" : "array_times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def array_times(self) -> list:
        """The array of times."""
        return self._intf.get_property(ITimeToolEventArrayFixedTimes._metadata, ITimeToolEventArrayFixedTimes._get_array_times_metadata)

    _set_array_times_metadata = { "name" : "set_array_times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def set_array_times(self, times:list) -> None:
        """Set array of times."""
        return self._intf.invoke(ITimeToolEventArrayFixedTimes._metadata, ITimeToolEventArrayFixedTimes._set_array_times_metadata, times)


agcls.AgClassCatalog.add_catalog_entry("{7C4ADAD2-9E29-466B-96E8-F2322EDECCDE}", ITimeToolEventArrayFixedTimes)
agcls.AgTypeNameMap["ITimeToolEventArrayFixedTimes"] = ITimeToolEventArrayFixedTimes

class ITimeToolEventArrayMerged(object):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_time_array_a" : 1,
                             "set_time_array_a" : 2,
                             "get_time_array_b" : 3,
                             "set_time_array_b" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayMerged)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayMerged)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayMerged, None)
    
    _get_time_array_a_metadata = { "name" : "time_array_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def time_array_a(self) -> "ITimeToolEventArray":
        """The first time array."""
        return self._intf.get_property(ITimeToolEventArrayMerged._metadata, ITimeToolEventArrayMerged._get_time_array_a_metadata)

    _set_time_array_a_metadata = { "name" : "time_array_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"),) }
    @time_array_a.setter
    def time_array_a(self, timeArrayA:"ITimeToolEventArray") -> None:
        return self._intf.set_property(ITimeToolEventArrayMerged._metadata, ITimeToolEventArrayMerged._set_time_array_a_metadata, timeArrayA)

    _get_time_array_b_metadata = { "name" : "time_array_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def time_array_b(self) -> "ITimeToolEventArray":
        """The second time array."""
        return self._intf.get_property(ITimeToolEventArrayMerged._metadata, ITimeToolEventArrayMerged._get_time_array_b_metadata)

    _set_time_array_b_metadata = { "name" : "time_array_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"),) }
    @time_array_b.setter
    def time_array_b(self, timeArrayB:"ITimeToolEventArray") -> None:
        return self._intf.set_property(ITimeToolEventArrayMerged._metadata, ITimeToolEventArrayMerged._set_time_array_b_metadata, timeArrayB)


agcls.AgClassCatalog.add_catalog_entry("{89FC5C8B-0A2A-4256-AA66-D6125A63D30A}", ITimeToolEventArrayMerged)
agcls.AgTypeNameMap["ITimeToolEventArrayMerged"] = ITimeToolEventArrayMerged

class ITimeToolEventArraySignaled(object):
    """Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_time_array" : 1,
                             "set_original_time_array" : 2,
                             "get_signal_sense" : 3,
                             "set_signal_sense" : 4,
                             "get_base_clock_location" : 5,
                             "set_base_clock_location" : 6,
                             "get_target_clock_location" : 7,
                             "set_target_clock_location" : 8,
                             "get_signal_delay" : 9,
                             "set_signal_delay" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArraySignaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArraySignaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArraySignaled, None)
    
    _get_original_time_array_metadata = { "name" : "original_time_array",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_time_array(self) -> "ITimeToolEventArray":
        """The original time array."""
        return self._intf.get_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._get_original_time_array_metadata)

    _set_original_time_array_metadata = { "name" : "original_time_array",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventArray"),) }
    @original_time_array.setter
    def original_time_array(self, originalTimeArray:"ITimeToolEventArray") -> None:
        return self._intf.set_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._set_original_time_array_metadata, originalTimeArray)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(ITimeToolEventArraySignaled._metadata, ITimeToolEventArraySignaled._set_signal_delay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{5E3991A8-CF15-4B73-982C-2EDF928B7BC8}", ITimeToolEventArraySignaled)
agcls.AgTypeNameMap["ITimeToolEventArraySignaled"] = ITimeToolEventArraySignaled

class ITimeToolEventArrayStartStopTimes(object):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1AB79442-7711-4342-B944-81C51D14FBE4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_stop_option" : 1,
                             "set_start_stop_option" : 2,
                             "get_reference_intervals" : 3,
                             "set_reference_intervals" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventArrayStartStopTimes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventArrayStartStopTimes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventArrayStartStopTimes, None)
    
    _get_start_stop_option_metadata = { "name" : "start_stop_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_START_STOP_OPTION),) }
    @property
    def start_stop_option(self) -> "CRDN_START_STOP_OPTION":
        """The edge type. At least one of the two edge types must be selected."""
        return self._intf.get_property(ITimeToolEventArrayStartStopTimes._metadata, ITimeToolEventArrayStartStopTimes._get_start_stop_option_metadata)

    _set_start_stop_option_metadata = { "name" : "start_stop_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_START_STOP_OPTION),) }
    @start_stop_option.setter
    def start_stop_option(self, startStopOption:"CRDN_START_STOP_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventArrayStartStopTimes._metadata, ITimeToolEventArrayStartStopTimes._set_start_stop_option_metadata, startStopOption)

    _get_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(ITimeToolEventArrayStartStopTimes._metadata, ITimeToolEventArrayStartStopTimes._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventArrayStartStopTimes._metadata, ITimeToolEventArrayStartStopTimes._set_reference_intervals_metadata, referenceIntervals)


agcls.AgClassCatalog.add_catalog_entry("{1AB79442-7711-4342-B944-81C51D14FBE4}", ITimeToolEventArrayStartStopTimes)
agcls.AgTypeNameMap["ITimeToolEventArrayStartStopTimes"] = ITimeToolEventArrayStartStopTimes

class ITimeToolEventEpoch(object):
    """Event set at specified date/time."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_epoch" : 1,
                             "set_epoch" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventEpoch)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventEpoch)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventEpoch, None)
    
    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """An explicit date/time, set using any STK date format."""
        return self._intf.get_property(ITimeToolEventEpoch._metadata, ITimeToolEventEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "name" : "epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(ITimeToolEventEpoch._metadata, ITimeToolEventEpoch._set_epoch_metadata, epoch)


agcls.AgClassCatalog.add_catalog_entry("{EB56DBC2-8BD6-4A66-A0EC-22BEB9853EA0}", ITimeToolEventEpoch)
agcls.AgTypeNameMap["ITimeToolEventEpoch"] = ITimeToolEventEpoch

class ITimeToolEventExtremum(object):
    """Determine time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C588FDD4-2008-4C33-AA63-1C59565AE4F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_extremum_type" : 1,
                             "set_extremum_type" : 2,
                             "get_calculation" : 3,
                             "set_calculation" : 4,
                             "get_custom_time_limits" : 5,
                             "set_custom_time_limits" : 6,
                             "get_use_custom_time_limits" : 7,
                             "set_use_custom_time_limits" : 8,
                             "get_save_data_option" : 9,
                             "set_save_data_option" : 10,
                             "get_sampling" : 11,
                             "set_sampling" : 12,
                             "get_convergence" : 13,
                             "set_convergence" : 14, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventExtremum)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventExtremum)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventExtremum, None)
    
    _get_extremum_type_metadata = { "name" : "extremum_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EXTREMUM_CONSTANTS),) }
    @property
    def extremum_type(self) -> "CRDN_EXTREMUM_CONSTANTS":
        """The extremum type of interest (either minimum or maximum) for scalar calculation."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_extremum_type_metadata)

    _set_extremum_type_metadata = { "name" : "extremum_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EXTREMUM_CONSTANTS),) }
    @extremum_type.setter
    def extremum_type(self, extremumType:"CRDN_EXTREMUM_CONSTANTS") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_extremum_type_metadata, extremumType)

    _get_calculation_metadata = { "name" : "calculation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def calculation(self) -> "ICalculationToolScalar":
        """The scalar calculation."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_calculation_metadata)

    _set_calculation_metadata = { "name" : "calculation",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @calculation.setter
    def calculation(self, calculation:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_calculation_metadata, calculation)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ITimeToolEventExtremum._metadata, ITimeToolEventExtremum._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{C588FDD4-2008-4C33-AA63-1C59565AE4F3}", ITimeToolEventExtremum)
agcls.AgTypeNameMap["ITimeToolEventExtremum"] = ITimeToolEventExtremum

class ITimeToolEventFactory(object):
    """The factory creates events."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{803DD343-F271-47D9-8D71-2092DD2A3387}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_today" : 1,
                             "get_tomorrow" : 2,
                             "create" : 3,
                             "create_event_epoch" : 4,
                             "create_event_extremum" : 5,
                             "create_event_start_stop_time" : 6,
                             "create_event_signaled" : 7,
                             "create_event_time_offset" : 8,
                             "create_smart_epoch_from_time" : 9,
                             "create_smart_epoch_from_event" : 10,
                             "is_type_supported" : 11, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventFactory, None)
    
    _get_today_metadata = { "name" : "today",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def today(self) -> "ITimeToolEvent":
        """Return Today time instant."""
        return self._intf.get_property(ITimeToolEventFactory._metadata, ITimeToolEventFactory._get_today_metadata)

    _get_tomorrow_metadata = { "name" : "tomorrow",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def tomorrow(self) -> "ITimeToolEvent":
        """Return Tomorrow time instant."""
        return self._intf.get_property(ITimeToolEventFactory._metadata, ITimeToolEventFactory._get_tomorrow_metadata)

    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_EVENT_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_TYPE") -> "ITimeToolEvent":
        """Create and registers an event using specified name, description, and type."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_metadata, name, description, type, out_arg())

    _create_event_epoch_metadata = { "name" : "create_event_epoch",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_epoch(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event set at a specified date/time."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_event_epoch_metadata, name, description, out_arg())

    _create_event_extremum_metadata = { "name" : "create_event_extremum",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_extremum(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event that determines the time of global minimum or maximum of specified scalar calculation."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_event_extremum_metadata, name, description, out_arg())

    _create_event_start_stop_time_metadata = { "name" : "create_event_start_stop_time",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_start_stop_time(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event that is either the start or stop time selected from a reference interval."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_event_start_stop_time_metadata, name, description, out_arg())

    _create_event_signaled_metadata = { "name" : "create_event_signaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_signaled(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event recorded on a specified clock via signal transmission from an original time instant recorded on different clock."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_event_signaled_metadata, name, description, out_arg())

    _create_event_time_offset_metadata = { "name" : "create_event_time_offset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_time_offset(self, name:str, description:str) -> "ITimeToolEvent":
        """Create an event at fixed offset from specified reference event."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_event_time_offset_metadata, name, description, out_arg())

    _create_smart_epoch_from_time_metadata = { "name" : "create_smart_epoch_from_time",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def create_smart_epoch_from_time(self, epoch:typing.Any) -> "TimeToolEventSmartEpoch":
        """Create a smart epoch from STK epoch."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_smart_epoch_from_time_metadata, epoch, out_arg())

    _create_smart_epoch_from_event_metadata = { "name" : "create_smart_epoch_from_event",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"), agmarshall.AgInterface_out_arg,) }
    def create_smart_epoch_from_event(self, refEvent:"ITimeToolEvent") -> "TimeToolEventSmartEpoch":
        """Create a smart epoch from an event."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._create_smart_epoch_from_event_metadata, refEvent, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ITimeToolEventFactory._metadata, ITimeToolEventFactory._is_type_supported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{803DD343-F271-47D9-8D71-2092DD2A3387}", ITimeToolEventFactory)
agcls.AgTypeNameMap["ITimeToolEventFactory"] = ITimeToolEventFactory

class ITimeToolEventInterval(object):
    """A single time interval."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "get_label_start_description" : 2,
                             "get_label_stop_description" : 3,
                             "get_label_start" : 4,
                             "get_label_stop" : 5,
                             "find_interval" : 6,
                             "occurred" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventInterval)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventInterval)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventInterval, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_TYPE":
        """Return the type of interval."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_type_metadata)

    _get_label_start_description_metadata = { "name" : "label_start_description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_start_description(self) -> str:
        """The start description."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_start_description_metadata)

    _get_label_stop_description_metadata = { "name" : "label_stop_description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_stop_description(self) -> str:
        """The stop description."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_stop_description_metadata)

    _get_label_start_metadata = { "name" : "label_start",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_start(self) -> str:
        """A label associated with the interval start."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_start_metadata)

    _get_label_stop_metadata = { "name" : "label_stop",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_stop(self) -> str:
        """A label associated with the interval stop."""
        return self._intf.get_property(ITimeToolEventInterval._metadata, ITimeToolEventInterval._get_label_stop_metadata)

    _find_interval_metadata = { "name" : "find_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def find_interval(self) -> "TimeToolEventIntervalResult":
        """Return computed interval if it exists."""
        return self._intf.invoke(ITimeToolEventInterval._metadata, ITimeToolEventInterval._find_interval_metadata, out_arg())

    _occurred_metadata = { "name" : "occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval if it exists."""
        return self._intf.invoke(ITimeToolEventInterval._metadata, ITimeToolEventInterval._occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{3CCAC5BD-7F97-4596-BD49-7E4A80A767A0}", ITimeToolEventInterval)
agcls.AgTypeNameMap["ITimeToolEventInterval"] = ITimeToolEventInterval

class ITimeToolEventIntervalBetweenTimeInstants(object):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18236EC1-B691-4FFD-995B-FB4896BAFD71}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time_instant" : 1,
                             "set_start_time_instant" : 2,
                             "get_stop_time_instant" : 3,
                             "set_stop_time_instant" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalBetweenTimeInstants)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalBetweenTimeInstants)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalBetweenTimeInstants, None)
    
    _get_start_time_instant_metadata = { "name" : "start_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def start_time_instant(self) -> "ITimeToolEvent":
        """The start time instant of the interval."""
        return self._intf.get_property(ITimeToolEventIntervalBetweenTimeInstants._metadata, ITimeToolEventIntervalBetweenTimeInstants._get_start_time_instant_metadata)

    _set_start_time_instant_metadata = { "name" : "start_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @start_time_instant.setter
    def start_time_instant(self, startTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventIntervalBetweenTimeInstants._metadata, ITimeToolEventIntervalBetweenTimeInstants._set_start_time_instant_metadata, startTimeInstant)

    _get_stop_time_instant_metadata = { "name" : "stop_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def stop_time_instant(self) -> "ITimeToolEvent":
        """The stop time instant of the interval."""
        return self._intf.get_property(ITimeToolEventIntervalBetweenTimeInstants._metadata, ITimeToolEventIntervalBetweenTimeInstants._get_stop_time_instant_metadata)

    _set_stop_time_instant_metadata = { "name" : "stop_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @stop_time_instant.setter
    def stop_time_instant(self, stopTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventIntervalBetweenTimeInstants._metadata, ITimeToolEventIntervalBetweenTimeInstants._set_stop_time_instant_metadata, stopTimeInstant)


agcls.AgClassCatalog.add_catalog_entry("{18236EC1-B691-4FFD-995B-FB4896BAFD71}", ITimeToolEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["ITimeToolEventIntervalBetweenTimeInstants"] = ITimeToolEventIntervalBetweenTimeInstants

class ITimeToolEventIntervalCollection(object):
    """A collection of related interval lists."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "get_labels" : 2,
                             "find_interval_collection" : 3,
                             "occurred" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollection, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_COLLECTION_TYPE":
        """Return the type of collection of interval lists."""
        return self._intf.get_property(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._get_type_metadata)

    _get_labels_metadata = { "name" : "labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def labels(self) -> list:
        """Get the labels associated with the interval lists in the collection."""
        return self._intf.get_property(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._get_labels_metadata)

    _find_interval_collection_metadata = { "name" : "find_interval_collection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def find_interval_collection(self) -> "TimeToolIntervalsVectorResult":
        """Return computed collection of interval lists."""
        return self._intf.invoke(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._find_interval_collection_metadata, out_arg())

    _occurred_metadata = { "name" : "occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def occurred(self, epoch:typing.Any) -> "TimeToolEventIntervalCollectionOccurredResult":
        """Determine if specified time falls within any of the computed interval lists in the collection."""
        return self._intf.invoke(ITimeToolEventIntervalCollection._metadata, ITimeToolEventIntervalCollection._occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{A23C49CC-2F4B-42A6-95B8-1FDD490F2E30}", ITimeToolEventIntervalCollection)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollection"] = ITimeToolEventIntervalCollection

class ITimeToolEventIntervalCollectionCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0253FA16-73AA-4F0A-9904-0789EC873ECB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_condition_set" : 1,
                             "set_condition_set" : 2,
                             "get_custom_time_limits" : 3,
                             "set_custom_time_limits" : 4,
                             "get_use_custom_time_limits" : 5,
                             "set_use_custom_time_limits" : 6,
                             "get_save_data_option" : 7,
                             "set_save_data_option" : 8,
                             "get_sampling" : 9,
                             "set_sampling" : 10,
                             "get_convergence" : 11,
                             "set_convergence" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionCondition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionCondition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionCondition, None)
    
    _get_condition_set_metadata = { "name" : "condition_set",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition_set(self) -> "ICalculationToolConditionSet":
        """Get/set the condition set object."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_condition_set_metadata)

    _set_condition_set_metadata = { "name" : "condition_set",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolConditionSet"),) }
    @condition_set.setter
    def condition_set(self, conditionSet:"ICalculationToolConditionSet") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_condition_set_metadata, conditionSet)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. By default it is set to overall availability of host object. This determines time limits within which global minimum or maximum is sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Specify whether to use specified custom interval list (see CustomTimeLimits)."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed time of extremum is saved/loaded, otherwise it is recomputed on load if necessary."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """A Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """A Convergence definition, which uses time tolerance to determine when time of extremum is found."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionCondition._metadata, ITimeToolEventIntervalCollectionCondition._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{0253FA16-73AA-4F0A-9904-0789EC873ECB}", ITimeToolEventIntervalCollectionCondition)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionCondition"] = ITimeToolEventIntervalCollectionCondition

class ITimeToolEventIntervalCollectionFactory(object):
    """The factory creates collections of event interval lists."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{15E2D2CF-61F9-4468-A5E1-770149F6B08C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_event_interval_collection_lighting" : 2,
                             "create_event_interval_collection_signaled" : 3,
                             "is_type_supported" : 4,
                             "create_event_interval_collection_satisfaction" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_COLLECTION_TYPE") -> "ITimeToolEventIntervalCollection":
        """Create and register an event interval collection using specified name, description, and type."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionFactory._metadata, ITimeToolEventIntervalCollectionFactory._create_metadata, name, description, type, out_arg())

    _create_event_interval_collection_lighting_metadata = { "name" : "create_event_interval_collection_lighting",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_collection_lighting(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionFactory._metadata, ITimeToolEventIntervalCollectionFactory._create_event_interval_collection_lighting_metadata, name, description, out_arg())

    _create_event_interval_collection_signaled_metadata = { "name" : "create_event_interval_collection_signaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_collection_signaled(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionFactory._metadata, ITimeToolEventIntervalCollectionFactory._create_event_interval_collection_signaled_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_COLLECTION_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_COLLECTION_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionFactory._metadata, ITimeToolEventIntervalCollectionFactory._is_type_supported_metadata, eType, out_arg())

    _create_event_interval_collection_satisfaction_metadata = { "name" : "create_event_interval_collection_satisfaction",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_collection_satisfaction(self, name:str, description:str) -> "ITimeToolEventIntervalCollection":
        """Create an event interval collection containing intervals during which condition set is satisfied."""
        return self._intf.invoke(ITimeToolEventIntervalCollectionFactory._metadata, ITimeToolEventIntervalCollectionFactory._create_event_interval_collection_satisfaction_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{15E2D2CF-61F9-4468-A5E1-770149F6B08C}", ITimeToolEventIntervalCollectionFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionFactory"] = ITimeToolEventIntervalCollectionFactory

class ITimeToolEventIntervalCollectionLighting(object):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_location" : 1,
                             "set_location" : 2,
                             "get_eclipsing_bodies" : 3,
                             "set_eclipsing_bodies" : 4,
                             "get_use_object_eclipsing_bodies" : 5,
                             "set_use_object_eclipsing_bodies" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionLighting)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionLighting)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionLighting, None)
    
    _get_location_metadata = { "name" : "location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def location(self) -> "IVectorGeometryToolPoint":
        """The location point to compute sunlight, penumbra and umbra."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._get_location_metadata)

    _set_location_metadata = { "name" : "location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @location.setter
    def location(self, location:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._set_location_metadata, location)

    _get_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionLighting._metadata, ITimeToolEventIntervalCollectionLighting._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)


agcls.AgClassCatalog.add_catalog_entry("{18530BC5-1ED6-4A66-BBBE-8A8FB4644791}", ITimeToolEventIntervalCollectionLighting)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionLighting"] = ITimeToolEventIntervalCollectionLighting

class ITimeToolEventIntervalCollectionSignaled(object):
    """Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AE464683-EEEC-46CF-8886-91F7A30B7859}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_collection" : 1,
                             "set_original_collection" : 2,
                             "get_signal_sense" : 3,
                             "set_signal_sense" : 4,
                             "get_base_clock_location" : 5,
                             "set_base_clock_location" : 6,
                             "get_target_clock_location" : 7,
                             "set_target_clock_location" : 8,
                             "get_signal_delay" : 9,
                             "set_signal_delay" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalCollectionSignaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalCollectionSignaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalCollectionSignaled, None)
    
    _get_original_collection_metadata = { "name" : "original_collection",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_collection(self) -> "ITimeToolEventIntervalCollection":
        """The original interval list collection."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._get_original_collection_metadata)

    _set_original_collection_metadata = { "name" : "original_collection",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalCollection"),) }
    @original_collection.setter
    def original_collection(self, originalCollection:"ITimeToolEventIntervalCollection") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._set_original_collection_metadata, originalCollection)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(ITimeToolEventIntervalCollectionSignaled._metadata, ITimeToolEventIntervalCollectionSignaled._set_signal_delay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{AE464683-EEEC-46CF-8886-91F7A30B7859}", ITimeToolEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalCollectionSignaled"] = ITimeToolEventIntervalCollectionSignaled

class ITimeToolEventIntervalFactory(object):
    """The factory creates event intervals."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F87C00CA-725C-425C-941E-6987709D788F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_event_interval_fixed" : 2,
                             "create_event_interval_fixed_duration" : 3,
                             "create_event_interval_between_time_instants" : 4,
                             "create_event_interval_from_interval_list" : 5,
                             "create_event_interval_scaled" : 6,
                             "create_event_interval_signaled" : 7,
                             "create_event_interval_time_offset" : 8,
                             "is_type_supported" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_TYPE") -> "ITimeToolEventInterval":
        """Create and register an interval using specified name, description, and type."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_metadata, name, description, type, out_arg())

    _create_event_interval_fixed_metadata = { "name" : "create_event_interval_fixed",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_fixed(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined between two explicitly specified start and stop times."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_fixed_metadata, name, description, out_arg())

    _create_event_interval_fixed_duration_metadata = { "name" : "create_event_interval_fixed_duration",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_fixed_duration(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_fixed_duration_metadata, name, description, out_arg())

    _create_event_interval_between_time_instants_metadata = { "name" : "create_event_interval_between_time_instants",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_between_time_instants(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval using specified start and stop time instants."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_between_time_instants_metadata, name, description, out_arg())

    _create_event_interval_from_interval_list_metadata = { "name" : "create_event_interval_from_interval_list",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_from_interval_list(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval from a specified interval list by using one of several selection methods."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_from_interval_list_metadata, name, description, out_arg())

    _create_event_interval_scaled_metadata = { "name" : "create_event_interval_scaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_scaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval by scaling an original interval using either absolute or relative scale."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_scaled_metadata, name, description, out_arg())

    _create_event_interval_signaled_metadata = { "name" : "create_event_interval_signaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_signaled(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval that is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_signaled_metadata, name, description, out_arg())

    _create_event_interval_time_offset_metadata = { "name" : "create_event_interval_time_offset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_time_offset(self, name:str, description:str) -> "ITimeToolEventInterval":
        """Create an interval defined by shifting the specified reference interval by a fixed time offset."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._create_event_interval_time_offset_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ITimeToolEventIntervalFactory._metadata, ITimeToolEventIntervalFactory._is_type_supported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F87C00CA-725C-425C-941E-6987709D788F}", ITimeToolEventIntervalFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalFactory"] = ITimeToolEventIntervalFactory

class ITimeToolEventIntervalFixed(object):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2DBC4523-FDD0-413B-B933-9F74B9B17BED}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_start_time" : 1,
                             "get_stop_time" : 2,
                             "set_interval" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalFixed)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalFixed)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalFixed, None)
    
    _get_start_time_metadata = { "name" : "start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_time(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(ITimeToolEventIntervalFixed._metadata, ITimeToolEventIntervalFixed._get_start_time_metadata)

    _get_stop_time_metadata = { "name" : "stop_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop_time(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(ITimeToolEventIntervalFixed._metadata, ITimeToolEventIntervalFixed._get_stop_time_metadata)

    _set_interval_metadata = { "name" : "set_interval",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def set_interval(self, startEpoch:typing.Any, stopEpoch:typing.Any) -> None:
        """Set interval's start and stop times."""
        return self._intf.invoke(ITimeToolEventIntervalFixed._metadata, ITimeToolEventIntervalFixed._set_interval_metadata, startEpoch, stopEpoch)


agcls.AgClassCatalog.add_catalog_entry("{2DBC4523-FDD0-413B-B933-9F74B9B17BED}", ITimeToolEventIntervalFixed)
agcls.AgTypeNameMap["ITimeToolEventIntervalFixed"] = ITimeToolEventIntervalFixed

class ITimeToolEventIntervalFixedDuration(object):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A20830B-D576-4DF1-9C15-51EB59AEC23F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2,
                             "get_start_offset" : 3,
                             "set_start_offset" : 4,
                             "get_stop_offset" : 5,
                             "set_stop_offset" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalFixedDuration)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalFixedDuration)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalFixedDuration, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_offset(self) -> float:
        """The start time offset value."""
        return self._intf.get_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._get_start_offset_metadata)

    _set_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_offset(self) -> float:
        """The stop time offset value."""
        return self._intf.get_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalFixedDuration._metadata, ITimeToolEventIntervalFixedDuration._set_stop_offset_metadata, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{2A20830B-D576-4DF1-9C15-51EB59AEC23F}", ITimeToolEventIntervalFixedDuration)
agcls.AgTypeNameMap["ITimeToolEventIntervalFixedDuration"] = ITimeToolEventIntervalFixedDuration

class ITimeToolEventIntervalFromIntervalList(object):
    """Interval created from specified interval list by using one of several selection methods."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DCF8AA30-67A3-4856-956D-C4952BF3818E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_intervals" : 1,
                             "set_reference_intervals" : 2,
                             "get_interval_selection" : 3,
                             "set_interval_selection" : 4,
                             "get_interval_number" : 5,
                             "set_interval_number" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalFromIntervalList)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalFromIntervalList)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalFromIntervalList, None)
    
    _get_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._set_reference_intervals_metadata, referenceIntervals)

    _get_interval_selection_metadata = { "name" : "interval_selection",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_SELECTION),) }
    @property
    def interval_selection(self) -> "CRDN_INTERVAL_SELECTION":
        """The method used to select an interval from the reference interval list."""
        return self._intf.get_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._get_interval_selection_metadata)

    _set_interval_selection_metadata = { "name" : "interval_selection",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_SELECTION),) }
    @interval_selection.setter
    def interval_selection(self, intervalSelection:"CRDN_INTERVAL_SELECTION") -> None:
        return self._intf.set_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._set_interval_selection_metadata, intervalSelection)

    _get_interval_number_metadata = { "name" : "interval_number",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def interval_number(self) -> int:
        """An interval number. Applicable only if IntervalSelection is IntervalSelectionFromStart or IntervalSelectionFromEnd."""
        return self._intf.get_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._get_interval_number_metadata)

    _set_interval_number_metadata = { "name" : "interval_number",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @interval_number.setter
    def interval_number(self, intervalNumber:int) -> None:
        return self._intf.set_property(ITimeToolEventIntervalFromIntervalList._metadata, ITimeToolEventIntervalFromIntervalList._set_interval_number_metadata, intervalNumber)


agcls.AgClassCatalog.add_catalog_entry("{DCF8AA30-67A3-4856-956D-C4952BF3818E}", ITimeToolEventIntervalFromIntervalList)
agcls.AgTypeNameMap["ITimeToolEventIntervalFromIntervalList"] = ITimeToolEventIntervalFromIntervalList

class ITimeToolEventIntervalList(object):
    """An ordered list of time intervals."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "get_labels" : 2,
                             "get_descriptions" : 3,
                             "find_intervals" : 4,
                             "occurred" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalList)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalList)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalList, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_LIST_TYPE),) }
    @property
    def type(self) -> "CRDN_EVENT_INTERVAL_LIST_TYPE":
        """Return the type of interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_type_metadata)

    _get_labels_metadata = { "name" : "labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def labels(self) -> list:
        """Get the label descriptions associated with the interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_labels_metadata)

    _get_descriptions_metadata = { "name" : "descriptions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def descriptions(self) -> list:
        """Get the labels associated with the interval list."""
        return self._intf.get_property(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._get_descriptions_metadata)

    _find_intervals_metadata = { "name" : "find_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def find_intervals(self) -> "TimeToolIntervalListResult":
        """Return computed interval list that can be empty."""
        return self._intf.invoke(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._find_intervals_metadata, out_arg())

    _occurred_metadata = { "name" : "occurred",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_BOOL_arg,) }
    def occurred(self, epoch:typing.Any) -> bool:
        """Determine if specified time falls within computed interval list."""
        return self._intf.invoke(ITimeToolEventIntervalList._metadata, ITimeToolEventIntervalList._occurred_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1FD46B70-FEBF-44E4-8336-B94D3FAC01EE}", ITimeToolEventIntervalList)
agcls.AgTypeNameMap["ITimeToolEventIntervalList"] = ITimeToolEventIntervalList

class ITimeToolEventIntervalListCondition(object):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D073568A-7398-45C2-998A-CD2EC12F06E0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_condition" : 1,
                             "set_condition" : 2,
                             "get_custom_time_limits" : 3,
                             "set_custom_time_limits" : 4,
                             "get_use_custom_time_limits" : 5,
                             "set_use_custom_time_limits" : 6,
                             "get_save_data_option" : 7,
                             "set_save_data_option" : 8,
                             "get_sampling" : 9,
                             "set_sampling" : 10,
                             "get_convergence" : 11,
                             "set_convergence" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListCondition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListCondition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListCondition, None)
    
    _get_condition_metadata = { "name" : "condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_condition_metadata)

    _set_condition_metadata = { "name" : "condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_condition_metadata, condition)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """The interval list or single interval within which intervals of satisfaction are sought. The specified value is used if UseCustomTimeLimits is true. The default is set to overall availability of host object..."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @property
    def save_data_option(self) -> "CRDN_SAVE_DATA_OPTION":
        """Determine if computed intervals of satisfaction are saved/loaded, or recomputed on load if necessary."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_save_data_option_metadata)

    _set_save_data_option_metadata = { "name" : "save_data_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAVE_DATA_OPTION),) }
    @save_data_option.setter
    def save_data_option(self, saveDataOption:"CRDN_SAVE_DATA_OPTION") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_save_data_option_metadata, saveDataOption)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times for intervals of satisfaction are found."""
        return self._intf.get_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListCondition._metadata, ITimeToolEventIntervalListCondition._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{D073568A-7398-45C2-998A-CD2EC12F06E0}", ITimeToolEventIntervalListCondition)
agcls.AgTypeNameMap["ITimeToolEventIntervalListCondition"] = ITimeToolEventIntervalListCondition

class ITimeToolEventIntervalListFactory(object):
    """The factory creates event interval lists."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_event_interval_list_merged" : 2,
                             "create_event_interval_list_filtered" : 3,
                             "create_event_interval_list_condition" : 4,
                             "create_event_interval_list_scaled" : 5,
                             "create_event_interval_list_signaled" : 6,
                             "create_event_interval_list_time_offset" : 7,
                             "is_type_supported" : 8,
                             "create_event_interval_list_file" : 9,
                             "create_event_interval_list_fixed" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_LIST_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_EVENT_INTERVAL_LIST_TYPE") -> "ITimeToolEventIntervalList":
        """Create and register an interval list using specified name, description, and type."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_metadata, name, description, type, out_arg())

    _create_event_interval_list_merged_metadata = { "name" : "create_event_interval_list_merged",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_merged(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by merging two constituent interval lists using specified logical operation."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_merged_metadata, name, description, out_arg())

    _create_event_interval_list_filtered_metadata = { "name" : "create_event_interval_list_filtered",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_filtered(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list by filtering intervals from original interval list using specified filtering method."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_filtered_metadata, name, description, out_arg())

    _create_event_interval_list_condition_metadata = { "name" : "create_event_interval_list_condition",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_condition(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list containing intervals during which specified condition is satisfied."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_condition_metadata, name, description, out_arg())

    _create_event_interval_list_scaled_metadata = { "name" : "create_event_interval_list_scaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_scaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by scaling every interval in original interval list using either absolute or relative scale."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_scaled_metadata, name, description, out_arg())

    _create_event_interval_list_signaled_metadata = { "name" : "create_event_interval_list_signaled",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_signaled(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list recorded at the target clock location by performing signal transmission of original interval list between base and target clock locations."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_signaled_metadata, name, description, out_arg())

    _create_event_interval_list_time_offset_metadata = { "name" : "create_event_interval_list_time_offset",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_time_offset(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Create an interval list defined by shifting the specified reference interval list by a fixed time offset."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_time_offset_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_INTERVAL_LIST_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_EVENT_INTERVAL_LIST_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._is_type_supported_metadata, eType, out_arg())

    _create_event_interval_list_file_metadata = { "name" : "create_event_interval_list_file",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_file(self, name:str, description:str, filePath:str) -> "ITimeToolEventIntervalList":
        """Create an interval list based on specified interval file."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_file_metadata, name, description, filePath, out_arg())

    _create_event_interval_list_fixed_metadata = { "name" : "create_event_interval_list_fixed",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_event_interval_list_fixed(self, name:str, description:str) -> "ITimeToolEventIntervalList":
        """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""
        return self._intf.invoke(ITimeToolEventIntervalListFactory._metadata, ITimeToolEventIntervalListFactory._create_event_interval_list_fixed_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EE3DB027-8A71-42DC-BA5C-A5F6D8B47BD7}", ITimeToolEventIntervalListFactory)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFactory"] = ITimeToolEventIntervalListFactory

class ITimeToolEventIntervalListFile(object):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A17588F4-C944-44F8-B8D8-275B13D27E3A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2,
                             "reload" : 3,
                             "get_file_span" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListFile)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListFile)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListFile, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """The path of an external file that contains the time interval list."""
        return self._intf.get_property(ITimeToolEventIntervalListFile._metadata, ITimeToolEventIntervalListFile._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListFile._metadata, ITimeToolEventIntervalListFile._set_filename_metadata, filename)

    _reload_metadata = { "name" : "reload",
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the interval list file."""
        return self._intf.invoke(ITimeToolEventIntervalListFile._metadata, ITimeToolEventIntervalListFile._reload_metadata, )

    _get_file_span_metadata = { "name" : "get_file_span",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_file_span(self) -> "TimeToolEventIntervalResult":
        """Compute the interval list file span."""
        return self._intf.invoke(ITimeToolEventIntervalListFile._metadata, ITimeToolEventIntervalListFile._get_file_span_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{A17588F4-C944-44F8-B8D8-275B13D27E3A}", ITimeToolEventIntervalListFile)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFile"] = ITimeToolEventIntervalListFile

class ITimeToolEventIntervalListFiltered(object):
    """Defined by filtering intervals from original interval list using specified filtering method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_intervals" : 1,
                             "set_original_intervals" : 2,
                             "get_filter_factory" : 3,
                             "get_filter" : 4,
                             "set_filter" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListFiltered)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListFiltered)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListFiltered, None)
    
    _get_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(ITimeToolEventIntervalListFiltered._metadata, ITimeToolEventIntervalListFiltered._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListFiltered._metadata, ITimeToolEventIntervalListFiltered._set_original_intervals_metadata, originalIntervals)

    _get_filter_factory_metadata = { "name" : "filter_factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def filter_factory(self) -> "TimeToolPruneFilterFactory":
        """Get the prune filter factory."""
        return self._intf.get_property(ITimeToolEventIntervalListFiltered._metadata, ITimeToolEventIntervalListFiltered._get_filter_factory_metadata)

    _get_filter_metadata = { "name" : "filter",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def filter(self) -> "ITimeToolPruneFilter":
        """The pruning filter."""
        return self._intf.get_property(ITimeToolEventIntervalListFiltered._metadata, ITimeToolEventIntervalListFiltered._get_filter_metadata)

    _set_filter_metadata = { "name" : "filter",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolPruneFilter"),) }
    @filter.setter
    def filter(self, filter:"ITimeToolPruneFilter") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListFiltered._metadata, ITimeToolEventIntervalListFiltered._set_filter_metadata, filter)


agcls.AgClassCatalog.add_catalog_entry("{D557D245-2747-4A6C-8A2D-D1A31A45EE5F}", ITimeToolEventIntervalListFiltered)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFiltered"] = ITimeToolEventIntervalListFiltered

class ITimeToolEventIntervalListFixed(object):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_intervals" : 1,
                             "set_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListFixed)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListFixed)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListFixed, None)
    
    _get_intervals_metadata = { "name" : "get_intervals",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_intervals(self) -> list:
        """Get intervals with explicitly specified start and stop times from interval list. The method returns a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(ITimeToolEventIntervalListFixed._metadata, ITimeToolEventIntervalListFixed._get_intervals_metadata, out_arg())

    _set_intervals_metadata = { "name" : "set_intervals",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def set_intervals(self, intervals:list) -> None:
        """Set interval list from intervals with explicitly specified start and stop times. The method takes a one-dimensional array which elements are 2-tuples of intervals' start/stop times converted according to the current unit preferences."""
        return self._intf.invoke(ITimeToolEventIntervalListFixed._metadata, ITimeToolEventIntervalListFixed._set_intervals_metadata, intervals)


agcls.AgClassCatalog.add_catalog_entry("{7C6059BB-3A9B-45E2-826A-8BCD6DFF343B}", ITimeToolEventIntervalListFixed)
agcls.AgTypeNameMap["ITimeToolEventIntervalListFixed"] = ITimeToolEventIntervalListFixed

class ITimeToolEventIntervalListMerged(object):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""

    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_interval_list_or_interval_a" : 1,
                             "get_interval_list_or_interval_b" : 2,
                             "get_merge_operation" : 3,
                             "set_merge_operation" : 4,
                             "set_interval_list_a" : 5,
                             "set_interval_a" : 6,
                             "set_interval_list_b" : 7,
                             "set_interval_b" : 8,
                             "add_interval" : 9,
                             "add_interval_list" : 10,
                             "set_interval" : 11,
                             "set_interval_list" : 12,
                             "get_time_component" : 13,
                             "get_time_component_size" : 14,
                             "remove_time_component" : 15, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListMerged)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListMerged)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListMerged, None)
    
    _get_interval_list_or_interval_a_metadata = { "name" : "interval_list_or_interval_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interval_list_or_interval_a(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval A."""
        return self._intf.get_property(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._get_interval_list_or_interval_a_metadata)

    _get_interval_list_or_interval_b_metadata = { "name" : "interval_list_or_interval_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def interval_list_or_interval_b(self) -> "IAnalysisWorkbenchComponent":
        """The interval list or interval B."""
        return self._intf.get_property(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._get_interval_list_or_interval_b_metadata)

    _get_merge_operation_metadata = { "name" : "merge_operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_LIST_MERGE_OPERATION),) }
    @property
    def merge_operation(self) -> "CRDN_EVENT_LIST_MERGE_OPERATION":
        """The merge operation."""
        return self._intf.get_property(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._get_merge_operation_metadata)

    _set_merge_operation_metadata = { "name" : "merge_operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_EVENT_LIST_MERGE_OPERATION),) }
    @merge_operation.setter
    def merge_operation(self, mergeOperation:"CRDN_EVENT_LIST_MERGE_OPERATION") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_merge_operation_metadata, mergeOperation)

    _set_interval_list_a_metadata = { "name" : "set_interval_list_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    def set_interval_list_a(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Set the interval list A."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_list_a_metadata, refIntervals)

    _set_interval_a_metadata = { "name" : "set_interval_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    def set_interval_a(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Set the interval A."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_a_metadata, refIntervals)

    _set_interval_list_b_metadata = { "name" : "set_interval_list_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    def set_interval_list_b(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Set the interval list B."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_list_b_metadata, refIntervals)

    _set_interval_b_metadata = { "name" : "set_interval_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    def set_interval_b(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Set the interval B."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_b_metadata, refIntervals)

    _add_interval_metadata = { "name" : "add_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    def add_interval(self, refIntervals:"ITimeToolEventInterval") -> None:
        """Add interval."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._add_interval_metadata, refIntervals)

    _add_interval_list_metadata = { "name" : "add_interval_list",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    def add_interval_list(self, refIntervals:"ITimeToolEventIntervalList") -> None:
        """Add interval list."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._add_interval_list_metadata, refIntervals)

    _set_interval_metadata = { "name" : "set_interval",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"), agmarshall.INT_arg,) }
    def set_interval(self, refIntervals:"ITimeToolEventInterval", pos:int) -> None:
        """Set the interval at given index."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_metadata, refIntervals, pos)

    _set_interval_list_metadata = { "name" : "set_interval_list",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"), agmarshall.INT_arg,) }
    def set_interval_list(self, refIntervals:"ITimeToolEventIntervalList", pos:int) -> None:
        """Set the interval list at given index."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._set_interval_list_metadata, refIntervals, pos)

    _get_time_component_metadata = { "name" : "get_time_component",
            "arg_types" : (agcom.INT, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.BSTR_arg,) }
    def get_time_component(self, pos:int) -> str:
        """Get time component at given position."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._get_time_component_metadata, pos, out_arg())

    _get_time_component_size_metadata = { "name" : "get_time_component_size",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    def get_time_component_size(self) -> int:
        """Get time component list size."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._get_time_component_size_metadata, out_arg())

    _remove_time_component_metadata = { "name" : "remove_time_component",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def remove_time_component(self, pos:int) -> None:
        """Remove time component at given position."""
        return self._intf.invoke(ITimeToolEventIntervalListMerged._metadata, ITimeToolEventIntervalListMerged._remove_time_component_metadata, pos)


agcls.AgClassCatalog.add_catalog_entry("{78E1CE61-5B2E-4A10-894D-A006F35ACDE1}", ITimeToolEventIntervalListMerged)
agcls.AgTypeNameMap["ITimeToolEventIntervalListMerged"] = ITimeToolEventIntervalListMerged

class ITimeToolEventIntervalListScaled(object):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7DDA88F8-A738-464E-9CDC-613E107F57D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_intervals" : 1,
                             "set_original_intervals" : 2,
                             "get_absolute_increment" : 3,
                             "set_absolute_increment" : 4,
                             "get_relative_increment" : 5,
                             "set_relative_increment" : 6,
                             "get_use_absolute_increment" : 7,
                             "set_use_absolute_increment" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListScaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListScaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListScaled, None)
    
    _get_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original interval list."""
        return self._intf.get_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._set_original_intervals_metadata, originalIntervals)

    _get_absolute_increment_metadata = { "name" : "absolute_increment",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_increment(self) -> float:
        """The absolute increment value which creates a new interval list by expanding (or shortening if negative) every interval in the original interval list by shifting interval's start/stop times equally by half of specified increment value."""
        return self._intf.get_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._get_absolute_increment_metadata)

    _set_absolute_increment_metadata = { "name" : "absolute_increment",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_increment.setter
    def absolute_increment(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._set_absolute_increment_metadata, absoluteIncrement)

    _get_relative_increment_metadata = { "name" : "relative_increment",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_increment(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._get_relative_increment_metadata)

    _set_relative_increment_metadata = { "name" : "relative_increment",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_increment.setter
    def relative_increment(self, relativeIncrement:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._set_relative_increment_metadata, relativeIncrement)

    _get_use_absolute_increment_metadata = { "name" : "use_absolute_increment",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_absolute_increment(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._get_use_absolute_increment_metadata)

    _set_use_absolute_increment_metadata = { "name" : "use_absolute_increment",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_absolute_increment.setter
    def use_absolute_increment(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListScaled._metadata, ITimeToolEventIntervalListScaled._set_use_absolute_increment_metadata, useAbsoluteIncrement)


agcls.AgClassCatalog.add_catalog_entry("{7DDA88F8-A738-464E-9CDC-613E107F57D0}", ITimeToolEventIntervalListScaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalListScaled"] = ITimeToolEventIntervalListScaled

class ITimeToolEventIntervalListSignaled(object):
    """Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C40EA24E-E258-4B0E-8A0F-89424F93F837}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_intervals" : 1,
                             "set_original_intervals" : 2,
                             "get_signal_sense" : 3,
                             "set_signal_sense" : 4,
                             "get_base_clock_location" : 5,
                             "set_base_clock_location" : 6,
                             "get_target_clock_location" : 7,
                             "set_target_clock_location" : 8,
                             "get_signal_delay" : 9,
                             "set_signal_delay" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListSignaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListSignaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListSignaled, None)
    
    _get_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_intervals(self) -> "ITimeToolEventIntervalList":
        """The original time interval list."""
        return self._intf.get_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._get_original_intervals_metadata)

    _set_original_intervals_metadata = { "name" : "original_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @original_intervals.setter
    def original_intervals(self, originalIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._set_original_intervals_metadata, originalIntervals)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the Base Clock Location."""
        return self._intf.get_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListSignaled._metadata, ITimeToolEventIntervalListSignaled._set_signal_delay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{C40EA24E-E258-4B0E-8A0F-89424F93F837}", ITimeToolEventIntervalListSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalListSignaled"] = ITimeToolEventIntervalListSignaled

class ITimeToolEventIntervalListTimeOffset(object):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EEA120D3-8E9F-419B-B11C-A034007EB2D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_intervals" : 1,
                             "set_reference_intervals" : 2,
                             "get_time_offset" : 3,
                             "set_time_offset" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalListTimeOffset)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalListTimeOffset)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalListTimeOffset, None)
    
    _get_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list."""
        return self._intf.get_property(ITimeToolEventIntervalListTimeOffset._metadata, ITimeToolEventIntervalListTimeOffset._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ITimeToolEventIntervalListTimeOffset._metadata, ITimeToolEventIntervalListTimeOffset._set_reference_intervals_metadata, referenceIntervals)

    _get_time_offset_metadata = { "name" : "time_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_offset(self) -> float:
        """The time offset."""
        return self._intf.get_property(ITimeToolEventIntervalListTimeOffset._metadata, ITimeToolEventIntervalListTimeOffset._get_time_offset_metadata)

    _set_time_offset_metadata = { "name" : "time_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_offset.setter
    def time_offset(self, timeOffset:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalListTimeOffset._metadata, ITimeToolEventIntervalListTimeOffset._set_time_offset_metadata, timeOffset)


agcls.AgClassCatalog.add_catalog_entry("{EEA120D3-8E9F-419B-B11C-A034007EB2D0}", ITimeToolEventIntervalListTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventIntervalListTimeOffset"] = ITimeToolEventIntervalListTimeOffset

class ITimeToolEventIntervalScaled(object):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FA9613FB-7341-4785-AD95-51CFA2B605BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_interval" : 1,
                             "set_original_interval" : 2,
                             "get_absolute_increment" : 3,
                             "set_absolute_increment" : 4,
                             "get_relative_increment" : 5,
                             "set_relative_increment" : 6,
                             "get_use_absolute_increment" : 7,
                             "set_use_absolute_increment" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalScaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalScaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalScaled, None)
    
    _get_original_interval_metadata = { "name" : "original_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_interval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        return self._intf.get_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._get_original_interval_metadata)

    _set_original_interval_metadata = { "name" : "original_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    @original_interval.setter
    def original_interval(self, originalInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._set_original_interval_metadata, originalInterval)

    _get_absolute_increment_metadata = { "name" : "absolute_increment",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_increment(self) -> float:
        """The absolute increment value which creates a interval by expanding (or shortening if negative) the original interval by shifting its start/stop times equally by half of specified increment value."""
        return self._intf.get_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._get_absolute_increment_metadata)

    _set_absolute_increment_metadata = { "name" : "absolute_increment",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_increment.setter
    def absolute_increment(self, absoluteIncrement:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._set_absolute_increment_metadata, absoluteIncrement)

    _get_relative_increment_metadata = { "name" : "relative_increment",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_increment(self) -> float:
        """The relative increment value from which absolute increment is obtained by multiplying relative value by interval duration..."""
        return self._intf.get_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._get_relative_increment_metadata)

    _set_relative_increment_metadata = { "name" : "relative_increment",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_increment.setter
    def relative_increment(self, relativeIncrement:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._set_relative_increment_metadata, relativeIncrement)

    _get_use_absolute_increment_metadata = { "name" : "use_absolute_increment",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_absolute_increment(self) -> bool:
        """Specify whether to use absolute or relative increment."""
        return self._intf.get_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._get_use_absolute_increment_metadata)

    _set_use_absolute_increment_metadata = { "name" : "use_absolute_increment",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_absolute_increment.setter
    def use_absolute_increment(self, useAbsoluteIncrement:bool) -> None:
        return self._intf.set_property(ITimeToolEventIntervalScaled._metadata, ITimeToolEventIntervalScaled._set_use_absolute_increment_metadata, useAbsoluteIncrement)


agcls.AgClassCatalog.add_catalog_entry("{FA9613FB-7341-4785-AD95-51CFA2B605BC}", ITimeToolEventIntervalScaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalScaled"] = ITimeToolEventIntervalScaled

class ITimeToolEventIntervalSignaled(object):
    """Determine what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{51B9DE87-9220-40B2-AA57-01F7B17BD945}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_interval" : 1,
                             "set_original_interval" : 2,
                             "get_signal_sense" : 3,
                             "set_signal_sense" : 4,
                             "get_base_clock_location" : 5,
                             "set_base_clock_location" : 6,
                             "get_target_clock_location" : 7,
                             "set_target_clock_location" : 8,
                             "get_signal_delay" : 9,
                             "set_signal_delay" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalSignaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalSignaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalSignaled, None)
    
    _get_original_interval_metadata = { "name" : "original_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_interval(self) -> "ITimeToolEventInterval":
        """The original interval."""
        return self._intf.get_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._get_original_interval_metadata)

    _set_original_interval_metadata = { "name" : "original_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    @original_interval.setter
    def original_interval(self, originalInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._set_original_interval_metadata, originalInterval)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSignaled._metadata, ITimeToolEventIntervalSignaled._set_signal_delay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{51B9DE87-9220-40B2-AA57-01F7B17BD945}", ITimeToolEventIntervalSignaled)
agcls.AgTypeNameMap["ITimeToolEventIntervalSignaled"] = ITimeToolEventIntervalSignaled

class ITimeToolEventIntervalSmartInterval(object):
    """A smart interval."""

    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_interval" : 1,
                             "get_duration_as_string" : 2,
                             "set_duration_as_string" : 3,
                             "get_state" : 4,
                             "set_state" : 5,
                             "set_implicit_interval" : 6,
                             "find_start_time" : 7,
                             "find_stop_time" : 8,
                             "get_start_epoch" : 9,
                             "set_start_epoch" : 10,
                             "get_stop_epoch" : 11,
                             "set_stop_epoch" : 12,
                             "set_explicit_interval" : 13,
                             "set_start_and_stop_epochs" : 14,
                             "set_start_and_stop_times" : 15,
                             "set_start_epoch_and_duration" : 16,
                             "set_start_time_and_duration" : 17, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalSmartInterval)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalSmartInterval)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalSmartInterval, None)
    
    _get_reference_interval_metadata = { "name" : "reference_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_interval(self) -> "ITimeToolEventInterval":
        """The reference interval used to compute start/stop times of this interval if the state of the interval is set to implicit."""
        return self._intf.get_property(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._get_reference_interval_metadata)

    _get_duration_as_string_metadata = { "name" : "duration_as_string",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def duration_as_string(self) -> str:
        """The duration of the interval."""
        return self._intf.get_property(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._get_duration_as_string_metadata)

    _set_duration_as_string_metadata = { "name" : "duration_as_string",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @duration_as_string.setter
    def duration_as_string(self, durationAsString:str) -> None:
        return self._intf.set_property(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_duration_as_string_metadata, durationAsString)

    _get_state_metadata = { "name" : "state",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SMART_INTERVAL_STATE),) }
    @property
    def state(self) -> "CRDN_SMART_INTERVAL_STATE":
        """A state of the smart interval."""
        return self._intf.get_property(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._get_state_metadata)

    _set_state_metadata = { "name" : "state",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SMART_INTERVAL_STATE),) }
    @state.setter
    def state(self, state:"CRDN_SMART_INTERVAL_STATE") -> None:
        return self._intf.set_property(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_state_metadata, state)

    _set_implicit_interval_metadata = { "name" : "set_implicit_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    def set_implicit_interval(self, eventInterval:"ITimeToolEventInterval") -> None:
        """Set the reference interval and changes the state to Implicit."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_implicit_interval_metadata, eventInterval)

    _find_start_time_metadata = { "name" : "find_start_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def find_start_time(self) -> typing.Any:
        """Find a start time of the interval. An exception is thrown if the start time cannot be determined from the interval's current state."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._find_start_time_metadata, out_arg())

    _find_stop_time_metadata = { "name" : "find_stop_time",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def find_stop_time(self) -> typing.Any:
        """Find a stop time of the interval. An exception is thrown if the stop time cannot be determined from the interval's current state."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._find_stop_time_metadata, out_arg())

    _get_start_epoch_metadata = { "name" : "get_start_epoch",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_start_epoch(self) -> "TimeToolEventSmartEpoch":
        """Return a copy of the start epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._get_start_epoch_metadata, out_arg())

    _set_start_epoch_metadata = { "name" : "set_start_epoch",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventSmartEpoch"),) }
    def set_start_epoch(self, startEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Set a start of the interval using specified epoch component."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_start_epoch_metadata, startEpoch)

    _get_stop_epoch_metadata = { "name" : "get_stop_epoch",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_stop_epoch(self) -> "TimeToolEventSmartEpoch":
        """Return a copy of the stop epoch. Changes to the epoch will not affect the state of the interval."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._get_stop_epoch_metadata, out_arg())

    _set_stop_epoch_metadata = { "name" : "set_stop_epoch",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventSmartEpoch"),) }
    def set_stop_epoch(self, stopEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Set a stop of the interval using specified epoch component."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_stop_epoch_metadata, stopEpoch)

    _set_explicit_interval_metadata = { "name" : "set_explicit_interval",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def set_explicit_interval(self, start:typing.Any, stop:typing.Any) -> None:
        """Set the interval's start and the stop times changes the interval's state to explicit. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_explicit_interval_metadata, start, stop)

    _set_start_and_stop_epochs_metadata = { "name" : "set_start_and_stop_epochs",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventSmartEpoch"), agmarshall.AgInterface_in_arg("ITimeToolEventSmartEpoch"),) }
    def set_start_and_stop_epochs(self, refStartEpoch:"ITimeToolEventSmartEpoch", refStopEpoch:"ITimeToolEventSmartEpoch") -> None:
        """Set the interval's start and stop epochs as two smart epoch components. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_start_and_stop_epochs_metadata, refStartEpoch, refStopEpoch)

    _set_start_and_stop_times_metadata = { "name" : "set_start_and_stop_times",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg,) }
    def set_start_and_stop_times(self, startTime:typing.Any, stopTime:typing.Any) -> None:
        """Set the interval's start and stop epochs as explicit times. Exception is thrown if specified start time is greater than stop time."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_start_and_stop_times_metadata, startTime, stopTime)

    _set_start_epoch_and_duration_metadata = { "name" : "set_start_epoch_and_duration",
            "arg_types" : (agcom.PVOID, agcom.BSTR,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventSmartEpoch"), agmarshall.BSTR_arg,) }
    def set_start_epoch_and_duration(self, refStartEpoch:"ITimeToolEventSmartEpoch", durationStr:str) -> None:
        """Set the interval's start epoch and the interval's duration."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_start_epoch_and_duration_metadata, refStartEpoch, durationStr)

    _set_start_time_and_duration_metadata = { "name" : "set_start_time_and_duration",
            "arg_types" : (agcom.VARIANT, agcom.BSTR,),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.BSTR_arg,) }
    def set_start_time_and_duration(self, epoch:typing.Any, durationStr:str) -> None:
        """Set the interval's start time and the interval's duration."""
        return self._intf.invoke(ITimeToolEventIntervalSmartInterval._metadata, ITimeToolEventIntervalSmartInterval._set_start_time_and_duration_metadata, epoch, durationStr)


agcls.AgClassCatalog.add_catalog_entry("{B26EEDF4-757B-4031-AEDA-B04805DD1D3C}", ITimeToolEventIntervalSmartInterval)
agcls.AgTypeNameMap["ITimeToolEventIntervalSmartInterval"] = ITimeToolEventIntervalSmartInterval

class ITimeToolEventIntervalTimeOffset(object):
    """Interval defined by shifting specified reference interval by fixed time offset."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_interval" : 1,
                             "set_reference_interval" : 2,
                             "get_time_offset" : 3,
                             "set_time_offset" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventIntervalTimeOffset)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventIntervalTimeOffset)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventIntervalTimeOffset, None)
    
    _get_reference_interval_metadata = { "name" : "reference_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_interval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        return self._intf.get_property(ITimeToolEventIntervalTimeOffset._metadata, ITimeToolEventIntervalTimeOffset._get_reference_interval_metadata)

    _set_reference_interval_metadata = { "name" : "reference_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    @reference_interval.setter
    def reference_interval(self, referenceInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(ITimeToolEventIntervalTimeOffset._metadata, ITimeToolEventIntervalTimeOffset._set_reference_interval_metadata, referenceInterval)

    _get_time_offset_metadata = { "name" : "time_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_offset(self) -> float:
        """The time offset value."""
        return self._intf.get_property(ITimeToolEventIntervalTimeOffset._metadata, ITimeToolEventIntervalTimeOffset._get_time_offset_metadata)

    _set_time_offset_metadata = { "name" : "time_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_offset.setter
    def time_offset(self, timeOffset:float) -> None:
        return self._intf.set_property(ITimeToolEventIntervalTimeOffset._metadata, ITimeToolEventIntervalTimeOffset._set_time_offset_metadata, timeOffset)


agcls.AgClassCatalog.add_catalog_entry("{2AA1BEDD-DB08-4306-99D1-E77933DC7EFC}", ITimeToolEventIntervalTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventIntervalTimeOffset"] = ITimeToolEventIntervalTimeOffset

class ITimeToolEventSignaled(object):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_original_time_instant" : 1,
                             "set_original_time_instant" : 2,
                             "get_signal_sense" : 3,
                             "set_signal_sense" : 4,
                             "get_base_clock_location" : 5,
                             "set_base_clock_location" : 6,
                             "get_target_clock_location" : 7,
                             "set_target_clock_location" : 8,
                             "get_signal_delay" : 9,
                             "set_signal_delay" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventSignaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventSignaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventSignaled, None)
    
    _get_original_time_instant_metadata = { "name" : "original_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def original_time_instant(self) -> "ITimeToolEvent":
        """The original time instant."""
        return self._intf.get_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._get_original_time_instant_metadata)

    _set_original_time_instant_metadata = { "name" : "original_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @original_time_instant.setter
    def original_time_instant(self, originalTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._set_original_time_instant_metadata, originalTimeInstant)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """The direction of the signal, whether you are Transmitting or Receiving from the BaseClockLocation."""
        return self._intf.get_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._set_signal_sense_metadata, signalSense)

    _get_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def base_clock_location(self) -> "IVectorGeometryToolPoint":
        """The base clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._get_base_clock_location_metadata)

    _set_base_clock_location_metadata = { "name" : "base_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @base_clock_location.setter
    def base_clock_location(self, baseClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._set_base_clock_location_metadata, baseClockLocation)

    _get_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_clock_location(self) -> "IVectorGeometryToolPoint":
        """The target clock location, which is a point from VGT."""
        return self._intf.get_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._get_target_clock_location_metadata)

    _set_target_clock_location_metadata = { "name" : "target_clock_location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @target_clock_location.setter
    def target_clock_location(self, targetClockLocation:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._set_target_clock_location_metadata, targetClockLocation)

    _get_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def signal_delay(self) -> "IAnalysisWorkbenchSignalDelay":
        """The Signal delay definition, which includes signal transmission, time delay convergence and signal path reference system."""
        return self._intf.get_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._get_signal_delay_metadata)

    _set_signal_delay_metadata = { "name" : "signal_delay",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSignalDelay"),) }
    @signal_delay.setter
    def signal_delay(self, signalDelay:"IAnalysisWorkbenchSignalDelay") -> None:
        return self._intf.set_property(ITimeToolEventSignaled._metadata, ITimeToolEventSignaled._set_signal_delay_metadata, signalDelay)


agcls.AgClassCatalog.add_catalog_entry("{1FC37CC0-BAF3-4663-9B9C-270D51C9413C}", ITimeToolEventSignaled)
agcls.AgTypeNameMap["ITimeToolEventSignaled"] = ITimeToolEventSignaled

class ITimeToolEventSmartEpoch(object):
    """A smart epoch."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4C5542F5-5B94-498B-90BC-CC7CB7C86629}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_time_instant" : 1,
                             "get_reference_event" : 2,
                             "get_state" : 3,
                             "set_state" : 4,
                             "set_explicit_time" : 5,
                             "set_implicit_time" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventSmartEpoch)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventSmartEpoch)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventSmartEpoch, None)
    
    _get_time_instant_metadata = { "name" : "time_instant",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def time_instant(self) -> typing.Any:
        """Represents the time instant if the state is set to explicit."""
        return self._intf.get_property(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._get_time_instant_metadata)

    _get_reference_event_metadata = { "name" : "reference_event",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_event(self) -> "ITimeToolEvent":
        """A reference event object used to compute time instant if the state is set to implicit."""
        return self._intf.get_property(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._get_reference_event_metadata)

    _get_state_metadata = { "name" : "state",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SMART_EPOCH_STATE),) }
    @property
    def state(self) -> "CRDN_SMART_EPOCH_STATE":
        """State of the event."""
        return self._intf.get_property(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._get_state_metadata)

    _set_state_metadata = { "name" : "state",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SMART_EPOCH_STATE),) }
    @state.setter
    def state(self, state:"CRDN_SMART_EPOCH_STATE") -> None:
        return self._intf.set_property(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._set_state_metadata, state)

    _set_explicit_time_metadata = { "name" : "set_explicit_time",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    def set_explicit_time(self, epoch:typing.Any) -> None:
        """Set explicit time instant and the smart epoch's state to Explicit."""
        return self._intf.invoke(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._set_explicit_time_metadata, epoch)

    _set_implicit_time_metadata = { "name" : "set_implicit_time",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    def set_implicit_time(self, eventEpoch:"ITimeToolEvent") -> None:
        """Set the reference event and the smart epoch's state to Implicit."""
        return self._intf.invoke(ITimeToolEventSmartEpoch._metadata, ITimeToolEventSmartEpoch._set_implicit_time_metadata, eventEpoch)


agcls.AgClassCatalog.add_catalog_entry("{4C5542F5-5B94-498B-90BC-CC7CB7C86629}", ITimeToolEventSmartEpoch)
agcls.AgTypeNameMap["ITimeToolEventSmartEpoch"] = ITimeToolEventSmartEpoch

class ITimeToolEventStartStopTime(object):
    """Event is either start or stop time selected from a reference interval."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB96850C-18E7-4269-8D35-67FB7E55BD59}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_start" : 1,
                             "set_use_start" : 2,
                             "get_reference_event_interval" : 3,
                             "set_reference_event_interval" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventStartStopTime)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventStartStopTime)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventStartStopTime, None)
    
    _get_use_start_metadata = { "name" : "use_start",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_start(self) -> bool:
        """Indicate whether to use start (true) or stop (false)."""
        return self._intf.get_property(ITimeToolEventStartStopTime._metadata, ITimeToolEventStartStopTime._get_use_start_metadata)

    _set_use_start_metadata = { "name" : "use_start",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_start.setter
    def use_start(self, useStart:bool) -> None:
        return self._intf.set_property(ITimeToolEventStartStopTime._metadata, ITimeToolEventStartStopTime._set_use_start_metadata, useStart)

    _get_reference_event_interval_metadata = { "name" : "reference_event_interval",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_event_interval(self) -> "ITimeToolEventInterval":
        """The reference interval."""
        return self._intf.get_property(ITimeToolEventStartStopTime._metadata, ITimeToolEventStartStopTime._get_reference_event_interval_metadata)

    _set_reference_event_interval_metadata = { "name" : "reference_event_interval",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventInterval"),) }
    @reference_event_interval.setter
    def reference_event_interval(self, referenceEventInterval:"ITimeToolEventInterval") -> None:
        return self._intf.set_property(ITimeToolEventStartStopTime._metadata, ITimeToolEventStartStopTime._set_reference_event_interval_metadata, referenceEventInterval)


agcls.AgClassCatalog.add_catalog_entry("{EB96850C-18E7-4269-8D35-67FB7E55BD59}", ITimeToolEventStartStopTime)
agcls.AgTypeNameMap["ITimeToolEventStartStopTime"] = ITimeToolEventStartStopTime

class ITimeToolEventTimeOffset(object):
    """Event at fixed offset from specified reference event."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EB95E24E-6BDF-434C-A278-BF64475E4EB5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2,
                             "get_time_offset2" : 3,
                             "set_time_offset2" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolEventTimeOffset)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolEventTimeOffset)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolEventTimeOffset, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """The reference time instant."""
        return self._intf.get_property(ITimeToolEventTimeOffset._metadata, ITimeToolEventTimeOffset._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(ITimeToolEventTimeOffset._metadata, ITimeToolEventTimeOffset._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_time_offset2_metadata = { "name" : "time_offset2",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_offset2(self) -> float:
        """The time offset from the ReferenceTimeInstant. The value is in ``TimeUnit`` dimension."""
        return self._intf.get_property(ITimeToolEventTimeOffset._metadata, ITimeToolEventTimeOffset._get_time_offset2_metadata)

    _set_time_offset2_metadata = { "name" : "time_offset2",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_offset2.setter
    def time_offset2(self, timeOffset2:float) -> None:
        return self._intf.set_property(ITimeToolEventTimeOffset._metadata, ITimeToolEventTimeOffset._set_time_offset2_metadata, timeOffset2)


agcls.AgClassCatalog.add_catalog_entry("{EB95E24E-6BDF-434C-A278-BF64475E4EB5}", ITimeToolEventTimeOffset)
agcls.AgTypeNameMap["ITimeToolEventTimeOffset"] = ITimeToolEventTimeOffset

class ITimeToolFirstIntervalsFilter(object):
    """The filter selects a portion of first intervals."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{032A1F18-16B1-48B3-BB59-AFE83A834880}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_maximum_number_of_intervals" : 1,
                             "set_maximum_number_of_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolFirstIntervalsFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolFirstIntervalsFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolFirstIntervalsFilter, None)
    
    _get_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(ITimeToolFirstIntervalsFilter._metadata, ITimeToolFirstIntervalsFilter._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(ITimeToolFirstIntervalsFilter._metadata, ITimeToolFirstIntervalsFilter._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)


agcls.AgClassCatalog.add_catalog_entry("{032A1F18-16B1-48B3-BB59-AFE83A834880}", ITimeToolFirstIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolFirstIntervalsFilter"] = ITimeToolFirstIntervalsFilter

class ITimeToolGapsFilter(object):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{97B393F6-5E70-4D67-80C1-F85080D818F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_duration_kind" : 1,
                             "set_duration_kind" : 2,
                             "get_gap_duration" : 3,
                             "set_gap_duration" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolGapsFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolGapsFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolGapsFilter, None)
    
    _get_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(ITimeToolGapsFilter._metadata, ITimeToolGapsFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(ITimeToolGapsFilter._metadata, ITimeToolGapsFilter._set_duration_kind_metadata, durationKind)

    _get_gap_duration_metadata = { "name" : "gap_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def gap_duration(self) -> float:
        """Duration of the gap."""
        return self._intf.get_property(ITimeToolGapsFilter._metadata, ITimeToolGapsFilter._get_gap_duration_metadata)

    _set_gap_duration_metadata = { "name" : "gap_duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @gap_duration.setter
    def gap_duration(self, gapDuration:float) -> None:
        return self._intf.set_property(ITimeToolGapsFilter._metadata, ITimeToolGapsFilter._set_gap_duration_metadata, gapDuration)


agcls.AgClassCatalog.add_catalog_entry("{97B393F6-5E70-4D67-80C1-F85080D818F3}", ITimeToolGapsFilter)
agcls.AgTypeNameMap["ITimeToolGapsFilter"] = ITimeToolGapsFilter

class IAnalysisWorkbenchIntegral(object):
    """Represents a base class for integral definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{61D34977-CC2E-43C1-9103-692FF9B3DEF0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchIntegral)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchIntegral)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchIntegral, None)
    

agcls.AgClassCatalog.add_catalog_entry("{61D34977-CC2E-43C1-9103-692FF9B3DEF0}", IAnalysisWorkbenchIntegral)
agcls.AgTypeNameMap["IAnalysisWorkbenchIntegral"] = IAnalysisWorkbenchIntegral

class ICalculationToolIntegralBasic(object):
    """Integral definition determines how scalar calculation is numerically integrated."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{19DEEA25-F655-487B-86FF-429B55093F77}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "set_type" : 2,
                             "get_tolerance" : 3,
                             "set_tolerance" : 4,
                             "get_maximum_iterations" : 5,
                             "set_maximum_iterations" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolIntegralBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolIntegralBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolIntegralBasic, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTEGRAL_TYPE),) }
    @property
    def type(self) -> "CRDN_INTEGRAL_TYPE":
        """Get the integral type which determines the method of integration and can be set to trapezoidal, Simplson or adaptive Lobatto."""
        return self._intf.get_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._get_type_metadata)

    _set_type_metadata = { "name" : "type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTEGRAL_TYPE),) }
    @type.setter
    def type(self, type:"CRDN_INTEGRAL_TYPE") -> None:
        return self._intf.set_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._set_type_metadata, type)

    _get_tolerance_metadata = { "name" : "tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def tolerance(self) -> float:
        """Get the tolerance which determines how accurate integral is computed by finding relative difference between refined and unrefined integral evaluations. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._get_tolerance_metadata)

    _set_tolerance_metadata = { "name" : "tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @tolerance.setter
    def tolerance(self, tolerance:float) -> None:
        return self._intf.set_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._set_tolerance_metadata, tolerance)

    _get_maximum_iterations_metadata = { "name" : "maximum_iterations",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def maximum_iterations(self) -> int:
        """Get the number of iteration which determines how many refinement iterations are allowed. Only available if Adaptive Lobatto is selected as the integral type."""
        return self._intf.get_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._get_maximum_iterations_metadata)

    _set_maximum_iterations_metadata = { "name" : "maximum_iterations",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @maximum_iterations.setter
    def maximum_iterations(self, maximumIterations:int) -> None:
        return self._intf.set_property(ICalculationToolIntegralBasic._metadata, ICalculationToolIntegralBasic._set_maximum_iterations_metadata, maximumIterations)


agcls.AgClassCatalog.add_catalog_entry("{19DEEA25-F655-487B-86FF-429B55093F77}", ICalculationToolIntegralBasic)
agcls.AgTypeNameMap["ICalculationToolIntegralBasic"] = ICalculationToolIntegralBasic

class IAnalysisWorkbenchInterp(object):
    """Represents a base class for interpolation definitions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchInterp)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchInterp)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchInterp, None)
    

agcls.AgClassCatalog.add_catalog_entry("{C92AA400-6E5F-47D7-8DF4-41E65F4CABEE}", IAnalysisWorkbenchInterp)
agcls.AgTypeNameMap["IAnalysisWorkbenchInterp"] = IAnalysisWorkbenchInterp

class ICalculationToolInterpBasic(object):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "set_type" : 2,
                             "get_order" : 3,
                             "set_order" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolInterpBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolInterpBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolInterpBasic, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERPOLATOR_TYPE),) }
    @property
    def type(self) -> "CRDN_INTERPOLATOR_TYPE":
        """Get the interpolation type, which can be Lagrange or Hermite interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(ICalculationToolInterpBasic._metadata, ICalculationToolInterpBasic._get_type_metadata)

    _set_type_metadata = { "name" : "type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERPOLATOR_TYPE),) }
    @type.setter
    def type(self, type:"CRDN_INTERPOLATOR_TYPE") -> None:
        return self._intf.set_property(ICalculationToolInterpBasic._metadata, ICalculationToolInterpBasic._set_type_metadata, type)

    _get_order_metadata = { "name" : "order",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def order(self) -> int:
        """Get the interpolation order, which determines the order of interpolation polynomial and is related to how many samples are used during interpolation. See STK help on interpolation for further details."""
        return self._intf.get_property(ICalculationToolInterpBasic._metadata, ICalculationToolInterpBasic._get_order_metadata)

    _set_order_metadata = { "name" : "order",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @order.setter
    def order(self, order:int) -> None:
        return self._intf.set_property(ICalculationToolInterpBasic._metadata, ICalculationToolInterpBasic._set_order_metadata, order)


agcls.AgClassCatalog.add_catalog_entry("{9AD022AA-A66A-4DFC-8355-9783A9B71BE3}", ICalculationToolInterpBasic)
agcls.AgTypeNameMap["ICalculationToolInterpBasic"] = ICalculationToolInterpBasic

class ITimeToolIntervalsFilter(object):
    """The filter selects intervals of at least/most certain duration."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_duration_kind" : 1,
                             "set_duration_kind" : 2,
                             "get_interval_duration" : 3,
                             "set_interval_duration" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolIntervalsFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolIntervalsFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolIntervalsFilter, None)
    
    _get_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(ITimeToolIntervalsFilter._metadata, ITimeToolIntervalsFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(ITimeToolIntervalsFilter._metadata, ITimeToolIntervalsFilter._set_duration_kind_metadata, durationKind)

    _get_interval_duration_metadata = { "name" : "interval_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interval_duration(self) -> float:
        """The interval duration."""
        return self._intf.get_property(ITimeToolIntervalsFilter._metadata, ITimeToolIntervalsFilter._get_interval_duration_metadata)

    _set_interval_duration_metadata = { "name" : "interval_duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interval_duration.setter
    def interval_duration(self, intervalDuration:float) -> None:
        return self._intf.set_property(ITimeToolIntervalsFilter._metadata, ITimeToolIntervalsFilter._set_interval_duration_metadata, intervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{4599D429-D3F6-4BA5-B959-AB62D9A67EE8}", ITimeToolIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolIntervalsFilter"] = ITimeToolIntervalsFilter

class ITimeToolLastIntervalsFilter(object):
    """The filter selects a portion of last intervals."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_maximum_number_of_intervals" : 1,
                             "set_maximum_number_of_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolLastIntervalsFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolLastIntervalsFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolLastIntervalsFilter, None)
    
    _get_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Maximum number of intervals."""
        return self._intf.get_property(ITimeToolLastIntervalsFilter._metadata, ITimeToolLastIntervalsFilter._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(ITimeToolLastIntervalsFilter._metadata, ITimeToolLastIntervalsFilter._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)


agcls.AgClassCatalog.add_catalog_entry("{18DB1782-0DAC-4989-BB3F-D7B95E294B3A}", ITimeToolLastIntervalsFilter)
agcls.AgTypeNameMap["ITimeToolLastIntervalsFilter"] = ITimeToolLastIntervalsFilter

class ICalculationToolParameterSet(object):
    """Parameter set contains various sets of scalar computations."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{285664E8-604B-4C0A-9ED0-5EE27CA1539D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type" : 1,
                             "get_labels" : 2,
                             "get_dimensions" : 3,
                             "get_scalar_names" : 4,
                             "calculate" : 5,
                             "calculate_with_derivative" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSet)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSet)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSet, None)
    
    _get_type_metadata = { "name" : "type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_PARAMETER_SET_TYPE),) }
    @property
    def type(self) -> "CRDN_PARAMETER_SET_TYPE":
        """Get the type of parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_type_metadata)

    _get_labels_metadata = { "name" : "labels",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def labels(self) -> list:
        """Get the labels identifying hierarchy of representations within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_labels_metadata)

    _get_dimensions_metadata = { "name" : "dimensions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def dimensions(self) -> list:
        """Get the names identifying types of dimensions of individual scalars within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_dimensions_metadata)

    _get_scalar_names_metadata = { "name" : "scalar_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def scalar_names(self) -> list:
        """Get the names identifying individual scalars within parameter set."""
        return self._intf.get_property(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._get_scalar_names_metadata)

    _calculate_metadata = { "name" : "calculate",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def calculate(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars within parameter set at the specified time."""
        return self._intf.invoke(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._calculate_metadata, epoch, out_arg())

    _calculate_with_derivative_metadata = { "name" : "calculate_with_derivative",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.LPSAFEARRAY_arg,) }
    def calculate_with_derivative(self, epoch:typing.Any) -> list:
        """Return results of computing individual scalars and their time derivatives within parameter set at the specified time."""
        return self._intf.invoke(ICalculationToolParameterSet._metadata, ICalculationToolParameterSet._calculate_with_derivative_metadata, epoch, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{285664E8-604B-4C0A-9ED0-5EE27CA1539D}", ICalculationToolParameterSet)
agcls.AgTypeNameMap["ICalculationToolParameterSet"] = ICalculationToolParameterSet

class ICalculationToolParameterSetAttitude(object):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8B7DCF32-3CA4-4794-8468-81A3627B4043}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_axes" : 1,
                             "set_axes" : 2,
                             "get_reference_axes" : 3,
                             "set_reference_axes" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetAttitude)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetAttitude)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetAttitude, None)
    
    _get_axes_metadata = { "name" : "axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def axes(self) -> "IVectorGeometryToolAxes":
        """Get the axes for which attitude representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetAttitude._metadata, ICalculationToolParameterSetAttitude._get_axes_metadata)

    _set_axes_metadata = { "name" : "axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @axes.setter
    def axes(self, axes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(ICalculationToolParameterSetAttitude._metadata, ICalculationToolParameterSetAttitude._set_axes_metadata, axes)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which attitude representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetAttitude._metadata, ICalculationToolParameterSetAttitude._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(ICalculationToolParameterSetAttitude._metadata, ICalculationToolParameterSetAttitude._set_reference_axes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{8B7DCF32-3CA4-4794-8468-81A3627B4043}", ICalculationToolParameterSetAttitude)
agcls.AgTypeNameMap["ICalculationToolParameterSetAttitude"] = ICalculationToolParameterSetAttitude

class ICalculationToolParameterSetFactory(object):
    """The factory is used to create instances of available parameter set types."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4D20E85F-1DEA-4963-9114-6B0407E53C5E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_parameter_set_attitude" : 2,
                             "create_parameter_set_ground_trajectory" : 3,
                             "create_parameter_set_trajectory" : 4,
                             "create_parameter_set_orbit" : 5,
                             "create_parameter_set_vector" : 6,
                             "is_type_supported" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_PARAMETER_SET_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_PARAMETER_SET_TYPE") -> "ICalculationToolParameterSet":
        """Create and registers a parameter set using specified name and description."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_metadata, name, description, type, out_arg())

    _create_parameter_set_attitude_metadata = { "name" : "create_parameter_set_attitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_parameter_set_attitude(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying one set of axes in reference to another."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_parameter_set_attitude_metadata, name, description, out_arg())

    _create_parameter_set_ground_trajectory_metadata = { "name" : "create_parameter_set_ground_trajectory",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_parameter_set_ground_trajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying location in reference central body."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_parameter_set_ground_trajectory_metadata, name, description, out_arg())

    _create_parameter_set_trajectory_metadata = { "name" : "create_parameter_set_trajectory",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_parameter_set_trajectory(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying location in reference coordinate system."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_parameter_set_trajectory_metadata, name, description, out_arg())

    _create_parameter_set_orbit_metadata = { "name" : "create_parameter_set_orbit",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_parameter_set_orbit(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying orbiting point and its central body."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_parameter_set_orbit_metadata, name, description, out_arg())

    _create_parameter_set_vector_metadata = { "name" : "create_parameter_set_vector",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_parameter_set_vector(self, name:str, description:str) -> "ICalculationToolParameterSet":
        """Create a parameter set defined by identifying vector in reference axes."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._create_parameter_set_vector_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_PARAMETER_SET_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_PARAMETER_SET_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ICalculationToolParameterSetFactory._metadata, ICalculationToolParameterSetFactory._is_type_supported_metadata, eType, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4D20E85F-1DEA-4963-9114-6B0407E53C5E}", ICalculationToolParameterSetFactory)
agcls.AgTypeNameMap["ICalculationToolParameterSetFactory"] = ICalculationToolParameterSetFactory

class ICalculationToolParameterSetGroundTrajectory(object):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{53ABEB95-F846-4574-BA87-C76220FDC19F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_location" : 1,
                             "set_location" : 2,
                             "get_central_body" : 3,
                             "set_central_body" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetGroundTrajectory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetGroundTrajectory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetGroundTrajectory, None)
    
    _get_location_metadata = { "name" : "location",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def location(self) -> "IVectorGeometryToolPoint":
        """Get the point for which ground trajectory representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetGroundTrajectory._metadata, ICalculationToolParameterSetGroundTrajectory._get_location_metadata)

    _set_location_metadata = { "name" : "location",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @location.setter
    def location(self, location:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolParameterSetGroundTrajectory._metadata, ICalculationToolParameterSetGroundTrajectory._set_location_metadata, location)

    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def central_body(self) -> str:
        """Get the central body relative to which ground trajectory representations are computed. Both the central body reference shape and its CBF (central body centered fixed) system are used by this parameter set."""
        return self._intf.get_property(ICalculationToolParameterSetGroundTrajectory._metadata, ICalculationToolParameterSetGroundTrajectory._get_central_body_metadata)

    _set_central_body_metadata = { "name" : "central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(ICalculationToolParameterSetGroundTrajectory._metadata, ICalculationToolParameterSetGroundTrajectory._set_central_body_metadata, centralBody)


agcls.AgClassCatalog.add_catalog_entry("{53ABEB95-F846-4574-BA87-C76220FDC19F}", ICalculationToolParameterSetGroundTrajectory)
agcls.AgTypeNameMap["ICalculationToolParameterSetGroundTrajectory"] = ICalculationToolParameterSetGroundTrajectory

class ICalculationToolParameterSetOrbit(object):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{141AEAB7-C017-4044-BE2C-EFE4AD724022}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_orbiting_point" : 1,
                             "set_orbiting_point" : 2,
                             "get_reference_system" : 3,
                             "set_reference_system" : 4,
                             "get_gravitational_parameter" : 5,
                             "set_gravitational_parameter" : 6,
                             "get_central_body" : 7,
                             "set_central_body" : 8,
                             "get_use_central_body_gravitational_parameter" : 9,
                             "set_use_central_body_gravitational_parameter" : 10,
                             "get_use_central_body_inertial" : 11,
                             "set_use_central_body_inertial" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetOrbit)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetOrbit)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetOrbit, None)
    
    _get_orbiting_point_metadata = { "name" : "orbiting_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def orbiting_point(self) -> "IVectorGeometryToolPoint":
        """Get the point for which orbital parameters are computed."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_orbiting_point_metadata)

    _set_orbiting_point_metadata = { "name" : "orbiting_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @orbiting_point.setter
    def orbiting_point(self, orbitingPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_orbiting_point_metadata, orbitingPoint)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which orbital parameters are computed. Only used if the option to specify reference system is selected."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_reference_system_metadata, referenceSystem)

    _get_gravitational_parameter_metadata = { "name" : "gravitational_parameter",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def gravitational_parameter(self) -> float:
        """Get the gravitational parameter for the mass relative to which orbital parameters are computed. Only used if the option to specify gravitational parameter is selected."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_gravitational_parameter_metadata)

    _set_gravitational_parameter_metadata = { "name" : "gravitational_parameter",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @gravitational_parameter.setter
    def gravitational_parameter(self, gravitationalParameter:float) -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_gravitational_parameter_metadata, gravitationalParameter)

    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def central_body(self) -> str:
        """Get the central body relative to which orbital parameters are computed."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_central_body_metadata)

    _set_central_body_metadata = { "name" : "central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_central_body_metadata, centralBody)

    _get_use_central_body_gravitational_parameter_metadata = { "name" : "use_central_body_gravitational_parameter",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_central_body_gravitational_parameter(self) -> bool:
        """Get the option that determines whether to specify the gravitational parameter value or to inherit it from the central body."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_use_central_body_gravitational_parameter_metadata)

    _set_use_central_body_gravitational_parameter_metadata = { "name" : "use_central_body_gravitational_parameter",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_central_body_gravitational_parameter.setter
    def use_central_body_gravitational_parameter(self, useCentralBodyGravitationalParameter:bool) -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_use_central_body_gravitational_parameter_metadata, useCentralBodyGravitationalParameter)

    _get_use_central_body_inertial_metadata = { "name" : "use_central_body_inertial",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_central_body_inertial(self) -> bool:
        """Get the option that determines whether to specify the reference coordinate system or to the inherit inertial reference system from the central body."""
        return self._intf.get_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._get_use_central_body_inertial_metadata)

    _set_use_central_body_inertial_metadata = { "name" : "use_central_body_inertial",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_central_body_inertial.setter
    def use_central_body_inertial(self, useCentralBodyInertial:bool) -> None:
        return self._intf.set_property(ICalculationToolParameterSetOrbit._metadata, ICalculationToolParameterSetOrbit._set_use_central_body_inertial_metadata, useCentralBodyInertial)


agcls.AgClassCatalog.add_catalog_entry("{141AEAB7-C017-4044-BE2C-EFE4AD724022}", ICalculationToolParameterSetOrbit)
agcls.AgTypeNameMap["ICalculationToolParameterSetOrbit"] = ICalculationToolParameterSetOrbit

class ICalculationToolParameterSetTrajectory(object):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0FE9C601-61BB-4579-B91F-B1123A19AFB4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_point" : 1,
                             "set_point" : 2,
                             "get_reference_system" : 3,
                             "set_reference_system" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetTrajectory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetTrajectory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetTrajectory, None)
    
    _get_point_metadata = { "name" : "point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """Get the point for which trajectory representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetTrajectory._metadata, ICalculationToolParameterSetTrajectory._get_point_metadata)

    _set_point_metadata = { "name" : "point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ICalculationToolParameterSetTrajectory._metadata, ICalculationToolParameterSetTrajectory._set_point_metadata, point)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system relative to which trajectory representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetTrajectory._metadata, ICalculationToolParameterSetTrajectory._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ICalculationToolParameterSetTrajectory._metadata, ICalculationToolParameterSetTrajectory._set_reference_system_metadata, referenceSystem)


agcls.AgClassCatalog.add_catalog_entry("{0FE9C601-61BB-4579-B91F-B1123A19AFB4}", ICalculationToolParameterSetTrajectory)
agcls.AgTypeNameMap["ICalculationToolParameterSetTrajectory"] = ICalculationToolParameterSetTrajectory

class ICalculationToolParameterSetVector(object):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5B99EEC1-21BD-48B5-96A0-0230894532F1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vector" : 1,
                             "set_vector" : 2,
                             "get_reference_axes" : 3,
                             "set_reference_axes" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolParameterSetVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolParameterSetVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolParameterSetVector, None)
    
    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "IVectorGeometryToolVector":
        """Get the vector for which representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetVector._metadata, ICalculationToolParameterSetVector._get_vector_metadata)

    _set_vector_metadata = { "name" : "vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector.setter
    def vector(self, vector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ICalculationToolParameterSetVector._metadata, ICalculationToolParameterSetVector._set_vector_metadata, vector)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """Get the reference axes relative to which representations are computed."""
        return self._intf.get_property(ICalculationToolParameterSetVector._metadata, ICalculationToolParameterSetVector._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(ICalculationToolParameterSetVector._metadata, ICalculationToolParameterSetVector._set_reference_axes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{5B99EEC1-21BD-48B5-96A0-0230894532F1}", ICalculationToolParameterSetVector)
agcls.AgTypeNameMap["ICalculationToolParameterSetVector"] = ICalculationToolParameterSetVector

class ITimeToolPruneFilter(object):
    """A filter used with event interval list pruned class to prune interval lists..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{89E95CD7-CDB2-4B17-9E47-DE17F551F873}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filter_type" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolPruneFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPruneFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolPruneFilter, None)
    
    _get_filter_type_metadata = { "name" : "filter_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_PRUNE_FILTER),) }
    @property
    def filter_type(self) -> "CRDN_PRUNE_FILTER":
        """Return a type of the filter."""
        return self._intf.get_property(ITimeToolPruneFilter._metadata, ITimeToolPruneFilter._get_filter_type_metadata)


agcls.AgClassCatalog.add_catalog_entry("{89E95CD7-CDB2-4B17-9E47-DE17F551F873}", ITimeToolPruneFilter)
agcls.AgTypeNameMap["ITimeToolPruneFilter"] = ITimeToolPruneFilter

class ITimeToolPruneFilterFactory(object):
    """The factory creates pruning filters."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{77E7099E-9B41-45FA-B50F-F8DE5964FABD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolPruneFilterFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPruneFilterFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolPruneFilterFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_PRUNE_FILTER), agmarshall.AgInterface_out_arg,) }
    def create(self, eFilter:"CRDN_PRUNE_FILTER") -> "ITimeToolPruneFilter":
        """Create and initializes a new prune filter using default configuration."""
        return self._intf.invoke(ITimeToolPruneFilterFactory._metadata, ITimeToolPruneFilterFactory._create_metadata, eFilter, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{77E7099E-9B41-45FA-B50F-F8DE5964FABD}", ITimeToolPruneFilterFactory)
agcls.AgTypeNameMap["ITimeToolPruneFilterFactory"] = ITimeToolPruneFilterFactory

class ITimeToolRelativeSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_condition" : 1,
                             "set_condition" : 2,
                             "get_duration_kind" : 3,
                             "set_duration_kind" : 4,
                             "get_relative_interval_duration" : 5,
                             "set_relative_interval_duration" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolRelativeSatisfactionConditionFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolRelativeSatisfactionConditionFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolRelativeSatisfactionConditionFilter, None)
    
    _get_condition_metadata = { "name" : "condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._get_condition_metadata)

    _set_condition_metadata = { "name" : "condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._set_condition_metadata, condition)

    _get_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._set_duration_kind_metadata, durationKind)

    _get_relative_interval_duration_metadata = { "name" : "relative_interval_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_interval_duration(self) -> float:
        """A percentage of time the condition must be satisfied."""
        return self._intf.get_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._get_relative_interval_duration_metadata)

    _set_relative_interval_duration_metadata = { "name" : "relative_interval_duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_interval_duration.setter
    def relative_interval_duration(self, relativeIntervalDuration:float) -> None:
        return self._intf.set_property(ITimeToolRelativeSatisfactionConditionFilter._metadata, ITimeToolRelativeSatisfactionConditionFilter._set_relative_interval_duration_metadata, relativeIntervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{5A8D2A73-C7D2-4158-8313-AA3EFEF14F75}", ITimeToolRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["ITimeToolRelativeSatisfactionConditionFilter"] = ITimeToolRelativeSatisfactionConditionFilter

class IAnalysisWorkbenchSampling(object):
    """Base sampling interface."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchSampling)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchSampling)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchSampling, None)
    

agcls.AgClassCatalog.add_catalog_entry("{69CE7273-6FFF-4BB1-BE3C-36D7E4ECC758}", IAnalysisWorkbenchSampling)
agcls.AgTypeNameMap["IAnalysisWorkbenchSampling"] = IAnalysisWorkbenchSampling

class ICalculationToolSamplingBasic(object):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_sampling_method" : 1,
                             "set_sampling_method" : 2,
                             "get_method_factory" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingBasic, None)
    
    _get_sampling_method_metadata = { "name" : "sampling_method",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling_method(self) -> "ICalculationToolSamplingMethod":
        """Get the sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ICalculationToolSamplingBasic._metadata, ICalculationToolSamplingBasic._get_sampling_method_metadata)

    _set_sampling_method_metadata = { "name" : "sampling_method",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolSamplingMethod"),) }
    @sampling_method.setter
    def sampling_method(self, samplingMethod:"ICalculationToolSamplingMethod") -> None:
        return self._intf.set_property(ICalculationToolSamplingBasic._metadata, ICalculationToolSamplingBasic._set_sampling_method_metadata, samplingMethod)

    _get_method_factory_metadata = { "name" : "method_factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def method_factory(self) -> "CalculationToolSamplingMethodFactory":
        """Create sampling definitions, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ICalculationToolSamplingBasic._metadata, ICalculationToolSamplingBasic._get_method_factory_metadata)


agcls.AgClassCatalog.add_catalog_entry("{170B370D-D5EA-43B3-AECD-54ACD16E2AE6}", ICalculationToolSamplingBasic)
agcls.AgTypeNameMap["ICalculationToolSamplingBasic"] = ICalculationToolSamplingBasic

class ICalculationToolSamplingCurvatureTolerance(object):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{618ADA55-9E3D-4CEC-815A-B028995774CB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_minimum_time_step" : 1,
                             "set_minimum_time_step" : 2,
                             "get_maximum_time_step" : 3,
                             "set_maximum_time_step" : 4,
                             "get_step_at_boundaries" : 5,
                             "set_step_at_boundaries" : 6,
                             "get_relative_tolerance" : 7,
                             "set_relative_tolerance" : 8,
                             "get_absolute_tolerance" : 9,
                             "set_absolute_tolerance" : 10,
                             "get_curvature_tolerance" : 11,
                             "set_curvature_tolerance" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingCurvatureTolerance)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingCurvatureTolerance)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingCurvatureTolerance, None)
    
    _get_minimum_time_step_metadata = { "name" : "minimum_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def minimum_time_step(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_minimum_time_step_metadata)

    _set_minimum_time_step_metadata = { "name" : "minimum_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @minimum_time_step.setter
    def minimum_time_step(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_minimum_time_step_metadata, minimumTimeStep)

    _get_maximum_time_step_metadata = { "name" : "maximum_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maximum_time_step(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_maximum_time_step_metadata)

    _set_maximum_time_step_metadata = { "name" : "maximum_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maximum_time_step.setter
    def maximum_time_step(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_maximum_time_step_metadata, maximumTimeStep)

    _get_step_at_boundaries_metadata = { "name" : "step_at_boundaries",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def step_at_boundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_step_at_boundaries_metadata)

    _set_step_at_boundaries_metadata = { "name" : "step_at_boundaries",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @step_at_boundaries.setter
    def step_at_boundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_step_at_boundaries_metadata, stepAtBoundaries)

    _get_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_relative_tolerance_metadata, relativeTolerance)

    _get_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_absolute_tolerance_metadata, absoluteTolerance)

    _get_curvature_tolerance_metadata = { "name" : "curvature_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def curvature_tolerance(self) -> float:
        """Get the curvature tolerance which determines acceptable angular difference between slopes over consecutive steps."""
        return self._intf.get_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._get_curvature_tolerance_metadata)

    _set_curvature_tolerance_metadata = { "name" : "curvature_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @curvature_tolerance.setter
    def curvature_tolerance(self, curvatureTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingCurvatureTolerance._metadata, ICalculationToolSamplingCurvatureTolerance._set_curvature_tolerance_metadata, curvatureTolerance)


agcls.AgClassCatalog.add_catalog_entry("{618ADA55-9E3D-4CEC-815A-B028995774CB}", ICalculationToolSamplingCurvatureTolerance)
agcls.AgTypeNameMap["ICalculationToolSamplingCurvatureTolerance"] = ICalculationToolSamplingCurvatureTolerance

class ICalculationToolSamplingFixedStep(object):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{68784D1E-776C-4212-B35E-121FFE569627}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_time_step" : 1,
                             "set_time_step" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingFixedStep)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingFixedStep)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingFixedStep, None)
    
    _get_time_step_metadata = { "name" : "time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_step(self) -> float:
        """Get the fixed time step."""
        return self._intf.get_property(ICalculationToolSamplingFixedStep._metadata, ICalculationToolSamplingFixedStep._get_time_step_metadata)

    _set_time_step_metadata = { "name" : "time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_step.setter
    def time_step(self, timeStep:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingFixedStep._metadata, ICalculationToolSamplingFixedStep._set_time_step_metadata, timeStep)


agcls.AgClassCatalog.add_catalog_entry("{68784D1E-776C-4212-B35E-121FFE569627}", ICalculationToolSamplingFixedStep)
agcls.AgTypeNameMap["ICalculationToolSamplingFixedStep"] = ICalculationToolSamplingFixedStep

class ICalculationToolSamplingMethod(object):
    """A sampling method."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1D14391E-F22F-42FF-B3FA-902F061A6F7B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_method_type" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingMethod)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingMethod)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingMethod, None)
    
    _get_method_type_metadata = { "name" : "method_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SAMPLING_METHOD),) }
    @property
    def method_type(self) -> "CRDN_SAMPLING_METHOD":
        """A sampling method type."""
        return self._intf.get_property(ICalculationToolSamplingMethod._metadata, ICalculationToolSamplingMethod._get_method_type_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1D14391E-F22F-42FF-B3FA-902F061A6F7B}", ICalculationToolSamplingMethod)
agcls.AgTypeNameMap["ICalculationToolSamplingMethod"] = ICalculationToolSamplingMethod

class ICalculationToolSamplingMethodFactory(object):
    """The factory creates sampling method components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C214929B-45FA-4023-9C40-6DCE747C151B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create_fixed_step" : 1,
                             "create_curvature_tolerance" : 2,
                             "create_relative_tolerance" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingMethodFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingMethodFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingMethodFactory, None)
    
    _create_fixed_step_metadata = { "name" : "create_fixed_step",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_fixed_step(self, fixedStep:float) -> "ICalculationToolSamplingMethod":
        """Create a fixed time step sampling definition."""
        return self._intf.invoke(ICalculationToolSamplingMethodFactory._metadata, ICalculationToolSamplingMethodFactory._create_fixed_step_metadata, fixedStep, out_arg())

    _create_curvature_tolerance_metadata = { "name" : "create_curvature_tolerance",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_curvature_tolerance(self, curvatureTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a curvature tolerance sampling definition. Curvature tolerance uses changes in slope between samples."""
        return self._intf.invoke(ICalculationToolSamplingMethodFactory._metadata, ICalculationToolSamplingMethodFactory._create_curvature_tolerance_metadata, curvatureTolerance, out_arg())

    _create_relative_tolerance_metadata = { "name" : "create_relative_tolerance",
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_relative_tolerance(self, relativeTolerance:float) -> "ICalculationToolSamplingMethod":
        """Create a relative tolerance sampling definition. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples."""
        return self._intf.invoke(ICalculationToolSamplingMethodFactory._metadata, ICalculationToolSamplingMethodFactory._create_relative_tolerance_metadata, relativeTolerance, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C214929B-45FA-4023-9C40-6DCE747C151B}", ICalculationToolSamplingMethodFactory)
agcls.AgTypeNameMap["ICalculationToolSamplingMethodFactory"] = ICalculationToolSamplingMethodFactory

class ICalculationToolSamplingRelativeTolerance(object):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{32BB5026-A93C-41F7-ADE8-0A04A43627BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_minimum_time_step" : 1,
                             "set_minimum_time_step" : 2,
                             "get_maximum_time_step" : 3,
                             "set_maximum_time_step" : 4,
                             "get_step_at_boundaries" : 5,
                             "set_step_at_boundaries" : 6,
                             "get_relative_tolerance" : 7,
                             "set_relative_tolerance" : 8,
                             "get_absolute_tolerance" : 9,
                             "set_absolute_tolerance" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ICalculationToolSamplingRelativeTolerance)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICalculationToolSamplingRelativeTolerance)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ICalculationToolSamplingRelativeTolerance, None)
    
    _get_minimum_time_step_metadata = { "name" : "minimum_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def minimum_time_step(self) -> float:
        """Get the minimum allowed time step."""
        return self._intf.get_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._get_minimum_time_step_metadata)

    _set_minimum_time_step_metadata = { "name" : "minimum_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @minimum_time_step.setter
    def minimum_time_step(self, minimumTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._set_minimum_time_step_metadata, minimumTimeStep)

    _get_maximum_time_step_metadata = { "name" : "maximum_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maximum_time_step(self) -> float:
        """Get the maximum allowed time step."""
        return self._intf.get_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._get_maximum_time_step_metadata)

    _set_maximum_time_step_metadata = { "name" : "maximum_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maximum_time_step.setter
    def maximum_time_step(self, maximumTimeStep:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._set_maximum_time_step_metadata, maximumTimeStep)

    _get_step_at_boundaries_metadata = { "name" : "step_at_boundaries",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def step_at_boundaries(self) -> float:
        """Get the step taken at boundaries of discontinuity or availability."""
        return self._intf.get_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._get_step_at_boundaries_metadata)

    _set_step_at_boundaries_metadata = { "name" : "step_at_boundaries",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @step_at_boundaries.setter
    def step_at_boundaries(self, stepAtBoundaries:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._set_step_at_boundaries_metadata, stepAtBoundaries)

    _get_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def relative_tolerance(self) -> float:
        """Get the relative tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step relative to the sampled values."""
        return self._intf.get_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._get_relative_tolerance_metadata)

    _set_relative_tolerance_metadata = { "name" : "relative_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @relative_tolerance.setter
    def relative_tolerance(self, relativeTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._set_relative_tolerance_metadata, relativeTolerance)

    _get_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def absolute_tolerance(self) -> float:
        """Get the absolute tolerance which determines acceptable difference between predicted and actual changes in values of sampled data over a step."""
        return self._intf.get_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._get_absolute_tolerance_metadata)

    _set_absolute_tolerance_metadata = { "name" : "absolute_tolerance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @absolute_tolerance.setter
    def absolute_tolerance(self, absoluteTolerance:float) -> None:
        return self._intf.set_property(ICalculationToolSamplingRelativeTolerance._metadata, ICalculationToolSamplingRelativeTolerance._set_absolute_tolerance_metadata, absoluteTolerance)


agcls.AgClassCatalog.add_catalog_entry("{32BB5026-A93C-41F7-ADE8-0A04A43627BC}", ICalculationToolSamplingRelativeTolerance)
agcls.AgTypeNameMap["ICalculationToolSamplingRelativeTolerance"] = ICalculationToolSamplingRelativeTolerance

class ITimeToolSatisfactionConditionFilter(object):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{84F129C1-1D47-4FE2-B87B-013BEF12269C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_condition" : 1,
                             "set_condition" : 2,
                             "get_duration_kind" : 3,
                             "set_duration_kind" : 4,
                             "get_interval_duration" : 5,
                             "set_interval_duration" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolSatisfactionConditionFilter)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolSatisfactionConditionFilter)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolSatisfactionConditionFilter, None)
    
    _get_condition_metadata = { "name" : "condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """This additional condition must be satisfied At Most or At Least specified duration within any interval for it to be considered in filtered list."""
        return self._intf.get_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._get_condition_metadata)

    _set_condition_metadata = { "name" : "condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._set_condition_metadata, condition)

    _get_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @property
    def duration_kind(self) -> "CRDN_INTERVAL_DURATION_KIND":
        """Choose a duration type (at least/at most)."""
        return self._intf.get_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._get_duration_kind_metadata)

    _set_duration_kind_metadata = { "name" : "duration_kind",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERVAL_DURATION_KIND),) }
    @duration_kind.setter
    def duration_kind(self, durationKind:"CRDN_INTERVAL_DURATION_KIND") -> None:
        return self._intf.set_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._set_duration_kind_metadata, durationKind)

    _get_interval_duration_metadata = { "name" : "interval_duration",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def interval_duration(self) -> float:
        """A duration of time the condition must be satisfied."""
        return self._intf.get_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._get_interval_duration_metadata)

    _set_interval_duration_metadata = { "name" : "interval_duration",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @interval_duration.setter
    def interval_duration(self, intervalDuration:float) -> None:
        return self._intf.set_property(ITimeToolSatisfactionConditionFilter._metadata, ITimeToolSatisfactionConditionFilter._set_interval_duration_metadata, intervalDuration)


agcls.AgClassCatalog.add_catalog_entry("{84F129C1-1D47-4FE2-B87B-013BEF12269C}", ITimeToolSatisfactionConditionFilter)
agcls.AgTypeNameMap["ITimeToolSatisfactionConditionFilter"] = ITimeToolSatisfactionConditionFilter

class IAnalysisWorkbenchSignalDelay(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5ED53953-1C55-431D-88AF-1AF23B2FE424}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchSignalDelay)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchSignalDelay)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchSignalDelay, None)
    

agcls.AgClassCatalog.add_catalog_entry("{5ED53953-1C55-431D-88AF-1AF23B2FE424}", IAnalysisWorkbenchSignalDelay)
agcls.AgTypeNameMap["IAnalysisWorkbenchSignalDelay"] = IAnalysisWorkbenchSignalDelay

class ITimeToolSignalDelayBasic(object):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_signal_path_reference_system" : 1,
                             "set_signal_path_reference_system" : 2,
                             "get_reference_system" : 3,
                             "set_reference_system" : 4,
                             "get_speed_option" : 5,
                             "set_speed_option" : 6,
                             "get_transfer_speed" : 7,
                             "set_transfer_speed" : 8,
                             "get_time_delay_convergence" : 9,
                             "set_time_delay_convergence" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolSignalDelayBasic)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolSignalDelayBasic)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolSignalDelayBasic, None)
    
    _get_signal_path_reference_system_metadata = { "name" : "signal_path_reference_system",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_PATH_REFERENCE_SYSTEM),) }
    @property
    def signal_path_reference_system(self) -> "CRDN_SIGNAL_PATH_REFERENCE_SYSTEM":
        """Get the type of signal path reference system which can be set to use STK Access default (see STK Help for further details), Solar system barycenter inertial reference, central body inertial reference or custom reference system..."""
        return self._intf.get_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._get_signal_path_reference_system_metadata)

    _set_signal_path_reference_system_metadata = { "name" : "signal_path_reference_system",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_PATH_REFERENCE_SYSTEM),) }
    @signal_path_reference_system.setter
    def signal_path_reference_system(self, signalPathReferenceSystem:"CRDN_SIGNAL_PATH_REFERENCE_SYSTEM") -> None:
        return self._intf.set_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._set_signal_path_reference_system_metadata, signalPathReferenceSystem)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the custom reference system which is used as a reference for signal path if the signal path reference option is set to Custom."""
        return self._intf.get_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._set_reference_system_metadata, referenceSystem)

    _get_speed_option_metadata = { "name" : "speed_option",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SPEED_OPTIONS),) }
    @property
    def speed_option(self) -> "CRDN_SPEED_OPTIONS":
        """Get the speed option which determines whether to use the speed of light or a custom speed value."""
        return self._intf.get_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._get_speed_option_metadata)

    _set_speed_option_metadata = { "name" : "speed_option",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SPEED_OPTIONS),) }
    @speed_option.setter
    def speed_option(self, speedOption:"CRDN_SPEED_OPTIONS") -> None:
        return self._intf.set_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._set_speed_option_metadata, speedOption)

    _get_transfer_speed_metadata = { "name" : "transfer_speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def transfer_speed(self) -> float:
        """Get the signal propagation speed value which is used if the speed option is set to Custom."""
        return self._intf.get_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._get_transfer_speed_metadata)

    _set_transfer_speed_metadata = { "name" : "transfer_speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @transfer_speed.setter
    def transfer_speed(self, transferSpeed:float) -> None:
        return self._intf.set_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._set_transfer_speed_metadata, transferSpeed)

    _get_time_delay_convergence_metadata = { "name" : "time_delay_convergence",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_delay_convergence(self) -> float:
        """Get the time delay convergence which determines the accuracy of computed propagation time between the two locations."""
        return self._intf.get_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._get_time_delay_convergence_metadata)

    _set_time_delay_convergence_metadata = { "name" : "time_delay_convergence",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_delay_convergence.setter
    def time_delay_convergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(ITimeToolSignalDelayBasic._metadata, ITimeToolSignalDelayBasic._set_time_delay_convergence_metadata, timeDelayConvergence)


agcls.AgClassCatalog.add_catalog_entry("{A5582117-B7C4-4F2D-8A78-23FDCDCB0CAC}", ITimeToolSignalDelayBasic)
agcls.AgTypeNameMap["ITimeToolSignalDelayBasic"] = ITimeToolSignalDelayBasic

class ISpatialAnalysisToolVolumeCalcFactory(object):
    """The factory is used to create instances of volume calcs."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{42eb6d4a-5cff-471f-997d-3f624cb4a416}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "is_type_supported" : 1,
                             "create" : 2,
                             "create_volume_calc_altitude" : 3,
                             "create_volume_calc_angle_off_vector" : 4,
                             "create_volume_calc_file" : 5,
                             "create_volume_calc_from_scalar" : 6,
                             "create_volume_calc_solar_intensity" : 7,
                             "create_volume_calc_volume_satisfaction_metric" : 8,
                             "create_volume_calc_range" : 9,
                             "create_volume_calc_delay_range" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcFactory, None)
    
    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_CALC_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._is_type_supported_metadata, eType, out_arg())

    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_CALC_TYPE") -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a volume calc using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_metadata, name, description, type, out_arg())

    _create_volume_calc_altitude_metadata = { "name" : "create_volume_calc_altitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a altitude to location volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_altitude_metadata, name, description, out_arg())

    _create_volume_calc_angle_off_vector_metadata = { "name" : "create_volume_calc_angle_off_vector",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_angle_off_vector(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a angle to location volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_angle_off_vector_metadata, name, description, out_arg())

    _create_volume_calc_file_metadata = { "name" : "create_volume_calc_file",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_file(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a file volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_file_metadata, name, description, out_arg())

    _create_volume_calc_from_scalar_metadata = { "name" : "create_volume_calc_from_scalar",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_from_scalar(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a scalar to location volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_from_scalar_metadata, name, description, out_arg())

    _create_volume_calc_solar_intensity_metadata = { "name" : "create_volume_calc_solar_intensity",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_solar_intensity(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a solar intensity volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_solar_intensity_metadata, name, description, out_arg())

    _create_volume_calc_volume_satisfaction_metric_metadata = { "name" : "create_volume_calc_volume_satisfaction_metric",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_volume_satisfaction_metric(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a spatial condition satisfaction metric volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_volume_satisfaction_metric_metadata, name, description, out_arg())

    _create_volume_calc_range_metadata = { "name" : "create_volume_calc_range",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_range(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_range_metadata, name, description, out_arg())

    _create_volume_calc_delay_range_metadata = { "name" : "create_volume_calc_delay_range",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_calc_delay_range(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeCalc":
        """Create and registers a distance to location volume calc type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFactory._metadata, ISpatialAnalysisToolVolumeCalcFactory._create_volume_calc_delay_range_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{42eb6d4a-5cff-471f-997d-3f624cb4a416}", ISpatialAnalysisToolVolumeCalcFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFactory"] = ISpatialAnalysisToolVolumeCalcFactory

class ISpatialAnalysisToolVolumeFactory(object):
    """The factory is used to create instances of volumes."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE97990E-A152-417C-883E-64C42AB9B913}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2,
                             "create_volume_combined" : 3,
                             "create_volume_lighting" : 4,
                             "create_volume_over_time" : 5,
                             "create_volume_from_grid" : 6,
                             "create_volume_from_calc" : 7,
                             "create_volume_from_time_satisfaction" : 8,
                             "create_volume_from_condition" : 9,
                             "create_volume_inview" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_VOLUME_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_TYPE") -> "ISpatialAnalysisToolVolume":
        """Create and registers a volume using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_metadata, name, description, type, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._is_type_supported_metadata, eType, out_arg())

    _create_volume_combined_metadata = { "name" : "create_volume_combined",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_combined(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type combined."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_combined_metadata, name, description, out_arg())

    _create_volume_lighting_metadata = { "name" : "create_volume_lighting",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_lighting(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type lighting."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_lighting_metadata, name, description, out_arg())

    _create_volume_over_time_metadata = { "name" : "create_volume_over_time",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_over_time(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type over time."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_over_time_metadata, name, description, out_arg())

    _create_volume_from_grid_metadata = { "name" : "create_volume_from_grid",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_from_grid(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from grid."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_from_grid_metadata, name, description, out_arg())

    _create_volume_from_calc_metadata = { "name" : "create_volume_from_calc",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_from_calc(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from calc."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_from_calc_metadata, name, description, out_arg())

    _create_volume_from_time_satisfaction_metadata = { "name" : "create_volume_from_time_satisfaction",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_from_time_satisfaction(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type from time satisfaction."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_from_time_satisfaction_metadata, name, description, out_arg())

    _create_volume_from_condition_metadata = { "name" : "create_volume_from_condition",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_from_condition(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type condition."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_from_condition_metadata, name, description, out_arg())

    _create_volume_inview_metadata = { "name" : "create_volume_inview",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_inview(self, name:str, description:str) -> "ISpatialAnalysisToolVolume":
        """Create a volume type Inview."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFactory._metadata, ISpatialAnalysisToolVolumeFactory._create_volume_inview_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{FE97990E-A152-417C-883E-64C42AB9B913}", ISpatialAnalysisToolVolumeFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFactory"] = ISpatialAnalysisToolVolumeFactory

class ISpatialAnalysisToolVolumeGridFactory(object):
    """The factory is used to create instances of volume grids."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4533DEA1-D754-4579-A79D-B5A639C2CD39}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "create_volume_grid_cartesian" : 2,
                             "is_type_supported" : 3,
                             "create_volume_grid_cylindrical" : 4,
                             "create_volume_grid_spherical" : 5,
                             "create_volume_grid_constrained" : 6,
                             "create_volume_grid_lat_lon_altitude" : 7,
                             "create_volume_grid_bearing_altitude" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_VOLUME_GRID_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, name:str, description:str, type:"CRDN_VOLUME_GRID_TYPE") -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_metadata, name, description, type, out_arg())

    _create_volume_grid_cartesian_metadata = { "name" : "create_volume_grid_cartesian",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_cartesian(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a cartesian volume grid type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_cartesian_metadata, name, description, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_GRID_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, eType:"CRDN_VOLUME_GRID_TYPE") -> bool:
        """Return whether the specified type is supported."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._is_type_supported_metadata, eType, out_arg())

    _create_volume_grid_cylindrical_metadata = { "name" : "create_volume_grid_cylindrical",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_cylindrical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a cylindrical volume grid type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_cylindrical_metadata, name, description, out_arg())

    _create_volume_grid_spherical_metadata = { "name" : "create_volume_grid_spherical",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_spherical(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a spherical volume grid type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_spherical_metadata, name, description, out_arg())

    _create_volume_grid_constrained_metadata = { "name" : "create_volume_grid_constrained",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_constrained(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid of type that can be constrained by conditions using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_constrained_metadata, name, description, out_arg())

    _create_volume_grid_lat_lon_altitude_metadata = { "name" : "create_volume_grid_lat_lon_altitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_lat_lon_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers cartographic volume grid type using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_lat_lon_altitude_metadata, name, description, out_arg())

    _create_volume_grid_bearing_altitude_metadata = { "name" : "create_volume_grid_bearing_altitude",
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_volume_grid_bearing_altitude(self, name:str, description:str) -> "ISpatialAnalysisToolVolumeGrid":
        """Create and registers a volume grid of type surface bearing using specified name and description."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeGridFactory._metadata, ISpatialAnalysisToolVolumeGridFactory._create_volume_grid_bearing_altitude_metadata, name, description, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4533DEA1-D754-4579-A79D-B5A639C2CD39}", ISpatialAnalysisToolVolumeGridFactory)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridFactory"] = ISpatialAnalysisToolVolumeGridFactory

class ISpatialAnalysisToolGridCoordinateDefinition(object):
    """Define a set of coordinate values."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96875D1C-9CBC-4732-A678-2CB17995C0E9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_method_type" : 1,
                             "get_grid_values_method" : 2,
                             "set_grid_values_fixed_step" : 3,
                             "set_grid_values_fixed_number_of_steps" : 4,
                             "set_grid_values_custom" : 5,
                             "set_grid_values_fixed_number_of_steps_ex" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridCoordinateDefinition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridCoordinateDefinition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridCoordinateDefinition, None)
    
    _get_method_type_metadata = { "name" : "method_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE),) }
    @property
    def method_type(self) -> "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE":
        """Grid values method type."""
        return self._intf.get_property(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._get_method_type_metadata)

    _get_grid_values_method_metadata = { "name" : "grid_values_method",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def grid_values_method(self) -> "ISpatialAnalysisToolGridValuesMethod":
        """Get or set the grid values interface."""
        return self._intf.get_property(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._get_grid_values_method_metadata)

    _set_grid_values_fixed_step_metadata = { "name" : "set_grid_values_fixed_step",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT_BOOL, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_BOOL_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def set_grid_values_fixed_step(self, min:float, max:float, includeMinMax:bool, refValue:float, fixedStep:float) -> "SpatialAnalysisToolGridValuesFixedStep":
        """Set grid values type to fixed step."""
        return self._intf.invoke(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_step_metadata, min, max, includeMinMax, refValue, fixedStep, out_arg())

    _set_grid_values_fixed_number_of_steps_metadata = { "name" : "set_grid_values_fixed_number_of_steps",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def set_grid_values_fixed_number_of_steps(self, min:float, max:float, numSteps:int) -> "SpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """This method is deprecated. Use SetGridValuesFixedNumberOfStepsEx."""
        return self._intf.invoke(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_number_of_steps_metadata, min, max, numSteps, out_arg())

    _set_grid_values_custom_metadata = { "name" : "set_grid_values_custom",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg, agmarshall.AgInterface_out_arg,) }
    def set_grid_values_custom(self, values:list) -> "SpatialAnalysisToolGridValuesCustom":
        """Set grid values type to custom values."""
        return self._intf.invoke(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._set_grid_values_custom_metadata, values, out_arg())

    _set_grid_values_fixed_number_of_steps_ex_metadata = { "name" : "set_grid_values_fixed_number_of_steps_ex",
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"), agmarshall.AgInterface_in_arg("IQuantity"), agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def set_grid_values_fixed_number_of_steps_ex(self, min:"IQuantity", max:"IQuantity", numSteps:int) -> "SpatialAnalysisToolGridValuesFixedNumberOfSteps":
        """Set grid values type to fixed number of steps with min and max as Quantity."""
        return self._intf.invoke(ISpatialAnalysisToolGridCoordinateDefinition._metadata, ISpatialAnalysisToolGridCoordinateDefinition._set_grid_values_fixed_number_of_steps_ex_metadata, min, max, numSteps, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{96875D1C-9CBC-4732-A678-2CB17995C0E9}", ISpatialAnalysisToolGridCoordinateDefinition)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridCoordinateDefinition"] = ISpatialAnalysisToolGridCoordinateDefinition

class ISpatialAnalysisToolGridValuesCustom(object):
    """Fixed step grid values."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_values" : 1,
                             "set_values" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridValuesCustom)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridValuesCustom)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridValuesCustom, None)
    
    _get_values_metadata = { "name" : "values",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def values(self) -> list:
        """Custom set of coordinate values."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesCustom._metadata, ISpatialAnalysisToolGridValuesCustom._get_values_metadata)

    _set_values_metadata = { "name" : "values",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @values.setter
    def values(self, values:list) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesCustom._metadata, ISpatialAnalysisToolGridValuesCustom._set_values_metadata, values)


agcls.AgClassCatalog.add_catalog_entry("{CFD13837-AB7F-467F-8E15-9AFEA33CFD13}", ISpatialAnalysisToolGridValuesCustom)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesCustom"] = ISpatialAnalysisToolGridValuesCustom

class ISpatialAnalysisToolGridValuesFixedNumberOfSteps(object):
    """Fixed step grid values."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{379ACEFA-1B1E-4753-BA9A-87939E5B8893}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_min" : 1,
                             "set_min" : 2,
                             "get_max" : 3,
                             "set_max" : 4,
                             "get_number_of_steps" : 5,
                             "set_number_of_steps" : 6,
                             "get_min_ex" : 7,
                             "set_min_ex" : 8,
                             "get_max_ex" : 9,
                             "set_max_ex" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridValuesFixedNumberOfSteps)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridValuesFixedNumberOfSteps)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridValuesFixedNumberOfSteps, None)
    
    _get_min_metadata = { "name" : "min",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min(self) -> float:
        """This property is deprecated. Use MinEx."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_min_metadata)

    _set_min_metadata = { "name" : "min",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min.setter
    def min(self, min:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._set_min_metadata, min)

    _get_max_metadata = { "name" : "max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max(self) -> float:
        """This property is deprecated. Use MaxEx."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_max_metadata)

    _set_max_metadata = { "name" : "max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max.setter
    def max(self, max:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._set_max_metadata, max)

    _get_number_of_steps_metadata = { "name" : "number_of_steps",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def number_of_steps(self) -> int:
        """The number of steps between coordinate values."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_number_of_steps_metadata)

    _set_number_of_steps_metadata = { "name" : "number_of_steps",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @number_of_steps.setter
    def number_of_steps(self, numberOfSteps:int) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._set_number_of_steps_metadata, numberOfSteps)

    _get_min_ex_metadata = { "name" : "min_ex",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def min_ex(self) -> "IQuantity":
        """Minimum coordinate value as Quantity."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_min_ex_metadata)

    _set_min_ex_metadata = { "name" : "min_ex",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    @min_ex.setter
    def min_ex(self, minEx:"IQuantity") -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._set_min_ex_metadata, minEx)

    _get_max_ex_metadata = { "name" : "max_ex",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def max_ex(self) -> "IQuantity":
        """Maximum coordinate value as Quantity."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._get_max_ex_metadata)

    _set_max_ex_metadata = { "name" : "max_ex",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    @max_ex.setter
    def max_ex(self, maxEx:"IQuantity") -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedNumberOfSteps._metadata, ISpatialAnalysisToolGridValuesFixedNumberOfSteps._set_max_ex_metadata, maxEx)


agcls.AgClassCatalog.add_catalog_entry("{379ACEFA-1B1E-4753-BA9A-87939E5B8893}", ISpatialAnalysisToolGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesFixedNumberOfSteps"] = ISpatialAnalysisToolGridValuesFixedNumberOfSteps

class ISpatialAnalysisToolGridValuesFixedStep(object):
    """Fixed step grid values."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7C18BF81-7E22-4A28-B462-37ED86EC3050}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_min" : 1,
                             "set_min" : 2,
                             "get_max" : 3,
                             "set_max" : 4,
                             "get_include_min_max" : 5,
                             "set_include_min_max" : 6,
                             "get_reference_value" : 7,
                             "set_reference_value" : 8,
                             "get_step" : 9,
                             "set_step" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridValuesFixedStep)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridValuesFixedStep)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridValuesFixedStep, None)
    
    _get_min_metadata = { "name" : "min",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def min(self) -> float:
        """Minimum coordinate value."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._get_min_metadata)

    _set_min_metadata = { "name" : "min",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @min.setter
    def min(self, min:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._set_min_metadata, min)

    _get_max_metadata = { "name" : "max",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def max(self) -> float:
        """Maximum coordinate value."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._get_max_metadata)

    _set_max_metadata = { "name" : "max",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @max.setter
    def max(self, max:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._set_max_metadata, max)

    _get_include_min_max_metadata = { "name" : "include_min_max",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def include_min_max(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._get_include_min_max_metadata)

    _set_include_min_max_metadata = { "name" : "include_min_max",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @include_min_max.setter
    def include_min_max(self, includeMinMax:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._set_include_min_max_metadata, includeMinMax)

    _get_reference_value_metadata = { "name" : "reference_value",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def reference_value(self) -> float:
        """Reference coordinate value from which steps are taken."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._get_reference_value_metadata)

    _set_reference_value_metadata = { "name" : "reference_value",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @reference_value.setter
    def reference_value(self, referenceValue:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._set_reference_value_metadata, referenceValue)

    _get_step_metadata = { "name" : "step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def step(self) -> float:
        """Step between subsequent coordinate values."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._get_step_metadata)

    _set_step_metadata = { "name" : "step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @step.setter
    def step(self, step:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolGridValuesFixedStep._metadata, ISpatialAnalysisToolGridValuesFixedStep._set_step_metadata, step)


agcls.AgClassCatalog.add_catalog_entry("{7C18BF81-7E22-4A28-B462-37ED86EC3050}", ISpatialAnalysisToolGridValuesFixedStep)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesFixedStep"] = ISpatialAnalysisToolGridValuesFixedStep

class ISpatialAnalysisToolGridValuesMethod(object):
    """A grid values method."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_method_type" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolGridValuesMethod)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolGridValuesMethod)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolGridValuesMethod, None)
    
    _get_method_type_metadata = { "name" : "method_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE),) }
    @property
    def method_type(self) -> "CRDN_VOLUMETRIC_GRID_VALUES_METHOD_TYPE":
        """Grid values method type."""
        return self._intf.get_property(ISpatialAnalysisToolGridValuesMethod._metadata, ISpatialAnalysisToolGridValuesMethod._get_method_type_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6B730A6A-86AD-41C4-A0C0-4DC72FD27D0A}", ISpatialAnalysisToolGridValuesMethod)
agcls.AgTypeNameMap["ISpatialAnalysisToolGridValuesMethod"] = ISpatialAnalysisToolGridValuesMethod

class ITimeToolLightTimeDelay(object):
    """Manage Light Time Delay options.."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{82765B62-B9AB-4D52-900E-52ADAC0365D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_use_light_time_delay" : 1,
                             "set_use_light_time_delay" : 2,
                             "get_time_delay_convergence" : 3,
                             "set_time_delay_convergence" : 4,
                             "get_aberration_type" : 5,
                             "set_aberration_type" : 6,
                             "get_clock_host" : 7,
                             "set_clock_host" : 8,
                             "get_time_sense" : 9,
                             "set_time_sense" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolLightTimeDelay)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolLightTimeDelay)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolLightTimeDelay, None)
    
    _get_use_light_time_delay_metadata = { "name" : "use_light_time_delay",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_light_time_delay(self) -> bool:
        """Flag indicating whether to include minimum and maximum coordinate values in the defined set of values."""
        return self._intf.get_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._get_use_light_time_delay_metadata)

    _set_use_light_time_delay_metadata = { "name" : "use_light_time_delay",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_light_time_delay.setter
    def use_light_time_delay(self, useLightTimeDelay:bool) -> None:
        return self._intf.set_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._set_use_light_time_delay_metadata, useLightTimeDelay)

    _get_time_delay_convergence_metadata = { "name" : "time_delay_convergence",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def time_delay_convergence(self) -> float:
        """Set light Time Delay Convergence."""
        return self._intf.get_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._get_time_delay_convergence_metadata)

    _set_time_delay_convergence_metadata = { "name" : "time_delay_convergence",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @time_delay_convergence.setter
    def time_delay_convergence(self, timeDelayConvergence:float) -> None:
        return self._intf.set_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._set_time_delay_convergence_metadata, timeDelayConvergence)

    _get_aberration_type_metadata = { "name" : "aberration_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_ABERRATION_TYPE),) }
    @property
    def aberration_type(self) -> "CRDN_VOLUME_ABERRATION_TYPE":
        """Method used to Aberration Type."""
        return self._intf.get_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._get_aberration_type_metadata)

    _set_aberration_type_metadata = { "name" : "aberration_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_ABERRATION_TYPE),) }
    @aberration_type.setter
    def aberration_type(self, aberrationType:"CRDN_VOLUME_ABERRATION_TYPE") -> None:
        return self._intf.set_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._set_aberration_type_metadata, aberrationType)

    _get_clock_host_metadata = { "name" : "clock_host",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CLOCK_HOST_TYPE),) }
    @property
    def clock_host(self) -> "CRDN_VOLUME_CLOCK_HOST_TYPE":
        """Indicate whether object1 or object2 of an Access instance holds the clock for Access times."""
        return self._intf.get_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._get_clock_host_metadata)

    _set_clock_host_metadata = { "name" : "clock_host",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CLOCK_HOST_TYPE),) }
    @clock_host.setter
    def clock_host(self, clockHost:"CRDN_VOLUME_CLOCK_HOST_TYPE") -> None:
        return self._intf.set_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._set_clock_host_metadata, clockHost)

    _get_time_sense_metadata = { "name" : "time_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_TIME_SENSE_TYPE),) }
    @property
    def time_sense(self) -> "CRDN_VOLUME_TIME_SENSE_TYPE":
        """Indicate whether apparent position is computed in a transmit or receive sense."""
        return self._intf.get_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._get_time_sense_metadata)

    _set_time_sense_metadata = { "name" : "time_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_TIME_SENSE_TYPE),) }
    @time_sense.setter
    def time_sense(self, timeSense:"CRDN_VOLUME_TIME_SENSE_TYPE") -> None:
        return self._intf.set_property(ITimeToolLightTimeDelay._metadata, ITimeToolLightTimeDelay._set_time_sense_metadata, timeSense)


agcls.AgClassCatalog.add_catalog_entry("{82765B62-B9AB-4D52-900E-52ADAC0365D0}", ITimeToolLightTimeDelay)
agcls.AgTypeNameMap["ITimeToolLightTimeDelay"] = ITimeToolLightTimeDelay

class ISpatialAnalysisToolVolume(object):
    """A volume interface. The methods and properties of the interface provide Volume functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F85958EC-F470-432F-81B1-8517D3952F1E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolume)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolume)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolume, None)
    

agcls.AgClassCatalog.add_catalog_entry("{F85958EC-F470-432F-81B1-8517D3952F1E}", ISpatialAnalysisToolVolume)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolume"] = ISpatialAnalysisToolVolume

class ISpatialAnalysisToolVolumeCalc(object):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalc)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalc)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalc, None)
    

agcls.AgClassCatalog.add_catalog_entry("{1de42e63-b555-4272-8b9b-d6cf0ee5d1cf}", ISpatialAnalysisToolVolumeCalc)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalc"] = ISpatialAnalysisToolVolumeCalc

class ISpatialAnalysisToolVolumeCalcAltitude(object):
    """A volume calc altitude interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6039868a-acea-4918-966b-c6f952fd94d3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "set_central_body" : 2,
                             "get_shape_model" : 3,
                             "set_shape_model" : 4,
                             "get_use_custom_reference" : 5,
                             "set_use_custom_reference" : 6,
                             "get_reference_point" : 7,
                             "set_reference_point" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcAltitude)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcAltitude)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcAltitude, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def central_body(self) -> str:
        """Get the central body for the volume calc. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume calc."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._get_central_body_metadata)

    _set_central_body_metadata = { "name" : "central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._set_central_body_metadata, centralBody)

    _get_shape_model_metadata = { "name" : "shape_model",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE),) }
    @property
    def shape_model(self) -> "CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE":
        """The Volume Calc Altitude Reference Type."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._get_shape_model_metadata)

    _set_shape_model_metadata = { "name" : "shape_model",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE),) }
    @shape_model.setter
    def shape_model(self, shapeModel:"CRDN_VOLUME_CALC_ALTITUDE_REFERENCE_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._set_shape_model_metadata, shapeModel)

    _get_use_custom_reference_metadata = { "name" : "use_custom_reference",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_reference(self) -> bool:
        """Whether to use custom reference."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._get_use_custom_reference_metadata)

    _set_use_custom_reference_metadata = { "name" : "use_custom_reference",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_reference.setter
    def use_custom_reference(self, useCustomReference:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._set_use_custom_reference_metadata, useCustomReference)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._get_reference_point_metadata)

    _set_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAltitude._metadata, ISpatialAnalysisToolVolumeCalcAltitude._set_reference_point_metadata, referencePoint)


agcls.AgClassCatalog.add_catalog_entry("{6039868a-acea-4918-966b-c6f952fd94d3}", ISpatialAnalysisToolVolumeCalcAltitude)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcAltitude"] = ISpatialAnalysisToolVolumeCalcAltitude

class ISpatialAnalysisToolVolumeCalcAngleOffVector(object):
    """A volume calc angle off vector interface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ad6880b4-afc1-47ba-b964-f38916955c7b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_angle" : 1,
                             "set_angle" : 2,
                             "get_reference_plane" : 3,
                             "set_reference_plane" : 4,
                             "get_reference_point" : 5,
                             "set_reference_point" : 6,
                             "get_reference_vector" : 7,
                             "set_reference_vector" : 8,
                             "get_about_vector" : 9,
                             "set_about_vector" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcAngleOffVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcAngleOffVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcAngleOffVector, None)
    
    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE),) }
    @property
    def angle(self) -> "CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE":
        """The Volume Calc Angle Off Vector Type."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._get_angle_metadata)

    _set_angle_metadata = { "name" : "angle",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE),) }
    @angle.setter
    def angle(self, angle:"CRDN_VOLUME_CALC_ANGLE_OFF_VECTOR_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._set_angle_metadata, angle)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Angle Off Vector reference plane."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_plane_metadata, referencePlane)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Angle Off Vector reference point."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_point_metadata)

    _set_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_point_metadata, referencePoint)

    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference vector."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._get_reference_vector_metadata)

    _set_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @reference_vector.setter
    def reference_vector(self, referenceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._set_reference_vector_metadata, referenceVector)

    _get_about_vector_metadata = { "name" : "about_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def about_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Angle Off Vector reference about vector."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._get_about_vector_metadata)

    _set_about_vector_metadata = { "name" : "about_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @about_vector.setter
    def about_vector(self, aboutVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcAngleOffVector._metadata, ISpatialAnalysisToolVolumeCalcAngleOffVector._set_about_vector_metadata, aboutVector)


agcls.AgClassCatalog.add_catalog_entry("{ad6880b4-afc1-47ba-b964-f38916955c7b}", ISpatialAnalysisToolVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcAngleOffVector"] = ISpatialAnalysisToolVolumeCalcAngleOffVector

class ISpatialAnalysisToolVolumeCalcConditionSatMetric(object):
    """A volume calc condition satisfaction interface."""

    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_spatial_condition" : 1,
                             "set_spatial_condition" : 2,
                             "get_satisfaction_metric" : 3,
                             "set_satisfaction_metric" : 4,
                             "get_accumulation_type" : 5,
                             "set_accumulation_type" : 6,
                             "get_duration_type" : 7,
                             "set_duration_type" : 8,
                             "get_filter" : 9,
                             "set_filter" : 10,
                             "get_maximum_number_of_intervals" : 11,
                             "set_maximum_number_of_intervals" : 12,
                             "get_use_minimum_duration" : 13,
                             "set_use_minimum_duration" : 14,
                             "get_use_maximum_duration" : 15,
                             "set_use_maximum_duration" : 16,
                             "get_minimum_duration_time" : 17,
                             "set_minimum_duration_time" : 18,
                             "get_maximum_duration_time" : 19,
                             "set_maximum_duration_time" : 20, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcConditionSatMetric)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcConditionSatMetric)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcConditionSatMetric, None)
    
    _get_spatial_condition_metadata = { "name" : "spatial_condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def spatial_condition(self) -> "ISpatialAnalysisToolVolume":
        """A spatial condition for satisfaction metric."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_spatial_condition_metadata)

    _set_spatial_condition_metadata = { "name" : "spatial_condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolume"),) }
    @spatial_condition.setter
    def spatial_condition(self, spatialCondition:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_spatial_condition_metadata, spatialCondition)

    _get_satisfaction_metric_metadata = { "name" : "satisfaction_metric",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE),) }
    @property
    def satisfaction_metric(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE":
        """Spatial condition satisfaction metric types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_satisfaction_metric_metadata)

    _set_satisfaction_metric_metadata = { "name" : "satisfaction_metric",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE),) }
    @satisfaction_metric.setter
    def satisfaction_metric(self, satisfactionMetric:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_METRIC_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_satisfaction_metric_metadata, satisfactionMetric)

    _get_accumulation_type_metadata = { "name" : "accumulation_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE),) }
    @property
    def accumulation_type(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE":
        """Spatial condition satisfaction accumulation types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_accumulation_type_metadata)

    _set_accumulation_type_metadata = { "name" : "accumulation_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE),) }
    @accumulation_type.setter
    def accumulation_type(self, accumulationType:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_ACCUMULATION_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_accumulation_type_metadata, accumulationType)

    _get_duration_type_metadata = { "name" : "duration_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE),) }
    @property
    def duration_type(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_duration_type_metadata)

    _set_duration_type_metadata = { "name" : "duration_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE),) }
    @duration_type.setter
    def duration_type(self, durationType:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_DURATION_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_duration_type_metadata, durationType)

    _get_filter_metadata = { "name" : "filter",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE),) }
    @property
    def filter(self) -> "CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE":
        """Spatial condition satisfaction duration types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_filter_metadata)

    _set_filter_metadata = { "name" : "filter",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE),) }
    @filter.setter
    def filter(self, filter:"CRDN_VOLUME_CALC_VOLUME_SATISFACTION_FILTER_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_filter_metadata, filter)

    _get_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def maximum_number_of_intervals(self) -> int:
        """Spatial condition satisfaction Maximum number of intervals."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_maximum_number_of_intervals_metadata)

    _set_maximum_number_of_intervals_metadata = { "name" : "maximum_number_of_intervals",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    @maximum_number_of_intervals.setter
    def maximum_number_of_intervals(self, maximumNumberOfIntervals:int) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_maximum_number_of_intervals_metadata, maximumNumberOfIntervals)

    _get_use_minimum_duration_metadata = { "name" : "use_minimum_duration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_minimum_duration(self) -> bool:
        """Spatial condition satisfaction enable minimum duration."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_use_minimum_duration_metadata)

    _set_use_minimum_duration_metadata = { "name" : "use_minimum_duration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_minimum_duration.setter
    def use_minimum_duration(self, useMinimumDuration:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_use_minimum_duration_metadata, useMinimumDuration)

    _get_use_maximum_duration_metadata = { "name" : "use_maximum_duration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_maximum_duration(self) -> bool:
        """Spatial condition satisfaction enable maximum duration."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_use_maximum_duration_metadata)

    _set_use_maximum_duration_metadata = { "name" : "use_maximum_duration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_maximum_duration.setter
    def use_maximum_duration(self, useMaximumDuration:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_use_maximum_duration_metadata, useMaximumDuration)

    _get_minimum_duration_time_metadata = { "name" : "minimum_duration_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def minimum_duration_time(self) -> float:
        """Spatial condition satisfaction minimum duration time."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_minimum_duration_time_metadata)

    _set_minimum_duration_time_metadata = { "name" : "minimum_duration_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @minimum_duration_time.setter
    def minimum_duration_time(self, minimumDurationTime:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_minimum_duration_time_metadata, minimumDurationTime)

    _get_maximum_duration_time_metadata = { "name" : "maximum_duration_time",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maximum_duration_time(self) -> float:
        """Spatial condition satisfaction maximum duration time."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._get_maximum_duration_time_metadata)

    _set_maximum_duration_time_metadata = { "name" : "maximum_duration_time",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maximum_duration_time.setter
    def maximum_duration_time(self, maximumDurationTime:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcConditionSatMetric._metadata, ISpatialAnalysisToolVolumeCalcConditionSatMetric._set_maximum_duration_time_metadata, maximumDurationTime)


agcls.AgClassCatalog.add_catalog_entry("{b0f59ef2-3895-4240-bf50-0d4b8eac74fa}", ISpatialAnalysisToolVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcConditionSatMetric"] = ISpatialAnalysisToolVolumeCalcConditionSatMetric

class ISpatialAnalysisToolVolumeCalcDelayRange(object):
    """A volume calc propagation delay to location interface."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{874bf6c9-20d7-486c-918a-a0094093879a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_distance" : 1,
                             "set_distance" : 2,
                             "get_reference_point" : 3,
                             "set_reference_point" : 4,
                             "get_reference_plane" : 5,
                             "set_reference_plane" : 6,
                             "get_along_vector" : 7,
                             "set_along_vector" : 8,
                             "get_speed_type" : 9,
                             "set_speed_type" : 10,
                             "get_speed" : 11,
                             "set_speed" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcDelayRange)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcDelayRange)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcDelayRange, None)
    
    _get_distance_metadata = { "name" : "distance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @property
    def distance(self) -> "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE":
        """The Volume Calc range distance types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_distance_metadata)

    _set_distance_metadata = { "name" : "distance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @distance.setter
    def distance(self, distance:"CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_distance_metadata, distance)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_reference_point_metadata)

    _set_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_reference_point_metadata, referencePoint)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_reference_plane_metadata, referencePlane)

    _get_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_along_vector_metadata)

    _set_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_along_vector_metadata, alongVector)

    _get_speed_type_metadata = { "name" : "speed_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_SPEED_TYPE),) }
    @property
    def speed_type(self) -> "CRDN_VOLUME_CALC_RANGE_SPEED_TYPE":
        """The Volume Calc range speed types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_speed_type_metadata)

    _set_speed_type_metadata = { "name" : "speed_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_SPEED_TYPE),) }
    @speed_type.setter
    def speed_type(self, speedType:"CRDN_VOLUME_CALC_RANGE_SPEED_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_speed_type_metadata, speedType)

    _get_speed_metadata = { "name" : "speed",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def speed(self) -> float:
        """The Volume Calc range speed value."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._get_speed_metadata)

    _set_speed_metadata = { "name" : "speed",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @speed.setter
    def speed(self, speed:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcDelayRange._metadata, ISpatialAnalysisToolVolumeCalcDelayRange._set_speed_metadata, speed)


agcls.AgClassCatalog.add_catalog_entry("{874bf6c9-20d7-486c-918a-a0094093879a}", ISpatialAnalysisToolVolumeCalcDelayRange)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcDelayRange"] = ISpatialAnalysisToolVolumeCalcDelayRange

class ISpatialAnalysisToolVolumeCalcFile(object):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{362b7405-edf6-486c-8fcf-1f9a93b75000}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2,
                             "reload" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcFile)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcFile)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcFile, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """The path of an external file that contains the volume calc data."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcFile._metadata, ISpatialAnalysisToolVolumeCalcFile._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcFile._metadata, ISpatialAnalysisToolVolumeCalcFile._set_filename_metadata, filename)

    _reload_metadata = { "name" : "reload",
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the volume calc file."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCalcFile._metadata, ISpatialAnalysisToolVolumeCalcFile._reload_metadata, )


agcls.AgClassCatalog.add_catalog_entry("{362b7405-edf6-486c-8fcf-1f9a93b75000}", ISpatialAnalysisToolVolumeCalcFile)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFile"] = ISpatialAnalysisToolVolumeCalcFile

class ISpatialAnalysisToolVolumeCalcFromScalar(object):
    """A volume calc scalar to location interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6e537b27-ee55-44c5-89b2-f2c504a44bb6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_scalar" : 1,
                             "set_scalar" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcFromScalar)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcFromScalar)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcFromScalar, None)
    
    _get_scalar_metadata = { "name" : "scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar(self) -> "ICalculationToolScalar":
        """The Volume calc scalar to location Type."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcFromScalar._metadata, ISpatialAnalysisToolVolumeCalcFromScalar._get_scalar_metadata)

    _set_scalar_metadata = { "name" : "scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar.setter
    def scalar(self, scalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcFromScalar._metadata, ISpatialAnalysisToolVolumeCalcFromScalar._set_scalar_metadata, scalar)


agcls.AgClassCatalog.add_catalog_entry("{6e537b27-ee55-44c5-89b2-f2c504a44bb6}", ISpatialAnalysisToolVolumeCalcFromScalar)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcFromScalar"] = ISpatialAnalysisToolVolumeCalcFromScalar

class ISpatialAnalysisToolVolumeCalcRange(object):
    """A volume calc distance to location interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_distance" : 1,
                             "set_distance" : 2,
                             "get_reference_point" : 3,
                             "set_reference_point" : 4,
                             "get_reference_plane" : 5,
                             "set_reference_plane" : 6,
                             "get_along_vector" : 7,
                             "set_along_vector" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcRange)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcRange)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcRange, None)
    
    _get_distance_metadata = { "name" : "distance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @property
    def distance(self) -> "CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE":
        """The Volume Calc range distance types."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._get_distance_metadata)

    _set_distance_metadata = { "name" : "distance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE),) }
    @distance.setter
    def distance(self, distance:"CRDN_VOLUME_CALC_RANGE_DISTANCE_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._set_distance_metadata, distance)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """The Volume Calc Range reference point."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._get_reference_point_metadata)

    _set_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._set_reference_point_metadata, referencePoint)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "IVectorGeometryToolPlane":
        """The Volume Calc Range reference plane."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._get_reference_plane_metadata)

    _set_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPlane"),) }
    @reference_plane.setter
    def reference_plane(self, referencePlane:"IVectorGeometryToolPlane") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._set_reference_plane_metadata, referencePlane)

    _get_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """The Volume Calc Range Along Vector."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._get_along_vector_metadata)

    _set_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcRange._metadata, ISpatialAnalysisToolVolumeCalcRange._set_along_vector_metadata, alongVector)


agcls.AgClassCatalog.add_catalog_entry("{3e52b4ce-9e1f-426a-b0a7-45e6bd9c9b85}", ISpatialAnalysisToolVolumeCalcRange)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcRange"] = ISpatialAnalysisToolVolumeCalcRange

class ISpatialAnalysisToolVolumeCalcSolarIntensity(object):
    """A volume calc solar intensityn interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{40e35f2b-9a83-449a-9a4e-35bdee832061}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_eclipsing_bodies" : 1,
                             "set_eclipsing_bodies" : 2,
                             "get_use_object_eclipsing_bodies" : 3,
                             "set_use_object_eclipsing_bodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCalcSolarIntensity)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCalcSolarIntensity)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCalcSolarIntensity, None)
    
    _get_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcSolarIntensity._metadata, ISpatialAnalysisToolVolumeCalcSolarIntensity._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcSolarIntensity._metadata, ISpatialAnalysisToolVolumeCalcSolarIntensity._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCalcSolarIntensity._metadata, ISpatialAnalysisToolVolumeCalcSolarIntensity._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCalcSolarIntensity._metadata, ISpatialAnalysisToolVolumeCalcSolarIntensity._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)


agcls.AgClassCatalog.add_catalog_entry("{40e35f2b-9a83-449a-9a4e-35bdee832061}", ISpatialAnalysisToolVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCalcSolarIntensity"] = ISpatialAnalysisToolVolumeCalcSolarIntensity

class ISpatialAnalysisToolVolumeCombined(object):
    """A combined volume interface."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{96684FB4-3839-44DB-AD80-B772BF58A39A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_combine_operation" : 1,
                             "set_combine_operation" : 2,
                             "get_condition_count" : 3,
                             "get_all_conditions" : 4,
                             "set_all_conditions" : 5,
                             "set_condition" : 6,
                             "get_condition" : 7,
                             "remove_condition" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeCombined)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeCombined)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeCombined, None)
    
    _get_combine_operation_metadata = { "name" : "combine_operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_COMBINED_OPERATION_TYPE),) }
    @property
    def combine_operation(self) -> "CRDN_VOLUME_COMBINED_OPERATION_TYPE":
        """Get or set volume combined operation."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._get_combine_operation_metadata)

    _set_combine_operation_metadata = { "name" : "combine_operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_COMBINED_OPERATION_TYPE),) }
    @combine_operation.setter
    def combine_operation(self, combineOperation:"CRDN_VOLUME_COMBINED_OPERATION_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._set_combine_operation_metadata, combineOperation)

    _get_condition_count_metadata = { "name" : "condition_count",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def condition_count(self) -> int:
        """Return the spatial condition vector size."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._get_condition_count_metadata)

    _get_all_conditions_metadata = { "name" : "get_all_conditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def get_all_conditions(self) -> list:
        """Get all spatial conditions."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._get_all_conditions_metadata, out_arg())

    _set_all_conditions_metadata = { "name" : "set_all_conditions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    def set_all_conditions(self, conditions:list) -> None:
        """Set all spatial conditions."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._set_all_conditions_metadata, conditions)

    _set_condition_metadata = { "name" : "set_condition",
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolume"), agmarshall.INT_arg,) }
    def set_condition(self, ref:"ISpatialAnalysisToolVolume", pos:int) -> None:
        """Set spatial conditions at a position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._set_condition_metadata, ref, pos)

    _get_condition_metadata = { "name" : "get_condition",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_condition(self, pos:int) -> "ISpatialAnalysisToolVolume":
        """Get spatial conditions at a position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._get_condition_metadata, pos, out_arg())

    _remove_condition_metadata = { "name" : "remove_condition",
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.INT_arg,) }
    def remove_condition(self, pos:int) -> None:
        """Remove spatial conditions at a position."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeCombined._metadata, ISpatialAnalysisToolVolumeCombined._remove_condition_metadata, pos)


agcls.AgClassCatalog.add_catalog_entry("{96684FB4-3839-44DB-AD80-B772BF58A39A}", ISpatialAnalysisToolVolumeCombined)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeCombined"] = ISpatialAnalysisToolVolumeCombined

class ISpatialAnalysisToolVolumeFromCalc(object):
    """An volume from calc volume interface."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{018666E1-C0E6-46F6-A682-F91FBF3C74F3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_operation" : 1,
                             "set_operation" : 2,
                             "get_volume_calc" : 3,
                             "set_volume_calc" : 4,
                             "get_minimum" : 5,
                             "set_minimum" : 6,
                             "get_maximum" : 7,
                             "set_maximum" : 8,
                             "set" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeFromCalc)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeFromCalc)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeFromCalc, None)
    
    _get_operation_metadata = { "name" : "operation",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @property
    def operation(self) -> "CRDN_CONDITION_THRESHOLD_OPTION":
        """Get the operation from the condition that determines how the bounds are considered. The operation can be set to define satisfaction when the scalar is above minimum, below maximum, between minimum and maximum or outside minimum and maximum."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._get_operation_metadata)

    _set_operation_metadata = { "name" : "operation",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_CONDITION_THRESHOLD_OPTION),) }
    @operation.setter
    def operation(self, operation:"CRDN_CONDITION_THRESHOLD_OPTION") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._set_operation_metadata, operation)

    _get_volume_calc_metadata = { "name" : "volume_calc",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def volume_calc(self) -> "ISpatialAnalysisToolVolumeCalc":
        """Get the volume calc from the bounds."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._get_volume_calc_metadata)

    _set_volume_calc_metadata = { "name" : "volume_calc",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolumeCalc"),) }
    @volume_calc.setter
    def volume_calc(self, volumeCalc:"ISpatialAnalysisToolVolumeCalc") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._set_volume_calc_metadata, volumeCalc)

    _get_minimum_metadata = { "name" : "get_minimum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_minimum(self) -> "IQuantity":
        """Get the minimum bound value from the bounds. Call SetMinimum to apply changes."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._get_minimum_metadata, out_arg())

    _set_minimum_metadata = { "name" : "set_minimum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set_minimum(self, value:"IQuantity") -> None:
        """Set the minimum bound value for the bounds."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._set_minimum_metadata, value)

    _get_maximum_metadata = { "name" : "get_maximum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_maximum(self) -> "IQuantity":
        """Get the maximum bound value from the bounds. Call SetMaximum to apply changes."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._get_maximum_metadata, out_arg())

    _set_maximum_metadata = { "name" : "set_maximum",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set_maximum(self, value:"IQuantity") -> None:
        """Set the maximum bound value for the condition."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._set_maximum_metadata, value)

    _set_metadata = { "name" : "set",
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IQuantity"), agmarshall.AgInterface_in_arg("IQuantity"),) }
    def set(self, min:"IQuantity", max:"IQuantity") -> None:
        """Set the min/max bounds. Throws an exception if the minimum is greater than maximum."""
        return self._intf.invoke(ISpatialAnalysisToolVolumeFromCalc._metadata, ISpatialAnalysisToolVolumeFromCalc._set_metadata, min, max)


agcls.AgClassCatalog.add_catalog_entry("{018666E1-C0E6-46F6-A682-F91FBF3C74F3}", ISpatialAnalysisToolVolumeFromCalc)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromCalc"] = ISpatialAnalysisToolVolumeFromCalc

class ISpatialAnalysisToolVolumeFromCondition(object):
    """A volume from conditioninterface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_condition" : 1,
                             "set_condition" : 2,
                             "get_use_custom_time_limits" : 3,
                             "set_use_custom_time_limits" : 4,
                             "get_custom_time_limits" : 5,
                             "set_custom_time_limits" : 6,
                             "get_sampling" : 7,
                             "set_sampling" : 8,
                             "get_convergence" : 9,
                             "set_convergence" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeFromCondition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeFromCondition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeFromCondition, None)
    
    _get_condition_metadata = { "name" : "condition",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition(self) -> "ICalculationToolCondition":
        """The condition component."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._get_condition_metadata)

    _set_condition_metadata = { "name" : "condition",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolCondition"),) }
    @condition.setter
    def condition(self, condition:"ICalculationToolCondition") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._set_condition_metadata, condition)

    _get_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_custom_time_limits(self) -> bool:
        """Indicate whether to use specified custom time limits (see CustomTimeLimits)."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._get_use_custom_time_limits_metadata)

    _set_use_custom_time_limits_metadata = { "name" : "use_custom_time_limits",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_custom_time_limits.setter
    def use_custom_time_limits(self, useCustomTimeLimits:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._set_use_custom_time_limits_metadata, useCustomTimeLimits)

    _get_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def custom_time_limits(self) -> "ITimeToolEventIntervalList":
        """A custom interval list or a single interval. It is by default set to overall availability of host object. This determines time limits within extrema are sought. The time limits will be used if UseCustomTimeLimits is set to true."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._get_custom_time_limits_metadata)

    _set_custom_time_limits_metadata = { "name" : "custom_time_limits",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @custom_time_limits.setter
    def custom_time_limits(self, customTimeLimits:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._set_custom_time_limits_metadata, customTimeLimits)

    _get_sampling_metadata = { "name" : "sampling",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sampling(self) -> "IAnalysisWorkbenchSampling":
        """The Sampling definition, which can use a fixed step, relative tolerance or curvature tolerance. Relative tolerance uses a combination of relative and absolute changes in scalar values between samples..."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._get_sampling_metadata)

    _set_sampling_metadata = { "name" : "sampling",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchSampling"),) }
    @sampling.setter
    def sampling(self, sampling:"IAnalysisWorkbenchSampling") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._set_sampling_metadata, sampling)

    _get_convergence_metadata = { "name" : "convergence",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def convergence(self) -> "IAnalysisWorkbenchConverge":
        """The Convergence definition, which uses time tolerance to determine when times of extrema are found."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._get_convergence_metadata)

    _set_convergence_metadata = { "name" : "convergence",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchConverge"),) }
    @convergence.setter
    def convergence(self, convergence:"IAnalysisWorkbenchConverge") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromCondition._metadata, ISpatialAnalysisToolVolumeFromCondition._set_convergence_metadata, convergence)


agcls.AgClassCatalog.add_catalog_entry("{4A572DE9-9173-4F9A-AE4A-53BCC1B74069}", ISpatialAnalysisToolVolumeFromCondition)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromCondition"] = ISpatialAnalysisToolVolumeFromCondition

class ISpatialAnalysisToolVolumeFromGrid(object):
    """An over time volume interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_edge_type" : 1,
                             "set_edge_type" : 2,
                             "get_volume_grid" : 3,
                             "set_volume_grid" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeFromGrid)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeFromGrid)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeFromGrid, None)
    
    _get_edge_type_metadata = { "name" : "edge_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_FROM_GRID_EDGE_TYPE),) }
    @property
    def edge_type(self) -> "CRDN_VOLUME_FROM_GRID_EDGE_TYPE":
        """Get or set the edge type."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromGrid._metadata, ISpatialAnalysisToolVolumeFromGrid._get_edge_type_metadata)

    _set_edge_type_metadata = { "name" : "edge_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_FROM_GRID_EDGE_TYPE),) }
    @edge_type.setter
    def edge_type(self, edgeType:"CRDN_VOLUME_FROM_GRID_EDGE_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromGrid._metadata, ISpatialAnalysisToolVolumeFromGrid._set_edge_type_metadata, edgeType)

    _get_volume_grid_metadata = { "name" : "volume_grid",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def volume_grid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Get or set the volume grid for bounding."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromGrid._metadata, ISpatialAnalysisToolVolumeFromGrid._get_volume_grid_metadata)

    _set_volume_grid_metadata = { "name" : "volume_grid",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolumeGrid"),) }
    @volume_grid.setter
    def volume_grid(self, volumeGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromGrid._metadata, ISpatialAnalysisToolVolumeFromGrid._set_volume_grid_metadata, volumeGrid)


agcls.AgClassCatalog.add_catalog_entry("{6DABC743-93D8-4E19-A0CC-03C469C5BE8D}", ISpatialAnalysisToolVolumeFromGrid)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromGrid"] = ISpatialAnalysisToolVolumeFromGrid

class ISpatialAnalysisToolVolumeFromTimeSatisfaction(object):
    """An volume from time satisfaction volume interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_time_satisfaction" : 1,
                             "set_time_satisfaction" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeFromTimeSatisfaction)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeFromTimeSatisfaction)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeFromTimeSatisfaction, None)
    
    _get_time_satisfaction_metadata = { "name" : "time_satisfaction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def time_satisfaction(self) -> "ITimeToolEventIntervalList":
        """The interval list within which the global minimum or maximum is sought. The default is the overall availability of host object."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeFromTimeSatisfaction._metadata, ISpatialAnalysisToolVolumeFromTimeSatisfaction._get_time_satisfaction_metadata)

    _set_time_satisfaction_metadata = { "name" : "time_satisfaction",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @time_satisfaction.setter
    def time_satisfaction(self, timeSatisfaction:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeFromTimeSatisfaction._metadata, ISpatialAnalysisToolVolumeFromTimeSatisfaction._set_time_satisfaction_metadata, timeSatisfaction)


agcls.AgClassCatalog.add_catalog_entry("{1028DA18-F3B4-4064-83C8-45A5B2DDCC4B}", ISpatialAnalysisToolVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeFromTimeSatisfaction"] = ISpatialAnalysisToolVolumeFromTimeSatisfaction

class ISpatialAnalysisToolVolumeGrid(object):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{88BBE781-85C1-439D-A4F4-58006B9A35EC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : {  }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGrid)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGrid)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGrid, None)
    

agcls.AgClassCatalog.add_catalog_entry("{88BBE781-85C1-439D-A4F4-58006B9A35EC}", ISpatialAnalysisToolVolumeGrid)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGrid"] = ISpatialAnalysisToolVolumeGrid

class ISpatialAnalysisToolVolumeGridBearingAlt(object):
    """A volume grid bearing alt (Surface Bearing) interface."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2814A890-E858-41A6-B640-19F9D27E5ACB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_central_body" : 1,
                             "set_reference_central_body" : 2,
                             "get_along_bearing_coordinates" : 3,
                             "get_cross_bearing_coordinates" : 4,
                             "get_altitude_coordinates" : 5,
                             "get_auto_fit_bounds" : 6,
                             "set_auto_fit_bounds" : 7,
                             "get_bearing_angle" : 8,
                             "set_bearing_angle" : 9,
                             "get_reference_location" : 10,
                             "set_reference_location" : 11, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridBearingAlt)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridBearingAlt)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridBearingAlt, None)
    
    _get_reference_central_body_metadata = { "name" : "reference_central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def reference_central_body(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_reference_central_body_metadata)

    _set_reference_central_body_metadata = { "name" : "reference_central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @reference_central_body.setter
    def reference_central_body(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._set_reference_central_body_metadata, referenceCentralBody)

    _get_along_bearing_coordinates_metadata = { "name" : "along_bearing_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def along_bearing_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return AlongBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_along_bearing_coordinates_metadata)

    _get_cross_bearing_coordinates_metadata = { "name" : "cross_bearing_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def cross_bearing_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return CrossBearing Coordinates parameters for the surface bearing."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_cross_bearing_coordinates_metadata)

    _get_altitude_coordinates_metadata = { "name" : "altitude_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return altitude Coordinates parameters for the surface bearing."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_altitude_coordinates_metadata)

    _get_auto_fit_bounds_metadata = { "name" : "auto_fit_bounds",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def auto_fit_bounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_auto_fit_bounds_metadata)

    _set_auto_fit_bounds_metadata = { "name" : "auto_fit_bounds",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @auto_fit_bounds.setter
    def auto_fit_bounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._set_auto_fit_bounds_metadata, autoFitBounds)

    _get_bearing_angle_metadata = { "name" : "bearing_angle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def bearing_angle(self) -> float:
        """Specify the Bearing Angle."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_bearing_angle_metadata)

    _set_bearing_angle_metadata = { "name" : "bearing_angle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @bearing_angle.setter
    def bearing_angle(self, bearingAngle:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._set_bearing_angle_metadata, bearingAngle)

    _get_reference_location_metadata = { "name" : "reference_location",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def reference_location(self) -> list:
        """Get lat/lon for reference location."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._get_reference_location_metadata)

    _set_reference_location_metadata = { "name" : "reference_location",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @reference_location.setter
    def reference_location(self, referenceLocation:list) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridBearingAlt._metadata, ISpatialAnalysisToolVolumeGridBearingAlt._set_reference_location_metadata, referenceLocation)


agcls.AgClassCatalog.add_catalog_entry("{2814A890-E858-41A6-B640-19F9D27E5ACB}", ISpatialAnalysisToolVolumeGridBearingAlt)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridBearingAlt"] = ISpatialAnalysisToolVolumeGridBearingAlt

class ISpatialAnalysisToolVolumeGridCartesian(object):
    """A volume grid Cartesian interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E959F851-165E-4201-8C13-81FA4C2D3E2D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_system" : 1,
                             "set_reference_system" : 2,
                             "get_x_coordinates" : 3,
                             "get_y_coordinates" : 4,
                             "get_z_coordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridCartesian)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridCartesian)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridCartesian, None)
    
    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which Cartesian parameters are computed."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCartesian._metadata, ISpatialAnalysisToolVolumeGridCartesian._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridCartesian._metadata, ISpatialAnalysisToolVolumeGridCartesian._set_reference_system_metadata, referenceSystem)

    _get_x_coordinates_metadata = { "name" : "x_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return X Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCartesian._metadata, ISpatialAnalysisToolVolumeGridCartesian._get_x_coordinates_metadata)

    _get_y_coordinates_metadata = { "name" : "y_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return Y Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCartesian._metadata, ISpatialAnalysisToolVolumeGridCartesian._get_y_coordinates_metadata)

    _get_z_coordinates_metadata = { "name" : "z_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def z_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return Z Coordinates parameters for the Cartesian system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCartesian._metadata, ISpatialAnalysisToolVolumeGridCartesian._get_z_coordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E959F851-165E-4201-8C13-81FA4C2D3E2D}", ISpatialAnalysisToolVolumeGridCartesian)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridCartesian"] = ISpatialAnalysisToolVolumeGridCartesian

class ISpatialAnalysisToolVolumeGridConstrained(object):
    """A volume grid constrained interface."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_grid" : 1,
                             "set_reference_grid" : 2,
                             "get_constraint" : 3,
                             "set_constraint" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridConstrained)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridConstrained)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridConstrained, None)
    
    _get_reference_grid_metadata = { "name" : "reference_grid",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_grid(self) -> "ISpatialAnalysisToolVolumeGrid":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridConstrained._metadata, ISpatialAnalysisToolVolumeGridConstrained._get_reference_grid_metadata)

    _set_reference_grid_metadata = { "name" : "reference_grid",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolumeGrid"),) }
    @reference_grid.setter
    def reference_grid(self, referenceGrid:"ISpatialAnalysisToolVolumeGrid") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridConstrained._metadata, ISpatialAnalysisToolVolumeGridConstrained._set_reference_grid_metadata, referenceGrid)

    _get_constraint_metadata = { "name" : "constraint",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def constraint(self) -> "ISpatialAnalysisToolVolume":
        """Get the volume constraint on the grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridConstrained._metadata, ISpatialAnalysisToolVolumeGridConstrained._get_constraint_metadata)

    _set_constraint_metadata = { "name" : "constraint",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolume"),) }
    @constraint.setter
    def constraint(self, constraint:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridConstrained._metadata, ISpatialAnalysisToolVolumeGridConstrained._set_constraint_metadata, constraint)


agcls.AgClassCatalog.add_catalog_entry("{8631DE26-8FA9-43B9-8F17-D967DCDEBF42}", ISpatialAnalysisToolVolumeGridConstrained)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridConstrained"] = ISpatialAnalysisToolVolumeGridConstrained

class ISpatialAnalysisToolVolumeGridCylindrical(object):
    """A volume grid cylindrical interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0CF87427-CC2B-4282-9B41-0A2D86395AD4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_system" : 1,
                             "set_reference_system" : 2,
                             "get_theta_coordinates" : 3,
                             "get_radius_coordinates" : 4,
                             "get_height_coordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridCylindrical)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridCylindrical)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridCylindrical, None)
    
    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which cylindrical parameters are computed."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCylindrical._metadata, ISpatialAnalysisToolVolumeGridCylindrical._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridCylindrical._metadata, ISpatialAnalysisToolVolumeGridCylindrical._set_reference_system_metadata, referenceSystem)

    _get_theta_coordinates_metadata = { "name" : "theta_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def theta_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return theta Coordinates parameters for the Theta system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCylindrical._metadata, ISpatialAnalysisToolVolumeGridCylindrical._get_theta_coordinates_metadata)

    _get_radius_coordinates_metadata = { "name" : "radius_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def radius_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return radius Coordinates parameters for the Radius system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCylindrical._metadata, ISpatialAnalysisToolVolumeGridCylindrical._get_radius_coordinates_metadata)

    _get_height_coordinates_metadata = { "name" : "height_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def height_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return height Coordinates parameters for the Height system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridCylindrical._metadata, ISpatialAnalysisToolVolumeGridCylindrical._get_height_coordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{0CF87427-CC2B-4282-9B41-0A2D86395AD4}", ISpatialAnalysisToolVolumeGridCylindrical)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridCylindrical"] = ISpatialAnalysisToolVolumeGridCylindrical

class ISpatialAnalysisToolVolumeGridLatLonAlt(object):
    """A volume grid lat lon alt (Cartogrographic) interface."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_central_body" : 1,
                             "set_reference_central_body" : 2,
                             "get_latitude_coordinates" : 3,
                             "get_longitude_coordinates" : 4,
                             "get_altitude_coordinates" : 5,
                             "get_auto_fit_bounds" : 6,
                             "set_auto_fit_bounds" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridLatLonAlt)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridLatLonAlt)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridLatLonAlt, None)
    
    _get_reference_central_body_metadata = { "name" : "reference_central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def reference_central_body(self) -> str:
        """Get the central body for the volume grid. Both the central body reference shape and its CBF (central body centered fixed) system are used by this volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._get_reference_central_body_metadata)

    _set_reference_central_body_metadata = { "name" : "reference_central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @reference_central_body.setter
    def reference_central_body(self, referenceCentralBody:str) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._set_reference_central_body_metadata, referenceCentralBody)

    _get_latitude_coordinates_metadata = { "name" : "latitude_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def latitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return latitude Coordinates parameters for the Theta system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._get_latitude_coordinates_metadata)

    _get_longitude_coordinates_metadata = { "name" : "longitude_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def longitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return longtitude Coordinates parameters for the Radius system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._get_longitude_coordinates_metadata)

    _get_altitude_coordinates_metadata = { "name" : "altitude_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def altitude_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return altitude parameters for the Height system."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._get_altitude_coordinates_metadata)

    _get_auto_fit_bounds_metadata = { "name" : "auto_fit_bounds",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def auto_fit_bounds(self) -> bool:
        """Specify whether to use the auto fit bounds. Set to true to use the auto fit bounds.."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._get_auto_fit_bounds_metadata)

    _set_auto_fit_bounds_metadata = { "name" : "auto_fit_bounds",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @auto_fit_bounds.setter
    def auto_fit_bounds(self, autoFitBounds:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridLatLonAlt._metadata, ISpatialAnalysisToolVolumeGridLatLonAlt._set_auto_fit_bounds_metadata, autoFitBounds)


agcls.AgClassCatalog.add_catalog_entry("{8FE5F029-DBD1-4A12-BEB4-49D1616AE1E0}", ISpatialAnalysisToolVolumeGridLatLonAlt)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridLatLonAlt"] = ISpatialAnalysisToolVolumeGridLatLonAlt

class ISpatialAnalysisToolVolumeGridResult(object):
    """An interface that generates Volume Grid results."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1C3B106C-011E-4C51-B321-20389C8EAF76}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_epoch" : 1,
                             "get_size_i" : 2,
                             "get_size_j" : 3,
                             "get_size_k" : 4,
                             "get_volume_metric_data_vector" : 5,
                             "get_volume_metric_position_vector" : 6,
                             "get_volume_metric_native_position_vector" : 7,
                             "get_volume_metric_gradient_vector" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridResult, None)
    
    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """Epoch of returned volumetric data."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_epoch_metadata)

    _get_size_i_metadata = { "name" : "size_i",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def size_i(self) -> int:
        """Number of grid point coordinates representing first dimension of volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_size_i_metadata)

    _get_size_j_metadata = { "name" : "size_j",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def size_j(self) -> int:
        """Number of grid point coordinates representing second dimension of volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_size_j_metadata)

    _get_size_k_metadata = { "name" : "size_k",
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.INT_arg,) }
    @property
    def size_k(self) -> int:
        """Number of grid point coordinates representing third dimension of volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_size_k_metadata)

    _get_volume_metric_data_vector_metadata = { "name" : "volume_metric_data_vector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def volume_metric_data_vector(self) -> list:
        """Vector of scalar values representing volumetric data."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_volume_metric_data_vector_metadata)

    _get_volume_metric_position_vector_metadata = { "name" : "volume_metric_position_vector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def volume_metric_position_vector(self) -> list:
        """Vector of Cartesian coordinates of all volume grid points."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_volume_metric_position_vector_metadata)

    _get_volume_metric_native_position_vector_metadata = { "name" : "volume_metric_native_position_vector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def volume_metric_native_position_vector(self) -> list:
        """Vector of native coordinates of all volume grid points."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_volume_metric_native_position_vector_metadata)

    _get_volume_metric_gradient_vector_metadata = { "name" : "volume_metric_gradient_vector",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def volume_metric_gradient_vector(self) -> list:
        """Vector of Cartesian coordinates representing gradient vectors at all volume grid points."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridResult._metadata, ISpatialAnalysisToolVolumeGridResult._get_volume_metric_gradient_vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1C3B106C-011E-4C51-B321-20389C8EAF76}", ISpatialAnalysisToolVolumeGridResult)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridResult"] = ISpatialAnalysisToolVolumeGridResult

class ISpatialAnalysisToolVolumeGridSpherical(object):
    """A volume grid spherical interface."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_system" : 1,
                             "set_reference_system" : 2,
                             "get_azimuth_coordinates" : 3,
                             "get_elevation_coordinates" : 4,
                             "get_range_coordinates" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeGridSpherical)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeGridSpherical)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeGridSpherical, None)
    
    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """Get the reference system in which spherical parameters are computed."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridSpherical._metadata, ISpatialAnalysisToolVolumeGridSpherical._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeGridSpherical._metadata, ISpatialAnalysisToolVolumeGridSpherical._set_reference_system_metadata, referenceSystem)

    _get_azimuth_coordinates_metadata = { "name" : "azimuth_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def azimuth_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return azimuth coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridSpherical._metadata, ISpatialAnalysisToolVolumeGridSpherical._get_azimuth_coordinates_metadata)

    _get_elevation_coordinates_metadata = { "name" : "elevation_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def elevation_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return elevation coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridSpherical._metadata, ISpatialAnalysisToolVolumeGridSpherical._get_elevation_coordinates_metadata)

    _get_range_coordinates_metadata = { "name" : "range_coordinates",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def range_coordinates(self) -> "SpatialAnalysisToolGridCoordinateDefinition":
        """Return range coordinates parameters for the spherical volume grid."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeGridSpherical._metadata, ISpatialAnalysisToolVolumeGridSpherical._get_range_coordinates_metadata)


agcls.AgClassCatalog.add_catalog_entry("{548EEB3E-CFF2-4E58-AAF2-6F66B0CCC7ED}", ISpatialAnalysisToolVolumeGridSpherical)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeGridSpherical"] = ISpatialAnalysisToolVolumeGridSpherical

class ISpatialAnalysisToolVolumeInview(object):
    """An Inview volume interface."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EF724630-CEB6-4818-A5BB-F74CF1B9D931}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_constraint_object" : 1,
                             "set_constraint_object" : 2,
                             "get_light_time_delay" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeInview)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeInview)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeInview, None)
    
    _get_constraint_object_metadata = { "name" : "constraint_object",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def constraint_object(self) -> typing.Any:
        """A constraint object of the access."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeInview._metadata, ISpatialAnalysisToolVolumeInview._get_constraint_object_metadata)

    _set_constraint_object_metadata = { "name" : "constraint_object",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @constraint_object.setter
    def constraint_object(self, constraintObject:typing.Any) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeInview._metadata, ISpatialAnalysisToolVolumeInview._set_constraint_object_metadata, constraintObject)

    _get_light_time_delay_metadata = { "name" : "light_time_delay",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def light_time_delay(self) -> "TimeToolLightTimeDelay":
        """Return Light Time Delay options parameters."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeInview._metadata, ISpatialAnalysisToolVolumeInview._get_light_time_delay_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EF724630-CEB6-4818-A5BB-F74CF1B9D931}", ISpatialAnalysisToolVolumeInview)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeInview"] = ISpatialAnalysisToolVolumeInview

class ISpatialAnalysisToolVolumeLighting(object):
    """A lighting volume interface."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE134C08-274E-4E29-9337-03E9C73AA8F9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_eclipsing_bodies" : 1,
                             "set_eclipsing_bodies" : 2,
                             "get_use_object_eclipsing_bodies" : 3,
                             "set_use_object_eclipsing_bodies" : 4,
                             "get_lighting_conditions" : 5,
                             "set_lighting_conditions" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeLighting)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeLighting)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeLighting, None)
    
    _get_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def eclipsing_bodies(self) -> list:
        """A custom list of eclipsing bodies. This list is used if UseObjectEclipsingBodies is set to false."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._get_eclipsing_bodies_metadata)

    _set_eclipsing_bodies_metadata = { "name" : "eclipsing_bodies",
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @eclipsing_bodies.setter
    def eclipsing_bodies(self, eclipsingBodies:list) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._set_eclipsing_bodies_metadata, eclipsingBodies)

    _get_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_object_eclipsing_bodies(self) -> bool:
        """When true, configure eclipsing bodies list based on that of parent STK Object."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._get_use_object_eclipsing_bodies_metadata)

    _set_use_object_eclipsing_bodies_metadata = { "name" : "use_object_eclipsing_bodies",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_object_eclipsing_bodies.setter
    def use_object_eclipsing_bodies(self, useObjectEclipsingBodies:bool) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._set_use_object_eclipsing_bodies_metadata, useObjectEclipsingBodies)

    _get_lighting_conditions_metadata = { "name" : "lighting_conditions",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE),) }
    @property
    def lighting_conditions(self) -> "CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE":
        """Get or set the lighting conditions."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._get_lighting_conditions_metadata)

    _set_lighting_conditions_metadata = { "name" : "lighting_conditions",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE),) }
    @lighting_conditions.setter
    def lighting_conditions(self, lightingConditions:"CRDN_VOLUME_LIGHTING_CONDITIONS_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeLighting._metadata, ISpatialAnalysisToolVolumeLighting._set_lighting_conditions_metadata, lightingConditions)


agcls.AgClassCatalog.add_catalog_entry("{CE134C08-274E-4E29-9337-03E9C73AA8F9}", ISpatialAnalysisToolVolumeLighting)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeLighting"] = ISpatialAnalysisToolVolumeLighting

class ISpatialAnalysisToolVolumeOverTime(object):
    """An over time volume interface."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_duration_type" : 1,
                             "set_duration_type" : 2,
                             "get_reference_volume" : 3,
                             "set_reference_volume" : 4,
                             "get_reference_intervals" : 5,
                             "set_reference_intervals" : 6,
                             "get_start_offset" : 7,
                             "set_start_offset" : 8,
                             "get_stop_offset" : 9,
                             "set_stop_offset" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ISpatialAnalysisToolVolumeOverTime)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISpatialAnalysisToolVolumeOverTime)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ISpatialAnalysisToolVolumeOverTime, None)
    
    _get_duration_type_metadata = { "name" : "duration_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_OVER_TIME_DURATION_TYPE),) }
    @property
    def duration_type(self) -> "CRDN_VOLUME_OVER_TIME_DURATION_TYPE":
        """Get or set the lighting conditions."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._get_duration_type_metadata)

    _set_duration_type_metadata = { "name" : "duration_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_VOLUME_OVER_TIME_DURATION_TYPE),) }
    @duration_type.setter
    def duration_type(self, durationType:"CRDN_VOLUME_OVER_TIME_DURATION_TYPE") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._set_duration_type_metadata, durationType)

    _get_reference_volume_metadata = { "name" : "reference_volume",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_volume(self) -> "ISpatialAnalysisToolVolume":
        """Get or set the reference volume."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._get_reference_volume_metadata)

    _set_reference_volume_metadata = { "name" : "reference_volume",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ISpatialAnalysisToolVolume"),) }
    @reference_volume.setter
    def reference_volume(self, referenceVolume:"ISpatialAnalysisToolVolume") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._set_reference_volume_metadata, referenceVolume)

    _get_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_intervals(self) -> "ITimeToolEventIntervalList":
        """The reference interval list for the over time volume."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._get_reference_intervals_metadata)

    _set_reference_intervals_metadata = { "name" : "reference_intervals",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEventIntervalList"),) }
    @reference_intervals.setter
    def reference_intervals(self, referenceIntervals:"ITimeToolEventIntervalList") -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._set_reference_intervals_metadata, referenceIntervals)

    _get_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_offset(self) -> float:
        """Set the offset with respect to current time to define the start of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._get_start_offset_metadata)

    _set_start_offset_metadata = { "name" : "start_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_offset.setter
    def start_offset(self, startOffset:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._set_start_offset_metadata, startOffset)

    _get_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_offset(self) -> float:
        """Set the offset with respect to current time to define the stop of the sliding window, used when over time volume is set to Sliding Window."""
        return self._intf.get_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._get_stop_offset_metadata)

    _set_stop_offset_metadata = { "name" : "stop_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_offset.setter
    def stop_offset(self, stopOffset:float) -> None:
        return self._intf.set_property(ISpatialAnalysisToolVolumeOverTime._metadata, ISpatialAnalysisToolVolumeOverTime._set_stop_offset_metadata, stopOffset)


agcls.AgClassCatalog.add_catalog_entry("{8CE9DE37-1A5E-43AD-B191-9D21722B64D8}", ISpatialAnalysisToolVolumeOverTime)
agcls.AgTypeNameMap["ISpatialAnalysisToolVolumeOverTime"] = ISpatialAnalysisToolVolumeOverTime

class ITimeToolTimeProperties(object):
    """Define methods to compute time properties such as availability and special times."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E95B72AA-F8DE-4122-AC60-54E46A208E19}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_availability" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolTimeProperties)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolTimeProperties)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolTimeProperties, None)
    
    _get_availability_metadata = { "name" : "get_availability",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_availability(self) -> "TimeToolIntervalCollection":
        """Return a collection of availability intervals."""
        return self._intf.invoke(ITimeToolTimeProperties._metadata, ITimeToolTimeProperties._get_availability_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E95B72AA-F8DE-4122-AC60-54E46A208E19}", ITimeToolTimeProperties)
agcls.AgTypeNameMap["ITimeToolTimeProperties"] = ITimeToolTimeProperties

class IAnalysisWorkbenchTypeInfo(object):
    """Provide information about the type of VGT components."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{67E20A46-9550-4A68-9276-697DC821A23A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_type_description" : 1,
                             "get_type_name" : 2,
                             "get_short_type_description" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchTypeInfo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchTypeInfo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchTypeInfo, None)
    
    _get_type_description_metadata = { "name" : "type_description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def type_description(self) -> str:
        """Return the type description."""
        return self._intf.get_property(IAnalysisWorkbenchTypeInfo._metadata, IAnalysisWorkbenchTypeInfo._get_type_description_metadata)

    _get_type_name_metadata = { "name" : "type_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def type_name(self) -> str:
        """Return the type name."""
        return self._intf.get_property(IAnalysisWorkbenchTypeInfo._metadata, IAnalysisWorkbenchTypeInfo._get_type_name_metadata)

    _get_short_type_description_metadata = { "name" : "short_type_description",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def short_type_description(self) -> str:
        """Return the short type description."""
        return self._intf.get_property(IAnalysisWorkbenchTypeInfo._metadata, IAnalysisWorkbenchTypeInfo._get_short_type_description_metadata)


agcls.AgClassCatalog.add_catalog_entry("{67E20A46-9550-4A68-9276-697DC821A23A}", IAnalysisWorkbenchTypeInfo)
agcls.AgTypeNameMap["IAnalysisWorkbenchTypeInfo"] = IAnalysisWorkbenchTypeInfo

class IAnalysisWorkbenchRefTo(object):
    """A base interface for all VGT component references."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2F3A17A6-4304-4565-BC1C-7A064DCFE310}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_path" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchRefTo, None)
    
    _get_path_metadata = { "name" : "path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def path(self) -> str:
        """Return a path to the referenced VGT component."""
        return self._intf.get_property(IAnalysisWorkbenchRefTo._metadata, IAnalysisWorkbenchRefTo._get_path_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2F3A17A6-4304-4565-BC1C-7A064DCFE310}", IAnalysisWorkbenchRefTo)
agcls.AgTypeNameMap["IAnalysisWorkbenchRefTo"] = IAnalysisWorkbenchRefTo

class IAnalysisWorkbenchTemplate(object):
    """The AnalysisWorkbenchTemplate interface enables to obtain information about the STK class that owns the VGT component."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_class_name" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchTemplate)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchTemplate)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchTemplate, None)
    
    _get_class_name_metadata = { "name" : "class_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def class_name(self) -> str:
        """Return a class name (i.e. 'Satellite', 'Facility', etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchTemplate._metadata, IAnalysisWorkbenchTemplate._get_class_name_metadata)


agcls.AgClassCatalog.add_catalog_entry("{990635EA-63F9-4CA7-A5A8-DEDAA9C52100}", IAnalysisWorkbenchTemplate)
agcls.AgTypeNameMap["IAnalysisWorkbenchTemplate"] = IAnalysisWorkbenchTemplate

class IAnalysisWorkbenchInstance(object):
    """The AnalysisWorkbenchInstance interface enables to obtain information about the parent object that owns the VGT component."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{17633665-9601-4FFF-8227-4D5DF0AAEA06}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_instance_path" : 1,
                             "get_template" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchInstance)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchInstance)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchInstance, None)
    
    _get_instance_path_metadata = { "name" : "instance_path",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def instance_path(self) -> str:
        """Return a path to the parent object that owns the VGT component."""
        return self._intf.get_property(IAnalysisWorkbenchInstance._metadata, IAnalysisWorkbenchInstance._get_instance_path_metadata)

    _get_template_metadata = { "name" : "template",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def template(self) -> "IAnalysisWorkbenchComponent":
        """Return a template object the VGT component was created from or null if the VGT component was not created from a template."""
        return self._intf.get_property(IAnalysisWorkbenchInstance._metadata, IAnalysisWorkbenchInstance._get_template_metadata)


agcls.AgClassCatalog.add_catalog_entry("{17633665-9601-4FFF-8227-4D5DF0AAEA06}", IAnalysisWorkbenchInstance)
agcls.AgTypeNameMap["IAnalysisWorkbenchInstance"] = IAnalysisWorkbenchInstance

class IVectorGeometryToolPointRefTo(object):
    """Represents a reference to a VGT point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B553DE32-05C9-4944-918A-90552E039DBE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_point" : 2,
                             "get_point" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new point."""
        return self._intf.invoke(IVectorGeometryToolPointRefTo._metadata, IVectorGeometryToolPointRefTo._set_path_metadata, path)

    _set_point_metadata = { "name" : "set_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    def set_point(self, point:"IVectorGeometryToolPoint") -> None:
        """Set a new point."""
        return self._intf.invoke(IVectorGeometryToolPointRefTo._metadata, IVectorGeometryToolPointRefTo._set_point_metadata, point)

    _get_point_metadata = { "name" : "get_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_point(self) -> "IVectorGeometryToolPoint":
        """Return the actual point object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolPointRefTo._metadata, IVectorGeometryToolPointRefTo._get_point_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, point:"IVectorGeometryToolPoint") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolPointRefTo._metadata, IVectorGeometryToolPointRefTo._has_cyclic_dependency_metadata, point, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{B553DE32-05C9-4944-918A-90552E039DBE}", IVectorGeometryToolPointRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolPointRefTo"] = IVectorGeometryToolPointRefTo

class IVectorGeometryToolVectorRefTo(object):
    """Represents a reference to a VGT vector."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EDF2E070-340E-456C-BDA8-BE9B9B40E728}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_vector" : 2,
                             "get_vector" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new vector."""
        return self._intf.invoke(IVectorGeometryToolVectorRefTo._metadata, IVectorGeometryToolVectorRefTo._set_path_metadata, path)

    _set_vector_metadata = { "name" : "set_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    def set_vector(self, vector:"IVectorGeometryToolVector") -> None:
        """Set a new vector."""
        return self._intf.invoke(IVectorGeometryToolVectorRefTo._metadata, IVectorGeometryToolVectorRefTo._set_vector_metadata, vector)

    _get_vector_metadata = { "name" : "get_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_vector(self) -> "IVectorGeometryToolVector":
        """Return the actual vector object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolVectorRefTo._metadata, IVectorGeometryToolVectorRefTo._get_vector_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, vector:"IVectorGeometryToolVector") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolVectorRefTo._metadata, IVectorGeometryToolVectorRefTo._has_cyclic_dependency_metadata, vector, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{EDF2E070-340E-456C-BDA8-BE9B9B40E728}", IVectorGeometryToolVectorRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolVectorRefTo"] = IVectorGeometryToolVectorRefTo

class IVectorGeometryToolAxesRefTo(object):
    """Represents a reference to a VGT axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_axes" : 2,
                             "get_axes" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new axes."""
        return self._intf.invoke(IVectorGeometryToolAxesRefTo._metadata, IVectorGeometryToolAxesRefTo._set_path_metadata, path)

    _set_axes_metadata = { "name" : "set_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    def set_axes(self, axes:"IVectorGeometryToolAxes") -> None:
        """Set a new axes."""
        return self._intf.invoke(IVectorGeometryToolAxesRefTo._metadata, IVectorGeometryToolAxesRefTo._set_axes_metadata, axes)

    _get_axes_metadata = { "name" : "get_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_axes(self) -> "IVectorGeometryToolAxes":
        """Return the actual axes object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolAxesRefTo._metadata, IVectorGeometryToolAxesRefTo._get_axes_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, axes:"IVectorGeometryToolAxes") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolAxesRefTo._metadata, IVectorGeometryToolAxesRefTo._has_cyclic_dependency_metadata, axes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{32701D6E-A7D0-4EDD-93B9-ADEA5D8BBF37}", IVectorGeometryToolAxesRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolAxesRefTo"] = IVectorGeometryToolAxesRefTo

class IVectorGeometryToolAngleRefTo(object):
    """Represents a reference to a VGT angle."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7A9D809F-D819-4458-9855-2DA8507F6E57}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_angle" : 2,
                             "get_angle" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new angle."""
        return self._intf.invoke(IVectorGeometryToolAngleRefTo._metadata, IVectorGeometryToolAngleRefTo._set_path_metadata, path)

    _set_angle_metadata = { "name" : "set_angle",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAngle"),) }
    def set_angle(self, angle:"IVectorGeometryToolAngle") -> None:
        """Set a new angle."""
        return self._intf.invoke(IVectorGeometryToolAngleRefTo._metadata, IVectorGeometryToolAngleRefTo._set_angle_metadata, angle)

    _get_angle_metadata = { "name" : "get_angle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_angle(self) -> "IVectorGeometryToolAngle":
        """Return the actual angle object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolAngleRefTo._metadata, IVectorGeometryToolAngleRefTo._get_angle_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAngle"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, angle:"IVectorGeometryToolAngle") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolAngleRefTo._metadata, IVectorGeometryToolAngleRefTo._has_cyclic_dependency_metadata, angle, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{7A9D809F-D819-4458-9855-2DA8507F6E57}", IVectorGeometryToolAngleRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolAngleRefTo"] = IVectorGeometryToolAngleRefTo

class IVectorGeometryToolSystemRefTo(object):
    """Represents a reference to a VGT system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_system" : 2,
                             "get_system" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new system."""
        return self._intf.invoke(IVectorGeometryToolSystemRefTo._metadata, IVectorGeometryToolSystemRefTo._set_path_metadata, path)

    _set_system_metadata = { "name" : "set_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    def set_system(self, system:"IVectorGeometryToolSystem") -> None:
        """Set a new system."""
        return self._intf.invoke(IVectorGeometryToolSystemRefTo._metadata, IVectorGeometryToolSystemRefTo._set_system_metadata, system)

    _get_system_metadata = { "name" : "get_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_system(self) -> "IVectorGeometryToolSystem":
        """Return the actual system object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolSystemRefTo._metadata, IVectorGeometryToolSystemRefTo._get_system_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, system:"IVectorGeometryToolSystem") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolSystemRefTo._metadata, IVectorGeometryToolSystemRefTo._has_cyclic_dependency_metadata, system, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{1CB0AFC5-CB6B-40FD-9F26-9295E2BED854}", IVectorGeometryToolSystemRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolSystemRefTo"] = IVectorGeometryToolSystemRefTo

class IVectorGeometryToolPlaneRefTo(object):
    """Represents a reference to a VGT plane."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CE3D70F2-61E0-4A23-803F-A734005DC36D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_plane" : 2,
                             "get_plane" : 3,
                             "has_cyclic_dependency" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new plane using a specified path."""
        return self._intf.invoke(IVectorGeometryToolPlaneRefTo._metadata, IVectorGeometryToolPlaneRefTo._set_path_metadata, path)

    _set_plane_metadata = { "name" : "set_plane",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPlane"),) }
    def set_plane(self, plane:"IVectorGeometryToolPlane") -> None:
        """Set a new plane."""
        return self._intf.invoke(IVectorGeometryToolPlaneRefTo._metadata, IVectorGeometryToolPlaneRefTo._set_plane_metadata, plane)

    _get_plane_metadata = { "name" : "get_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_plane(self) -> "IVectorGeometryToolPlane":
        """Return the actual plane object behind the reference. Use IAnalysisWorkbenchComponent.IsValid to test the validity of the returned object."""
        return self._intf.invoke(IVectorGeometryToolPlaneRefTo._metadata, IVectorGeometryToolPlaneRefTo._get_plane_metadata, out_arg())

    _has_cyclic_dependency_metadata = { "name" : "has_cyclic_dependency",
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPlane"), agmarshall.VARIANT_BOOL_arg,) }
    def has_cyclic_dependency(self, plane:"IVectorGeometryToolPlane") -> bool:
        """Test whether the input component and the target component form a cyclic dependency."""
        return self._intf.invoke(IVectorGeometryToolPlaneRefTo._metadata, IVectorGeometryToolPlaneRefTo._has_cyclic_dependency_metadata, plane, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CE3D70F2-61E0-4A23-803F-A734005DC36D}", IVectorGeometryToolPlaneRefTo)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneRefTo"] = IVectorGeometryToolPlaneRefTo

class IVectorGeometryToolAxesLabels(object):
    """Allow configuring the VGT axes labels."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0CD79528-D932-4473-9CC4-0BF5C936A6CD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_label_x" : 1,
                             "set_label_x" : 2,
                             "get_label_y" : 3,
                             "set_label_y" : 4,
                             "get_label_z" : 5,
                             "set_label_z" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesLabels)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesLabels)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesLabels, None)
    
    _get_label_x_metadata = { "name" : "label_x",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_x(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._get_label_x_metadata)

    _set_label_x_metadata = { "name" : "label_x",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @label_x.setter
    def label_x(self, labelX:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._set_label_x_metadata, labelX)

    _get_label_y_metadata = { "name" : "label_y",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_y(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._get_label_y_metadata)

    _set_label_y_metadata = { "name" : "label_y",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @label_y.setter
    def label_y(self, labelY:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._set_label_y_metadata, labelY)

    _get_label_z_metadata = { "name" : "label_z",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def label_z(self) -> str:
        """Specify a Z axis label."""
        return self._intf.get_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._get_label_z_metadata)

    _set_label_z_metadata = { "name" : "label_z",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @label_z.setter
    def label_z(self, labelZ:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesLabels._metadata, IVectorGeometryToolAxesLabels._set_label_z_metadata, labelZ)


agcls.AgClassCatalog.add_catalog_entry("{0CD79528-D932-4473-9CC4-0BF5C936A6CD}", IVectorGeometryToolAxesLabels)
agcls.AgTypeNameMap["IVectorGeometryToolAxesLabels"] = IVectorGeometryToolAxesLabels

class IVectorGeometryToolPlaneLabels(object):
    """Allow configuring the X and Y axes labels."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_x_axis_label" : 1,
                             "set_x_axis_label" : 2,
                             "get_y_axis_label" : 3,
                             "set_y_axis_label" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneLabels)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneLabels)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneLabels, None)
    
    _get_x_axis_label_metadata = { "name" : "x_axis_label",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def x_axis_label(self) -> str:
        """Specify an X axis label."""
        return self._intf.get_property(IVectorGeometryToolPlaneLabels._metadata, IVectorGeometryToolPlaneLabels._get_x_axis_label_metadata)

    _set_x_axis_label_metadata = { "name" : "x_axis_label",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @x_axis_label.setter
    def x_axis_label(self, xAxisLabel:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPlaneLabels._metadata, IVectorGeometryToolPlaneLabels._set_x_axis_label_metadata, xAxisLabel)

    _get_y_axis_label_metadata = { "name" : "y_axis_label",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def y_axis_label(self) -> str:
        """Specify a Y axis label."""
        return self._intf.get_property(IVectorGeometryToolPlaneLabels._metadata, IVectorGeometryToolPlaneLabels._get_y_axis_label_metadata)

    _set_y_axis_label_metadata = { "name" : "y_axis_label",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @y_axis_label.setter
    def y_axis_label(self, yAxisLabel:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPlaneLabels._metadata, IVectorGeometryToolPlaneLabels._set_y_axis_label_metadata, yAxisLabel)


agcls.AgClassCatalog.add_catalog_entry("{CBBA652F-D011-4B7E-8517-D1F27EFA35D3}", IVectorGeometryToolPlaneLabels)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneLabels"] = IVectorGeometryToolPlaneLabels

class IVectorGeometryToolAxesAlignedAndConstrained(object):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{19991E4F-F368-41CD-AE27-96CF11EC963F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_alignment_reference_vector" : 1,
                             "get_constraint_reference_vector" : 2,
                             "get_alignment_direction" : 3,
                             "get_constraint_direction" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesAlignedAndConstrained)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesAlignedAndConstrained)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesAlignedAndConstrained, None)
    
    _get_alignment_reference_vector_metadata = { "name" : "alignment_reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def alignment_reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify an alignment reference vector."""
        return self._intf.get_property(IVectorGeometryToolAxesAlignedAndConstrained._metadata, IVectorGeometryToolAxesAlignedAndConstrained._get_alignment_reference_vector_metadata)

    _get_constraint_reference_vector_metadata = { "name" : "constraint_reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def constraint_reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a constraint reference vector."""
        return self._intf.get_property(IVectorGeometryToolAxesAlignedAndConstrained._metadata, IVectorGeometryToolAxesAlignedAndConstrained._get_constraint_reference_vector_metadata)

    _get_alignment_direction_metadata = { "name" : "alignment_direction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def alignment_direction(self) -> "IDirection":
        """Specify a desired alignment direction and the applicable parameters."""
        return self._intf.get_property(IVectorGeometryToolAxesAlignedAndConstrained._metadata, IVectorGeometryToolAxesAlignedAndConstrained._get_alignment_direction_metadata)

    _get_constraint_direction_metadata = { "name" : "constraint_direction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def constraint_direction(self) -> "IDirection":
        """Specify a desired constraint direction and the applicable parameters."""
        return self._intf.get_property(IVectorGeometryToolAxesAlignedAndConstrained._metadata, IVectorGeometryToolAxesAlignedAndConstrained._get_constraint_direction_metadata)


agcls.AgClassCatalog.add_catalog_entry("{19991E4F-F368-41CD-AE27-96CF11EC963F}", IVectorGeometryToolAxesAlignedAndConstrained)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAlignedAndConstrained"] = IVectorGeometryToolAxesAlignedAndConstrained

class IVectorGeometryToolAxesAngularOffset(object):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0096F935-281A-4EC9-92A4-7400BD2DEF60}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_spin_vector" : 1,
                             "get_rotation_angle" : 2,
                             "get_reference_axes" : 3,
                             "get_fixed_offset_angle" : 4,
                             "set_fixed_offset_angle" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesAngularOffset)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesAngularOffset)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesAngularOffset, None)
    
    _get_spin_vector_metadata = { "name" : "spin_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def spin_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(IVectorGeometryToolAxesAngularOffset._metadata, IVectorGeometryToolAxesAngularOffset._get_spin_vector_metadata)

    _get_rotation_angle_metadata = { "name" : "rotation_angle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def rotation_angle(self) -> "VectorGeometryToolAngleRefTo":
        """Specify a rotational angle."""
        return self._intf.get_property(IVectorGeometryToolAxesAngularOffset._metadata, IVectorGeometryToolAxesAngularOffset._get_rotation_angle_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesAngularOffset._metadata, IVectorGeometryToolAxesAngularOffset._get_reference_axes_metadata)

    _get_fixed_offset_angle_metadata = { "name" : "fixed_offset_angle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def fixed_offset_angle(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(IVectorGeometryToolAxesAngularOffset._metadata, IVectorGeometryToolAxesAngularOffset._get_fixed_offset_angle_metadata)

    _set_fixed_offset_angle_metadata = { "name" : "fixed_offset_angle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @fixed_offset_angle.setter
    def fixed_offset_angle(self, fixedOffsetAngle:float) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesAngularOffset._metadata, IVectorGeometryToolAxesAngularOffset._set_fixed_offset_angle_metadata, fixedOffsetAngle)


agcls.AgClassCatalog.add_catalog_entry("{0096F935-281A-4EC9-92A4-7400BD2DEF60}", IVectorGeometryToolAxesAngularOffset)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAngularOffset"] = IVectorGeometryToolAxesAngularOffset

class IVectorGeometryToolAxesFixedAtEpoch(object):
    """Axes based on another set fixed at a specified epoch."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CEB9E066-A9F8-4B74-AF7A-0301BF611843}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_source_axes" : 1,
                             "get_reference_axes" : 2,
                             "get_epoch" : 3,
                             "set_epoch" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFixedAtEpoch)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFixedAtEpoch)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFixedAtEpoch, None)
    
    _get_source_axes_metadata = { "name" : "source_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a source axes."""
        return self._intf.get_property(IVectorGeometryToolAxesFixedAtEpoch._metadata, IVectorGeometryToolAxesFixedAtEpoch._get_source_axes_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesFixedAtEpoch._metadata, IVectorGeometryToolAxesFixedAtEpoch._get_reference_axes_metadata)

    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(IVectorGeometryToolAxesFixedAtEpoch._metadata, IVectorGeometryToolAxesFixedAtEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "name" : "epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesFixedAtEpoch._metadata, IVectorGeometryToolAxesFixedAtEpoch._set_epoch_metadata, epoch)


agcls.AgClassCatalog.add_catalog_entry("{CEB9E066-A9F8-4B74-AF7A-0301BF611843}", IVectorGeometryToolAxesFixedAtEpoch)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFixedAtEpoch"] = IVectorGeometryToolAxesFixedAtEpoch

class IVectorGeometryToolAxesBPlane(object):
    """B-Plane axes using the selected target body and reference vector."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72FD97D1-AE64-45D2-973E-E4F491B474AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_trajectory" : 1,
                             "get_reference_vector" : 2,
                             "get_target_body" : 3,
                             "get_direction" : 4,
                             "set_direction" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesBPlane)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesBPlane)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesBPlane, None)
    
    _get_trajectory_metadata = { "name" : "trajectory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def trajectory(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IVectorGeometryToolAxesBPlane._metadata, IVectorGeometryToolAxesBPlane._get_trajectory_metadata)

    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IVectorGeometryToolAxesBPlane._metadata, IVectorGeometryToolAxesBPlane._get_reference_vector_metadata)

    _get_target_body_metadata = { "name" : "target_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(IVectorGeometryToolAxesBPlane._metadata, IVectorGeometryToolAxesBPlane._get_target_body_metadata)

    _get_direction_metadata = { "name" : "direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIRECTION_TYPE),) }
    @property
    def direction(self) -> "CRDN_DIRECTION_TYPE":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(IVectorGeometryToolAxesBPlane._metadata, IVectorGeometryToolAxesBPlane._get_direction_metadata)

    _set_direction_metadata = { "name" : "direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIRECTION_TYPE),) }
    @direction.setter
    def direction(self, direction:"CRDN_DIRECTION_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesBPlane._metadata, IVectorGeometryToolAxesBPlane._set_direction_metadata, direction)


agcls.AgClassCatalog.add_catalog_entry("{72FD97D1-AE64-45D2-973E-E4F491B474AC}", IVectorGeometryToolAxesBPlane)
agcls.AgTypeNameMap["IVectorGeometryToolAxesBPlane"] = IVectorGeometryToolAxesBPlane

class IVectorGeometryToolAxesCustomScript(object):
    """Customized axes offset with respect to a set of reference Axes."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F5A690E6-0304-49E0-BAB5-229F848B0401}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_axes" : 1,
                             "get_filename" : 2,
                             "set_filename" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesCustomScript)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesCustomScript)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesCustomScript, None)
    
    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesCustomScript._metadata, IVectorGeometryToolAxesCustomScript._get_reference_axes_metadata)

    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """Can be MATLAB (.m or .dll) or VB Script (.vbs) script file."""
        return self._intf.get_property(IVectorGeometryToolAxesCustomScript._metadata, IVectorGeometryToolAxesCustomScript._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesCustomScript._metadata, IVectorGeometryToolAxesCustomScript._set_filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{F5A690E6-0304-49E0-BAB5-229F848B0401}", IVectorGeometryToolAxesCustomScript)
agcls.AgTypeNameMap["IVectorGeometryToolAxesCustomScript"] = IVectorGeometryToolAxesCustomScript

class IVectorGeometryToolAxesAttitudeFile(object):
    """Axes specified by data from a file."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E4A194BD-44ED-498F-ACB2-9911C19F52E8}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesAttitudeFile)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesAttitudeFile)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesAttitudeFile, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(IVectorGeometryToolAxesAttitudeFile._metadata, IVectorGeometryToolAxesAttitudeFile._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesAttitudeFile._metadata, IVectorGeometryToolAxesAttitudeFile._set_filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{E4A194BD-44ED-498F-ACB2-9911C19F52E8}", IVectorGeometryToolAxesAttitudeFile)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAttitudeFile"] = IVectorGeometryToolAxesAttitudeFile

class IVectorGeometryToolAxesFixed(object):
    """Axes fixed in reference axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_axes" : 1,
                             "get_fixed_orientation" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFixed)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFixed)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFixed, None)
    
    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesFixed._metadata, IVectorGeometryToolAxesFixed._get_reference_axes_metadata)

    _get_fixed_orientation_metadata = { "name" : "fixed_orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed_orientation(self) -> "IOrientation":
        """Specify a desired orientation and the applicable parameters."""
        return self._intf.get_property(IVectorGeometryToolAxesFixed._metadata, IVectorGeometryToolAxesFixed._get_fixed_orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{AE9B0D51-E7DD-4B44-AB8C-A133177E4722}", IVectorGeometryToolAxesFixed)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFixed"] = IVectorGeometryToolAxesFixed

class IVectorGeometryToolAxesModelAttach(object):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3A20DEC4-2D89-416C-8B47-D76E859763B0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_pointable_element_name" : 1,
                             "set_pointable_element_name" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesModelAttach)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesModelAttach)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesModelAttach, None)
    
    _get_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(IVectorGeometryToolAxesModelAttach._metadata, IVectorGeometryToolAxesModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesModelAttach._metadata, IVectorGeometryToolAxesModelAttach._set_pointable_element_name_metadata, pointableElementName)


agcls.AgClassCatalog.add_catalog_entry("{3A20DEC4-2D89-416C-8B47-D76E859763B0}", IVectorGeometryToolAxesModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolAxesModelAttach"] = IVectorGeometryToolAxesModelAttach

class IVectorGeometryToolAxesSpinning(object):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ECB36015-B534-40C6-B50F-298217335C38}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_spin_vector" : 1,
                             "get_reference_axes" : 2,
                             "get_epoch" : 3,
                             "set_epoch" : 4,
                             "get_initial_offset" : 5,
                             "set_initial_offset" : 6,
                             "get_spin_rate" : 7,
                             "set_spin_rate" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesSpinning)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesSpinning)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesSpinning, None)
    
    _get_spin_vector_metadata = { "name" : "spin_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def spin_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a spin vector."""
        return self._intf.get_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._get_spin_vector_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._get_reference_axes_metadata)

    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch at which the axes are aligned with the reference axes."""
        return self._intf.get_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._get_epoch_metadata)

    _set_epoch_metadata = { "name" : "epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._set_epoch_metadata, epoch)

    _get_initial_offset_metadata = { "name" : "initial_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def initial_offset(self) -> float:
        """Specify an additional rotational offset."""
        return self._intf.get_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._get_initial_offset_metadata)

    _set_initial_offset_metadata = { "name" : "initial_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @initial_offset.setter
    def initial_offset(self, initialOffset:float) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._set_initial_offset_metadata, initialOffset)

    _get_spin_rate_metadata = { "name" : "spin_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def spin_rate(self) -> float:
        """Specify a spin rate the axes spins about the spin vector."""
        return self._intf.get_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._get_spin_rate_metadata)

    _set_spin_rate_metadata = { "name" : "spin_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @spin_rate.setter
    def spin_rate(self, spinRate:float) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesSpinning._metadata, IVectorGeometryToolAxesSpinning._set_spin_rate_metadata, spinRate)


agcls.AgClassCatalog.add_catalog_entry("{ECB36015-B534-40C6-B50F-298217335C38}", IVectorGeometryToolAxesSpinning)
agcls.AgTypeNameMap["IVectorGeometryToolAxesSpinning"] = IVectorGeometryToolAxesSpinning

class IVectorGeometryToolAxesOnSurface(object):
    """Topocentric axes located at the reference point's projection on the central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_use_msl" : 3,
                             "set_use_msl" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesOnSurface)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesOnSurface)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesOnSurface, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolAxesOnSurface._metadata, IVectorGeometryToolAxesOnSurface._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolAxesOnSurface._metadata, IVectorGeometryToolAxesOnSurface._get_reference_point_metadata)

    _get_use_msl_metadata = { "name" : "use_msl",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_msl(self) -> bool:
        """Specify whether the reference shape is at the Mean Sea Level."""
        return self._intf.get_property(IVectorGeometryToolAxesOnSurface._metadata, IVectorGeometryToolAxesOnSurface._get_use_msl_metadata)

    _set_use_msl_metadata = { "name" : "use_msl",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_msl.setter
    def use_msl(self, useMSL:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolAxesOnSurface._metadata, IVectorGeometryToolAxesOnSurface._set_use_msl_metadata, useMSL)


agcls.AgClassCatalog.add_catalog_entry("{4BA7B8F7-229B-47F8-8C6F-169F425B5BAA}", IVectorGeometryToolAxesOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolAxesOnSurface"] = IVectorGeometryToolAxesOnSurface

class IVectorGeometryToolAxesTrajectory(object):
    """Axes based on trajectory of the point relative to the reference coordinate system."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_trajectory_point" : 1,
                             "get_reference_system" : 2,
                             "get_trajectory_axes_type" : 3,
                             "set_trajectory_axes_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesTrajectory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesTrajectory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesTrajectory, None)
    
    _get_trajectory_point_metadata = { "name" : "trajectory_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def trajectory_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IVectorGeometryToolAxesTrajectory._metadata, IVectorGeometryToolAxesTrajectory._get_trajectory_point_metadata)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IVectorGeometryToolAxesTrajectory._metadata, IVectorGeometryToolAxesTrajectory._get_reference_system_metadata)

    _get_trajectory_axes_type_metadata = { "name" : "trajectory_axes_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_TRAJECTORY_AXES_TYPE),) }
    @property
    def trajectory_axes_type(self) -> "CRDN_TRAJECTORY_AXES_TYPE":
        """Specify a type of the trajectory's coordinate frame."""
        return self._intf.get_property(IVectorGeometryToolAxesTrajectory._metadata, IVectorGeometryToolAxesTrajectory._get_trajectory_axes_type_metadata)

    _set_trajectory_axes_type_metadata = { "name" : "trajectory_axes_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_TRAJECTORY_AXES_TYPE),) }
    @trajectory_axes_type.setter
    def trajectory_axes_type(self, trajectoryAxesType:"CRDN_TRAJECTORY_AXES_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesTrajectory._metadata, IVectorGeometryToolAxesTrajectory._set_trajectory_axes_type_metadata, trajectoryAxesType)


agcls.AgClassCatalog.add_catalog_entry("{012AC3CF-A84B-4E6D-8450-D0B09DE5873B}", IVectorGeometryToolAxesTrajectory)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTrajectory"] = IVectorGeometryToolAxesTrajectory

class IVectorGeometryToolAxesLagrangeLibration(object):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_primary_central_body" : 1,
                             "get_point_type" : 2,
                             "set_point_type" : 3,
                             "get_secondary_central_bodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesLagrangeLibration)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesLagrangeLibration)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesLagrangeLibration, None)
    
    _get_primary_central_body_metadata = { "name" : "primary_central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def primary_central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a primary central body."""
        return self._intf.get_property(IVectorGeometryToolAxesLagrangeLibration._metadata, IVectorGeometryToolAxesLagrangeLibration._get_primary_central_body_metadata)

    _get_point_type_metadata = { "name" : "point_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @property
    def point_type(self) -> "CRDN_LAGRANGE_LIBRATION_POINT_TYPE":
        """Specify a lagrange point (L1, L2, etc.)."""
        return self._intf.get_property(IVectorGeometryToolAxesLagrangeLibration._metadata, IVectorGeometryToolAxesLagrangeLibration._get_point_type_metadata)

    _set_point_type_metadata = { "name" : "point_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"CRDN_LAGRANGE_LIBRATION_POINT_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesLagrangeLibration._metadata, IVectorGeometryToolAxesLagrangeLibration._set_point_type_metadata, pointType)

    _get_secondary_central_bodies_metadata = { "name" : "secondary_central_bodies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def secondary_central_bodies(self) -> "AnalysisWorkbenchCentralBodyCollection":
        """Specify secondary central bodies."""
        return self._intf.get_property(IVectorGeometryToolAxesLagrangeLibration._metadata, IVectorGeometryToolAxesLagrangeLibration._get_secondary_central_bodies_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B08F0A95-4B11-4586-81C4-4EFCA4DE27DB}", IVectorGeometryToolAxesLagrangeLibration)
agcls.AgTypeNameMap["IVectorGeometryToolAxesLagrangeLibration"] = IVectorGeometryToolAxesLagrangeLibration

class IVectorGeometryToolAxesCommonTasks(object):
    """Provide methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create_topocentric_axes_quaternion" : 1,
                             "create_topocentric_axes_euler_angles" : 2,
                             "create_fixed" : 3,
                             "sample" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesCommonTasks)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesCommonTasks)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesCommonTasks, None)
    
    _create_topocentric_axes_quaternion_metadata = { "name" : "create_topocentric_axes_quaternion",
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_topocentric_axes_quaternion(self, originPoint:"IVectorGeometryToolPoint", qx:float, qy:float, qz:float, qs:float) -> "VectorGeometryToolAxesFixed":
        """Create non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The quaternion defines the axes's orientation."""
        return self._intf.invoke(IVectorGeometryToolAxesCommonTasks._metadata, IVectorGeometryToolAxesCommonTasks._create_topocentric_axes_quaternion_metadata, originPoint, qx, qy, qz, qs, out_arg())

    _create_topocentric_axes_euler_angles_metadata = { "name" : "create_topocentric_axes_euler_angles",
            "arg_types" : (agcom.PVOID, agcom.LONG, agcom.VARIANT, agcom.VARIANT, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.AgEnum_arg(EULER_ORIENTATION_SEQUENCE), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def create_topocentric_axes_euler_angles(self, originPoint:"IVectorGeometryToolPoint", sequence:"EULER_ORIENTATION_SEQUENCE", a:typing.Any, b:typing.Any, c:typing.Any) -> "VectorGeometryToolAxesFixed":
        """Create non-persistent axes fixed in axes on the surface of a central body with the location specified by the origin point. The euler angles define the axes's orientation."""
        return self._intf.invoke(IVectorGeometryToolAxesCommonTasks._metadata, IVectorGeometryToolAxesCommonTasks._create_topocentric_axes_euler_angles_metadata, originPoint, sequence, a, b, c, out_arg())

    _create_fixed_metadata = { "name" : "create_fixed",
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def create_fixed(self, referenceAxes:"IVectorGeometryToolAxes") -> "VectorGeometryToolAxesFixed":
        """Create non-persistent fixed axes based on specified axes."""
        return self._intf.invoke(IVectorGeometryToolAxesCommonTasks._metadata, IVectorGeometryToolAxesCommonTasks._create_fixed_metadata, referenceAxes, out_arg())

    _sample_metadata = { "name" : "sample",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.LPSAFEARRAY_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def sample(self, axes:"IVectorGeometryToolAxes", referenceAxes:"IVectorGeometryToolAxes", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "TimeToolAxesSamplingResult":
        """Compute and returns tabulated orientations and angular velocities of axes with respect to reference axes using specified sampling parameters."""
        return self._intf.invoke(IVectorGeometryToolAxesCommonTasks._metadata, IVectorGeometryToolAxesCommonTasks._sample_metadata, axes, referenceAxes, intervals, minStep, maxStep, targetRate, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{4A6CA7E3-BAF0-4D5A-AF67-5D44515D869D}", IVectorGeometryToolAxesCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolAxesCommonTasks"] = IVectorGeometryToolAxesCommonTasks

class IVectorGeometryToolAxesAtTimeInstant(object):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{193F4A55-5E79-43A1-8A2C-3C001F7608A5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2,
                             "get_source_axes" : 3,
                             "set_source_axes" : 4,
                             "get_reference_axes" : 5,
                             "set_reference_axes" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesAtTimeInstant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesAtTimeInstant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesAtTimeInstant, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_axes_metadata = { "name" : "source_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_axes(self) -> "IVectorGeometryToolAxes":
        """A base axes defining the orientation. Can be any VGT axes."""
        return self._intf.get_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._get_source_axes_metadata)

    _set_source_axes_metadata = { "name" : "source_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @source_axes.setter
    def source_axes(self, sourceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._set_source_axes_metadata, sourceAxes)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(IVectorGeometryToolAxesAtTimeInstant._metadata, IVectorGeometryToolAxesAtTimeInstant._set_reference_axes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{193F4A55-5E79-43A1-8A2C-3C001F7608A5}", IVectorGeometryToolAxesAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolAxesAtTimeInstant"] = IVectorGeometryToolAxesAtTimeInstant

class IVectorGeometryToolAxesPlugin(object):
    """A VGT axes plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E63FD5E1-B844-4893-9E4C-3F02210AE74C}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prog_id" : 1,
                             "get_display_name" : 2,
                             "get_available_properties" : 3,
                             "reset" : 4,
                             "set_property" : 5,
                             "get_property" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesPlugin)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesPlugin)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesPlugin, None)
    
    _get_prog_id_metadata = { "name" : "prog_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "name" : "display_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "name" : "available_properties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._get_available_properties_metadata)

    _reset_metadata = { "name" : "reset",
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._reset_metadata, )

    _set_property_metadata = { "name" : "set_property",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_property(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "name" : "get_property",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def get_property(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IVectorGeometryToolAxesPlugin._metadata, IVectorGeometryToolAxesPlugin._get_property_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{E63FD5E1-B844-4893-9E4C-3F02210AE74C}", IVectorGeometryToolAxesPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolAxesPlugin"] = IVectorGeometryToolAxesPlugin

class IVectorGeometryToolAngleBetweenVectors(object):
    """An angle between two vectors."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B3986E8E-A8CB-414F-8214-71C53ED00740}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_from_vector" : 1,
                             "get_to_vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleBetweenVectors)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleBetweenVectors)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleBetweenVectors, None)
    
    _get_from_vector_metadata = { "name" : "from_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def from_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the first of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleBetweenVectors._metadata, IVectorGeometryToolAngleBetweenVectors._get_from_vector_metadata)

    _get_to_vector_metadata = { "name" : "to_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def to_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleBetweenVectors._metadata, IVectorGeometryToolAngleBetweenVectors._get_to_vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B3986E8E-A8CB-414F-8214-71C53ED00740}", IVectorGeometryToolAngleBetweenVectors)
agcls.AgTypeNameMap["IVectorGeometryToolAngleBetweenVectors"] = IVectorGeometryToolAngleBetweenVectors

class IVectorGeometryToolAngleBetweenPlanes(object):
    """An angle between two planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_from_plane" : 1,
                             "get_to_plane" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleBetweenPlanes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleBetweenPlanes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleBetweenPlanes, None)
    
    _get_from_plane_metadata = { "name" : "from_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def from_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleBetweenPlanes._metadata, IVectorGeometryToolAngleBetweenPlanes._get_from_plane_metadata)

    _get_to_plane_metadata = { "name" : "to_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def to_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleBetweenPlanes._metadata, IVectorGeometryToolAngleBetweenPlanes._get_to_plane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{ACFE3BF5-C259-42DE-8EAE-D04FAD37C144}", IVectorGeometryToolAngleBetweenPlanes)
agcls.AgTypeNameMap["IVectorGeometryToolAngleBetweenPlanes"] = IVectorGeometryToolAngleBetweenPlanes

class IVectorGeometryToolAngleDihedral(object):
    """An angle between two vectors about an axis."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_from_vector" : 1,
                             "get_to_vector" : 2,
                             "get_pole_about" : 3,
                             "get_counter_clockwise_rotation" : 4,
                             "set_counter_clockwise_rotation" : 5,
                             "get_signed_angle" : 6,
                             "set_signed_angle" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleDihedral)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleDihedral)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleDihedral, None)
    
    _get_from_vector_metadata = { "name" : "from_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def from_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a first vector to measure the angle."""
        return self._intf.get_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._get_from_vector_metadata)

    _get_to_vector_metadata = { "name" : "to_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def to_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a second vector to measure the angle."""
        return self._intf.get_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._get_to_vector_metadata)

    _get_pole_about_metadata = { "name" : "pole_about",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def pole_about(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a vector about."""
        return self._intf.get_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._get_pole_about_metadata)

    _get_counter_clockwise_rotation_metadata = { "name" : "counter_clockwise_rotation",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def counter_clockwise_rotation(self) -> bool:
        """Specify whether the rotation is counter-clockwise."""
        return self._intf.get_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._get_counter_clockwise_rotation_metadata)

    _set_counter_clockwise_rotation_metadata = { "name" : "counter_clockwise_rotation",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @counter_clockwise_rotation.setter
    def counter_clockwise_rotation(self, counterClockwiseRotation:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._set_counter_clockwise_rotation_metadata, counterClockwiseRotation)

    _get_signed_angle_metadata = { "name" : "signed_angle",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def signed_angle(self) -> bool:
        """Specify whether the axis of rotation for the angle is aligned with Positive or Negative direction of the about vector."""
        return self._intf.get_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._get_signed_angle_metadata)

    _set_signed_angle_metadata = { "name" : "signed_angle",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @signed_angle.setter
    def signed_angle(self, signedAngle:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolAngleDihedral._metadata, IVectorGeometryToolAngleDihedral._set_signed_angle_metadata, signedAngle)


agcls.AgClassCatalog.add_catalog_entry("{39CB2F20-653C-4ED2-8B6F-A05C88AA50D7}", IVectorGeometryToolAngleDihedral)
agcls.AgTypeNameMap["IVectorGeometryToolAngleDihedral"] = IVectorGeometryToolAngleDihedral

class IVectorGeometryToolAngleRotation(object):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9E842F77-B3A8-475C-96AA-E692B35E8E05}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_from_axes" : 1,
                             "get_to_axes" : 2,
                             "get_reference_direction" : 3,
                             "set_reference_direction" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleRotation)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleRotation)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleRotation, None)
    
    _get_from_axes_metadata = { "name" : "from_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def from_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify an axes to rotate from."""
        return self._intf.get_property(IVectorGeometryToolAngleRotation._metadata, IVectorGeometryToolAngleRotation._get_from_axes_metadata)

    _get_to_axes_metadata = { "name" : "to_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def to_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify an axes to rotate to."""
        return self._intf.get_property(IVectorGeometryToolAngleRotation._metadata, IVectorGeometryToolAngleRotation._get_to_axes_metadata)

    _get_reference_direction_metadata = { "name" : "reference_direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DISPLAY_AXIS_SELECTOR),) }
    @property
    def reference_direction(self) -> "CRDN_DISPLAY_AXIS_SELECTOR":
        """Specify a rotation direction."""
        return self._intf.get_property(IVectorGeometryToolAngleRotation._metadata, IVectorGeometryToolAngleRotation._get_reference_direction_metadata)

    _set_reference_direction_metadata = { "name" : "reference_direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DISPLAY_AXIS_SELECTOR),) }
    @reference_direction.setter
    def reference_direction(self, referenceDirection:"CRDN_DISPLAY_AXIS_SELECTOR") -> None:
        return self._intf.set_property(IVectorGeometryToolAngleRotation._metadata, IVectorGeometryToolAngleRotation._set_reference_direction_metadata, referenceDirection)


agcls.AgClassCatalog.add_catalog_entry("{9E842F77-B3A8-475C-96AA-E692B35E8E05}", IVectorGeometryToolAngleRotation)
agcls.AgTypeNameMap["IVectorGeometryToolAngleRotation"] = IVectorGeometryToolAngleRotation

class IVectorGeometryToolAngleToPlane(object):
    """An angle between a vector and a plane."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DDFA25AD-174D-407B-B90C-747B3E43F7C9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_vector" : 1,
                             "get_reference_plane" : 2,
                             "get_signed" : 3,
                             "set_signed" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleToPlane)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleToPlane)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleToPlane, None)
    
    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IVectorGeometryToolAngleToPlane._metadata, IVectorGeometryToolAngleToPlane._get_reference_vector_metadata)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IVectorGeometryToolAngleToPlane._metadata, IVectorGeometryToolAngleToPlane._get_reference_plane_metadata)

    _get_signed_metadata = { "name" : "signed",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNED_ANGLE_TYPE),) }
    @property
    def signed(self) -> "CRDN_SIGNED_ANGLE_TYPE":
        """Control whether the angle is measured as either Positive or Negative when the reference Vector is directed toward the plane's normal, or always positive."""
        return self._intf.get_property(IVectorGeometryToolAngleToPlane._metadata, IVectorGeometryToolAngleToPlane._get_signed_metadata)

    _set_signed_metadata = { "name" : "signed",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNED_ANGLE_TYPE),) }
    @signed.setter
    def signed(self, signed:"CRDN_SIGNED_ANGLE_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolAngleToPlane._metadata, IVectorGeometryToolAngleToPlane._set_signed_metadata, signed)


agcls.AgClassCatalog.add_catalog_entry("{DDFA25AD-174D-407B-B90C-747B3E43F7C9}", IVectorGeometryToolAngleToPlane)
agcls.AgTypeNameMap["IVectorGeometryToolAngleToPlane"] = IVectorGeometryToolAngleToPlane

class IVectorGeometryToolPlaneNormal(object):
    """A plane normal to a vector at a given point."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AAF66E5C-B310-4387-BDAE-D45F24F226BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_normal_vector" : 1,
                             "get_reference_vector" : 2,
                             "get_reference_point" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneNormal)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneNormal)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneNormal, None)
    
    _get_normal_vector_metadata = { "name" : "normal_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def normal_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(IVectorGeometryToolPlaneNormal._metadata, IVectorGeometryToolPlaneNormal._get_normal_vector_metadata)

    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IVectorGeometryToolPlaneNormal._metadata, IVectorGeometryToolPlaneNormal._get_reference_vector_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolPlaneNormal._metadata, IVectorGeometryToolPlaneNormal._get_reference_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{AAF66E5C-B310-4387-BDAE-D45F24F226BC}", IVectorGeometryToolPlaneNormal)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneNormal"] = IVectorGeometryToolPlaneNormal

class IVectorGeometryToolPlaneQuadrant(object):
    """A plane based on a selected Quadrant of a reference system."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_system" : 1,
                             "get_quadrant" : 2,
                             "set_quadrant" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneQuadrant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneQuadrant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneQuadrant, None)
    
    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneQuadrant._metadata, IVectorGeometryToolPlaneQuadrant._get_reference_system_metadata)

    _get_quadrant_metadata = { "name" : "quadrant",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_QUADRANT_TYPE),) }
    @property
    def quadrant(self) -> "CRDN_QUADRANT_TYPE":
        """Specify a quadrant."""
        return self._intf.get_property(IVectorGeometryToolPlaneQuadrant._metadata, IVectorGeometryToolPlaneQuadrant._get_quadrant_metadata)

    _set_quadrant_metadata = { "name" : "quadrant",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_QUADRANT_TYPE),) }
    @quadrant.setter
    def quadrant(self, quadrant:"CRDN_QUADRANT_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPlaneQuadrant._metadata, IVectorGeometryToolPlaneQuadrant._set_quadrant_metadata, quadrant)


agcls.AgClassCatalog.add_catalog_entry("{5EDFD8B0-D7B0-4475-9A28-9C3898E60E7A}", IVectorGeometryToolPlaneQuadrant)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneQuadrant"] = IVectorGeometryToolPlaneQuadrant

class IVectorGeometryToolPlaneTrajectory(object):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_point" : 1,
                             "get_reference_system" : 2,
                             "get_rotation_offset" : 3,
                             "set_rotation_offset" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneTrajectory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneTrajectory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneTrajectory, None)
    
    _get_point_metadata = { "name" : "point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IVectorGeometryToolPlaneTrajectory._metadata, IVectorGeometryToolPlaneTrajectory._get_point_metadata)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneTrajectory._metadata, IVectorGeometryToolPlaneTrajectory._get_reference_system_metadata)

    _get_rotation_offset_metadata = { "name" : "rotation_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rotation_offset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(IVectorGeometryToolPlaneTrajectory._metadata, IVectorGeometryToolPlaneTrajectory._get_rotation_offset_metadata)

    _set_rotation_offset_metadata = { "name" : "rotation_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @rotation_offset.setter
    def rotation_offset(self, rotationOffset:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPlaneTrajectory._metadata, IVectorGeometryToolPlaneTrajectory._set_rotation_offset_metadata, rotationOffset)


agcls.AgClassCatalog.add_catalog_entry("{38B84821-37E5-4CBC-83F9-AB4D84E0DFBE}", IVectorGeometryToolPlaneTrajectory)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTrajectory"] = IVectorGeometryToolPlaneTrajectory

class IVectorGeometryToolPlaneTriad(object):
    """A Plane containing points A, B and ReferencePont with the first axis aligned with the direction from the ReferencePoint to point A and the second axis toward the direction from the ReferencePoint to point B."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_point_a" : 1,
                             "get_point_b" : 2,
                             "get_reference_point" : 3,
                             "get_rotation_offset" : 4,
                             "set_rotation_offset" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneTriad)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneTriad)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneTriad, None)
    
    _get_point_a_metadata = { "name" : "point_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point_a(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point A."""
        return self._intf.get_property(IVectorGeometryToolPlaneTriad._metadata, IVectorGeometryToolPlaneTriad._get_point_a_metadata)

    _get_point_b_metadata = { "name" : "point_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point_b(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point B."""
        return self._intf.get_property(IVectorGeometryToolPlaneTriad._metadata, IVectorGeometryToolPlaneTriad._get_point_b_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolPlaneTriad._metadata, IVectorGeometryToolPlaneTriad._get_reference_point_metadata)

    _get_rotation_offset_metadata = { "name" : "rotation_offset",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def rotation_offset(self) -> float:
        """Specify an angle measured from X (Axis 1) away from Y (Axis 2)."""
        return self._intf.get_property(IVectorGeometryToolPlaneTriad._metadata, IVectorGeometryToolPlaneTriad._get_rotation_offset_metadata)

    _set_rotation_offset_metadata = { "name" : "rotation_offset",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @rotation_offset.setter
    def rotation_offset(self, rotationOffset:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPlaneTriad._metadata, IVectorGeometryToolPlaneTriad._set_rotation_offset_metadata, rotationOffset)


agcls.AgClassCatalog.add_catalog_entry("{EEC540C3-22AA-4E68-818C-A8A02B9EF2DC}", IVectorGeometryToolPlaneTriad)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTriad"] = IVectorGeometryToolPlaneTriad

class IVectorGeometryToolPlaneTwoVector(object):
    """A plane passing through point and containing two given vectors."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{345761f0-0ace-494c-8d9c-0f3e3af9c2da}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_vector" : 1,
                             "get_vector2" : 2,
                             "get_reference_point" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneTwoVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneTwoVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneTwoVector, None)
    
    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IVectorGeometryToolPlaneTwoVector._metadata, IVectorGeometryToolPlaneTwoVector._get_reference_vector_metadata)

    _get_vector2_metadata = { "name" : "vector2",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector2(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a Normal vector."""
        return self._intf.get_property(IVectorGeometryToolPlaneTwoVector._metadata, IVectorGeometryToolPlaneTwoVector._get_vector2_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolPlaneTwoVector._metadata, IVectorGeometryToolPlaneTwoVector._get_reference_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{345761f0-0ace-494c-8d9c-0f3e3af9c2da}", IVectorGeometryToolPlaneTwoVector)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneTwoVector"] = IVectorGeometryToolPlaneTwoVector

class IVectorGeometryToolPointBPlane(object):
    """B-Plane point using the selected target body."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CC3B797F-5327-4D04-911D-8ED499E056AF}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_target_body" : 1,
                             "get_trajectory" : 2,
                             "get_point_type" : 3,
                             "set_point_type" : 4,
                             "get_direction" : 5,
                             "set_direction" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointBPlane)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointBPlane)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointBPlane, None)
    
    _get_target_body_metadata = { "name" : "target_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def target_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a target central body."""
        return self._intf.get_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._get_target_body_metadata)

    _get_trajectory_metadata = { "name" : "trajectory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def trajectory(self) -> "VectorGeometryToolPointRefTo":
        """Specify a trajectory point."""
        return self._intf.get_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._get_trajectory_metadata)

    _get_point_type_metadata = { "name" : "point_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE),) }
    @property
    def point_type(self) -> "VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE":
        """Specify a point type."""
        return self._intf.get_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._get_point_type_metadata)

    _set_point_type_metadata = { "name" : "point_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"VECTOR_GEOMETRY_TOOL_POINT_B_PLANE_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._set_point_type_metadata, pointType)

    _get_direction_metadata = { "name" : "direction",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIRECTION_TYPE),) }
    @property
    def direction(self) -> "CRDN_DIRECTION_TYPE":
        """Specify a direction (incoming or outgoing)."""
        return self._intf.get_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._get_direction_metadata)

    _set_direction_metadata = { "name" : "direction",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIRECTION_TYPE),) }
    @direction.setter
    def direction(self, direction:"CRDN_DIRECTION_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointBPlane._metadata, IVectorGeometryToolPointBPlane._set_direction_metadata, direction)


agcls.AgClassCatalog.add_catalog_entry("{CC3B797F-5327-4D04-911D-8ED499E056AF}", IVectorGeometryToolPointBPlane)
agcls.AgTypeNameMap["IVectorGeometryToolPointBPlane"] = IVectorGeometryToolPointBPlane

class IVectorGeometryToolPointFile(object):
    """Point specified by data from a file."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9612277C-2238-42BD-89D7-E54D7701D8F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_filename" : 1,
                             "set_filename" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointFile)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointFile)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointFile, None)
    
    _get_filename_metadata = { "name" : "filename",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def filename(self) -> str:
        """Specify a path to a file. The file must exist. Specifying an invalid path will generate an exception."""
        return self._intf.get_property(IVectorGeometryToolPointFile._metadata, IVectorGeometryToolPointFile._get_filename_metadata)

    _set_filename_metadata = { "name" : "filename",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @filename.setter
    def filename(self, filename:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointFile._metadata, IVectorGeometryToolPointFile._set_filename_metadata, filename)


agcls.AgClassCatalog.add_catalog_entry("{9612277C-2238-42BD-89D7-E54D7701D8F2}", IVectorGeometryToolPointFile)
agcls.AgTypeNameMap["IVectorGeometryToolPointFile"] = IVectorGeometryToolPointFile

class IVectorGeometryToolPointFixedInSystem(object):
    """Point fixed in a reference coordinate system using the selected coordinate type."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference" : 1,
                             "get_fixed_point" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointFixedInSystem)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointFixedInSystem)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointFixedInSystem, None)
    
    _get_reference_metadata = { "name" : "reference",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a reference system."""
        return self._intf.get_property(IVectorGeometryToolPointFixedInSystem._metadata, IVectorGeometryToolPointFixedInSystem._get_reference_metadata)

    _get_fixed_point_metadata = { "name" : "fixed_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed_point(self) -> "IPosition":
        """Specify the point's position. The position is relative with respect to the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPointFixedInSystem._metadata, IVectorGeometryToolPointFixedInSystem._get_fixed_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{EF7020AE-4103-4E9A-9EDB-A7EF7D8EDF74}", IVectorGeometryToolPointFixedInSystem)
agcls.AgTypeNameMap["IVectorGeometryToolPointFixedInSystem"] = IVectorGeometryToolPointFixedInSystem

class IVectorGeometryToolPointGrazing(object):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7FDF037E-1367-4590-A330-660EF3442DE1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_direction_vector" : 3,
                             "get_altitude" : 4,
                             "set_altitude" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointGrazing)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointGrazing)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointGrazing, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolPointGrazing._metadata, IVectorGeometryToolPointGrazing._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(IVectorGeometryToolPointGrazing._metadata, IVectorGeometryToolPointGrazing._get_reference_point_metadata)

    _get_direction_vector_metadata = { "name" : "direction_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the position vector from the selected central body to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(IVectorGeometryToolPointGrazing._metadata, IVectorGeometryToolPointGrazing._get_direction_vector_metadata)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """The point of closest approach to the central body surface occurs at the specified altitude."""
        return self._intf.get_property(IVectorGeometryToolPointGrazing._metadata, IVectorGeometryToolPointGrazing._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointGrazing._metadata, IVectorGeometryToolPointGrazing._set_altitude_metadata, altitude)


agcls.AgClassCatalog.add_catalog_entry("{7FDF037E-1367-4590-A330-660EF3442DE1}", IVectorGeometryToolPointGrazing)
agcls.AgTypeNameMap["IVectorGeometryToolPointGrazing"] = IVectorGeometryToolPointGrazing

class IVectorGeometryToolPointGlint(object):
    """Point on central body surface that reflects from source to observer."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4168949-A6F2-42B7-8019-671FF808836D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_source_point" : 2,
                             "get_observer_point" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointGlint)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointGlint)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointGlint, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolPointGlint._metadata, IVectorGeometryToolPointGlint._get_central_body_metadata)

    _get_source_point_metadata = { "name" : "source_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(IVectorGeometryToolPointGlint._metadata, IVectorGeometryToolPointGlint._get_source_point_metadata)

    _get_observer_point_metadata = { "name" : "observer_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def observer_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify an observer point."""
        return self._intf.get_property(IVectorGeometryToolPointGlint._metadata, IVectorGeometryToolPointGlint._get_observer_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{C4168949-A6F2-42B7-8019-671FF808836D}", IVectorGeometryToolPointGlint)
agcls.AgTypeNameMap["IVectorGeometryToolPointGlint"] = IVectorGeometryToolPointGlint

class IVectorGeometryToolPointCovarianceGrazing(object):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CC9E8B92-77D8-46A9-BD52-3DABB173913D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_point" : 1,
                             "get_direction_vector" : 2,
                             "get_target_name" : 3,
                             "set_target_name" : 4,
                             "get_distance" : 5,
                             "set_distance" : 6,
                             "get_probability" : 7,
                             "set_probability" : 8,
                             "get_scale" : 9,
                             "set_scale" : 10,
                             "get_use_probability" : 11,
                             "set_use_probability" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointCovarianceGrazing)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointCovarianceGrazing)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointCovarianceGrazing, None)
    
    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point which will serve as the starting location for the line along which the grazing point will be computed."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_reference_point_metadata)

    _get_direction_vector_metadata = { "name" : "direction_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector to be used in conjunction with the displacement vector from the selected target object to the reference point to define a plane in which the line will lie."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_direction_vector_metadata)

    _get_target_name_metadata = { "name" : "target_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def target_name(self) -> str:
        """Specify a target object about which the covariance ellipsoid is centered."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_target_name_metadata)

    _set_target_name_metadata = { "name" : "target_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @target_name.setter
    def target_name(self, targetName:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._set_target_name_metadata, targetName)

    _get_distance_metadata = { "name" : "distance",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def distance(self) -> float:
        """The point of closest approach to the covariance ellipsoid surface occurs at the specified distance."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_distance_metadata)

    _set_distance_metadata = { "name" : "distance",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @distance.setter
    def distance(self, distance:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._set_distance_metadata, distance)

    _get_probability_metadata = { "name" : "probability",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def probability(self) -> float:
        """Specify a probability that the true position is inside the ellipsoid boundary."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_probability_metadata)

    _set_probability_metadata = { "name" : "probability",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @probability.setter
    def probability(self, probability:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._set_probability_metadata, probability)

    _get_scale_metadata = { "name" : "scale",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale(self) -> float:
        """Specify a scale factor which is applied to the one sigma ellipsoid."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_scale_metadata)

    _set_scale_metadata = { "name" : "scale",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._set_scale_metadata, scale)

    _get_use_probability_metadata = { "name" : "use_probability",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_probability(self) -> bool:
        """A flag controlling whether to use probability or scale factor."""
        return self._intf.get_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._get_use_probability_metadata)

    _set_use_probability_metadata = { "name" : "use_probability",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_probability.setter
    def use_probability(self, useProbability:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCovarianceGrazing._metadata, IVectorGeometryToolPointCovarianceGrazing._set_use_probability_metadata, useProbability)


agcls.AgClassCatalog.add_catalog_entry("{CC9E8B92-77D8-46A9-BD52-3DABB173913D}", IVectorGeometryToolPointCovarianceGrazing)
agcls.AgTypeNameMap["IVectorGeometryToolPointCovarianceGrazing"] = IVectorGeometryToolPointCovarianceGrazing

class IVectorGeometryToolPointPlaneIntersection(object):
    """Point on a plane located along a given direction looking from a given origin."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_direction_vector" : 1,
                             "get_reference_plane" : 2,
                             "get_origin_point" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointPlaneIntersection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointPlaneIntersection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointPlaneIntersection, None)
    
    _get_direction_vector_metadata = { "name" : "direction_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def direction_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a direction vector."""
        return self._intf.get_property(IVectorGeometryToolPointPlaneIntersection._metadata, IVectorGeometryToolPointPlaneIntersection._get_direction_vector_metadata)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IVectorGeometryToolPointPlaneIntersection._metadata, IVectorGeometryToolPointPlaneIntersection._get_reference_plane_metadata)

    _get_origin_point_metadata = { "name" : "origin_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify the origin point."""
        return self._intf.get_property(IVectorGeometryToolPointPlaneIntersection._metadata, IVectorGeometryToolPointPlaneIntersection._get_origin_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{1823CE59-7F9D-43EC-9915-D6161FF3B6B3}", IVectorGeometryToolPointPlaneIntersection)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlaneIntersection"] = IVectorGeometryToolPointPlaneIntersection

class IVectorGeometryToolPointOnSurface(object):
    """The detic subpoint of the reference point as projected onto the central body."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AED0D41F-BB69-4672-A513-17A43B12873D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_reference_shape" : 3,
                             "set_reference_shape" : 4,
                             "get_surface_type" : 5,
                             "set_surface_type" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointOnSurface)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointOnSurface)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointOnSurface, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._get_reference_point_metadata)

    _get_reference_shape_metadata = { "name" : "reference_shape",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @property
    def reference_shape(self) -> "CRDN_REFERENCE_SHAPE_TYPE":
        """Specify a reference shape."""
        return self._intf.get_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._get_reference_shape_metadata)

    _set_reference_shape_metadata = { "name" : "reference_shape",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @reference_shape.setter
    def reference_shape(self, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._set_reference_shape_metadata, referenceShape)

    _get_surface_type_metadata = { "name" : "surface_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SURFACE_TYPE),) }
    @property
    def surface_type(self) -> "CRDN_SURFACE_TYPE":
        """Specify a surface type."""
        return self._intf.get_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._get_surface_type_metadata)

    _set_surface_type_metadata = { "name" : "surface_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SURFACE_TYPE),) }
    @surface_type.setter
    def surface_type(self, surfaceType:"CRDN_SURFACE_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointOnSurface._metadata, IVectorGeometryToolPointOnSurface._set_surface_type_metadata, surfaceType)


agcls.AgClassCatalog.add_catalog_entry("{AED0D41F-BB69-4672-A513-17A43B12873D}", IVectorGeometryToolPointOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolPointOnSurface"] = IVectorGeometryToolPointOnSurface

class IVectorGeometryToolPointModelAttach(object):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFEB5448-9053-44F6-BCB5-35280361131F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_pointable_element_name" : 1,
                             "set_pointable_element_name" : 2,
                             "get_use_scale" : 3,
                             "set_use_scale" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointModelAttach)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointModelAttach)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointModelAttach, None)
    
    _get_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a model attachment point."""
        return self._intf.get_property(IVectorGeometryToolPointModelAttach._metadata, IVectorGeometryToolPointModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointModelAttach._metadata, IVectorGeometryToolPointModelAttach._set_pointable_element_name_metadata, pointableElementName)

    _get_use_scale_metadata = { "name" : "use_scale",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_scale(self) -> bool:
        """Specify whether to use the model scale."""
        return self._intf.get_property(IVectorGeometryToolPointModelAttach._metadata, IVectorGeometryToolPointModelAttach._get_use_scale_metadata)

    _set_use_scale_metadata = { "name" : "use_scale",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_scale.setter
    def use_scale(self, useScale:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointModelAttach._metadata, IVectorGeometryToolPointModelAttach._set_use_scale_metadata, useScale)


agcls.AgClassCatalog.add_catalog_entry("{CFEB5448-9053-44F6-BCB5-35280361131F}", IVectorGeometryToolPointModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolPointModelAttach"] = IVectorGeometryToolPointModelAttach

class IVectorGeometryToolPointSatelliteCollectionEntry(object):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_entry_name" : 1,
                             "set_entry_name" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointSatelliteCollectionEntry)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointSatelliteCollectionEntry)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointSatelliteCollectionEntry, None)
    
    _get_entry_name_metadata = { "name" : "entry_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def entry_name(self) -> str:
        """Specify a satellite collection entry name."""
        return self._intf.get_property(IVectorGeometryToolPointSatelliteCollectionEntry._metadata, IVectorGeometryToolPointSatelliteCollectionEntry._get_entry_name_metadata)

    _set_entry_name_metadata = { "name" : "entry_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @entry_name.setter
    def entry_name(self, entryName:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointSatelliteCollectionEntry._metadata, IVectorGeometryToolPointSatelliteCollectionEntry._set_entry_name_metadata, entryName)


agcls.AgClassCatalog.add_catalog_entry("{b87dd19b-9b0c-4e77-b1d4-937ab05e710a}", IVectorGeometryToolPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["IVectorGeometryToolPointSatelliteCollectionEntry"] = IVectorGeometryToolPointSatelliteCollectionEntry

class IVectorGeometryToolPointPlaneProjection(object):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_source_point" : 1,
                             "get_reference_plane" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointPlaneProjection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointPlaneProjection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointPlaneProjection, None)
    
    _get_source_point_metadata = { "name" : "source_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a source point."""
        return self._intf.get_property(IVectorGeometryToolPointPlaneProjection._metadata, IVectorGeometryToolPointPlaneProjection._get_source_point_metadata)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IVectorGeometryToolPointPlaneProjection._metadata, IVectorGeometryToolPointPlaneProjection._get_reference_plane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{9DD5F6D2-C99A-4461-92AE-C795FE0971BE}", IVectorGeometryToolPointPlaneProjection)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlaneProjection"] = IVectorGeometryToolPointPlaneProjection

class IVectorGeometryToolPointLagrangeLibration(object):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_point_type" : 2,
                             "set_point_type" : 3,
                             "get_secondary_central_bodies" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointLagrangeLibration)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointLagrangeLibration)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointLagrangeLibration, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolPointLagrangeLibration._metadata, IVectorGeometryToolPointLagrangeLibration._get_central_body_metadata)

    _get_point_type_metadata = { "name" : "point_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @property
    def point_type(self) -> "CRDN_LAGRANGE_LIBRATION_POINT_TYPE":
        """Specify a lagrange point (L1, L2, etc.)."""
        return self._intf.get_property(IVectorGeometryToolPointLagrangeLibration._metadata, IVectorGeometryToolPointLagrangeLibration._get_point_type_metadata)

    _set_point_type_metadata = { "name" : "point_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_LAGRANGE_LIBRATION_POINT_TYPE),) }
    @point_type.setter
    def point_type(self, pointType:"CRDN_LAGRANGE_LIBRATION_POINT_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointLagrangeLibration._metadata, IVectorGeometryToolPointLagrangeLibration._set_point_type_metadata, pointType)

    _get_secondary_central_bodies_metadata = { "name" : "secondary_central_bodies",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def secondary_central_bodies(self) -> "AnalysisWorkbenchCentralBodyCollection":
        """Specify multiple secondary central bodies."""
        return self._intf.get_property(IVectorGeometryToolPointLagrangeLibration._metadata, IVectorGeometryToolPointLagrangeLibration._get_secondary_central_bodies_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A90D9C70-1E09-4F42-8E36-4EECD2CAD722}", IVectorGeometryToolPointLagrangeLibration)
agcls.AgTypeNameMap["IVectorGeometryToolPointLagrangeLibration"] = IVectorGeometryToolPointLagrangeLibration

class IVectorGeometryToolPointCommonTasks(object):
    """Provide methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C357C0A5-3F2A-499C-83F3-6824532C969E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create_fixed_in_system_cartographic" : 1,
                             "create_fixed_in_system_cartesian" : 2,
                             "sample" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointCommonTasks)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointCommonTasks)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointCommonTasks, None)
    
    _create_fixed_in_system_cartographic_metadata = { "name" : "create_fixed_in_system_cartographic",
            "arg_types" : (agcom.PVOID, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_fixed_in_system_cartographic(self, referenceSystem:"IVectorGeometryToolSystem", latitude:typing.Any, longitude:typing.Any, altitude:float) -> "VectorGeometryToolPointFixedInSystem":
        """Create a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(IVectorGeometryToolPointCommonTasks._metadata, IVectorGeometryToolPointCommonTasks._create_fixed_in_system_cartographic_metadata, referenceSystem, latitude, longitude, altitude, out_arg())

    _create_fixed_in_system_cartesian_metadata = { "name" : "create_fixed_in_system_cartesian",
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_fixed_in_system_cartesian(self, referenceSystem:"IVectorGeometryToolSystem", x:float, y:float, z:float) -> "VectorGeometryToolPointFixedInSystem":
        """Create a non-persistent point fixed in a specified reference system."""
        return self._intf.invoke(IVectorGeometryToolPointCommonTasks._metadata, IVectorGeometryToolPointCommonTasks._create_fixed_in_system_cartesian_metadata, referenceSystem, x, y, z, out_arg())

    _sample_metadata = { "name" : "sample",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"), agmarshall.LPSAFEARRAY_arg, agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg, agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def sample(self, point:"IVectorGeometryToolPoint", referenceSystem:"IVectorGeometryToolSystem", intervals:list, minStep:float, maxStep:float, targetRate:typing.Any) -> "TimeToolPointSamplingResult":
        """Compute and returns tabulated positions and velocities of a point with respect to reference system using specified sampling parameters."""
        return self._intf.invoke(IVectorGeometryToolPointCommonTasks._metadata, IVectorGeometryToolPointCommonTasks._sample_metadata, point, referenceSystem, intervals, minStep, maxStep, targetRate, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C357C0A5-3F2A-499C-83F3-6824532C969E}", IVectorGeometryToolPointCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolPointCommonTasks"] = IVectorGeometryToolPointCommonTasks

class IVectorGeometryToolPointCentBodyIntersect(object):
    """Point on central body surface along direction vector originating at source point."""

    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C0F5946B-9467-44AC-B16A-9276CE4EA141}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "set_central_body" : 2,
                             "get_reference_point" : 3,
                             "set_reference_point" : 4,
                             "get_direction_vector" : 5,
                             "set_direction_vector" : 6,
                             "get_intersection_surface" : 7,
                             "set_intersection_surface" : 8,
                             "get_altitude" : 9,
                             "set_altitude" : 10,
                             "get_use_range_constraint" : 11,
                             "set_use_range_constraint" : 12,
                             "get_minimum_range" : 13,
                             "set_minimum_range" : 14,
                             "get_maximum_range" : 15,
                             "set_maximum_range" : 16,
                             "get_use_minimum_range" : 17,
                             "set_use_minimum_range" : 18,
                             "get_use_maximum_range" : 19,
                             "set_use_maximum_range" : 20,
                             "set_range" : 21,
                             "get_allow_intersection_from_below" : 22,
                             "set_allow_intersection_from_below" : 23, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointCentBodyIntersect)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointCentBodyIntersect)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointCentBodyIntersect, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def central_body(self) -> str:
        """Central body."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_central_body_metadata)

    _set_central_body_metadata = { "name" : "central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_central_body_metadata, centralBody)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "IVectorGeometryToolPoint":
        """A reference point. Can be any point from VGT."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_reference_point_metadata)

    _set_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @reference_point.setter
    def reference_point(self, referencePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_reference_point_metadata, referencePoint)

    _get_direction_vector_metadata = { "name" : "direction_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def direction_vector(self) -> "IVectorGeometryToolVector":
        """A direction vector. Can be any vector from VGT."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_direction_vector_metadata)

    _set_direction_vector_metadata = { "name" : "direction_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @direction_vector.setter
    def direction_vector(self, directionVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_direction_vector_metadata, directionVector)

    _get_intersection_surface_metadata = { "name" : "intersection_surface",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERSECTION_SURFACE),) }
    @property
    def intersection_surface(self) -> "CRDN_INTERSECTION_SURFACE":
        """An intersection surface."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_intersection_surface_metadata)

    _set_intersection_surface_metadata = { "name" : "intersection_surface",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_INTERSECTION_SURFACE),) }
    @intersection_surface.setter
    def intersection_surface(self, intersectionSurface:"CRDN_INTERSECTION_SURFACE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_intersection_surface_metadata, intersectionSurface)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """An altitude."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_altitude_metadata, altitude)

    _get_use_range_constraint_metadata = { "name" : "use_range_constraint",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_range_constraint(self) -> bool:
        """Whether to use range constraint."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_use_range_constraint_metadata)

    _set_use_range_constraint_metadata = { "name" : "use_range_constraint",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_range_constraint.setter
    def use_range_constraint(self, useRangeConstraint:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_use_range_constraint_metadata, useRangeConstraint)

    _get_minimum_range_metadata = { "name" : "minimum_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def minimum_range(self) -> float:
        """A minimum range. An exception is thrown if the value exceeds the MaximumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_minimum_range_metadata)

    _set_minimum_range_metadata = { "name" : "minimum_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @minimum_range.setter
    def minimum_range(self, minimumRange:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_minimum_range_metadata, minimumRange)

    _get_maximum_range_metadata = { "name" : "maximum_range",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def maximum_range(self) -> float:
        """A maximum range. An exception is thrown if the value is less than the MinimumRange. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_maximum_range_metadata)

    _set_maximum_range_metadata = { "name" : "maximum_range",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @maximum_range.setter
    def maximum_range(self, maximumRange:float) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_maximum_range_metadata, maximumRange)

    _get_use_minimum_range_metadata = { "name" : "use_minimum_range",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_minimum_range(self) -> bool:
        """Whether the minimum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_use_minimum_range_metadata)

    _set_use_minimum_range_metadata = { "name" : "use_minimum_range",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_minimum_range.setter
    def use_minimum_range(self, useMinimumRange:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_use_minimum_range_metadata, useMinimumRange)

    _get_use_maximum_range_metadata = { "name" : "use_maximum_range",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_maximum_range(self) -> bool:
        """Whether the maximum range is used. Applicable only if the range constraint is not used."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_use_maximum_range_metadata)

    _set_use_maximum_range_metadata = { "name" : "use_maximum_range",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_maximum_range.setter
    def use_maximum_range(self, useMaximumRange:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_use_maximum_range_metadata, useMaximumRange)

    _set_range_metadata = { "name" : "set_range",
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg, agmarshall.DOUBLE_arg,) }
    def set_range(self, minimum:float, maximum:float) -> None:
        """Set minimum and maximum range. An exception is thrown if Minimum exceeds Maximum. An exception is thrown if UseRangeConstraint is set to true. Applicable only if the range constraint is not used."""
        return self._intf.invoke(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_range_metadata, minimum, maximum)

    _get_allow_intersection_from_below_metadata = { "name" : "allow_intersection_from_below",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def allow_intersection_from_below(self) -> bool:
        """Whether intersection is computed when reference point is inside the surface. Applicable when the surface is not defined by terrain."""
        return self._intf.get_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._get_allow_intersection_from_below_metadata)

    _set_allow_intersection_from_below_metadata = { "name" : "allow_intersection_from_below",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @allow_intersection_from_below.setter
    def allow_intersection_from_below(self, allowIntersectionFromBelow:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCentBodyIntersect._metadata, IVectorGeometryToolPointCentBodyIntersect._set_allow_intersection_from_below_metadata, allowIntersectionFromBelow)


agcls.AgClassCatalog.add_catalog_entry("{C0F5946B-9467-44AC-B16A-9276CE4EA141}", IVectorGeometryToolPointCentBodyIntersect)
agcls.AgTypeNameMap["IVectorGeometryToolPointCentBodyIntersect"] = IVectorGeometryToolPointCentBodyIntersect

class IVectorGeometryToolPointAtTimeInstant(object):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2,
                             "get_source_point" : 3,
                             "set_source_point" : 4,
                             "get_reference_system" : 5,
                             "set_reference_system" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointAtTimeInstant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointAtTimeInstant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointAtTimeInstant, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_point_metadata = { "name" : "source_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_point(self) -> "IVectorGeometryToolPoint":
        """A source point. Can be any VGT point."""
        return self._intf.get_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._get_source_point_metadata)

    _set_source_point_metadata = { "name" : "source_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @source_point.setter
    def source_point(self, sourcePoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._set_source_point_metadata, sourcePoint)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """A reference system. Can be any VGT system."""
        return self._intf.get_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(IVectorGeometryToolPointAtTimeInstant._metadata, IVectorGeometryToolPointAtTimeInstant._set_reference_system_metadata, referenceSystem)


agcls.AgClassCatalog.add_catalog_entry("{1EE173F1-C1BD-4120-95B4-46F67EDB67D9}", IVectorGeometryToolPointAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolPointAtTimeInstant"] = IVectorGeometryToolPointAtTimeInstant

class IVectorGeometryToolPointPlugin(object):
    """A VGT point plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prog_id" : 1,
                             "get_display_name" : 2,
                             "get_available_properties" : 3,
                             "reset" : 4,
                             "set_property" : 5,
                             "get_property" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointPlugin)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointPlugin)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointPlugin, None)
    
    _get_prog_id_metadata = { "name" : "prog_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "name" : "display_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "name" : "available_properties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._get_available_properties_metadata)

    _reset_metadata = { "name" : "reset",
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._reset_metadata, )

    _set_property_metadata = { "name" : "set_property",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_property(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "name" : "get_property",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def get_property(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IVectorGeometryToolPointPlugin._metadata, IVectorGeometryToolPointPlugin._get_property_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{B4D91BB8-CC32-41BA-B1CF-DF73326EC72B}", IVectorGeometryToolPointPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolPointPlugin"] = IVectorGeometryToolPointPlugin

class IVectorGeometryToolPointCBFixedOffset(object):
    """Point specified by fixed components with respect to central body."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "set_central_body" : 2,
                             "get_reference_shape" : 3,
                             "set_reference_shape" : 4,
                             "get_position" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointCBFixedOffset)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointCBFixedOffset)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointCBFixedOffset, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def central_body(self) -> str:
        """Get the central body."""
        return self._intf.get_property(IVectorGeometryToolPointCBFixedOffset._metadata, IVectorGeometryToolPointCBFixedOffset._get_central_body_metadata)

    _set_central_body_metadata = { "name" : "central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(IVectorGeometryToolPointCBFixedOffset._metadata, IVectorGeometryToolPointCBFixedOffset._set_central_body_metadata, centralBody)

    _get_reference_shape_metadata = { "name" : "reference_shape",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @property
    def reference_shape(self) -> "CRDN_REFERENCE_SHAPE_TYPE":
        """Choose the point height's reference. Available options are central body ellipsoid (WSG84), terrain or Mean Sea Level."""
        return self._intf.get_property(IVectorGeometryToolPointCBFixedOffset._metadata, IVectorGeometryToolPointCBFixedOffset._get_reference_shape_metadata)

    _set_reference_shape_metadata = { "name" : "reference_shape",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_REFERENCE_SHAPE_TYPE),) }
    @reference_shape.setter
    def reference_shape(self, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> None:
        return self._intf.set_property(IVectorGeometryToolPointCBFixedOffset._metadata, IVectorGeometryToolPointCBFixedOffset._set_reference_shape_metadata, referenceShape)

    _get_position_metadata = { "name" : "position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position(self) -> "IPosition":
        """A position of the point fixed on the central body."""
        return self._intf.get_property(IVectorGeometryToolPointCBFixedOffset._metadata, IVectorGeometryToolPointCBFixedOffset._get_position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F78E4010-6C60-4000-9FD1-55BB76D7CDA5}", IVectorGeometryToolPointCBFixedOffset)
agcls.AgTypeNameMap["IVectorGeometryToolPointCBFixedOffset"] = IVectorGeometryToolPointCBFixedOffset

class IVectorGeometryToolSystemAssembled(object):
    """A system assembled from an origin point and a set of reference axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_origin_point" : 1,
                             "get_reference_axes" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemAssembled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemAssembled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemAssembled, None)
    
    _get_origin_point_metadata = { "name" : "origin_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a point of origin."""
        return self._intf.get_property(IVectorGeometryToolSystemAssembled._metadata, IVectorGeometryToolSystemAssembled._get_origin_point_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolSystemAssembled._metadata, IVectorGeometryToolSystemAssembled._get_reference_axes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5BAD4598-1CC2-45CD-8894-EEFCDBF55377}", IVectorGeometryToolSystemAssembled)
agcls.AgTypeNameMap["IVectorGeometryToolSystemAssembled"] = IVectorGeometryToolSystemAssembled

class IVectorGeometryToolSystemOnSurface(object):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{15798E36-1EC0-4A73-A910-FC28CC404082}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_azimuth_angle" : 2,
                             "set_azimuth_angle" : 3,
                             "get_use_msl" : 4,
                             "set_use_msl" : 5,
                             "get_position" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemOnSurface)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemOnSurface)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemOnSurface, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._get_central_body_metadata)

    _get_azimuth_angle_metadata = { "name" : "azimuth_angle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def azimuth_angle(self) -> float:
        """An angle by which the topocentric axes is rotated."""
        return self._intf.get_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._get_azimuth_angle_metadata)

    _set_azimuth_angle_metadata = { "name" : "azimuth_angle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @azimuth_angle.setter
    def azimuth_angle(self, azimuthAngle:float) -> None:
        return self._intf.set_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._set_azimuth_angle_metadata, azimuthAngle)

    _get_use_msl_metadata = { "name" : "use_msl",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_msl(self) -> bool:
        """Specify whether to use the Mean Sea Level as the reference shape."""
        return self._intf.get_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._get_use_msl_metadata)

    _set_use_msl_metadata = { "name" : "use_msl",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_msl.setter
    def use_msl(self, useMSL:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._set_use_msl_metadata, useMSL)

    _get_position_metadata = { "name" : "position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position(self) -> "AnalysisWorkbenchLLAPosition":
        """Specify the position of the system's origin."""
        return self._intf.get_property(IVectorGeometryToolSystemOnSurface._metadata, IVectorGeometryToolSystemOnSurface._get_position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{15798E36-1EC0-4A73-A910-FC28CC404082}", IVectorGeometryToolSystemOnSurface)
agcls.AgTypeNameMap["IVectorGeometryToolSystemOnSurface"] = IVectorGeometryToolSystemOnSurface

class IAnalysisWorkbenchLLAPosition(object):
    """A position represented by the Latitude, longtitude and Latitude."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_latitude" : 1,
                             "set_latitude" : 2,
                             "get_longitude" : 3,
                             "set_longitude" : 4,
                             "get_altitude" : 5,
                             "set_altitude" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchLLAPosition)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchLLAPosition)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchLLAPosition, None)
    
    _get_latitude_metadata = { "name" : "latitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def latitude(self) -> float:
        """Specify a latitude angle."""
        return self._intf.get_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._get_latitude_metadata)

    _set_latitude_metadata = { "name" : "latitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @latitude.setter
    def latitude(self, latitude:float) -> None:
        return self._intf.set_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._set_latitude_metadata, latitude)

    _get_longitude_metadata = { "name" : "longitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def longitude(self) -> float:
        """Specify a longitude angle."""
        return self._intf.get_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._get_longitude_metadata)

    _set_longitude_metadata = { "name" : "longitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @longitude.setter
    def longitude(self, longitude:float) -> None:
        return self._intf.set_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._set_longitude_metadata, longitude)

    _get_altitude_metadata = { "name" : "altitude",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def altitude(self) -> float:
        """Specify an altitude value."""
        return self._intf.get_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._get_altitude_metadata)

    _set_altitude_metadata = { "name" : "altitude",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(IAnalysisWorkbenchLLAPosition._metadata, IAnalysisWorkbenchLLAPosition._set_altitude_metadata, altitude)


agcls.AgClassCatalog.add_catalog_entry("{7D36B32A-FA96-4F7E-BA7C-99C2E90671C2}", IAnalysisWorkbenchLLAPosition)
agcls.AgTypeNameMap["IAnalysisWorkbenchLLAPosition"] = IAnalysisWorkbenchLLAPosition

class IVectorGeometryToolSystemCommonTasks(object):
    """Provide methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create_east_north_up_cartographic" : 1,
                             "create_assembled" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemCommonTasks)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemCommonTasks)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemCommonTasks, None)
    
    _create_east_north_up_cartographic_metadata = { "name" : "create_east_north_up_cartographic",
            "arg_types" : (agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgInterface_out_arg,) }
    def create_east_north_up_cartographic(self, latitude:typing.Any, longitude:typing.Any, altitude:float) -> "VectorGeometryToolSystemAssembled":
        """Create a non-persistent East-North-Up (ENU) reference frame with the origin at the specified geodetic location."""
        return self._intf.invoke(IVectorGeometryToolSystemCommonTasks._metadata, IVectorGeometryToolSystemCommonTasks._create_east_north_up_cartographic_metadata, latitude, longitude, altitude, out_arg())

    _create_assembled_metadata = { "name" : "create_assembled",
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"), agmarshall.AgInterface_out_arg,) }
    def create_assembled(self, originPoint:"IVectorGeometryToolPoint", referenceAxes:"IVectorGeometryToolAxes") -> "VectorGeometryToolSystemAssembled":
        """Create a non-persistent system component assembled from an origin point and a set of reference axes."""
        return self._intf.invoke(IVectorGeometryToolSystemCommonTasks._metadata, IVectorGeometryToolSystemCommonTasks._create_assembled_metadata, originPoint, referenceAxes, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{28CDCE82-8B5C-4C73-AEFB-B4FADE8F8C82}", IVectorGeometryToolSystemCommonTasks)
agcls.AgTypeNameMap["IVectorGeometryToolSystemCommonTasks"] = IVectorGeometryToolSystemCommonTasks

class IVectorGeometryToolVectorAngleRate(object):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFC40EEB-A99F-4DAD-A366-1C7908C15128}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_angle" : 1,
                             "get_differencing_time_step" : 2,
                             "set_differencing_time_step" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorAngleRate)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorAngleRate)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorAngleRate, None)
    
    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def angle(self) -> "VectorGeometryToolAngleRefTo":
        """Specify an angle. The angle vector will be perpendicular to the plane in which the angle is defined."""
        return self._intf.get_property(IVectorGeometryToolVectorAngleRate._metadata, IVectorGeometryToolVectorAngleRate._get_angle_metadata)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IVectorGeometryToolVectorAngleRate._metadata, IVectorGeometryToolVectorAngleRate._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorAngleRate._metadata, IVectorGeometryToolVectorAngleRate._set_differencing_time_step_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{CFC40EEB-A99F-4DAD-A366-1C7908C15128}", IVectorGeometryToolVectorAngleRate)
agcls.AgTypeNameMap["IVectorGeometryToolVectorAngleRate"] = IVectorGeometryToolVectorAngleRate

class IVectorGeometryToolVectorApoapsis(object):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A082FC52-1C33-4D63-B02E-1D163FC2F837}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_point" : 1,
                             "get_central_body" : 2,
                             "get_mean_element_type" : 3,
                             "set_mean_element_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorApoapsis)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorApoapsis)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorApoapsis, None)
    
    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolVectorApoapsis._metadata, IVectorGeometryToolVectorApoapsis._get_reference_point_metadata)

    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorApoapsis._metadata, IVectorGeometryToolVectorApoapsis._get_central_body_metadata)

    _get_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IVectorGeometryToolVectorApoapsis._metadata, IVectorGeometryToolVectorApoapsis._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorApoapsis._metadata, IVectorGeometryToolVectorApoapsis._set_mean_element_type_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{A082FC52-1C33-4D63-B02E-1D163FC2F837}", IVectorGeometryToolVectorApoapsis)
agcls.AgTypeNameMap["IVectorGeometryToolVectorApoapsis"] = IVectorGeometryToolVectorApoapsis

class IVectorGeometryToolVectorFixedAtEpoch(object):
    """A vector based on another vector fixed at a specified epoch."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7F816808-CF9D-434A-82CE-78F4A88BC75D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_epoch" : 1,
                             "set_epoch" : 2,
                             "get_source_vector" : 3,
                             "get_reference_axes" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFixedAtEpoch)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFixedAtEpoch)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFixedAtEpoch, None)
    
    _get_epoch_metadata = { "name" : "epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def epoch(self) -> typing.Any:
        """Specify an epoch."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtEpoch._metadata, IVectorGeometryToolVectorFixedAtEpoch._get_epoch_metadata)

    _set_epoch_metadata = { "name" : "epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorFixedAtEpoch._metadata, IVectorGeometryToolVectorFixedAtEpoch._set_epoch_metadata, epoch)

    _get_source_vector_metadata = { "name" : "source_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtEpoch._metadata, IVectorGeometryToolVectorFixedAtEpoch._get_source_vector_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtEpoch._metadata, IVectorGeometryToolVectorFixedAtEpoch._get_reference_axes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{7F816808-CF9D-434A-82CE-78F4A88BC75D}", IVectorGeometryToolVectorFixedAtEpoch)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedAtEpoch"] = IVectorGeometryToolVectorFixedAtEpoch

class IVectorGeometryToolVectorAngularVelocity(object):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_axes" : 1,
                             "get_reference_axes" : 2,
                             "get_differencing_time_step" : 3,
                             "set_differencing_time_step" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorAngularVelocity)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorAngularVelocity)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorAngularVelocity, None)
    
    _get_axes_metadata = { "name" : "axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(IVectorGeometryToolVectorAngularVelocity._metadata, IVectorGeometryToolVectorAngularVelocity._get_axes_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorAngularVelocity._metadata, IVectorGeometryToolVectorAngularVelocity._get_reference_axes_metadata)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IVectorGeometryToolVectorAngularVelocity._metadata, IVectorGeometryToolVectorAngularVelocity._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorAngularVelocity._metadata, IVectorGeometryToolVectorAngularVelocity._set_differencing_time_step_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{A4BB1049-215B-4FF3-B9FE-8F894D6CF9C9}", IVectorGeometryToolVectorAngularVelocity)
agcls.AgTypeNameMap["IVectorGeometryToolVectorAngularVelocity"] = IVectorGeometryToolVectorAngularVelocity

class IVectorGeometryToolVectorConing(object):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_about_vector" : 1,
                             "get_reference_vector" : 2,
                             "get_start_clock_angle" : 3,
                             "set_start_clock_angle" : 4,
                             "get_stop_clock_angle" : 5,
                             "set_stop_clock_angle" : 6,
                             "get_start_epoch" : 7,
                             "set_start_epoch" : 8,
                             "get_clock_angle_rate" : 9,
                             "set_clock_angle_rate" : 10,
                             "get_mode" : 11,
                             "set_mode" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorConing)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorConing)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorConing, None)
    
    _get_about_vector_metadata = { "name" : "about_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def about_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a vector around which the the reference vector is revolved."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_about_vector_metadata)

    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a reference vector."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_reference_vector_metadata)

    _get_start_clock_angle_metadata = { "name" : "start_clock_angle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def start_clock_angle(self) -> float:
        """Specify a start angle."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_start_clock_angle_metadata)

    _set_start_clock_angle_metadata = { "name" : "start_clock_angle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @start_clock_angle.setter
    def start_clock_angle(self, startClockAngle:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._set_start_clock_angle_metadata, startClockAngle)

    _get_stop_clock_angle_metadata = { "name" : "stop_clock_angle",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def stop_clock_angle(self) -> float:
        """Specify a stop angle."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_stop_clock_angle_metadata)

    _set_stop_clock_angle_metadata = { "name" : "stop_clock_angle",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @stop_clock_angle.setter
    def stop_clock_angle(self, stopClockAngle:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._set_stop_clock_angle_metadata, stopClockAngle)

    _get_start_epoch_metadata = { "name" : "start_epoch",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start_epoch(self) -> typing.Any:
        """Specify an epoch at which the coning vector is aligned with the reference vector."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_start_epoch_metadata)

    _set_start_epoch_metadata = { "name" : "start_epoch",
            "arg_types" : (agcom.VARIANT,),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @start_epoch.setter
    def start_epoch(self, startEpoch:typing.Any) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._set_start_epoch_metadata, startEpoch)

    _get_clock_angle_rate_metadata = { "name" : "clock_angle_rate",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def clock_angle_rate(self) -> float:
        """Specify a rotation rate."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_clock_angle_rate_metadata)

    _set_clock_angle_rate_metadata = { "name" : "clock_angle_rate",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @clock_angle_rate.setter
    def clock_angle_rate(self, clockAngleRate:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._set_clock_angle_rate_metadata, clockAngleRate)

    _get_mode_metadata = { "name" : "mode",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SWEEP_MODE),) }
    @property
    def mode(self) -> "CRDN_SWEEP_MODE":
        """Specify either unidirectional or bidirectional mode."""
        return self._intf.get_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._get_mode_metadata)

    _set_mode_metadata = { "name" : "mode",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SWEEP_MODE),) }
    @mode.setter
    def mode(self, mode:"CRDN_SWEEP_MODE") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorConing._metadata, IVectorGeometryToolVectorConing._set_mode_metadata, mode)


agcls.AgClassCatalog.add_catalog_entry("{3CA2F9EC-F108-4F3B-9E51-48B87685C3A4}", IVectorGeometryToolVectorConing)
agcls.AgTypeNameMap["IVectorGeometryToolVectorConing"] = IVectorGeometryToolVectorConing

class IVectorGeometryToolVectorCross(object):
    """The vector cross product of two vectors."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F695FE24-7AE1-4935-837F-D7106A3C99A4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_from_method" : 1,
                             "get_to" : 2,
                             "get_is_normalized" : 3,
                             "set_is_normalized" : 4,
                             "get_dimension" : 5,
                             "set_dimension" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorCross)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorCross)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorCross, None)
    
    _get_from_method_metadata = { "name" : "from_method",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def from_method(self) -> "VectorGeometryToolVectorRefTo":
        """Specify one of the two vectors which define the vector cross product."""
        return self._intf.get_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._get_from_method_metadata)

    _get_to_metadata = { "name" : "to",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def to(self) -> "VectorGeometryToolVectorRefTo":
        """Specify the second of the two vectors which define the vector cross product."""
        return self._intf.get_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._get_to_metadata)

    _get_is_normalized_metadata = { "name" : "is_normalized",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_normalized(self) -> bool:
        """Whether to convert the cross product of two vectors to a unit vector."""
        return self._intf.get_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._get_is_normalized_metadata)

    _set_is_normalized_metadata = { "name" : "is_normalized",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @is_normalized.setter
    def is_normalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._set_is_normalized_metadata, isNormalized)

    _get_dimension_metadata = { "name" : "dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def dimension(self) -> str:
        """Return a unit of measure, i.e. 'AngleUnit', 'DistanceUnit', etc."""
        return self._intf.get_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._get_dimension_metadata)

    _set_dimension_metadata = { "name" : "dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorCross._metadata, IVectorGeometryToolVectorCross._set_dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{F695FE24-7AE1-4935-837F-D7106A3C99A4}", IVectorGeometryToolVectorCross)
agcls.AgTypeNameMap["IVectorGeometryToolVectorCross"] = IVectorGeometryToolVectorCross

class IVectorGeometryToolVectorCustomScript(object):
    """Customized vector components defined with respect to reference axes."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{66756C64-795C-4E24-9D6A-E560851BBDE0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_axes" : 1,
                             "get_script_file" : 2,
                             "set_script_file" : 3,
                             "get_initialization_script_file" : 4,
                             "set_initialization_script_file" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorCustomScript)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorCustomScript)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorCustomScript, None)
    
    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorCustomScript._metadata, IVectorGeometryToolVectorCustomScript._get_reference_axes_metadata)

    _get_script_file_metadata = { "name" : "script_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def script_file(self) -> str:
        """Specify a script file."""
        return self._intf.get_property(IVectorGeometryToolVectorCustomScript._metadata, IVectorGeometryToolVectorCustomScript._get_script_file_metadata)

    _set_script_file_metadata = { "name" : "script_file",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @script_file.setter
    def script_file(self, scriptFile:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorCustomScript._metadata, IVectorGeometryToolVectorCustomScript._set_script_file_metadata, scriptFile)

    _get_initialization_script_file_metadata = { "name" : "initialization_script_file",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def initialization_script_file(self) -> str:
        """Specify an initialization script file (optional). The initialization script is run once, at the beginning of the calculation."""
        return self._intf.get_property(IVectorGeometryToolVectorCustomScript._metadata, IVectorGeometryToolVectorCustomScript._get_initialization_script_file_metadata)

    _set_initialization_script_file_metadata = { "name" : "initialization_script_file",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @initialization_script_file.setter
    def initialization_script_file(self, initializationScriptFile:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorCustomScript._metadata, IVectorGeometryToolVectorCustomScript._set_initialization_script_file_metadata, initializationScriptFile)


agcls.AgClassCatalog.add_catalog_entry("{66756C64-795C-4E24-9D6A-E560851BBDE0}", IVectorGeometryToolVectorCustomScript)
agcls.AgTypeNameMap["IVectorGeometryToolVectorCustomScript"] = IVectorGeometryToolVectorCustomScript

class IVectorGeometryToolVectorDerivative(object):
    """A vector derivative of a vector computed with respect to specified axes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vector" : 1,
                             "get_reference_axes" : 2,
                             "get_differencing_time_step" : 3,
                             "set_differencing_time_step" : 4,
                             "get_force_use_of_numerical_differences" : 5,
                             "set_force_use_of_numerical_differences" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorDerivative)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorDerivative)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorDerivative, None)
    
    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a base vector."""
        return self._intf.get_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._get_vector_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._get_reference_axes_metadata)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._set_differencing_time_step_metadata, differencingTimeStep)

    _get_force_use_of_numerical_differences_metadata = { "name" : "force_use_of_numerical_differences",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def force_use_of_numerical_differences(self) -> bool:
        """Force the use of numerical differences even if the derivative can be computed analytically."""
        return self._intf.get_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._get_force_use_of_numerical_differences_metadata)

    _set_force_use_of_numerical_differences_metadata = { "name" : "force_use_of_numerical_differences",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @force_use_of_numerical_differences.setter
    def force_use_of_numerical_differences(self, forceUseOfNumericalDifferences:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDerivative._metadata, IVectorGeometryToolVectorDerivative._set_force_use_of_numerical_differences_metadata, forceUseOfNumericalDifferences)


agcls.AgClassCatalog.add_catalog_entry("{4D7F4E0C-F02E-4CBF-B142-D88706C8D2C7}", IVectorGeometryToolVectorDerivative)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDerivative"] = IVectorGeometryToolVectorDerivative

class IVectorGeometryToolVectorDisplacement(object):
    """Vector defined by its start and end points."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{457E8D69-0F1F-4C02-A9D6-F48F86F63853}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_origin" : 1,
                             "get_destination" : 2,
                             "get_apparent" : 3,
                             "set_apparent" : 4,
                             "get_ignore_aberration" : 5,
                             "set_ignore_aberration" : 6,
                             "get_signal_sense" : 7,
                             "set_signal_sense" : 8,
                             "get_reference_system" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorDisplacement)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorDisplacement)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorDisplacement, None)
    
    _get_origin_metadata = { "name" : "origin",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin(self) -> "VectorGeometryToolPointRefTo":
        """Specify the vector's origin point."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_origin_metadata)

    _get_destination_metadata = { "name" : "destination",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def destination(self) -> "VectorGeometryToolPointRefTo":
        """Specify the vector's destination point."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_destination_metadata)

    _get_apparent_metadata = { "name" : "apparent",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def apparent(self) -> bool:
        """Control whether to take a light speed delay into account."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_apparent_metadata)

    _set_apparent_metadata = { "name" : "apparent",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @apparent.setter
    def apparent(self, apparent:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._set_apparent_metadata, apparent)

    _get_ignore_aberration_metadata = { "name" : "ignore_aberration",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def ignore_aberration(self) -> bool:
        """Set to true if you do not want to calculate the aberration correction. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_ignore_aberration_metadata)

    _set_ignore_aberration_metadata = { "name" : "ignore_aberration",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @ignore_aberration.setter
    def ignore_aberration(self, ignoreAberration:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._set_ignore_aberration_metadata, ignoreAberration)

    _get_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @property
    def signal_sense(self) -> "CRDN_SIGNAL_SENSE":
        """Specify a sense of signal transmission. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_signal_sense_metadata)

    _set_signal_sense_metadata = { "name" : "signal_sense",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SIGNAL_SENSE),) }
    @signal_sense.setter
    def signal_sense(self, signalSense:"CRDN_SIGNAL_SENSE") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._set_signal_sense_metadata, signalSense)

    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "VectorGeometryToolSystemRefTo":
        """Specify a frame in which the light time delay is computed. This property is read-only if Apparent is set to false."""
        return self._intf.get_property(IVectorGeometryToolVectorDisplacement._metadata, IVectorGeometryToolVectorDisplacement._get_reference_system_metadata)


agcls.AgClassCatalog.add_catalog_entry("{457E8D69-0F1F-4C02-A9D6-F48F86F63853}", IVectorGeometryToolVectorDisplacement)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDisplacement"] = IVectorGeometryToolVectorDisplacement

class IVectorGeometryToolVectorTwoPlanesIntersection(object):
    """Defined along the intersection of two planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_plane_a" : 1,
                             "get_plane_b" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorTwoPlanesIntersection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorTwoPlanesIntersection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorTwoPlanesIntersection, None)
    
    _get_plane_a_metadata = { "name" : "plane_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def plane_a(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the first of the two planes which intersection defines the vector."""
        return self._intf.get_property(IVectorGeometryToolVectorTwoPlanesIntersection._metadata, IVectorGeometryToolVectorTwoPlanesIntersection._get_plane_a_metadata)

    _get_plane_b_metadata = { "name" : "plane_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def plane_b(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify the second of the two planes which intersection defines the vector."""
        return self._intf.get_property(IVectorGeometryToolVectorTwoPlanesIntersection._metadata, IVectorGeometryToolVectorTwoPlanesIntersection._get_plane_b_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2A58B245-6CF9-4788-9F4E-2E6F98F027F9}", IVectorGeometryToolVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorTwoPlanesIntersection"] = IVectorGeometryToolVectorTwoPlanesIntersection

class IVectorGeometryToolVectorModelAttach(object):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4CCEE5C-B053-413F-8456-6A43720BD314}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_pointable_element_name" : 1,
                             "set_pointable_element_name" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorModelAttach)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorModelAttach)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorModelAttach, None)
    
    _get_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def pointable_element_name(self) -> str:
        """Specify a pointable element of the 3D model associated with the object."""
        return self._intf.get_property(IVectorGeometryToolVectorModelAttach._metadata, IVectorGeometryToolVectorModelAttach._get_pointable_element_name_metadata)

    _set_pointable_element_name_metadata = { "name" : "pointable_element_name",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @pointable_element_name.setter
    def pointable_element_name(self, pointableElementName:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorModelAttach._metadata, IVectorGeometryToolVectorModelAttach._set_pointable_element_name_metadata, pointableElementName)


agcls.AgClassCatalog.add_catalog_entry("{C4CCEE5C-B053-413F-8456-6A43720BD314}", IVectorGeometryToolVectorModelAttach)
agcls.AgTypeNameMap["IVectorGeometryToolVectorModelAttach"] = IVectorGeometryToolVectorModelAttach

class IVectorGeometryToolVectorProjection(object):
    """A projection of a vector computed with respect to a reference plane."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2050D921-A98C-408C-8170-FDBB23FEA6E5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_source" : 1,
                             "get_reference_plane" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorProjection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorProjection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorProjection, None)
    
    _get_source_metadata = { "name" : "source",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source(self) -> "VectorGeometryToolVectorRefTo":
        """Specify a source vector."""
        return self._intf.get_property(IVectorGeometryToolVectorProjection._metadata, IVectorGeometryToolVectorProjection._get_source_metadata)

    _get_reference_plane_metadata = { "name" : "reference_plane",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_plane(self) -> "VectorGeometryToolPlaneRefTo":
        """Specify a reference plane."""
        return self._intf.get_property(IVectorGeometryToolVectorProjection._metadata, IVectorGeometryToolVectorProjection._get_reference_plane_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2050D921-A98C-408C-8170-FDBB23FEA6E5}", IVectorGeometryToolVectorProjection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorProjection"] = IVectorGeometryToolVectorProjection

class IVectorGeometryToolVectorScaled(object):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{7D89412E-17A8-43D2-9153-58F45E7072F6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_vector" : 1,
                             "get_scale" : 2,
                             "set_scale" : 3,
                             "get_is_normalized" : 4,
                             "set_is_normalized" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorScaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorScaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorScaled, None)
    
    _get_reference_vector_metadata = { "name" : "reference_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_vector(self) -> "VectorGeometryToolVectorRefTo":
        """A vector being scaled."""
        return self._intf.get_property(IVectorGeometryToolVectorScaled._metadata, IVectorGeometryToolVectorScaled._get_reference_vector_metadata)

    _get_scale_metadata = { "name" : "scale",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale(self) -> float:
        """A scaling multiple."""
        return self._intf.get_property(IVectorGeometryToolVectorScaled._metadata, IVectorGeometryToolVectorScaled._get_scale_metadata)

    _set_scale_metadata = { "name" : "scale",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScaled._metadata, IVectorGeometryToolVectorScaled._set_scale_metadata, scale)

    _get_is_normalized_metadata = { "name" : "is_normalized",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_normalized(self) -> bool:
        """Control whether to convert the reference vector to a unit vector before scalling."""
        return self._intf.get_property(IVectorGeometryToolVectorScaled._metadata, IVectorGeometryToolVectorScaled._get_is_normalized_metadata)

    _set_is_normalized_metadata = { "name" : "is_normalized",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @is_normalized.setter
    def is_normalized(self, isNormalized:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScaled._metadata, IVectorGeometryToolVectorScaled._set_is_normalized_metadata, isNormalized)


agcls.AgClassCatalog.add_catalog_entry("{7D89412E-17A8-43D2-9153-58F45E7072F6}", IVectorGeometryToolVectorScaled)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScaled"] = IVectorGeometryToolVectorScaled

class IVectorGeometryToolVectorEccentricity(object):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_mean_element_type" : 3,
                             "set_mean_element_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorEccentricity)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorEccentricity)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorEccentricity, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorEccentricity._metadata, IVectorGeometryToolVectorEccentricity._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IVectorGeometryToolVectorEccentricity._metadata, IVectorGeometryToolVectorEccentricity._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IVectorGeometryToolVectorEccentricity._metadata, IVectorGeometryToolVectorEccentricity._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorEccentricity._metadata, IVectorGeometryToolVectorEccentricity._set_mean_element_type_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{4DD01FAD-E77E-45BE-9DDD-0468A3B45FB0}", IVectorGeometryToolVectorEccentricity)
agcls.AgTypeNameMap["IVectorGeometryToolVectorEccentricity"] = IVectorGeometryToolVectorEccentricity

class IVectorGeometryToolVectorFixedInAxes(object):
    """Vector fixed in the reference axes using the selected coordinate type."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{912ECDDB-B23C-4B7A-A173-AC22170DA343}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_axes" : 1,
                             "get_direction" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFixedInAxes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFixedInAxes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFixedInAxes, None)
    
    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedInAxes._metadata, IVectorGeometryToolVectorFixedInAxes._get_reference_axes_metadata)

    _get_direction_metadata = { "name" : "direction",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def direction(self) -> "IDirection":
        """Specify the vector direction."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedInAxes._metadata, IVectorGeometryToolVectorFixedInAxes._get_direction_metadata)


agcls.AgClassCatalog.add_catalog_entry("{912ECDDB-B23C-4B7A-A173-AC22170DA343}", IVectorGeometryToolVectorFixedInAxes)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedInAxes"] = IVectorGeometryToolVectorFixedInAxes

class IVectorGeometryToolVectorLineOfNodes(object):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{DC23EB21-198C-4E01-9898-D565E937AFF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorLineOfNodes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorLineOfNodes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorLineOfNodes, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorLineOfNodes._metadata, IVectorGeometryToolVectorLineOfNodes._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Specify a reference point."""
        return self._intf.get_property(IVectorGeometryToolVectorLineOfNodes._metadata, IVectorGeometryToolVectorLineOfNodes._get_reference_point_metadata)


agcls.AgClassCatalog.add_catalog_entry("{DC23EB21-198C-4E01-9898-D565E937AFF1}", IVectorGeometryToolVectorLineOfNodes)
agcls.AgTypeNameMap["IVectorGeometryToolVectorLineOfNodes"] = IVectorGeometryToolVectorLineOfNodes

class IVectorGeometryToolVectorOrbitAngularMomentum(object):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{22C8270A-7B36-40D7-9EC5-44FED3DEE541}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_mean_element_type" : 3,
                             "set_mean_element_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorOrbitAngularMomentum)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorOrbitAngularMomentum)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorOrbitAngularMomentum, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitAngularMomentum._metadata, IVectorGeometryToolVectorOrbitAngularMomentum._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitAngularMomentum._metadata, IVectorGeometryToolVectorOrbitAngularMomentum._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitAngularMomentum._metadata, IVectorGeometryToolVectorOrbitAngularMomentum._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorOrbitAngularMomentum._metadata, IVectorGeometryToolVectorOrbitAngularMomentum._set_mean_element_type_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{22C8270A-7B36-40D7-9EC5-44FED3DEE541}", IVectorGeometryToolVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["IVectorGeometryToolVectorOrbitAngularMomentum"] = IVectorGeometryToolVectorOrbitAngularMomentum

class IVectorGeometryToolVectorOrbitNormal(object):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{296D4695-53FE-40B7-BA3E-41A3C04A805F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_mean_element_type" : 3,
                             "set_mean_element_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorOrbitNormal)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorOrbitNormal)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorOrbitNormal, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitNormal._metadata, IVectorGeometryToolVectorOrbitNormal._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitNormal._metadata, IVectorGeometryToolVectorOrbitNormal._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IVectorGeometryToolVectorOrbitNormal._metadata, IVectorGeometryToolVectorOrbitNormal._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorOrbitNormal._metadata, IVectorGeometryToolVectorOrbitNormal._set_mean_element_type_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{296D4695-53FE-40B7-BA3E-41A3C04A805F}", IVectorGeometryToolVectorOrbitNormal)
agcls.AgTypeNameMap["IVectorGeometryToolVectorOrbitNormal"] = IVectorGeometryToolVectorOrbitNormal

class IVectorGeometryToolVectorPeriapsis(object):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_central_body" : 1,
                             "get_reference_point" : 2,
                             "get_mean_element_type" : 3,
                             "set_mean_element_type" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorPeriapsis)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorPeriapsis)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorPeriapsis, None)
    
    _get_central_body_metadata = { "name" : "central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def central_body(self) -> "AnalysisWorkbenchCentralBodyRefTo":
        """Specify a central body."""
        return self._intf.get_property(IVectorGeometryToolVectorPeriapsis._metadata, IVectorGeometryToolVectorPeriapsis._get_central_body_metadata)

    _get_reference_point_metadata = { "name" : "reference_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_point(self) -> "VectorGeometryToolPointRefTo":
        """Elliptical orbit is fit to the current motion of the reference point according to the selected mean theory."""
        return self._intf.get_property(IVectorGeometryToolVectorPeriapsis._metadata, IVectorGeometryToolVectorPeriapsis._get_reference_point_metadata)

    _get_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @property
    def mean_element_type(self) -> "CRDN_MEAN_ELEMENT_THEORY":
        """Specify the mean element theory type for approximating motion."""
        return self._intf.get_property(IVectorGeometryToolVectorPeriapsis._metadata, IVectorGeometryToolVectorPeriapsis._get_mean_element_type_metadata)

    _set_mean_element_type_metadata = { "name" : "mean_element_type",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_MEAN_ELEMENT_THEORY),) }
    @mean_element_type.setter
    def mean_element_type(self, meanElementType:"CRDN_MEAN_ELEMENT_THEORY") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorPeriapsis._metadata, IVectorGeometryToolVectorPeriapsis._set_mean_element_type_metadata, meanElementType)


agcls.AgClassCatalog.add_catalog_entry("{83BA8CAD-1273-4B77-9EF2-9E049D9571D6}", IVectorGeometryToolVectorPeriapsis)
agcls.AgTypeNameMap["IVectorGeometryToolVectorPeriapsis"] = IVectorGeometryToolVectorPeriapsis

class IVectorGeometryToolVectorReflection(object):
    """A vector (incident vector) reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{AF054174-278A-41E6-B8FA-0FC48E19A8BC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_incoming_vector" : 1,
                             "get_use_opposite_of_selected_vector" : 2,
                             "set_use_opposite_of_selected_vector" : 3,
                             "get_normal_vector" : 4,
                             "get_allow_reflections_on_backside" : 5,
                             "set_allow_reflections_on_backside" : 6,
                             "get_scale_factor" : 7,
                             "set_scale_factor" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorReflection)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorReflection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorReflection, None)
    
    _get_incoming_vector_metadata = { "name" : "incoming_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def incoming_vector(self) -> "VectorGeometryToolVectorRefTo":
        """The reflecting vector."""
        return self._intf.get_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._get_incoming_vector_metadata)

    _get_use_opposite_of_selected_vector_metadata = { "name" : "use_opposite_of_selected_vector",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_opposite_of_selected_vector(self) -> bool:
        """When set to false, resets the direction of the Incident Vector to default."""
        return self._intf.get_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._get_use_opposite_of_selected_vector_metadata)

    _set_use_opposite_of_selected_vector_metadata = { "name" : "use_opposite_of_selected_vector",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_opposite_of_selected_vector.setter
    def use_opposite_of_selected_vector(self, useOppositeOfSelectedVector:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._set_use_opposite_of_selected_vector_metadata, useOppositeOfSelectedVector)

    _get_normal_vector_metadata = { "name" : "normal_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def normal_vector(self) -> "VectorGeometryToolVectorRefTo":
        """The vector defines the reflection surface."""
        return self._intf.get_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._get_normal_vector_metadata)

    _get_allow_reflections_on_backside_metadata = { "name" : "allow_reflections_on_backside",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def allow_reflections_on_backside(self) -> bool:
        """Control whether to reflect the indicent vector on both sides of the plane."""
        return self._intf.get_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._get_allow_reflections_on_backside_metadata)

    _set_allow_reflections_on_backside_metadata = { "name" : "allow_reflections_on_backside",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @allow_reflections_on_backside.setter
    def allow_reflections_on_backside(self, allowReflectionsOnBackside:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._set_allow_reflections_on_backside_metadata, allowReflectionsOnBackside)

    _get_scale_factor_metadata = { "name" : "scale_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor(self) -> float:
        """The vector's scale factor."""
        return self._intf.get_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._get_scale_factor_metadata)

    _set_scale_factor_metadata = { "name" : "scale_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor.setter
    def scale_factor(self, scaleFactor:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorReflection._metadata, IVectorGeometryToolVectorReflection._set_scale_factor_metadata, scaleFactor)


agcls.AgClassCatalog.add_catalog_entry("{AF054174-278A-41E6-B8FA-0FC48E19A8BC}", IVectorGeometryToolVectorReflection)
agcls.AgTypeNameMap["IVectorGeometryToolVectorReflection"] = IVectorGeometryToolVectorReflection

class IVectorGeometryToolVectorRotationVector(object):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2dc152fa-f029-4bc6-bc47-f27d92219a32}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_axes" : 1,
                             "get_reference_axes" : 2,
                             "get_force_minimum_rotation" : 3,
                             "set_force_minimum_rotation" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorRotationVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorRotationVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorRotationVector, None)
    
    _get_axes_metadata = { "name" : "axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify the axes."""
        return self._intf.get_property(IVectorGeometryToolVectorRotationVector._metadata, IVectorGeometryToolVectorRotationVector._get_axes_metadata)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "VectorGeometryToolAxesRefTo":
        """Specify a reference axes."""
        return self._intf.get_property(IVectorGeometryToolVectorRotationVector._metadata, IVectorGeometryToolVectorRotationVector._get_reference_axes_metadata)

    _get_force_minimum_rotation_metadata = { "name" : "force_minimum_rotation",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def force_minimum_rotation(self) -> bool:
        """Insures that the rotation angle will be between 0 and pi. If the angle is increasing at pi, then the axis direction will be negated to keep phi less than pi."""
        return self._intf.get_property(IVectorGeometryToolVectorRotationVector._metadata, IVectorGeometryToolVectorRotationVector._get_force_minimum_rotation_metadata)

    _set_force_minimum_rotation_metadata = { "name" : "force_minimum_rotation",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @force_minimum_rotation.setter
    def force_minimum_rotation(self, forceMinimumRotation:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorRotationVector._metadata, IVectorGeometryToolVectorRotationVector._set_force_minimum_rotation_metadata, forceMinimumRotation)


agcls.AgClassCatalog.add_catalog_entry("{2dc152fa-f029-4bc6-bc47-f27d92219a32}", IVectorGeometryToolVectorRotationVector)
agcls.AgTypeNameMap["IVectorGeometryToolVectorRotationVector"] = IVectorGeometryToolVectorRotationVector

class IVectorGeometryToolVectorDirectionToStar(object):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_selected_star" : 1,
                             "set_selected_star" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorDirectionToStar)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorDirectionToStar)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorDirectionToStar, None)
    
    _get_selected_star_metadata = { "name" : "selected_star",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def selected_star(self) -> str:
        """A fully qualified path to a Star object."""
        return self._intf.get_property(IVectorGeometryToolVectorDirectionToStar._metadata, IVectorGeometryToolVectorDirectionToStar._get_selected_star_metadata)

    _set_selected_star_metadata = { "name" : "selected_star",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @selected_star.setter
    def selected_star(self, selectedStar:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDirectionToStar._metadata, IVectorGeometryToolVectorDirectionToStar._set_selected_star_metadata, selectedStar)


agcls.AgClassCatalog.add_catalog_entry("{5F3A0E54-65A6-42E5-85E2-6F1B19D2F4AC}", IVectorGeometryToolVectorDirectionToStar)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDirectionToStar"] = IVectorGeometryToolVectorDirectionToStar

class IVectorGeometryToolVectorFixedAtTimeInstant(object):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B35CE60F-7CC5-4289-9052-2203B609087E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_time_instant" : 1,
                             "set_reference_time_instant" : 2,
                             "get_source_vector" : 3,
                             "set_source_vector" : 4,
                             "get_reference_axes" : 5,
                             "set_reference_axes" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFixedAtTimeInstant)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFixedAtTimeInstant)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFixedAtTimeInstant, None)
    
    _get_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_time_instant(self) -> "ITimeToolEvent":
        """A reference time instant. Can be any Time event."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._get_reference_time_instant_metadata)

    _set_reference_time_instant_metadata = { "name" : "reference_time_instant",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ITimeToolEvent"),) }
    @reference_time_instant.setter
    def reference_time_instant(self, referenceTimeInstant:"ITimeToolEvent") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._set_reference_time_instant_metadata, referenceTimeInstant)

    _get_source_vector_metadata = { "name" : "source_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_vector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._get_source_vector_metadata)

    _set_source_vector_metadata = { "name" : "source_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @source_vector.setter
    def source_vector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._set_source_vector_metadata, sourceVector)

    _get_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_axes(self) -> "IVectorGeometryToolAxes":
        """A reference axes. Can be any VGT axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._get_reference_axes_metadata)

    _set_reference_axes_metadata = { "name" : "reference_axes",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolAxes"),) }
    @reference_axes.setter
    def reference_axes(self, referenceAxes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorFixedAtTimeInstant._metadata, IVectorGeometryToolVectorFixedAtTimeInstant._set_reference_axes_metadata, referenceAxes)


agcls.AgClassCatalog.add_catalog_entry("{B35CE60F-7CC5-4289-9052-2203B609087E}", IVectorGeometryToolVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFixedAtTimeInstant"] = IVectorGeometryToolVectorFixedAtTimeInstant

class IVectorGeometryToolVectorLinearCombination(object):
    """Linear combination of two input vectors."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vector_a" : 1,
                             "set_vector_a" : 2,
                             "get_scale_factor_a" : 3,
                             "set_scale_factor_a" : 4,
                             "get_normalize_vector_a" : 5,
                             "set_normalize_vector_a" : 6,
                             "get_vector_b" : 7,
                             "set_vector_b" : 8,
                             "get_scale_factor_b" : 9,
                             "set_scale_factor_b" : 10,
                             "get_normalize_vector_b" : 11,
                             "set_normalize_vector_b" : 12,
                             "get_output_dimension_inheritance" : 13,
                             "set_output_dimension_inheritance" : 14,
                             "get_output_dimension" : 15,
                             "set_output_dimension" : 16, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorLinearCombination)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorLinearCombination)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorLinearCombination, None)
    
    _get_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_vector_a_metadata)

    _set_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_vector_a_metadata, vectorA)

    _get_scale_factor_a_metadata = { "name" : "scale_factor_a",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor_a(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_scale_factor_a_metadata)

    _set_scale_factor_a_metadata = { "name" : "scale_factor_a",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor_a.setter
    def scale_factor_a(self, scaleFactorA:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_scale_factor_a_metadata, scaleFactorA)

    _get_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_vector_b_metadata)

    _set_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_vector_b_metadata, vectorB)

    _get_scale_factor_b_metadata = { "name" : "scale_factor_b",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor_b(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_scale_factor_b_metadata)

    _set_scale_factor_b_metadata = { "name" : "scale_factor_b",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor_b.setter
    def scale_factor_b(self, scaleFactorB:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_scale_factor_b_metadata, scaleFactorB)

    _get_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Determine whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_dimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorLinearCombination._metadata, IVectorGeometryToolVectorLinearCombination._set_output_dimension_metadata, outputDimension)


agcls.AgClassCatalog.add_catalog_entry("{3F42BCB8-0F59-41C8-9E8E-48E6C773A8DC}", IVectorGeometryToolVectorLinearCombination)
agcls.AgTypeNameMap["IVectorGeometryToolVectorLinearCombination"] = IVectorGeometryToolVectorLinearCombination

class IVectorGeometryToolVectorProjectAlongVector(object):
    """A projection of a source vector in the direction of another vector."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_source_vector" : 1,
                             "set_source_vector" : 2,
                             "get_along_vector" : 3,
                             "set_along_vector" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorProjectAlongVector)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorProjectAlongVector)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorProjectAlongVector, None)
    
    _get_source_vector_metadata = { "name" : "source_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def source_vector(self) -> "IVectorGeometryToolVector":
        """A source vector. Can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorProjectAlongVector._metadata, IVectorGeometryToolVectorProjectAlongVector._get_source_vector_metadata)

    _set_source_vector_metadata = { "name" : "source_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @source_vector.setter
    def source_vector(self, sourceVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorProjectAlongVector._metadata, IVectorGeometryToolVectorProjectAlongVector._set_source_vector_metadata, sourceVector)

    _get_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def along_vector(self) -> "IVectorGeometryToolVector":
        """A vector along which the source vector is projected. Can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorProjectAlongVector._metadata, IVectorGeometryToolVectorProjectAlongVector._get_along_vector_metadata)

    _set_along_vector_metadata = { "name" : "along_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @along_vector.setter
    def along_vector(self, alongVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorProjectAlongVector._metadata, IVectorGeometryToolVectorProjectAlongVector._set_along_vector_metadata, alongVector)


agcls.AgClassCatalog.add_catalog_entry("{9D0CA6C5-1A1F-4FDE-82EA-6948ADA3072F}", IVectorGeometryToolVectorProjectAlongVector)
agcls.AgTypeNameMap["IVectorGeometryToolVectorProjectAlongVector"] = IVectorGeometryToolVectorProjectAlongVector

class IVectorGeometryToolVectorScalarLinearCombination(object):
    """Linear combination of two input vectors using scalars."""

    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0886A066-8650-4C8D-B234-14D28A175A78}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vector_a" : 1,
                             "set_vector_a" : 2,
                             "get_scale_factor_a" : 3,
                             "set_scale_factor_a" : 4,
                             "get_normalize_vector_a" : 5,
                             "set_normalize_vector_a" : 6,
                             "get_use_scale_from_scalar_a" : 7,
                             "set_use_scale_from_scalar_a" : 8,
                             "get_use_scale_from_scalar_b" : 9,
                             "set_use_scale_from_scalar_b" : 10,
                             "get_scalar_a" : 11,
                             "set_scalar_a" : 12,
                             "get_scalar_b" : 13,
                             "set_scalar_b" : 14,
                             "get_vector_b" : 15,
                             "set_vector_b" : 16,
                             "get_scale_factor_b" : 17,
                             "set_scale_factor_b" : 18,
                             "get_normalize_vector_b" : 19,
                             "set_normalize_vector_b" : 20,
                             "get_output_dimension_inheritance" : 21,
                             "set_output_dimension_inheritance" : 22,
                             "get_output_dimension" : 23,
                             "set_output_dimension" : 24, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorScalarLinearCombination)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorScalarLinearCombination)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorScalarLinearCombination, None)
    
    _get_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_a(self) -> "IVectorGeometryToolVector":
        """Vector A can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_vector_a_metadata)

    _set_vector_a_metadata = { "name" : "vector_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_a.setter
    def vector_a(self, vectorA:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_vector_a_metadata, vectorA)

    _get_scale_factor_a_metadata = { "name" : "scale_factor_a",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor_a(self) -> float:
        """Scale factor for vector A."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_scale_factor_a_metadata)

    _set_scale_factor_a_metadata = { "name" : "scale_factor_a",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor_a.setter
    def scale_factor_a(self, scaleFactorA:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_scale_factor_a_metadata, scaleFactorA)

    _get_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_a(self) -> bool:
        """Whether to normalize vector A."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_normalize_vector_a_metadata)

    _set_normalize_vector_a_metadata = { "name" : "normalize_vector_a",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_a.setter
    def normalize_vector_a(self, normalizeVectorA:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_normalize_vector_a_metadata, normalizeVectorA)

    _get_use_scale_from_scalar_a_metadata = { "name" : "use_scale_from_scalar_a",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_scale_from_scalar_a(self) -> bool:
        """Whether to use a scale from scalar A."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_use_scale_from_scalar_a_metadata)

    _set_use_scale_from_scalar_a_metadata = { "name" : "use_scale_from_scalar_a",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_scale_from_scalar_a.setter
    def use_scale_from_scalar_a(self, useScaleFromScalarA:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_use_scale_from_scalar_a_metadata, useScaleFromScalarA)

    _get_use_scale_from_scalar_b_metadata = { "name" : "use_scale_from_scalar_b",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def use_scale_from_scalar_b(self) -> bool:
        """Whether to use a scale from scalar B."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_use_scale_from_scalar_b_metadata)

    _set_use_scale_from_scalar_b_metadata = { "name" : "use_scale_from_scalar_b",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @use_scale_from_scalar_b.setter
    def use_scale_from_scalar_b(self, useScaleFromScalarB:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_use_scale_from_scalar_b_metadata, useScaleFromScalarB)

    _get_scalar_a_metadata = { "name" : "scalar_a",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar_a(self) -> "ICalculationToolScalar":
        """Scalar scale A. Can be any Scalar calculation."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_scalar_a_metadata)

    _set_scalar_a_metadata = { "name" : "scalar_a",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar_a.setter
    def scalar_a(self, scalarA:"ICalculationToolScalar") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_scalar_a_metadata, scalarA)

    _get_scalar_b_metadata = { "name" : "scalar_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def scalar_b(self) -> "ICalculationToolScalar":
        """Scalar scale B. Can be any Scalar calculation."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_scalar_b_metadata)

    _set_scalar_b_metadata = { "name" : "scalar_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @scalar_b.setter
    def scalar_b(self, scalarB:"ICalculationToolScalar") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_scalar_b_metadata, scalarB)

    _get_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_b(self) -> "IVectorGeometryToolVector":
        """Vector B can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_vector_b_metadata)

    _set_vector_b_metadata = { "name" : "vector_b",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @vector_b.setter
    def vector_b(self, vectorB:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_vector_b_metadata, vectorB)

    _get_scale_factor_b_metadata = { "name" : "scale_factor_b",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor_b(self) -> float:
        """Scale factor for vector B."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_scale_factor_b_metadata)

    _set_scale_factor_b_metadata = { "name" : "scale_factor_b",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor_b.setter
    def scale_factor_b(self, scaleFactorB:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_scale_factor_b_metadata, scaleFactorB)

    _get_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize_vector_b(self) -> bool:
        """Whether to normalize vector B."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_normalize_vector_b_metadata)

    _set_normalize_vector_b_metadata = { "name" : "normalize_vector_b",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize_vector_b.setter
    def normalize_vector_b(self, normalizeVectorB:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_normalize_vector_b_metadata, normalizeVectorB)

    _get_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @property
    def output_dimension_inheritance(self) -> "CRDN_DIMENSION_INHERITANCE":
        """Determine whether the output dimension is inherited or explicitly specified using OutputDimension."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_output_dimension_inheritance_metadata)

    _set_output_dimension_inheritance_metadata = { "name" : "output_dimension_inheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_DIMENSION_INHERITANCE),) }
    @output_dimension_inheritance.setter
    def output_dimension_inheritance(self, outputDimensionInheritance:"CRDN_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_output_dimension_inheritance_metadata, outputDimensionInheritance)

    _get_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def output_dimension(self) -> str:
        """A dimension to interpret the output vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._get_output_dimension_metadata)

    _set_output_dimension_metadata = { "name" : "output_dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @output_dimension.setter
    def output_dimension(self, outputDimension:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarLinearCombination._metadata, IVectorGeometryToolVectorScalarLinearCombination._set_output_dimension_metadata, outputDimension)


agcls.AgClassCatalog.add_catalog_entry("{0886A066-8650-4C8D-B234-14D28A175A78}", IVectorGeometryToolVectorScalarLinearCombination)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScalarLinearCombination"] = IVectorGeometryToolVectorScalarLinearCombination

class IVectorGeometryToolVectorScalarScaled(object):
    """Scaled version of the input vector using scalar."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{306C3852-C3E9-43EB-9371-1B9540B52097}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_input_vector" : 1,
                             "set_input_vector" : 2,
                             "get_input_scalar" : 3,
                             "set_input_scalar" : 4,
                             "get_scale_factor" : 5,
                             "set_scale_factor" : 6,
                             "get_normalize" : 7,
                             "set_normalize" : 8,
                             "get_dimension_inheritance" : 9,
                             "set_dimension_inheritance" : 10,
                             "get_dimension" : 11,
                             "set_dimension" : 12, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorScalarScaled)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorScalarScaled)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorScalarScaled, None)
    
    _get_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_vector(self) -> "IVectorGeometryToolVector":
        """An input vector scaled by the scalar. Can be any VGT vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_input_vector_metadata)

    _set_input_vector_metadata = { "name" : "input_vector",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"),) }
    @input_vector.setter
    def input_vector(self, inputVector:"IVectorGeometryToolVector") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_input_vector_metadata, inputVector)

    _get_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def input_scalar(self) -> "ICalculationToolScalar":
        """A variable scale applied to the input vector. Can be based on any Scalar calculation."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_input_scalar_metadata)

    _set_input_scalar_metadata = { "name" : "input_scalar",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("ICalculationToolScalar"),) }
    @input_scalar.setter
    def input_scalar(self, inputScalar:"ICalculationToolScalar") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_input_scalar_metadata, inputScalar)

    _get_scale_factor_metadata = { "name" : "scale_factor",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def scale_factor(self) -> float:
        """A constant scale applied to the input vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_scale_factor_metadata)

    _set_scale_factor_metadata = { "name" : "scale_factor",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @scale_factor.setter
    def scale_factor(self, scaleFactor:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_scale_factor_metadata, scaleFactor)

    _get_normalize_metadata = { "name" : "normalize",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def normalize(self) -> bool:
        """Whether to normalize the input vector before applying constant and variable scales."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_normalize_metadata)

    _set_normalize_metadata = { "name" : "normalize",
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @normalize.setter
    def normalize(self, normalize:bool) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_normalize_metadata, normalize)

    _get_dimension_inheritance_metadata = { "name" : "dimension_inheritance",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE),) }
    @property
    def dimension_inheritance(self) -> "VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE":
        """Whether or not to inherit dimension from the input vector or the scalar."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_dimension_inheritance_metadata)

    _set_dimension_inheritance_metadata = { "name" : "dimension_inheritance",
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE),) }
    @dimension_inheritance.setter
    def dimension_inheritance(self, dimensionInheritance:"VECTOR_GEOMETRY_TOOL_VECTOR_SCALED_DIMENSION_INHERITANCE") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_dimension_inheritance_metadata, dimensionInheritance)

    _get_dimension_metadata = { "name" : "dimension",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def dimension(self) -> str:
        """A dimension assigned to the output vector."""
        return self._intf.get_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._get_dimension_metadata)

    _set_dimension_metadata = { "name" : "dimension",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @dimension.setter
    def dimension(self, dimension:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorScalarScaled._metadata, IVectorGeometryToolVectorScalarScaled._set_dimension_metadata, dimension)


agcls.AgClassCatalog.add_catalog_entry("{306C3852-C3E9-43EB-9371-1B9540B52097}", IVectorGeometryToolVectorScalarScaled)
agcls.AgTypeNameMap["IVectorGeometryToolVectorScalarScaled"] = IVectorGeometryToolVectorScalarScaled

class IVectorGeometryToolVectorVelocityAcceleration(object):
    """Velocity vector of a point in a coordinate system."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_reference_system" : 1,
                             "set_reference_system" : 2,
                             "get_point" : 3,
                             "set_point" : 4,
                             "get_differencing_time_step" : 5,
                             "set_differencing_time_step" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorVelocityAcceleration)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorVelocityAcceleration)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorVelocityAcceleration, None)
    
    _get_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def reference_system(self) -> "IVectorGeometryToolSystem":
        """A reference (coordinate) system. Can be any VGT system."""
        return self._intf.get_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._get_reference_system_metadata)

    _set_reference_system_metadata = { "name" : "reference_system",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolSystem"),) }
    @reference_system.setter
    def reference_system(self, referenceSystem:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._set_reference_system_metadata, referenceSystem)

    _get_point_metadata = { "name" : "point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def point(self) -> "IVectorGeometryToolPoint":
        """A point which velocity this vector represents. Can be any VGT point."""
        return self._intf.get_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._get_point_metadata)

    _set_point_metadata = { "name" : "point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @point.setter
    def point(self, point:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._set_point_metadata, point)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in numerical evaluation of derivatives using central differencing."""
        return self._intf.get_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorVelocityAcceleration._metadata, IVectorGeometryToolVectorVelocityAcceleration._set_differencing_time_step_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{265D93E1-E454-4A9A-A7C3-FF1EEB0BD9F2}", IVectorGeometryToolVectorVelocityAcceleration)
agcls.AgTypeNameMap["IVectorGeometryToolVectorVelocityAcceleration"] = IVectorGeometryToolVectorVelocityAcceleration

class IVectorGeometryToolVectorPlugin(object):
    """A VGT vector plugin."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F889F617-059E-4BC9-9000-206091889FEB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_prog_id" : 1,
                             "get_display_name" : 2,
                             "get_available_properties" : 3,
                             "reset" : 4,
                             "set_property" : 5,
                             "get_property" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorPlugin)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorPlugin)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorPlugin, None)
    
    _get_prog_id_metadata = { "name" : "prog_id",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def prog_id(self) -> str:
        """A programmatic ID associated with the component."""
        return self._intf.get_property(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._get_prog_id_metadata)

    _get_display_name_metadata = { "name" : "display_name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def display_name(self) -> str:
        """Plugin's Display Name associated with the COM plugin."""
        return self._intf.get_property(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._get_display_name_metadata)

    _get_available_properties_metadata = { "name" : "available_properties",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_properties(self) -> list:
        """An array of names of the properties that can be used to configure the plugin."""
        return self._intf.get_property(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._get_available_properties_metadata)

    _reset_metadata = { "name" : "reset",
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the plugin."""
        return self._intf.invoke(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._reset_metadata, )

    _set_property_metadata = { "name" : "set_property",
            "arg_types" : (agcom.BSTR, agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def set_property(self, name:str, value:str) -> None:
        """The method is used to set the plugin properties. The method throws an exception if the specified property does not exist, invalid value was specified or the specified property is read-only."""
        return self._intf.invoke(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._set_property_metadata, name, value)

    _get_property_metadata = { "name" : "get_property",
            "arg_types" : (agcom.BSTR, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg,) }
    def get_property(self, name:str) -> str:
        """The method reads a value of the specified plugin property. The method throws an exception if the property does not exist."""
        return self._intf.invoke(IVectorGeometryToolVectorPlugin._metadata, IVectorGeometryToolVectorPlugin._get_property_metadata, name, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{F889F617-059E-4BC9-9000-206091889FEB}", IVectorGeometryToolVectorPlugin)
agcls.AgTypeNameMap["IVectorGeometryToolVectorPlugin"] = IVectorGeometryToolVectorPlugin

class IVectorGeometryToolVectorDispSurface(object):
    """Displacement between origin and destination points using surface distance and altitude difference."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_origin_point" : 1,
                             "set_origin_point" : 2,
                             "get_destination_point" : 3,
                             "set_destination_point" : 4,
                             "get_surface_central_body" : 5,
                             "set_surface_central_body" : 6,
                             "get_differencing_time_step" : 7,
                             "set_differencing_time_step" : 8, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorDispSurface)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorDispSurface)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorDispSurface, None)
    
    _get_origin_point_metadata = { "name" : "origin_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_point(self) -> "IVectorGeometryToolPoint":
        """An origin point."""
        return self._intf.get_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._get_origin_point_metadata)

    _set_origin_point_metadata = { "name" : "origin_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @origin_point.setter
    def origin_point(self, originPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._set_origin_point_metadata, originPoint)

    _get_destination_point_metadata = { "name" : "destination_point",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def destination_point(self) -> "IVectorGeometryToolPoint":
        """Destination point."""
        return self._intf.get_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._get_destination_point_metadata)

    _set_destination_point_metadata = { "name" : "destination_point",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"),) }
    @destination_point.setter
    def destination_point(self, destinationPoint:"IVectorGeometryToolPoint") -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._set_destination_point_metadata, destinationPoint)

    _get_surface_central_body_metadata = { "name" : "surface_central_body",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def surface_central_body(self) -> str:
        """surface central body."""
        return self._intf.get_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._get_surface_central_body_metadata)

    _set_surface_central_body_metadata = { "name" : "surface_central_body",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @surface_central_body.setter
    def surface_central_body(self, surfaceCentralBody:str) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._set_surface_central_body_metadata, surfaceCentralBody)

    _get_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @property
    def differencing_time_step(self) -> float:
        """Time step used in displacement on surface vector. (derivatives using central differencing)."""
        return self._intf.get_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._get_differencing_time_step_metadata)

    _set_differencing_time_step_metadata = { "name" : "differencing_time_step",
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DOUBLE_arg,) }
    @differencing_time_step.setter
    def differencing_time_step(self, differencingTimeStep:float) -> None:
        return self._intf.set_property(IVectorGeometryToolVectorDispSurface._metadata, IVectorGeometryToolVectorDispSurface._set_differencing_time_step_metadata, differencingTimeStep)


agcls.AgClassCatalog.add_catalog_entry("{68f34fc6-fbe1-41e8-84d9-b1b0c8338f2b}", IVectorGeometryToolVectorDispSurface)
agcls.AgTypeNameMap["IVectorGeometryToolVectorDispSurface"] = IVectorGeometryToolVectorDispSurface

class IVectorGeometryToolVectorFactory(object):
    """A Factory object to create vectors."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{09F7F253-392A-44D9-9701-51CC0110C033}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2,
                             "create_displacement_vector" : 3,
                             "get_available_vector_plugin_display_names" : 4,
                             "create_vector_plugin_from_display_name" : 5,
                             "create_cross_product_vector" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, vectorName:str, description:str, vectorType:"VECTOR_GEOMETRY_TOOL_VECTOR_TYPE") -> "IVectorGeometryToolVector":
        """Create a VGT vector using specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._create_metadata, vectorName, description, vectorType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_VECTOR_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_VECTOR_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._is_type_supported_metadata, type, out_arg())

    _create_displacement_vector_metadata = { "name" : "create_displacement_vector",
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.AgInterface_in_arg("IVectorGeometryToolPoint"), agmarshall.AgInterface_out_arg,) }
    def create_displacement_vector(self, vectorName:str, originPoint:"IVectorGeometryToolPoint", destPoint:"IVectorGeometryToolPoint") -> "VectorGeometryToolVectorDisplacement":
        """Create a displacement vector."""
        return self._intf.invoke(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._create_displacement_vector_metadata, vectorName, originPoint, destPoint, out_arg())

    _get_available_vector_plugin_display_names_metadata = { "name" : "available_vector_plugin_display_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_vector_plugin_display_names(self) -> list:
        """An array of display names associated with available vector plugins. The elements of the array are strings. Display names are used to create VGT vectors based on COM plugins using CreateVectorPluginFromDisplayName method."""
        return self._intf.get_property(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._get_available_vector_plugin_display_names_metadata)

    _create_vector_plugin_from_display_name_metadata = { "name" : "create_vector_plugin_from_display_name",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_vector_plugin_from_display_name(self, vectorName:str, description:str, displayName:str) -> "IVectorGeometryToolVector":
        """Create a vector component based on a COM vector plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._create_vector_plugin_from_display_name_metadata, vectorName, description, displayName, out_arg())

    _create_cross_product_vector_metadata = { "name" : "create_cross_product_vector",
            "arg_types" : (agcom.BSTR, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"), agmarshall.AgInterface_in_arg("IVectorGeometryToolVector"), agmarshall.AgInterface_out_arg,) }
    def create_cross_product_vector(self, vectorName:str, vectorA:"IVectorGeometryToolVector", vectorB:"IVectorGeometryToolVector") -> "VectorGeometryToolVectorCross":
        """Create a cross product C = A x B."""
        return self._intf.invoke(IVectorGeometryToolVectorFactory._metadata, IVectorGeometryToolVectorFactory._create_cross_product_vector_metadata, vectorName, vectorA, vectorB, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{09F7F253-392A-44D9-9701-51CC0110C033}", IVectorGeometryToolVectorFactory)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFactory"] = IVectorGeometryToolVectorFactory

class IVectorGeometryToolAxesFactory(object):
    """A Factory object to create axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2,
                             "get_available_axes_plugin_display_names" : 3,
                             "create_axes_plugin_from_display_name" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_AXES_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, axesName:str, description:str, axesType:"VECTOR_GEOMETRY_TOOL_AXES_TYPE") -> "IVectorGeometryToolAxes":
        """Create a VGT axes using specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolAxesFactory._metadata, IVectorGeometryToolAxesFactory._create_metadata, axesName, description, axesType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_AXES_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_AXES_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(IVectorGeometryToolAxesFactory._metadata, IVectorGeometryToolAxesFactory._is_type_supported_metadata, type, out_arg())

    _get_available_axes_plugin_display_names_metadata = { "name" : "available_axes_plugin_display_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_axes_plugin_display_names(self) -> list:
        """An array of display names associated with available axes plugins. The elements of the array are strings. Display names are used to create VGT axes based on COM plugins using CreateAxesPluginFromDisplayName method."""
        return self._intf.get_property(IVectorGeometryToolAxesFactory._metadata, IVectorGeometryToolAxesFactory._get_available_axes_plugin_display_names_metadata)

    _create_axes_plugin_from_display_name_metadata = { "name" : "create_axes_plugin_from_display_name",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_axes_plugin_from_display_name(self, axesName:str, description:str, displayName:str) -> "IVectorGeometryToolAxes":
        """Create an axes component based on a COM axes plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(IVectorGeometryToolAxesFactory._metadata, IVectorGeometryToolAxesFactory._create_axes_plugin_from_display_name_metadata, axesName, description, displayName, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{BDE82D7E-6D8B-4BD7-ADC7-441525EA888B}", IVectorGeometryToolAxesFactory)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFactory"] = IVectorGeometryToolAxesFactory

class IVectorGeometryToolSystemFactory(object):
    """A Factory interface to create VGT systems."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(CRDN_SYSTEM_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, systemName:str, description:str, systemType:"CRDN_SYSTEM_TYPE") -> "IVectorGeometryToolSystem":
        """Create a VGT system using the specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolSystemFactory._metadata, IVectorGeometryToolSystemFactory._create_metadata, systemName, description, systemType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_SYSTEM_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"CRDN_SYSTEM_TYPE") -> bool:
        """Return true if the specified system type is supported."""
        return self._intf.invoke(IVectorGeometryToolSystemFactory._metadata, IVectorGeometryToolSystemFactory._is_type_supported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{C4D5ACA9-9F29-4AFF-A7BA-3CBA24BBC059}", IVectorGeometryToolSystemFactory)
agcls.AgTypeNameMap["IVectorGeometryToolSystemFactory"] = IVectorGeometryToolSystemFactory

class IVectorGeometryToolPointFactory(object):
    """A Factory object to create points."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{18FA11DA-BC93-4467-B53F-4D894739C3A3}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2,
                             "get_available_point_plugin_display_names" : 3,
                             "create_point_plugin_from_display_name" : 4,
                             "create_point_fixed_on_central_body" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_POINT_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, pointName:str, description:str, pointType:"VECTOR_GEOMETRY_TOOL_POINT_TYPE") -> "IVectorGeometryToolPoint":
        """Create a VGT point using the specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolPointFactory._metadata, IVectorGeometryToolPointFactory._create_metadata, pointName, description, pointType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_POINT_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_POINT_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(IVectorGeometryToolPointFactory._metadata, IVectorGeometryToolPointFactory._is_type_supported_metadata, type, out_arg())

    _get_available_point_plugin_display_names_metadata = { "name" : "available_point_plugin_display_names",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def available_point_plugin_display_names(self) -> list:
        """An array of display names associated with available point plugins. The elements of the array are strings. Display names are used to create VGT points based on COM plugins using CreatePointPluginFromDisplayName method."""
        return self._intf.get_property(IVectorGeometryToolPointFactory._metadata, IVectorGeometryToolPointFactory._get_available_point_plugin_display_names_metadata)

    _create_point_plugin_from_display_name_metadata = { "name" : "create_point_plugin_from_display_name",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def create_point_plugin_from_display_name(self, pointName:str, description:str, displayName:str) -> "IVectorGeometryToolPoint":
        """Create a point component based on a COM point plugin. For information how to implement and register VGT plugins, see."""
        return self._intf.invoke(IVectorGeometryToolPointFactory._metadata, IVectorGeometryToolPointFactory._create_point_plugin_from_display_name_metadata, pointName, description, displayName, out_arg())

    _create_point_fixed_on_central_body_metadata = { "name" : "create_point_fixed_on_central_body",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.VARIANT_arg, agmarshall.VARIANT_arg, agmarshall.DOUBLE_arg, agmarshall.AgEnum_arg(CRDN_REFERENCE_SHAPE_TYPE), agmarshall.AgInterface_out_arg,) }
    def create_point_fixed_on_central_body(self, pointName:str, description:str, longitude:typing.Any, latitude:typing.Any, altitude:float, referenceShape:"CRDN_REFERENCE_SHAPE_TYPE") -> "IVectorGeometryToolPoint":
        """Create a point fixed on a central body."""
        return self._intf.invoke(IVectorGeometryToolPointFactory._metadata, IVectorGeometryToolPointFactory._create_point_fixed_on_central_body_metadata, pointName, description, longitude, latitude, altitude, referenceShape, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{18FA11DA-BC93-4467-B53F-4D894739C3A3}", IVectorGeometryToolPointFactory)
agcls.AgTypeNameMap["IVectorGeometryToolPointFactory"] = IVectorGeometryToolPointFactory

class IVectorGeometryToolPlaneFactory(object):
    """A Factory object to create VGT planes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, planeName:str, description:str, planeType:"VECTOR_GEOMETRY_TOOL_PLANE_TYPE") -> "IVectorGeometryToolPlane":
        """Create a VGT plane using the specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolPlaneFactory._metadata, IVectorGeometryToolPlaneFactory._create_metadata, planeName, description, planeType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_PLANE_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_PLANE_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(IVectorGeometryToolPlaneFactory._metadata, IVectorGeometryToolPlaneFactory._is_type_supported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{CFA2BE32-47F7-4C7D-87AA-44E95B0191EB}", IVectorGeometryToolPlaneFactory)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFactory"] = IVectorGeometryToolPlaneFactory

class IVectorGeometryToolAngleFactory(object):
    """A Factory object to create angles."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{703883F3-9716-4D37-8930-184BECDE1461}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "create" : 1,
                             "is_type_supported" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFactory)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFactory)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFactory, None)
    
    _create_metadata = { "name" : "create",
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.BSTR_arg, agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE), agmarshall.AgInterface_out_arg,) }
    def create(self, angleName:str, description:str, angleType:"VECTOR_GEOMETRY_TOOL_ANGLE_TYPE") -> "IVectorGeometryToolAngle":
        """Create a VGT angle using specified name, description and type."""
        return self._intf.invoke(IVectorGeometryToolAngleFactory._metadata, IVectorGeometryToolAngleFactory._create_metadata, angleName, description, angleType, out_arg())

    _is_type_supported_metadata = { "name" : "is_type_supported",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(VECTOR_GEOMETRY_TOOL_ANGLE_TYPE), agmarshall.VARIANT_BOOL_arg,) }
    def is_type_supported(self, type:"VECTOR_GEOMETRY_TOOL_ANGLE_TYPE") -> bool:
        """Return true if the type is supported."""
        return self._intf.invoke(IVectorGeometryToolAngleFactory._metadata, IVectorGeometryToolAngleFactory._is_type_supported_metadata, type, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{703883F3-9716-4D37-8930-184BECDE1461}", IVectorGeometryToolAngleFactory)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFactory"] = IVectorGeometryToolAngleFactory

class IVectorGeometryToolVectorGroup(object):
    """Access or create VGT vectors associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{4412F0DD-2138-4653-8D20-9B4A0CA450D4}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolVector":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, vectorName:str) -> None:
        """Remove a specified vector."""
        return self._intf.invoke(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._remove_metadata, vectorName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolVectorFactory":
        """Return a Factory object used to create custom vectors."""
        return self._intf.get_property(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolVector":
        """Return a vector by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolVector":
        """Retrieve a vector from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolVector":
        """Retrieve a vector from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolVectorGroup._metadata, IVectorGeometryToolVectorGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{4412F0DD-2138-4653-8D20-9B4A0CA450D4}", IVectorGeometryToolVectorGroup)
agcls.AgTypeNameMap["IVectorGeometryToolVectorGroup"] = IVectorGeometryToolVectorGroup

class IVectorGeometryToolPointGroup(object):
    """Access or create VGT points associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{6FB1415A-EC77-476F-B650-CC6813BE740C}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_common_tasks" : 8,
                             "get_item_by_index" : 9,
                             "get_item_by_name" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPoint":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, pointName:str) -> None:
        """Remove a specified point by name."""
        return self._intf.invoke(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._remove_metadata, pointName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolPointFactory":
        """Return a Factory object used to create custom points."""
        return self._intf.get_property(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPoint":
        """Return a point by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "name" : "common_tasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolPointCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known point types, etc."""
        return self._intf.get_property(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolPoint":
        """Retrieve a point from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolPoint":
        """Retrieve a point from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolPointGroup._metadata, IVectorGeometryToolPointGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6FB1415A-EC77-476F-B650-CC6813BE740C}", IVectorGeometryToolPointGroup)
agcls.AgTypeNameMap["IVectorGeometryToolPointGroup"] = IVectorGeometryToolPointGroup

class IVectorGeometryToolAngleGroup(object):
    """Access or create VGT angles associated with an object or a central body."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{C025A1BA-F856-4B26-9134-BBCC785B6C45}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAngle":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, angleName:str) -> None:
        """Remove a specified Angle."""
        return self._intf.invoke(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._remove_metadata, angleName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolAngleFactory":
        """Return a Factory object used to create custom angles."""
        return self._intf.get_property(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAngle":
        """Return an angle by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolAngle":
        """Retrieve an angle from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolAngle":
        """Retrieve an angle from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolAngleGroup._metadata, IVectorGeometryToolAngleGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{C025A1BA-F856-4B26-9134-BBCC785B6C45}", IVectorGeometryToolAngleGroup)
agcls.AgTypeNameMap["IVectorGeometryToolAngleGroup"] = IVectorGeometryToolAngleGroup

class IVectorGeometryToolAxesGroup(object):
    """Access or create VGT axes associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{21C67E72-992F-481F-B77F-1DFC43B4B705}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_common_tasks" : 8,
                             "get_item_by_index" : 9,
                             "get_item_by_name" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolAxes":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, axesName:str) -> None:
        """Remove a specified Axes."""
        return self._intf.invoke(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._remove_metadata, axesName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolAxesFactory":
        """Return a Factory object used to create custom axes."""
        return self._intf.get_property(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolAxes":
        """Return an axes by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "name" : "common_tasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolAxesCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known axes, etc."""
        return self._intf.get_property(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolAxes":
        """Retrieve an axes from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolAxes":
        """Retrieve an axes from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolAxesGroup._metadata, IVectorGeometryToolAxesGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{21C67E72-992F-481F-B77F-1DFC43B4B705}", IVectorGeometryToolAxesGroup)
agcls.AgTypeNameMap["IVectorGeometryToolAxesGroup"] = IVectorGeometryToolAxesGroup

class IVectorGeometryToolPlaneGroup(object):
    """Represents a single entry point to manipulate VGT Planes associated with an object."""

    _num_methods = 9
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_item_by_index" : 8,
                             "get_item_by_name" : 9, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolPlane":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, planeName:str) -> None:
        """Remove a specified Plane."""
        return self._intf.invoke(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._remove_metadata, planeName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the group."""
        return self._intf.get_property(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolPlaneFactory":
        """Return a Factory object used to create custom planes."""
        return self._intf.get_property(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolPlane":
        """Return an Plane by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolPlane":
        """Retrieve a plane from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolPlane":
        """Retrieve a plane from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolPlaneGroup._metadata, IVectorGeometryToolPlaneGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{1F297A6D-4368-4650-9DA8-CDFD1438C6E2}", IVectorGeometryToolPlaneGroup)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneGroup"] = IVectorGeometryToolPlaneGroup

class IVectorGeometryToolSystemGroup(object):
    """Access or create VGT systems associated with an object or a central body."""

    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{05FF6322-1363-4B66-933E-03EA158B7523}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "remove" : 1,
                             "get_context" : 2,
                             "contains" : 3,
                             "get_count" : 4,
                             "get_factory" : 5,
                             "item" : 6,
                             "get__NewEnum" : 7,
                             "get_common_tasks" : 8,
                             "get_item_by_index" : 9,
                             "get_item_by_name" : 10, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemGroup)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemGroup)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemGroup, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IVectorGeometryToolSystem":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, systemName:str) -> None:
        """Remove a specified System."""
        return self._intf.invoke(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._remove_metadata, systemName)

    _get_context_metadata = { "name" : "context",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def context(self) -> "IAnalysisWorkbenchContext":
        """Return a context object. The context can be used to find out which central body or STK object this instance is associated with."""
        return self._intf.get_property(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_context_metadata)

    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_count_metadata)

    _get_factory_metadata = { "name" : "factory",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def factory(self) -> "VectorGeometryToolSystemFactory":
        """Return a Factory object used to create custom VGT systems."""
        return self._intf.get_property(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_factory_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IVectorGeometryToolSystem":
        """Return a System by name or at a specified position."""
        return self._intf.invoke(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get__NewEnum_metadata)

    _get_common_tasks_metadata = { "name" : "common_tasks",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def common_tasks(self) -> "VectorGeometryToolSystemCommonTasks":
        """Provide access to common tasks that allow users quickly carry out tasks such as creating known systems, etc."""
        return self._intf.get_property(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_common_tasks_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IVectorGeometryToolSystem":
        """Retrieve a system from the collection by index."""
        return self._intf.invoke(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IVectorGeometryToolSystem":
        """Retrieve a system from the collection by name."""
        return self._intf.invoke(IVectorGeometryToolSystemGroup._metadata, IVectorGeometryToolSystemGroup._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{05FF6322-1363-4B66-933E-03EA158B7523}", IVectorGeometryToolSystemGroup)
agcls.AgTypeNameMap["IVectorGeometryToolSystemGroup"] = IVectorGeometryToolSystemGroup

class IAnalysisWorkbenchProvider(object):
    """Allow accessing existing Vector Geometry Tool components."""

    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_vectors" : 1,
                             "get_points" : 2,
                             "get_angles" : 3,
                             "get_axes" : 4,
                             "get_planes" : 5,
                             "get_systems" : 6,
                             "get_well_known_systems" : 7,
                             "get_well_known_axes" : 8,
                             "get_events" : 9,
                             "get_event_intervals" : 10,
                             "get_calc_scalars" : 11,
                             "get_event_arrays" : 12,
                             "get_event_interval_lists" : 13,
                             "get_event_interval_collections" : 14,
                             "get_parameter_sets" : 15,
                             "get_conditions" : 16,
                             "supports" : 17,
                             "get_condition_sets" : 18,
                             "import_method" : 19,
                             "get_volume_grids" : 20,
                             "get_volumes" : 21,
                             "get_volume_calcs" : 22, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchProvider)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchProvider)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchProvider, None)
    
    _get_vectors_metadata = { "name" : "vectors",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vectors(self) -> "VectorGeometryToolVectorGroup":
        """Return a group of vectors."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_vectors_metadata)

    _get_points_metadata = { "name" : "points",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def points(self) -> "VectorGeometryToolPointGroup":
        """Return a group of points."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_points_metadata)

    _get_angles_metadata = { "name" : "angles",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def angles(self) -> "VectorGeometryToolAngleGroup":
        """Return a group of angles."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_angles_metadata)

    _get_axes_metadata = { "name" : "axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def axes(self) -> "VectorGeometryToolAxesGroup":
        """Return a group of axes."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_axes_metadata)

    _get_planes_metadata = { "name" : "planes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def planes(self) -> "VectorGeometryToolPlaneGroup":
        """Return a group of planes."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_planes_metadata)

    _get_systems_metadata = { "name" : "systems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def systems(self) -> "VectorGeometryToolSystemGroup":
        """Return a group of systems."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_systems_metadata)

    _get_well_known_systems_metadata = { "name" : "well_known_systems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def well_known_systems(self) -> "VectorGeometryToolWellKnownSystems":
        """Return well-known systems."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_well_known_systems_metadata)

    _get_well_known_axes_metadata = { "name" : "well_known_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def well_known_axes(self) -> "VectorGeometryToolWellKnownAxes":
        """Return well-known axes."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_well_known_axes_metadata)

    _get_events_metadata = { "name" : "events",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def events(self) -> "TimeToolEventGroup":
        """Return a group of events."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_events_metadata)

    _get_event_intervals_metadata = { "name" : "event_intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def event_intervals(self) -> "TimeToolEventIntervalGroup":
        """Return a group of event intervals."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_event_intervals_metadata)

    _get_calc_scalars_metadata = { "name" : "calc_scalars",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def calc_scalars(self) -> "CalculationToolScalarGroup":
        """Return a group of calc scalars."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_calc_scalars_metadata)

    _get_event_arrays_metadata = { "name" : "event_arrays",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def event_arrays(self) -> "TimeToolEventArrayGroup":
        """Return a group of event arrays."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_event_arrays_metadata)

    _get_event_interval_lists_metadata = { "name" : "event_interval_lists",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def event_interval_lists(self) -> "TimeToolEventIntervalListGroup":
        """Return a group of event interval lists."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_event_interval_lists_metadata)

    _get_event_interval_collections_metadata = { "name" : "event_interval_collections",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def event_interval_collections(self) -> "TimeToolEventIntervalCollectionGroup":
        """Return a group of event interval collections."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_event_interval_collections_metadata)

    _get_parameter_sets_metadata = { "name" : "parameter_sets",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def parameter_sets(self) -> "CalculationToolParameterSetGroup":
        """Access, add new or remove existing parameter set components."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_parameter_sets_metadata)

    _get_conditions_metadata = { "name" : "conditions",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def conditions(self) -> "CalculationToolConditionGroup":
        """Return a group of condition objects."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_conditions_metadata)

    _supports_metadata = { "name" : "supports",
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.AgEnum_arg(CRDN_KIND), agmarshall.VARIANT_BOOL_arg,) }
    def supports(self, feature:"CRDN_KIND") -> bool:
        """Test whether the specified VGT feature is supported."""
        return self._intf.invoke(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._supports_metadata, feature, out_arg())

    _get_condition_sets_metadata = { "name" : "condition_sets",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def condition_sets(self) -> "CalculationToolConditionSetGroup":
        """Return a group of condition set objects."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_condition_sets_metadata)

    _import_method_metadata = { "name" : "import_method",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def import_method(self, filename:str) -> "AnalysisWorkbenchCollection":
        """Import Analysis Workbench components from a file."""
        return self._intf.invoke(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._import_method_metadata, filename, out_arg())

    _get_volume_grids_metadata = { "name" : "volume_grids",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def volume_grids(self) -> "SpatialAnalysisToolVolumeGridGroup":
        """Return a group of volume grid objects."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_volume_grids_metadata)

    _get_volumes_metadata = { "name" : "volumes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def volumes(self) -> "SpatialAnalysisToolVolumeGroup":
        """Return a group of volume objects."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_volumes_metadata)

    _get_volume_calcs_metadata = { "name" : "volume_calcs",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def volume_calcs(self) -> "SpatialAnalysisToolVolumeCalcGroup":
        """Return a group of volume calc objects."""
        return self._intf.get_property(IAnalysisWorkbenchProvider._metadata, IAnalysisWorkbenchProvider._get_volume_calcs_metadata)


agcls.AgClassCatalog.add_catalog_entry("{48B9F0CD-DFBA-4A82-BB30-E9932E1E7266}", IAnalysisWorkbenchProvider)
agcls.AgTypeNameMap["IAnalysisWorkbenchProvider"] = IAnalysisWorkbenchProvider

class IAnalysisWorkbenchRoot(object):
    """Represents a VGT root object."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FEF8B20D-5EEB-4299-8775-038EE30AA30B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_template_provider" : 1,
                             "get_provider" : 2,
                             "get_well_known_systems" : 3,
                             "get_well_known_axes" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchRoot)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchRoot)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchRoot, None)
    
    _get_template_provider_metadata = { "name" : "get_template_provider",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_template_provider(self, className:str) -> "AnalysisWorkbenchProvider":
        """Return a template provider. The method takes a class name (i.e. ``Satellite``, ``Facility``, etc.)."""
        return self._intf.invoke(IAnalysisWorkbenchRoot._metadata, IAnalysisWorkbenchRoot._get_template_provider_metadata, className, out_arg())

    _get_provider_metadata = { "name" : "get_provider",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_provider(self, instPath:str) -> "AnalysisWorkbenchProvider":
        """Return an instance provider. The method takes a short instance path to an STK object or a central body.(i.e. ``Satellite/Satellite1``, ``CentralBody/Earth``, etc.)."""
        return self._intf.invoke(IAnalysisWorkbenchRoot._metadata, IAnalysisWorkbenchRoot._get_provider_metadata, instPath, out_arg())

    _get_well_known_systems_metadata = { "name" : "well_known_systems",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def well_known_systems(self) -> "VectorGeometryToolWellKnownSystems":
        """Return the most commonly used systems (e.g. Sun Fixed, Earth Fixed, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchRoot._metadata, IAnalysisWorkbenchRoot._get_well_known_systems_metadata)

    _get_well_known_axes_metadata = { "name" : "well_known_axes",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def well_known_axes(self) -> "VectorGeometryToolWellKnownAxes":
        """Return the most commonly used axes (e.g. Sun ICRF, Earth Inertial, etc.)."""
        return self._intf.get_property(IAnalysisWorkbenchRoot._metadata, IAnalysisWorkbenchRoot._get_well_known_axes_metadata)


agcls.AgClassCatalog.add_catalog_entry("{FEF8B20D-5EEB-4299-8775-038EE30AA30B}", IAnalysisWorkbenchRoot)
agcls.AgTypeNameMap["IAnalysisWorkbenchRoot"] = IAnalysisWorkbenchRoot

class IVectorGeometryToolWellKnownEarthSystems(object):
    """Well-known Earth's coordinate systems."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{230A8949-FB8F-415E-A786-5EED50AEB11B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fixed" : 1,
                             "get_icrf" : 2,
                             "get_inertial" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownEarthSystems)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownEarthSystems)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownEarthSystems, None)
    
    _get_fixed_metadata = { "name" : "fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolSystem":
        """Earth's Fixed coordinate system."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthSystems._metadata, IVectorGeometryToolWellKnownEarthSystems._get_fixed_metadata)

    _get_icrf_metadata = { "name" : "icrf",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolSystem":
        """Earth's ICRF."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthSystems._metadata, IVectorGeometryToolWellKnownEarthSystems._get_icrf_metadata)

    _get_inertial_metadata = { "name" : "inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolSystem":
        """Earth's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthSystems._metadata, IVectorGeometryToolWellKnownEarthSystems._get_inertial_metadata)


agcls.AgClassCatalog.add_catalog_entry("{230A8949-FB8F-415E-A786-5EED50AEB11B}", IVectorGeometryToolWellKnownEarthSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownEarthSystems"] = IVectorGeometryToolWellKnownEarthSystems

class IVectorGeometryToolWellKnownEarthAxes(object):
    """Well-known Earth's axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fixed" : 1,
                             "get_icrf" : 2,
                             "get_inertial" : 3,
                             "get_j2000" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownEarthAxes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownEarthAxes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownEarthAxes, None)
    
    _get_fixed_metadata = { "name" : "fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolAxes":
        """Earth's Fixed axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthAxes._metadata, IVectorGeometryToolWellKnownEarthAxes._get_fixed_metadata)

    _get_icrf_metadata = { "name" : "icrf",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolAxes":
        """Earth's ICRF axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthAxes._metadata, IVectorGeometryToolWellKnownEarthAxes._get_icrf_metadata)

    _get_inertial_metadata = { "name" : "inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolAxes":
        """Earth's Inertial axes (as defined in STK)."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthAxes._metadata, IVectorGeometryToolWellKnownEarthAxes._get_inertial_metadata)

    _get_j2000_metadata = { "name" : "j2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolAxes":
        """The Earth's J2000 axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownEarthAxes._metadata, IVectorGeometryToolWellKnownEarthAxes._get_j2000_metadata)


agcls.AgClassCatalog.add_catalog_entry("{BD3F561B-9118-4C17-A5A8-95DAD82CA2F0}", IVectorGeometryToolWellKnownEarthAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownEarthAxes"] = IVectorGeometryToolWellKnownEarthAxes

class IVectorGeometryToolWellKnownSunSystems(object):
    """The Sun's well-known coordinate reference systems."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fixed" : 1,
                             "get_icrf" : 2,
                             "get_inertial" : 3,
                             "get_j2000" : 4,
                             "get_barycenter" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownSunSystems)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownSunSystems)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownSunSystems, None)
    
    _get_fixed_metadata = { "name" : "fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolSystem":
        """The Sun's Fixed coordinate system."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunSystems._metadata, IVectorGeometryToolWellKnownSunSystems._get_fixed_metadata)

    _get_icrf_metadata = { "name" : "icrf",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolSystem":
        """The Sun's International Celestial Reference Frame (ICRF)."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunSystems._metadata, IVectorGeometryToolWellKnownSunSystems._get_icrf_metadata)

    _get_inertial_metadata = { "name" : "inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolSystem":
        """The Sun's Inertial coordinate system (as defined in STK)."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunSystems._metadata, IVectorGeometryToolWellKnownSunSystems._get_inertial_metadata)

    _get_j2000_metadata = { "name" : "j2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolSystem":
        """The Sun's J2000 coordinate system."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunSystems._metadata, IVectorGeometryToolWellKnownSunSystems._get_j2000_metadata)

    _get_barycenter_metadata = { "name" : "barycenter",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def barycenter(self) -> "IVectorGeometryToolSystem":
        """The Inertial system at the Sun's barycenter."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunSystems._metadata, IVectorGeometryToolWellKnownSunSystems._get_barycenter_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B3EE0E1F-5BB3-4387-962B-91C84C5C25B7}", IVectorGeometryToolWellKnownSunSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSunSystems"] = IVectorGeometryToolWellKnownSunSystems

class IVectorGeometryToolWellKnownSunAxes(object):
    """Well-known Sun's axes."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_fixed" : 1,
                             "get_icrf" : 2,
                             "get_inertial" : 3,
                             "get_j2000" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownSunAxes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownSunAxes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownSunAxes, None)
    
    _get_fixed_metadata = { "name" : "fixed",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def fixed(self) -> "IVectorGeometryToolAxes":
        """Sun's Fixed axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunAxes._metadata, IVectorGeometryToolWellKnownSunAxes._get_fixed_metadata)

    _get_icrf_metadata = { "name" : "icrf",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def icrf(self) -> "IVectorGeometryToolAxes":
        """Sun's ICRF."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunAxes._metadata, IVectorGeometryToolWellKnownSunAxes._get_icrf_metadata)

    _get_inertial_metadata = { "name" : "inertial",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def inertial(self) -> "IVectorGeometryToolAxes":
        """Sun's Inertial axes (as defined in STK)."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunAxes._metadata, IVectorGeometryToolWellKnownSunAxes._get_inertial_metadata)

    _get_j2000_metadata = { "name" : "j2000",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def j2000(self) -> "IVectorGeometryToolAxes":
        """The Sun's J2000 axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSunAxes._metadata, IVectorGeometryToolWellKnownSunAxes._get_j2000_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5ADEDD34-CCAA-40B8-87F2-DA20497670BA}", IVectorGeometryToolWellKnownSunAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSunAxes"] = IVectorGeometryToolWellKnownSunAxes

class IVectorGeometryToolWellKnownSystems(object):
    """Well-known coordinate reference systems."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D93C6B6F-D457-4D20-BA7B-960773E3652B}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_earth" : 1,
                             "get_sun" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownSystems)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownSystems)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownSystems, None)
    
    _get_earth_metadata = { "name" : "earth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def earth(self) -> "VectorGeometryToolWellKnownEarthSystems":
        """Earth's coordinate reference systems."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSystems._metadata, IVectorGeometryToolWellKnownSystems._get_earth_metadata)

    _get_sun_metadata = { "name" : "sun",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sun(self) -> "VectorGeometryToolWellKnownSunSystems":
        """The Sun's coordinate reference systems."""
        return self._intf.get_property(IVectorGeometryToolWellKnownSystems._metadata, IVectorGeometryToolWellKnownSystems._get_sun_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D93C6B6F-D457-4D20-BA7B-960773E3652B}", IVectorGeometryToolWellKnownSystems)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownSystems"] = IVectorGeometryToolWellKnownSystems

class IVectorGeometryToolWellKnownAxes(object):
    """Well-known Axes."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B2546963-CC14-4F18-91DE-7091EBEA34C5}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_earth" : 1,
                             "get_sun" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolWellKnownAxes)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolWellKnownAxes)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolWellKnownAxes, None)
    
    _get_earth_metadata = { "name" : "earth",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def earth(self) -> "VectorGeometryToolWellKnownEarthAxes":
        """Earth's well-known axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownAxes._metadata, IVectorGeometryToolWellKnownAxes._get_earth_metadata)

    _get_sun_metadata = { "name" : "sun",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def sun(self) -> "VectorGeometryToolWellKnownSunAxes":
        """The Sun's well-known axes."""
        return self._intf.get_property(IVectorGeometryToolWellKnownAxes._metadata, IVectorGeometryToolWellKnownAxes._get_sun_metadata)


agcls.AgClassCatalog.add_catalog_entry("{B2546963-CC14-4F18-91DE-7091EBEA34C5}", IVectorGeometryToolWellKnownAxes)
agcls.AgTypeNameMap["IVectorGeometryToolWellKnownAxes"] = IVectorGeometryToolWellKnownAxes

class IVectorGeometryToolAngleFindAngleResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngle method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_angle" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindAngleResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindAngleResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindAngleResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleResult._metadata, IVectorGeometryToolAngleFindAngleResult._get_is_valid_metadata)

    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleResult._metadata, IVectorGeometryToolAngleFindAngleResult._get_angle_metadata)


agcls.AgClassCatalog.add_catalog_entry("{0D2774CC-8D38-4C1D-9BE4-A87BE67B58B4}", IVectorGeometryToolAngleFindAngleResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleResult"] = IVectorGeometryToolAngleFindAngleResult

class IVectorGeometryToolAngleFindAngleWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngleWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{E46570BA-661C-4974-A780-32DFEAFB9630}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_angle" : 2,
                             "get_angle_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindAngleWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindAngleWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindAngleWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_is_valid_metadata)

    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_angle_metadata)

    _get_angle_rate_metadata = { "name" : "angle_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle_rate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindAngleWithRateResult._metadata, IVectorGeometryToolAngleFindAngleWithRateResult._get_angle_rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{E46570BA-661C-4974-A780-32DFEAFB9630}", IVectorGeometryToolAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindAngleWithRateResult"] = IVectorGeometryToolAngleFindAngleWithRateResult

class IVectorGeometryToolAngleFindWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinatesWithRate method."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{C4E80CE7-2E38-4364-96D5-004EE425471D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_angle" : 2,
                             "get_angle_rate" : 3,
                             "get_vector_from" : 4,
                             "get_vector_to" : 5,
                             "get_vector_about" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_is_valid_metadata)

    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_angle_metadata)

    _get_angle_rate_metadata = { "name" : "angle_rate",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle_rate(self) -> typing.Any:
        """The computed angle rate. The value of the angle rate is in ``AngleRateUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_angle_rate_metadata)

    _get_vector_from_metadata = { "name" : "vector_from",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_from(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_from_metadata)

    _get_vector_to_metadata = { "name" : "vector_to",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_to(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_to_metadata)

    _get_vector_about_metadata = { "name" : "vector_about",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_about(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IVectorGeometryToolAngleFindWithRateResult._metadata, IVectorGeometryToolAngleFindWithRateResult._get_vector_about_metadata)


agcls.AgClassCatalog.add_catalog_entry("{C4E80CE7-2E38-4364-96D5-004EE425471D}", IVectorGeometryToolAngleFindWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindWithRateResult"] = IVectorGeometryToolAngleFindWithRateResult

class IVectorGeometryToolAngleFindResult(object):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinates method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{36DD880D-214E-4987-A70A-EA31E7E26B84}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_angle" : 2,
                             "get_vector_from" : 3,
                             "get_vector_to" : 4,
                             "get_vector_about" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAngleFindResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAngleFindResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAngleFindResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_is_valid_metadata)

    _get_angle_metadata = { "name" : "angle",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def angle(self) -> typing.Any:
        """The computed angle. The value of the angle is in ``AngleUnit`` dimension."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_angle_metadata)

    _get_vector_from_metadata = { "name" : "vector_from",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_from(self) -> "ICartesian3Vector":
        """The first of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_from_metadata)

    _get_vector_to_metadata = { "name" : "vector_to",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_to(self) -> "ICartesian3Vector":
        """The second of the two vectors the angle is measured."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_to_metadata)

    _get_vector_about_metadata = { "name" : "vector_about",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector_about(self) -> "ICartesian3Vector":
        """The vector the angle is rotated about."""
        return self._intf.get_property(IVectorGeometryToolAngleFindResult._metadata, IVectorGeometryToolAngleFindResult._get_vector_about_metadata)


agcls.AgClassCatalog.add_catalog_entry("{36DD880D-214E-4987-A70A-EA31E7E26B84}", IVectorGeometryToolAngleFindResult)
agcls.AgTypeNameMap["IVectorGeometryToolAngleFindResult"] = IVectorGeometryToolAngleFindResult

class IVectorGeometryToolAxesTransformResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFrom method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{D4EC98BE-0D20-4284-96D0-3C40A3100A06}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesTransformResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesTransformResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesTransformResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformResult._metadata, IVectorGeometryToolAxesTransformResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformResult._metadata, IVectorGeometryToolAxesTransformResult._get_vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{D4EC98BE-0D20-4284-96D0-3C40A3100A06}", IVectorGeometryToolAxesTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformResult"] = IVectorGeometryToolAxesTransformResult

class IVectorGeometryToolAxesTransformWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFromWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6434061B-3584-49FF-99C5-2C2D6B385CF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2,
                             "get_velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesTransformWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesTransformWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesTransformWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The output vector in the current axes."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_vector_metadata)

    _get_velocity_metadata = { "name" : "velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The vector velocity."""
        return self._intf.get_property(IVectorGeometryToolAxesTransformWithRateResult._metadata, IVectorGeometryToolAxesTransformWithRateResult._get_velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6434061B-3584-49FF-99C5-2C2D6B385CF1}", IVectorGeometryToolAxesTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesTransformWithRateResult"] = IVectorGeometryToolAxesTransformWithRateResult

class IVectorGeometryToolPlaneFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxes method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_x_axis" : 2,
                             "get_y_axis" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInAxesResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInAxesResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInAxesResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_is_valid_metadata)

    _get_x_axis_metadata = { "name" : "x_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_x_axis_metadata)

    _get_y_axis_metadata = { "name" : "y_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesResult._metadata, IVectorGeometryToolPlaneFindInAxesResult._get_y_axis_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A5CD1D7F-224B-4B19-A149-DAFDA3FF1550}", IVectorGeometryToolPlaneFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesResult"] = IVectorGeometryToolPlaneFindInAxesResult

class IVectorGeometryToolPlaneFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxesWithRate method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{CD4424A8-28CF-4AE5-8242-480B6625F0EB}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_x_axis" : 2,
                             "get_x_axis_rate" : 3,
                             "get_y_axis" : 4,
                             "get_y_axis_rate" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInAxesWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_is_valid_metadata)

    _get_x_axis_metadata = { "name" : "x_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_x_axis_metadata)

    _get_x_axis_rate_metadata = { "name" : "x_axis_rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis_rate(self) -> "ICartesian3Vector":
        """The rate of change of X-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_x_axis_rate_metadata)

    _get_y_axis_metadata = { "name" : "y_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_y_axis_metadata)

    _get_y_axis_rate_metadata = { "name" : "y_axis_rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis_rate(self) -> "ICartesian3Vector":
        """The rate of change of Y-axis vector in the specified reference axes."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInAxesWithRateResult._metadata, IVectorGeometryToolPlaneFindInAxesWithRateResult._get_y_axis_rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{CD4424A8-28CF-4AE5-8242-480B6625F0EB}", IVectorGeometryToolPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInAxesWithRateResult"] = IVectorGeometryToolPlaneFindInAxesWithRateResult

class IVectorGeometryToolPlaneFindInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystem method."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{85D16885-3BEB-4590-963B-F1CC8D016097}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_origin_position" : 2,
                             "get_x_axis" : 3,
                             "get_y_axis" : 4, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInSystemResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInSystemResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInSystemResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_is_valid_metadata)

    _get_origin_position_metadata = { "name" : "origin_position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_position(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_origin_position_metadata)

    _get_x_axis_metadata = { "name" : "x_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_x_axis_metadata)

    _get_y_axis_metadata = { "name" : "y_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemResult._metadata, IVectorGeometryToolPlaneFindInSystemResult._get_y_axis_metadata)


agcls.AgClassCatalog.add_catalog_entry("{85D16885-3BEB-4590-963B-F1CC8D016097}", IVectorGeometryToolPlaneFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemResult"] = IVectorGeometryToolPlaneFindInSystemResult

class IVectorGeometryToolPlaneFindInSystemWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{888499CB-4BF7-46A6-A11B-3FFC05EA6804}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_origin_position" : 2,
                             "get_origin_velocity" : 3,
                             "get_x_axis" : 4,
                             "get_x_axis_rate" : 5,
                             "get_y_axis" : 6,
                             "get_y_axis_rate" : 7, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPlaneFindInSystemWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPlaneFindInSystemWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPlaneFindInSystemWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_is_valid_metadata)

    _get_origin_position_metadata = { "name" : "origin_position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_position(self) -> "ICartesian3Vector":
        """The position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_origin_position_metadata)

    _get_origin_velocity_metadata = { "name" : "origin_velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def origin_velocity(self) -> "ICartesian3Vector":
        """The rate of change of the position of the plane's center point in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_origin_velocity_metadata)

    _get_x_axis_metadata = { "name" : "x_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis(self) -> "ICartesian3Vector":
        """X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_x_axis_metadata)

    _get_x_axis_rate_metadata = { "name" : "x_axis_rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def x_axis_rate(self) -> "ICartesian3Vector":
        """A rate of change of the X-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_x_axis_rate_metadata)

    _get_y_axis_metadata = { "name" : "y_axis",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis(self) -> "ICartesian3Vector":
        """Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_y_axis_metadata)

    _get_y_axis_rate_metadata = { "name" : "y_axis_rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def y_axis_rate(self) -> "ICartesian3Vector":
        """A rate of change of the Y-axis vector in the specified reference system."""
        return self._intf.get_property(IVectorGeometryToolPlaneFindInSystemWithRateResult._metadata, IVectorGeometryToolPlaneFindInSystemWithRateResult._get_y_axis_rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{888499CB-4BF7-46A6-A11B-3FFC05EA6804}", IVectorGeometryToolPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPlaneFindInSystemWithRateResult"] = IVectorGeometryToolPlaneFindInSystemWithRateResult

class IVectorGeometryToolAxesFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxes method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_orientation" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFindInAxesResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFindInAxesResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFindInAxesResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesResult._metadata, IVectorGeometryToolAxesFindInAxesResult._get_is_valid_metadata)

    _get_orientation_metadata = { "name" : "orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def orientation(self) -> "IOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesResult._metadata, IVectorGeometryToolAxesFindInAxesResult._get_orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{654E97B2-DF6A-4CB1-8EFC-AE3E01F3005A}", IVectorGeometryToolAxesFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesResult"] = IVectorGeometryToolAxesFindInAxesResult

class IVectorGeometryToolAxesFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxesWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{72644DD0-D129-4D7A-8A81-586E86E639BD}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_angular_velocity" : 2,
                             "get_orientation" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolAxesFindInAxesWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolAxesFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolAxesFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_is_valid_metadata)

    _get_angular_velocity_metadata = { "name" : "angular_velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def angular_velocity(self) -> "ICartesian3Vector":
        """Axes' angular velocity."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_angular_velocity_metadata)

    _get_orientation_metadata = { "name" : "orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def orientation(self) -> "IOrientation":
        """The axes' orientation."""
        return self._intf.get_property(IVectorGeometryToolAxesFindInAxesWithRateResult._metadata, IVectorGeometryToolAxesFindInAxesWithRateResult._get_orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{72644DD0-D129-4D7A-8A81-586E86E639BD}", IVectorGeometryToolAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolAxesFindInAxesWithRateResult"] = IVectorGeometryToolAxesFindInAxesWithRateResult

class IVectorGeometryToolPointLocateInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystem method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{84453DEC-5D01-4D47-A177-F8A737F0496D}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_position" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointLocateInSystemResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointLocateInSystemResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointLocateInSystemResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemResult._metadata, IVectorGeometryToolPointLocateInSystemResult._get_is_valid_metadata)

    _get_position_metadata = { "name" : "position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemResult._metadata, IVectorGeometryToolPointLocateInSystemResult._get_position_metadata)


agcls.AgClassCatalog.add_catalog_entry("{84453DEC-5D01-4D47-A177-F8A737F0496D}", IVectorGeometryToolPointLocateInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemResult"] = IVectorGeometryToolPointLocateInSystemResult

class IVectorGeometryToolPointLocateInSystemWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystemWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_position" : 2,
                             "get_velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolPointLocateInSystemWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolPointLocateInSystemWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolPointLocateInSystemWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_is_valid_metadata)

    _get_position_metadata = { "name" : "position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """The point position in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_position_metadata)

    _get_velocity_metadata = { "name" : "velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The point velocity in the specified coordinate system."""
        return self._intf.get_property(IVectorGeometryToolPointLocateInSystemWithRateResult._metadata, IVectorGeometryToolPointLocateInSystemWithRateResult._get_velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{6CB1D8DC-42CB-417B-9B80-B7320EEEFC9E}", IVectorGeometryToolPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolPointLocateInSystemWithRateResult"] = IVectorGeometryToolPointLocateInSystemWithRateResult

class IVectorGeometryToolSystemTransformResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFrom and IVectorGeometryToolSystem.TransformTo methods."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemTransformResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemTransformResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemTransformResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformResult._metadata, IVectorGeometryToolSystemTransformResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformResult._metadata, IVectorGeometryToolSystemTransformResult._get_vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{FE5C3393-E2B9-4DC0-BFA9-0A1377E1692A}", IVectorGeometryToolSystemTransformResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformResult"] = IVectorGeometryToolSystemTransformResult

class IVectorGeometryToolSystemTransformWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFromWithRate and IVectorGeometryToolSystem.TransformToWithRate methods."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A9E92350-230F-45C7-A617-DB684FF89C78}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2,
                             "get_velocity" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemTransformWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemTransformWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemTransformWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The transformed vector."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_vector_metadata)

    _get_velocity_metadata = { "name" : "velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """The vector's velocity."""
        return self._intf.get_property(IVectorGeometryToolSystemTransformWithRateResult._metadata, IVectorGeometryToolSystemTransformWithRateResult._get_velocity_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A9E92350-230F-45C7-A617-DB684FF89C78}", IVectorGeometryToolSystemTransformWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemTransformWithRateResult"] = IVectorGeometryToolSystemTransformWithRateResult

class IVectorGeometryToolSystemFindInSystemResult(object):
    """Contains the results returned with IVectorGeometryToolSystem.FindInSystem method."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_position" : 2,
                             "get_velocity" : 3,
                             "get_rate" : 4,
                             "get_orientation" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolSystemFindInSystemResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolSystemFindInSystemResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolSystemFindInSystemResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_is_valid_metadata)

    _get_position_metadata = { "name" : "position",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def position(self) -> "ICartesian3Vector":
        """A position vector."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_position_metadata)

    _get_velocity_metadata = { "name" : "velocity",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def velocity(self) -> "ICartesian3Vector":
        """A velocity vector."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_velocity_metadata)

    _get_rate_metadata = { "name" : "rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def rate(self) -> "ICartesian3Vector":
        """Rate of change."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_rate_metadata)

    _get_orientation_metadata = { "name" : "orientation",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def orientation(self) -> "IOrientation":
        """Orientation."""
        return self._intf.get_property(IVectorGeometryToolSystemFindInSystemResult._metadata, IVectorGeometryToolSystemFindInSystemResult._get_orientation_metadata)


agcls.AgClassCatalog.add_catalog_entry("{2A97D0CA-38C6-44D9-BCB1-16CCA1C1A25E}", IVectorGeometryToolSystemFindInSystemResult)
agcls.AgTypeNameMap["IVectorGeometryToolSystemFindInSystemResult"] = IVectorGeometryToolSystemFindInSystemResult

class IVectorGeometryToolVectorFindInAxesResult(object):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxes method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFindInAxesResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFindInAxesResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFindInAxesResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesResult._metadata, IVectorGeometryToolVectorFindInAxesResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesResult._metadata, IVectorGeometryToolVectorFindInAxesResult._get_vector_metadata)


agcls.AgClassCatalog.add_catalog_entry("{BBCEDAA0-AF02-47A9-A904-0E6B456A4D99}", IVectorGeometryToolVectorFindInAxesResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesResult"] = IVectorGeometryToolVectorFindInAxesResult

class IVectorGeometryToolVectorFindInAxesWithRateResult(object):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxesWithRate method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{A5EB9B7C-559C-4ABB-839E-47109CDC8446}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_vector" : 2,
                             "get_rate" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IVectorGeometryToolVectorFindInAxesWithRateResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorGeometryToolVectorFindInAxesWithRateResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IVectorGeometryToolVectorFindInAxesWithRateResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_is_valid_metadata)

    _get_vector_metadata = { "name" : "vector",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def vector(self) -> "ICartesian3Vector":
        """The vector in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_vector_metadata)

    _get_rate_metadata = { "name" : "rate",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def rate(self) -> "ICartesian3Vector":
        """The vector rate in a specified axes."""
        return self._intf.get_property(IVectorGeometryToolVectorFindInAxesWithRateResult._metadata, IVectorGeometryToolVectorFindInAxesWithRateResult._get_rate_metadata)


agcls.AgClassCatalog.add_catalog_entry("{A5EB9B7C-559C-4ABB-839E-47109CDC8446}", IVectorGeometryToolVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["IVectorGeometryToolVectorFindInAxesWithRateResult"] = IVectorGeometryToolVectorFindInAxesWithRateResult

class IAnalysisWorkbenchMethodCallResult(object):
    """Instances of the interface are used to return the result of a computation."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchMethodCallResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchMethodCallResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchMethodCallResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """True indicates the method call was successful."""
        return self._intf.get_property(IAnalysisWorkbenchMethodCallResult._metadata, IAnalysisWorkbenchMethodCallResult._get_is_valid_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5B3BE0BF-AFA2-4077-954F-F11A5B43F086}", IAnalysisWorkbenchMethodCallResult)
agcls.AgTypeNameMap["IAnalysisWorkbenchMethodCallResult"] = IAnalysisWorkbenchMethodCallResult

class IAnalysisWorkbenchCentralBody(object):
    """The interface represents a central body."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8742150E-1663-4DCC-A442-278479FF93DC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_name" : 1, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchCentralBody)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchCentralBody)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchCentralBody, None)
    
    _get_name_metadata = { "name" : "name",
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BSTR_arg,) }
    @property
    def name(self) -> str:
        """A name of the central body."""
        return self._intf.get_property(IAnalysisWorkbenchCentralBody._metadata, IAnalysisWorkbenchCentralBody._get_name_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8742150E-1663-4DCC-A442-278479FF93DC}", IAnalysisWorkbenchCentralBody)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBody"] = IAnalysisWorkbenchCentralBody

class IAnalysisWorkbenchCentralBodyRefTo(object):
    """Represents a reference to a VGT CentralBody."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{40596A74-4E5F-4406-85FF-70FA79893BFC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "set_path" : 1,
                             "set_central_body" : 2,
                             "get_central_body" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchCentralBodyRefTo)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchCentralBodyRefTo)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchCentralBodyRefTo, None)
    
    _set_path_metadata = { "name" : "set_path",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def set_path(self, path:str) -> None:
        """Set a new central body using specified path."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyRefTo._metadata, IAnalysisWorkbenchCentralBodyRefTo._set_path_metadata, path)

    _set_central_body_metadata = { "name" : "set_central_body",
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.AgInterface_in_arg("IAnalysisWorkbenchCentralBody"),) }
    def set_central_body(self, centralBody:"IAnalysisWorkbenchCentralBody") -> None:
        """Set a new central body."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyRefTo._metadata, IAnalysisWorkbenchCentralBodyRefTo._set_central_body_metadata, centralBody)

    _get_central_body_metadata = { "name" : "get_central_body",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    def get_central_body(self) -> "AnalysisWorkbenchCentralBody":
        """Return a central body or null if the central body is invalid."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyRefTo._metadata, IAnalysisWorkbenchCentralBodyRefTo._get_central_body_metadata, out_arg())


agcls.AgClassCatalog.add_catalog_entry("{40596A74-4E5F-4406-85FF-70FA79893BFC}", IAnalysisWorkbenchCentralBodyRefTo)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBodyRefTo"] = IAnalysisWorkbenchCentralBodyRefTo

class IAnalysisWorkbenchCentralBodyCollection(object):
    """A collection of central body names."""

    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{FB32C9FA-327D-4AF9-9330-7DE8854F827E}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3,
                             "add" : 4,
                             "remove" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchCentralBodyCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchCentralBodyCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchCentralBodyCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> str:
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(IAnalysisWorkbenchCentralBodyCollection._metadata, IAnalysisWorkbenchCentralBodyCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.BSTR_arg,) }
    def item(self, index:int) -> str:
        """Return a central body name at a specified index."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyCollection._metadata, IAnalysisWorkbenchCentralBodyCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IAnalysisWorkbenchCentralBodyCollection._metadata, IAnalysisWorkbenchCentralBodyCollection._get__NewEnum_metadata)

    _add_metadata = { "name" : "add",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def add(self, centralBodyName:str) -> bool:
        """Add a central body to the collection of central bodies. True indicates success."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyCollection._metadata, IAnalysisWorkbenchCentralBodyCollection._add_metadata, centralBodyName, out_arg())

    _remove_metadata = { "name" : "remove",
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BSTR_arg,) }
    def remove(self, centralBodyName:str) -> None:
        """Remove a central body with the specified name from the collection of the central bodies."""
        return self._intf.invoke(IAnalysisWorkbenchCentralBodyCollection._metadata, IAnalysisWorkbenchCentralBodyCollection._remove_metadata, centralBodyName)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{FB32C9FA-327D-4AF9-9330-7DE8854F827E}", IAnalysisWorkbenchCentralBodyCollection)
agcls.AgTypeNameMap["IAnalysisWorkbenchCentralBodyCollection"] = IAnalysisWorkbenchCentralBodyCollection

class IAnalysisWorkbenchCollection(object):
    """A collection of VGT objects."""

    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    _metadata = {
        "uuid" : "{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}",
        "vtable_reference" : IDispatch._vtable_offset + IDispatch._num_methods - 1,
        "method_offsets" : { "contains" : 1,
                             "get_count" : 2,
                             "item" : 3,
                             "get__NewEnum" : 4,
                             "get_item_by_index" : 5,
                             "get_item_by_name" : 6, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, IAnalysisWorkbenchCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAnalysisWorkbenchCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, IAnalysisWorkbenchCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IAnalysisWorkbenchComponent":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _contains_metadata = { "name" : "contains",
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.VARIANT_BOOL_arg,) }
    def contains(self, name:str) -> bool:
        """Search for a an element with a given name. Returns false if the specified element does not exist."""
        return self._intf.invoke(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._contains_metadata, name, out_arg())

    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Return a number of elements in the collection."""
        return self._intf.get_property(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.VARIANT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VARIANT_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, indexOrName:typing.Any) -> "IAnalysisWorkbenchComponent":
        """Retrieve an element of the collection using the name of the element or a position in the collection."""
        return self._intf.invoke(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._item_metadata, indexOrName, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._get__NewEnum_metadata)

    _get_item_by_index_metadata = { "name" : "get_item_by_index",
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.INT_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_index(self, index:int) -> "IAnalysisWorkbenchComponent":
        """Retrieve an item from the crdn collection by index."""
        return self._intf.invoke(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._get_item_by_index_metadata, index, out_arg())

    _get_item_by_name_metadata = { "name" : "get_item_by_name",
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BSTR_arg, agmarshall.AgInterface_out_arg,) }
    def get_item_by_name(self, name:str) -> "IAnalysisWorkbenchComponent":
        """Retrieve an item from the crdn collection by name."""
        return self._intf.invoke(IAnalysisWorkbenchCollection._metadata, IAnalysisWorkbenchCollection._get_item_by_name_metadata, name, out_arg())

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{F4232BB4-7009-491A-9F2D-2B520B3A9BB3}", IAnalysisWorkbenchCollection)
agcls.AgTypeNameMap["IAnalysisWorkbenchCollection"] = IAnalysisWorkbenchCollection

class ITimeToolPointSamplingResult(object):
    """Contains tabulated positions and velocities of a point created by Sample method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5131DB47-EFEA-4021-BEC5-DD13A73D9917}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolPointSamplingResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPointSamplingResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolPointSamplingResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolPointSamplingResult._metadata, ITimeToolPointSamplingResult._get_is_valid_metadata)

    _get_intervals_metadata = { "name" : "intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def intervals(self) -> "TimeToolPointSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(ITimeToolPointSamplingResult._metadata, ITimeToolPointSamplingResult._get_intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5131DB47-EFEA-4021-BEC5-DD13A73D9917}", ITimeToolPointSamplingResult)
agcls.AgTypeNameMap["ITimeToolPointSamplingResult"] = ITimeToolPointSamplingResult

class ITimeToolPointSamplingInterval(object):
    """The interface represents an interval with the time, position and velocity arrays."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_times" : 1,
                             "get_positions" : 2,
                             "get_velocities" : 3,
                             "get_start" : 4,
                             "get_stop" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolPointSamplingInterval)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPointSamplingInterval)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolPointSamplingInterval, None)
    
    _get_times_metadata = { "name" : "times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(ITimeToolPointSamplingInterval._metadata, ITimeToolPointSamplingInterval._get_times_metadata)

    _get_positions_metadata = { "name" : "positions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def positions(self) -> list:
        """An array of 3-tuples each tuple representing the point's cartesian position (x,y,z)."""
        return self._intf.get_property(ITimeToolPointSamplingInterval._metadata, ITimeToolPointSamplingInterval._get_positions_metadata)

    _get_velocities_metadata = { "name" : "velocities",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def velocities(self) -> list:
        """An array of velocities."""
        return self._intf.get_property(ITimeToolPointSamplingInterval._metadata, ITimeToolPointSamplingInterval._get_velocities_metadata)

    _get_start_metadata = { "name" : "start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(ITimeToolPointSamplingInterval._metadata, ITimeToolPointSamplingInterval._get_start_metadata)

    _get_stop_metadata = { "name" : "stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(ITimeToolPointSamplingInterval._metadata, ITimeToolPointSamplingInterval._get_stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{8FDCDDF2-3B42-4D98-8A94-ACB3805F2632}", ITimeToolPointSamplingInterval)
agcls.AgTypeNameMap["ITimeToolPointSamplingInterval"] = ITimeToolPointSamplingInterval

class ITimeToolPointSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolPointSamplingIntervalCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolPointSamplingIntervalCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolPointSamplingIntervalCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolPointSamplingInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(ITimeToolPointSamplingIntervalCollection._metadata, ITimeToolPointSamplingIntervalCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "TimeToolPointSamplingInterval":
        """Access an element at the specified position."""
        return self._intf.invoke(ITimeToolPointSamplingIntervalCollection._metadata, ITimeToolPointSamplingIntervalCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolPointSamplingIntervalCollection._metadata, ITimeToolPointSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{B8A5C3E5-C76E-4CBF-BAFE-1582016C3908}", ITimeToolPointSamplingIntervalCollection)
agcls.AgTypeNameMap["ITimeToolPointSamplingIntervalCollection"] = ITimeToolPointSamplingIntervalCollection

class ITimeToolAxesSamplingResult(object):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F01C2A06-2998-406C-9898-CB60F5711EF1}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_is_valid" : 1,
                             "get_intervals" : 2, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolAxesSamplingResult)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolAxesSamplingResult)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolAxesSamplingResult, None)
    
    _get_is_valid_metadata = { "name" : "is_valid",
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VARIANT_BOOL_arg,) }
    @property
    def is_valid(self) -> bool:
        """Indicate whether the result object is valid."""
        return self._intf.get_property(ITimeToolAxesSamplingResult._metadata, ITimeToolAxesSamplingResult._get_is_valid_metadata)

    _get_intervals_metadata = { "name" : "intervals",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.AgInterface_out_arg,) }
    @property
    def intervals(self) -> "TimeToolAxesSamplingIntervalCollection":
        """A collection of sampling intervals."""
        return self._intf.get_property(ITimeToolAxesSamplingResult._metadata, ITimeToolAxesSamplingResult._get_intervals_metadata)


agcls.AgClassCatalog.add_catalog_entry("{F01C2A06-2998-406C-9898-CB60F5711EF1}", ITimeToolAxesSamplingResult)
agcls.AgTypeNameMap["ITimeToolAxesSamplingResult"] = ITimeToolAxesSamplingResult

class ITimeToolAxesSamplingInterval(object):
    """The interface represents an interval with the time, orientation and velocity arrays."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{5BF49282-A56A-48F1-85C9-92CF71C803D0}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_times" : 1,
                             "get_quaternions" : 2,
                             "get_velocities" : 3,
                             "get_start" : 4,
                             "get_stop" : 5, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolAxesSamplingInterval)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolAxesSamplingInterval)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolAxesSamplingInterval, None)
    
    _get_times_metadata = { "name" : "times",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def times(self) -> list:
        """A time array associated with the interval."""
        return self._intf.get_property(ITimeToolAxesSamplingInterval._metadata, ITimeToolAxesSamplingInterval._get_times_metadata)

    _get_quaternions_metadata = { "name" : "quaternions",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def quaternions(self) -> list:
        """An array of 4-tuples each tuple representing the orientation of the axes as a quaternion (q1,q2,q3,q4)."""
        return self._intf.get_property(ITimeToolAxesSamplingInterval._metadata, ITimeToolAxesSamplingInterval._get_quaternions_metadata)

    _get_velocities_metadata = { "name" : "velocities",
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSAFEARRAY_arg,) }
    @property
    def velocities(self) -> list:
        """An array of angular velocities."""
        return self._intf.get_property(ITimeToolAxesSamplingInterval._metadata, ITimeToolAxesSamplingInterval._get_velocities_metadata)

    _get_start_metadata = { "name" : "start",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def start(self) -> typing.Any:
        """The start time of the interval."""
        return self._intf.get_property(ITimeToolAxesSamplingInterval._metadata, ITimeToolAxesSamplingInterval._get_start_metadata)

    _get_stop_metadata = { "name" : "stop",
            "arg_types" : (POINTER(agcom.VARIANT),),
            "marshallers" : (agmarshall.VARIANT_arg,) }
    @property
    def stop(self) -> typing.Any:
        """The stop time of the interval."""
        return self._intf.get_property(ITimeToolAxesSamplingInterval._metadata, ITimeToolAxesSamplingInterval._get_stop_metadata)


agcls.AgClassCatalog.add_catalog_entry("{5BF49282-A56A-48F1-85C9-92CF71C803D0}", ITimeToolAxesSamplingInterval)
agcls.AgTypeNameMap["ITimeToolAxesSamplingInterval"] = ITimeToolAxesSamplingInterval

class ITimeToolAxesSamplingIntervalCollection(object):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "uuid" : "{F593657B-35A4-4F40-B697-4D14E66195AC}",
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
        "method_offsets" : { "get_count" : 1,
                             "item" : 2,
                             "get__NewEnum" : 3, }
    }
    def __init__(self, sourceObject=None):
        initialize_from_source_object(self, sourceObject, ITimeToolAxesSamplingIntervalCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeToolAxesSamplingIntervalCollection)
    def __setattr__(self, attrname, value):
        set_interface_attribute(self, attrname, value, ITimeToolAxesSamplingIntervalCollection, None)
    def __iter__(self):
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITimeToolAxesSamplingInterval":
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "name" : "count",
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LONG_arg,) }
    @property
    def count(self) -> int:
        """Number of elements in the collection."""
        return self._intf.get_property(ITimeToolAxesSamplingIntervalCollection._metadata, ITimeToolAxesSamplingIntervalCollection._get_count_metadata)

    _item_metadata = { "name" : "item",
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LONG_arg, agmarshall.AgInterface_out_arg,) }
    def item(self, index:int) -> "TimeToolAxesSamplingInterval":
        """Access an element at the specified position."""
        return self._intf.invoke(ITimeToolAxesSamplingIntervalCollection._metadata, ITimeToolAxesSamplingIntervalCollection._item_metadata, index, out_arg())

    _get__NewEnum_metadata = { "name" : "_NewEnum",
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVARIANT_arg,) }
    @property
    def _NewEnum(self) -> enumerator_proxy:
        """Return a COM enumerator."""
        return self._intf.get_property(ITimeToolAxesSamplingIntervalCollection._metadata, ITimeToolAxesSamplingIntervalCollection._get__NewEnum_metadata)

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{F593657B-35A4-4F40-B697-4D14E66195AC}", ITimeToolAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["ITimeToolAxesSamplingIntervalCollection"] = ITimeToolAxesSamplingIntervalCollection



class CalculationToolEvaluateResult(ICalculationToolEvaluateResult):
    """Represents the results of evaluating a scalar component."""

    def __init__(self, sourceObject=None):
        ICalculationToolEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolEvaluateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolEvaluateResult, [ICalculationToolEvaluateResult])

agcls.AgClassCatalog.add_catalog_entry("{94FD0DFF-1DD0-4CA5-A7DB-1CB9CA3E3C93}", CalculationToolEvaluateResult)
agcls.AgTypeNameMap["CalculationToolEvaluateResult"] = CalculationToolEvaluateResult

class CalculationToolEvaluateWithRateResult(ICalculationToolEvaluateWithRateResult):
    """Represents the results of evaluating a scalar component."""

    def __init__(self, sourceObject=None):
        ICalculationToolEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolEvaluateWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolEvaluateWithRateResult, [ICalculationToolEvaluateWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{832CA139-8ECF-4E95-AB67-1BB7713CF9FC}", CalculationToolEvaluateWithRateResult)
agcls.AgTypeNameMap["CalculationToolEvaluateWithRateResult"] = CalculationToolEvaluateWithRateResult

class TimeToolEventIntervalResult(ITimeToolEventIntervalResult):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalResult, [ITimeToolEventIntervalResult])

agcls.AgClassCatalog.add_catalog_entry("{ACE6C28C-4664-4B7F-8736-91F55C7962A6}", TimeToolEventIntervalResult)
agcls.AgTypeNameMap["TimeToolEventIntervalResult"] = TimeToolEventIntervalResult

class TimeToolEventFindOccurrenceResult(ITimeToolEventFindOccurrenceResult):
    """Contains the results returned with ITimeToolEvent.FindOccurrence method."""

    def __init__(self, sourceObject=None):
        ITimeToolEventFindOccurrenceResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventFindOccurrenceResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventFindOccurrenceResult, [ITimeToolEventFindOccurrenceResult])

agcls.AgClassCatalog.add_catalog_entry("{6A432F58-4CAB-4448-8540-CBBAA9C2B9F0}", TimeToolEventFindOccurrenceResult)
agcls.AgTypeNameMap["TimeToolEventFindOccurrenceResult"] = TimeToolEventFindOccurrenceResult

class TimeToolFindTimesResult(ITimeToolFindTimesResult):
    """Return a collection of intervals and an array of times."""

    def __init__(self, sourceObject=None):
        ITimeToolFindTimesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolFindTimesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolFindTimesResult, [ITimeToolFindTimesResult])

agcls.AgClassCatalog.add_catalog_entry("{AF246FCF-7FA3-4CD6-878B-E9AC267F017A}", TimeToolFindTimesResult)
agcls.AgTypeNameMap["TimeToolFindTimesResult"] = TimeToolFindTimesResult

class TimeToolIntervalsVectorResult(ITimeToolIntervalsVectorResult):
    """Contains the results returned with ITimeToolEventIntervalCollection.FindIntervalCollection method."""

    def __init__(self, sourceObject=None):
        ITimeToolIntervalsVectorResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolIntervalsVectorResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolIntervalsVectorResult, [ITimeToolIntervalsVectorResult])

agcls.AgClassCatalog.add_catalog_entry("{233B8EB4-0B6A-485F-BACB-C678798FDA21}", TimeToolIntervalsVectorResult)
agcls.AgTypeNameMap["TimeToolIntervalsVectorResult"] = TimeToolIntervalsVectorResult

class TimeToolEventIntervalCollectionOccurredResult(ITimeToolEventIntervalCollectionOccurredResult):
    """Contains the results returned with ITimeToolEventIntervalCollection.Occurred method."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionOccurredResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionOccurredResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionOccurredResult, [ITimeToolEventIntervalCollectionOccurredResult])

agcls.AgClassCatalog.add_catalog_entry("{9D2BD8F6-406D-4BA0-B5CF-C81711C7C344}", TimeToolEventIntervalCollectionOccurredResult)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionOccurredResult"] = TimeToolEventIntervalCollectionOccurredResult

class TimeToolIntervalListResult(ITimeToolIntervalListResult):
    """Contains the results returned with ITimeToolEventIntervalList.FindIntervals method."""

    def __init__(self, sourceObject=None):
        ITimeToolIntervalListResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolIntervalListResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolIntervalListResult, [ITimeToolIntervalListResult])

agcls.AgClassCatalog.add_catalog_entry("{C24C2EE4-3F75-41E8-BDC3-FE71E863921F}", TimeToolIntervalListResult)
agcls.AgTypeNameMap["TimeToolIntervalListResult"] = TimeToolIntervalListResult

class TimeToolIntervalVectorCollection(ITimeToolIntervalVectorCollection):
    """A collection of interval collections."""

    def __init__(self, sourceObject=None):
        ITimeToolIntervalVectorCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolIntervalVectorCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolIntervalVectorCollection, [ITimeToolIntervalVectorCollection])

agcls.AgClassCatalog.add_catalog_entry("{99AAE1D2-3C5D-4836-A1BD-6EAD38FC9BC5}", TimeToolIntervalVectorCollection)
agcls.AgTypeNameMap["TimeToolIntervalVectorCollection"] = TimeToolIntervalVectorCollection

class TimeToolEventGroup(ITimeToolEventGroup):
    """Access or create VGT events associated with an object."""

    def __init__(self, sourceObject=None):
        ITimeToolEventGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventGroup, [ITimeToolEventGroup])

agcls.AgClassCatalog.add_catalog_entry("{D5D83181-A954-4FA9-886E-A917F135C974}", TimeToolEventGroup)
agcls.AgTypeNameMap["TimeToolEventGroup"] = TimeToolEventGroup

class TimeToolEventIntervalGroup(ITimeToolEventIntervalGroup):
    """Access or create VGT event intervals associated with an object."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalGroup, [ITimeToolEventIntervalGroup])

agcls.AgClassCatalog.add_catalog_entry("{48C9D4D2-2713-4063-8BB1-D6F2E72E1025}", TimeToolEventIntervalGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalGroup"] = TimeToolEventIntervalGroup

class TimeToolEventIntervalListGroup(ITimeToolEventIntervalListGroup):
    """Access or create VGT event interval lists associated with an object."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListGroup, [ITimeToolEventIntervalListGroup])

agcls.AgClassCatalog.add_catalog_entry("{3B2FDEBA-A2B9-4568-8F48-469F604DB966}", TimeToolEventIntervalListGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalListGroup"] = TimeToolEventIntervalListGroup

class TimeToolEventArrayGroup(ITimeToolEventArrayGroup):
    """Access or create VGT event arrays associated with an object."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayGroup, [ITimeToolEventArrayGroup])

agcls.AgClassCatalog.add_catalog_entry("{365C4A6E-9C2B-4883-96C6-CF689BCC2943}", TimeToolEventArrayGroup)
agcls.AgTypeNameMap["TimeToolEventArrayGroup"] = TimeToolEventArrayGroup

class CalculationToolScalarGroup(ICalculationToolScalarGroup):
    """Access or create VGT calculation scalars associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarGroup, [ICalculationToolScalarGroup])

agcls.AgClassCatalog.add_catalog_entry("{DFAD8468-4480-460F-993D-74FFADB567B3}", CalculationToolScalarGroup)
agcls.AgTypeNameMap["CalculationToolScalarGroup"] = CalculationToolScalarGroup

class TimeToolEventIntervalCollectionGroup(ITimeToolEventIntervalCollectionGroup):
    """Access or create VGT event interval collections associated with an object."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionGroup, [ITimeToolEventIntervalCollectionGroup])

agcls.AgClassCatalog.add_catalog_entry("{16E277E2-E306-40E7-B698-B725BDED5739}", TimeToolEventIntervalCollectionGroup)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionGroup"] = TimeToolEventIntervalCollectionGroup

class CalculationToolParameterSetGroup(ICalculationToolParameterSetGroup):
    """Access or create VGT parameter sets associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetGroup, [ICalculationToolParameterSetGroup])

agcls.AgClassCatalog.add_catalog_entry("{4AF3C889-3805-40E2-94E2-3EA11AAFB0D7}", CalculationToolParameterSetGroup)
agcls.AgTypeNameMap["CalculationToolParameterSetGroup"] = CalculationToolParameterSetGroup

class CalculationToolConditionGroup(ICalculationToolConditionGroup):
    """Access or create VGT conditions associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionGroup, [ICalculationToolConditionGroup])

agcls.AgClassCatalog.add_catalog_entry("{28BCB469-D32F-4FCE-9CC2-76216E3A37CA}", CalculationToolConditionGroup)
agcls.AgTypeNameMap["CalculationToolConditionGroup"] = CalculationToolConditionGroup

class CalculationToolConditionSetGroup(ICalculationToolConditionSetGroup):
    """Allow accessing and creating condition set components."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSetGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSetGroup, [ICalculationToolConditionSetGroup])

agcls.AgClassCatalog.add_catalog_entry("{D82D5C71-102E-4154-9FF6-153C4EDB5A94}", CalculationToolConditionSetGroup)
agcls.AgTypeNameMap["CalculationToolConditionSetGroup"] = CalculationToolConditionSetGroup

class CalculationToolConditionSetEvaluateResult(ICalculationToolConditionSetEvaluateResult):
    """Represents the results returned by ConditionSet.Evaluate."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetEvaluateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSetEvaluateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSetEvaluateResult, [ICalculationToolConditionSetEvaluateResult])

agcls.AgClassCatalog.add_catalog_entry("{13F4EB53-F5AB-487A-BC09-AA186C884744}", CalculationToolConditionSetEvaluateResult)
agcls.AgTypeNameMap["CalculationToolConditionSetEvaluateResult"] = CalculationToolConditionSetEvaluateResult

class CalculationToolConditionSetEvaluateWithRateResult(ICalculationToolConditionSetEvaluateWithRateResult):
    """Represents the results returned by ConditionSet.EvaluateWithRate."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetEvaluateWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSetEvaluateWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSetEvaluateWithRateResult, [ICalculationToolConditionSetEvaluateWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{53051D77-87D0-432C-9044-A2AB1E2104BA}", CalculationToolConditionSetEvaluateWithRateResult)
agcls.AgTypeNameMap["CalculationToolConditionSetEvaluateWithRateResult"] = CalculationToolConditionSetEvaluateWithRateResult

class SpatialAnalysisToolVolumeGridGroup(ISpatialAnalysisToolVolumeGridGroup):
    """Access or create VGT volume grids associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridGroup, [ISpatialAnalysisToolVolumeGridGroup])

agcls.AgClassCatalog.add_catalog_entry("{5E471C90-D0F2-4B6B-88AE-D529E9D16D03}", SpatialAnalysisToolVolumeGridGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridGroup"] = SpatialAnalysisToolVolumeGridGroup

class SpatialAnalysisToolVolumeGroup(ISpatialAnalysisToolVolumeGroup):
    """Access or create spatial conditions associated with a volume grid."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGroup, [ISpatialAnalysisToolVolumeGroup])

agcls.AgClassCatalog.add_catalog_entry("{0055B726-654F-446B-82D7-BCDD744F1D8F}", SpatialAnalysisToolVolumeGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGroup"] = SpatialAnalysisToolVolumeGroup

class SpatialAnalysisToolVolumeCalcGroup(ISpatialAnalysisToolVolumeCalcGroup):
    """Access or create VGT volume calc associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcGroup, [ISpatialAnalysisToolVolumeCalcGroup])

agcls.AgClassCatalog.add_catalog_entry("{b10331b7-f8c3-4a59-9e9b-b05dd6599167}", SpatialAnalysisToolVolumeCalcGroup)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcGroup"] = SpatialAnalysisToolVolumeCalcGroup

class CalculationToolScalar(ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Any scalar calculation that is not constant by construction."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalar, [ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{440E178B-1B34-4896-A25F-2A4F3AD4848E}", CalculationToolScalar)
agcls.AgTypeNameMap["CalculationToolScalar"] = CalculationToolScalar

class CalculationToolScalarAngle(ICalculationToolScalarAngle, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Scalar equal to angular displacement obtained from any angle in VGT."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarAngle.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarAngle._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarAngle, [ICalculationToolScalarAngle, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2E2A940D-2656-4410-86B4-D7314B788E47}", CalculationToolScalarAngle)
agcls.AgTypeNameMap["CalculationToolScalarAngle"] = CalculationToolScalarAngle

class CalculationToolScalarConstant(ICalculationToolScalarConstant, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Constant scalar value of specified dimension."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarConstant.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarConstant._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarConstant, [ICalculationToolScalarConstant, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0725A767-6788-4FF4-B848-EF3D526BD7B0}", CalculationToolScalarConstant)
agcls.AgTypeNameMap["CalculationToolScalarConstant"] = CalculationToolScalarConstant

class CalculationToolScalarCustom(ICalculationToolScalarCustom, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """A calc scalar based on a scripted algorithm in MATLAB (.m or .dll), Perl or VBScript to define its value and rate."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarCustom.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarCustom._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarCustom, [ICalculationToolScalarCustom, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{80114DE9-EF5E-47DB-AC1B-91FD78FCA094}", CalculationToolScalarCustom)
agcls.AgTypeNameMap["CalculationToolScalarCustom"] = CalculationToolScalarCustom

class CalculationToolScalarDataElement(ICalculationToolScalarDataElement, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Any time-dependent data element from STK data providers available for parent STK object."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarDataElement.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarDataElement._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarDataElement, [ICalculationToolScalarDataElement, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{260D686F-07E2-49DB-8E88-467EF79EFA54}", CalculationToolScalarDataElement)
agcls.AgTypeNameMap["CalculationToolScalarDataElement"] = CalculationToolScalarDataElement

class CalculationToolScalarDerivative(ICalculationToolScalarDerivative, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Derivative of an input scalar calculation."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarDerivative.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarDerivative._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarDerivative, [ICalculationToolScalarDerivative, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{865CE7A8-F7C3-4B25-AA1D-10CA305C7CF0}", CalculationToolScalarDerivative)
agcls.AgTypeNameMap["CalculationToolScalarDerivative"] = CalculationToolScalarDerivative

class CalculationToolScalarDotProduct(ICalculationToolScalarDotProduct, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Dot product between two vectors."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarDotProduct.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarDotProduct._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarDotProduct, [ICalculationToolScalarDotProduct, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{703f009e-faab-4281-8d07-733b1344d42b}", CalculationToolScalarDotProduct)
agcls.AgTypeNameMap["CalculationToolScalarDotProduct"] = CalculationToolScalarDotProduct

class CalculationToolScalarElapsedTime(ICalculationToolScalarElapsedTime, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Time elapsed since the reference time instant. Negative if in the past."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarElapsedTime.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarElapsedTime._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarElapsedTime, [ICalculationToolScalarElapsedTime, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{9D9FAF22-291A-4348-9EAD-1C8DF06D9C1C}", CalculationToolScalarElapsedTime)
agcls.AgTypeNameMap["CalculationToolScalarElapsedTime"] = CalculationToolScalarElapsedTime

class CalculationToolScalarFactory(ICalculationToolScalarFactory):
    """The factory creates scalar calculation components."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarFactory, [ICalculationToolScalarFactory])

agcls.AgClassCatalog.add_catalog_entry("{47235112-821F-4DC2-9A70-57AB9F1F17E8}", CalculationToolScalarFactory)
agcls.AgTypeNameMap["CalculationToolScalarFactory"] = CalculationToolScalarFactory

class CalculationToolScalarFile(ICalculationToolScalarFile, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Tabulated scalar calculation data loaded from specified file - a file with .csc extension."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarFile.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarFile._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarFile, [ICalculationToolScalarFile, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{75F0039F-B789-4771-BD50-9AEF30F6038E}", CalculationToolScalarFile)
agcls.AgTypeNameMap["CalculationToolScalarFile"] = CalculationToolScalarFile

class CalculationToolScalarFixedAtTimeInstant(ICalculationToolScalarFixedAtTimeInstant, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Constant scalar created by evaluating the input scalar calculation at the specified reference time instant. Undefined if original scalar is not available at specified time or if reference time instant is undefined."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarFixedAtTimeInstant.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarFixedAtTimeInstant._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarFixedAtTimeInstant, [ICalculationToolScalarFixedAtTimeInstant, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{83E8DC6B-7821-4474-AA5B-29646ECD1EC1}", CalculationToolScalarFixedAtTimeInstant)
agcls.AgTypeNameMap["CalculationToolScalarFixedAtTimeInstant"] = CalculationToolScalarFixedAtTimeInstant

class CalculationToolScalarFunction(ICalculationToolScalarFunction, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Defined by performing the specified function on the input scalar or time instant."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarFunction.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarFunction._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarFunction, [ICalculationToolScalarFunction, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{40158F99-3146-4167-8BB0-A0046BB08EEB}", CalculationToolScalarFunction)
agcls.AgTypeNameMap["CalculationToolScalarFunction"] = CalculationToolScalarFunction

class CalculationToolScalarFunction2Var(ICalculationToolScalarFunction2Var, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Defined by performing a function(x,y) on two scalar arguments."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarFunction2Var.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarFunction2Var._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarFunction2Var, [ICalculationToolScalarFunction2Var, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{05CA07A4-A36F-44EF-99C4-5E0999E79200}", CalculationToolScalarFunction2Var)
agcls.AgTypeNameMap["CalculationToolScalarFunction2Var"] = CalculationToolScalarFunction2Var

class CalculationToolScalarIntegral(ICalculationToolScalarIntegral, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Integral of input scalar computed with respect to time using one of the specified numerical methods and using one of the specified accumulation types."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarIntegral.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarIntegral._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarIntegral, [ICalculationToolScalarIntegral, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C87C787A-BEDA-4AEC-9F88-3D6EE0936A03}", CalculationToolScalarIntegral)
agcls.AgTypeNameMap["CalculationToolScalarIntegral"] = CalculationToolScalarIntegral

class CalculationToolScalarPlugin(ICalculationToolScalarPlugin, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Use a scalar calculation plugin."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarPlugin.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarPlugin._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarPlugin, [ICalculationToolScalarPlugin, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{E435E30B-EA9B-4EFB-852A-C20427B71484}", CalculationToolScalarPlugin)
agcls.AgTypeNameMap["CalculationToolScalarPlugin"] = CalculationToolScalarPlugin

class CalculationToolScalarSurfaceDistanceBetweenPoints(ICalculationToolScalarSurfaceDistanceBetweenPoints, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Surface distance along the specified central body ellipsoid between two points (or their respective projections if specified at altitude)."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarSurfaceDistanceBetweenPoints.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarSurfaceDistanceBetweenPoints._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarSurfaceDistanceBetweenPoints, [ICalculationToolScalarSurfaceDistanceBetweenPoints, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{DEDCB488-6C70-4BC0-A719-68832FB6D30E}", CalculationToolScalarSurfaceDistanceBetweenPoints)
agcls.AgTypeNameMap["CalculationToolScalarSurfaceDistanceBetweenPoints"] = CalculationToolScalarSurfaceDistanceBetweenPoints

class CalculationToolScalarVectorComponent(ICalculationToolScalarVectorComponent, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """The specified component of a vector when resolved in the specified axes."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarVectorComponent.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarVectorComponent._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarVectorComponent, [ICalculationToolScalarVectorComponent, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0b8e5c9f-de1b-4b6b-9e38-87b16db7bb71}", CalculationToolScalarVectorComponent)
agcls.AgTypeNameMap["CalculationToolScalarVectorComponent"] = CalculationToolScalarVectorComponent

class CalculationToolScalarVectorMagnitude(ICalculationToolScalarVectorMagnitude, ICalculationToolScalar, IAnalysisWorkbenchComponent):
    """Scalar equal to the magnitude of a specified vector."""

    def __init__(self, sourceObject=None):
        ICalculationToolScalarVectorMagnitude.__init__(self, sourceObject)
        ICalculationToolScalar.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolScalarVectorMagnitude._private_init(self, intf)
        ICalculationToolScalar._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolScalarVectorMagnitude, [ICalculationToolScalarVectorMagnitude, ICalculationToolScalar, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C7430CE8-D611-4F5C-B4B4-05531F1E0CC0}", CalculationToolScalarVectorMagnitude)
agcls.AgTypeNameMap["CalculationToolScalarVectorMagnitude"] = CalculationToolScalarVectorMagnitude

class CalculationToolCondition(ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Condition returns a non-dimensional metric that is positive if satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for accurate detection of condition crossings."""

    def __init__(self, sourceObject=None):
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolCondition, [ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{D1BED244-FFB2-4038-AE76-A9B3194B2E49}", CalculationToolCondition)
agcls.AgTypeNameMap["CalculationToolCondition"] = CalculationToolCondition

class CalculationToolConditionCombined(ICalculationToolConditionCombined, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Define a condition which combines multiple conditions."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionCombined.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionCombined._private_init(self, intf)
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionCombined, [ICalculationToolConditionCombined, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{92F4488B-3543-4229-B1FB-447D282199B9}", CalculationToolConditionCombined)
agcls.AgTypeNameMap["CalculationToolConditionCombined"] = CalculationToolConditionCombined

class CalculationToolConditionFactory(ICalculationToolConditionFactory):
    """The factory creates condition components."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionFactory, [ICalculationToolConditionFactory])

agcls.AgClassCatalog.add_catalog_entry("{06C627F8-87EA-4552-86E8-7E5049914CDE}", CalculationToolConditionFactory)
agcls.AgTypeNameMap["CalculationToolConditionFactory"] = CalculationToolConditionFactory

class CalculationToolConditionPointInVolume(ICalculationToolConditionPointInVolume, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Defined by determining if input trajectory poiny is within extents of specified volume grid coordinate."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionPointInVolume.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionPointInVolume._private_init(self, intf)
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionPointInVolume, [ICalculationToolConditionPointInVolume, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{41532AD9-B30C-44AE-8581-CE74C24846A8}", CalculationToolConditionPointInVolume)
agcls.AgTypeNameMap["CalculationToolConditionPointInVolume"] = CalculationToolConditionPointInVolume

class CalculationToolConditionScalarBounds(ICalculationToolConditionScalarBounds, ICalculationToolCondition, IAnalysisWorkbenchComponent):
    """Defined by determining if input scalar is within specified bounds; returns +1 if satisfied, -1 if not satisfied and 0 if on boundary."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionScalarBounds.__init__(self, sourceObject)
        ICalculationToolCondition.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionScalarBounds._private_init(self, intf)
        ICalculationToolCondition._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionScalarBounds, [ICalculationToolConditionScalarBounds, ICalculationToolCondition, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{452E2178-AFB0-4E61-8187-9C6CB4A704A0}", CalculationToolConditionScalarBounds)
agcls.AgTypeNameMap["CalculationToolConditionScalarBounds"] = CalculationToolConditionScalarBounds

class CalculationToolConditionSet(ICalculationToolConditionSet, IAnalysisWorkbenchComponent):
    """Condition set returns an array of non-dimensional metrics, one for each condition in the set; each metric is positive if corresponding condition is satisfied, negative if not satisfied and 0 if on boundary; this provides computational methods needed for..."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSet, [ICalculationToolConditionSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B6407B1B-6858-49FC-845A-F8A6239162C2}", CalculationToolConditionSet)
agcls.AgTypeNameMap["CalculationToolConditionSet"] = CalculationToolConditionSet

class CalculationToolConditionSetFactory(ICalculationToolConditionSetFactory):
    """The factory creates condition set components."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSetFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSetFactory, [ICalculationToolConditionSetFactory])

agcls.AgClassCatalog.add_catalog_entry("{D2445C98-9EA1-458F-9B6A-607249BF399A}", CalculationToolConditionSetFactory)
agcls.AgTypeNameMap["CalculationToolConditionSetFactory"] = CalculationToolConditionSetFactory

class CalculationToolConditionSetScalarThresholds(ICalculationToolConditionSetScalarThresholds, ICalculationToolConditionSet, IAnalysisWorkbenchComponent):
    """Condition set based on single scalar calculation compared to set of threshold values."""

    def __init__(self, sourceObject=None):
        ICalculationToolConditionSetScalarThresholds.__init__(self, sourceObject)
        ICalculationToolConditionSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConditionSetScalarThresholds._private_init(self, intf)
        ICalculationToolConditionSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConditionSetScalarThresholds, [ICalculationToolConditionSetScalarThresholds, ICalculationToolConditionSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{EED0BF6B-4D96-4D55-B988-0B962DCDBB4E}", CalculationToolConditionSetScalarThresholds)
agcls.AgTypeNameMap["CalculationToolConditionSetScalarThresholds"] = CalculationToolConditionSetScalarThresholds

class AnalysisWorkbenchConverge(IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent):
    """Represents a base class for convergence definitions."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchConverge._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchConverge, [IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{6A13D679-1970-43C2-8D4F-174B08AB04DC}", AnalysisWorkbenchConverge)
agcls.AgTypeNameMap["AnalysisWorkbenchConverge"] = AnalysisWorkbenchConverge

class CalculationToolConvergeBasic(ICalculationToolConvergeBasic, IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent):
    """Convergence definition includes parameters that determine criteria for accurate detection of extrema or condition crossings for scalar calculations."""

    def __init__(self, sourceObject=None):
        ICalculationToolConvergeBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchConverge.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolConvergeBasic._private_init(self, intf)
        IAnalysisWorkbenchConverge._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolConvergeBasic, [ICalculationToolConvergeBasic, IAnalysisWorkbenchConverge, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{808F19C3-0E31-4C89-94C8-BBE01E067DFF}", CalculationToolConvergeBasic)
agcls.AgTypeNameMap["CalculationToolConvergeBasic"] = CalculationToolConvergeBasic

class AnalysisWorkbenchDerivative(IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent):
    """Represents a base class for derivative definitions."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchDerivative._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchDerivative, [IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2C7C1DA3-BD86-4D8B-9505-AC796FF1FD45}", AnalysisWorkbenchDerivative)
agcls.AgTypeNameMap["AnalysisWorkbenchDerivative"] = AnalysisWorkbenchDerivative

class CalculationToolDerivativeBasic(ICalculationToolDerivativeBasic, IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent):
    """Derivative definition determines how numerical differencing is used to compute derivatives."""

    def __init__(self, sourceObject=None):
        ICalculationToolDerivativeBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchDerivative.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolDerivativeBasic._private_init(self, intf)
        IAnalysisWorkbenchDerivative._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolDerivativeBasic, [ICalculationToolDerivativeBasic, IAnalysisWorkbenchDerivative, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{3CD084C3-0045-4452-9793-AE8DF4073433}", CalculationToolDerivativeBasic)
agcls.AgTypeNameMap["CalculationToolDerivativeBasic"] = CalculationToolDerivativeBasic

class TimeToolEvent(ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Define an event (time instant)."""

    def __init__(self, sourceObject=None):
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEvent, [ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{A4B75B25-5DAE-4AEC-86EF-512F5E031766}", TimeToolEvent)
agcls.AgTypeNameMap["TimeToolEvent"] = TimeToolEvent

class TimeToolEventArray(ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """An ordered array of times, which may or may not be evenly spaced."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArray, [ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F5C87B1A-D519-4A01-8649-AA7560CD503A}", TimeToolEventArray)
agcls.AgTypeNameMap["TimeToolEventArray"] = TimeToolEventArray

class TimeToolEventArrayConditionCrossings(ITimeToolEventArrayConditionCrossings, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Time array containing times at which the specified condition will change its satisfaction status. Determination is performed within the interval list using Sampling and Convergence parameters."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayConditionCrossings.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayConditionCrossings._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayConditionCrossings, [ITimeToolEventArrayConditionCrossings, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B6FBC501-3521-4AE3-AFD8-4971F089D14F}", TimeToolEventArrayConditionCrossings)
agcls.AgTypeNameMap["TimeToolEventArrayConditionCrossings"] = TimeToolEventArrayConditionCrossings

class TimeToolEventArrayExtrema(ITimeToolEventArrayExtrema, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Determine times of local minimum and/or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayExtrema.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayExtrema._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayExtrema, [ITimeToolEventArrayExtrema, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{8FB3F78C-D9F6-43F0-BCAA-5A7DCD035592}", TimeToolEventArrayExtrema)
agcls.AgTypeNameMap["TimeToolEventArrayExtrema"] = TimeToolEventArrayExtrema

class TimeToolEventArrayFactory(ITimeToolEventArrayFactory):
    """The factory creates event arrays."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayFactory, [ITimeToolEventArrayFactory])

agcls.AgClassCatalog.add_catalog_entry("{A001EDFD-FAC8-4BBE-9FDC-0C7A5C4BB11C}", TimeToolEventArrayFactory)
agcls.AgTypeNameMap["TimeToolEventArrayFactory"] = TimeToolEventArrayFactory

class TimeToolEventArrayFiltered(ITimeToolEventArrayFiltered, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by filtering times from original time array according to specified filtering method."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFiltered.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayFiltered._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayFiltered, [ITimeToolEventArrayFiltered, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CA0D9FE7-E921-406E-8A1A-EE448A46C03C}", TimeToolEventArrayFiltered)
agcls.AgTypeNameMap["TimeToolEventArrayFiltered"] = TimeToolEventArrayFiltered

class TimeToolEventArrayFixedStep(ITimeToolEventArrayFixedStep, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by taking fixed time steps from specified time reference and adding sampled times to array if they fall within specified bounding interval list."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFixedStep.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayFixedStep._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayFixedStep, [ITimeToolEventArrayFixedStep, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CDA379CC-7511-496E-874E-14E10F3E2B1A}", TimeToolEventArrayFixedStep)
agcls.AgTypeNameMap["TimeToolEventArrayFixedStep"] = TimeToolEventArrayFixedStep

class TimeToolEventArrayFixedTimes(ITimeToolEventArrayFixedTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Array defined by time ordered instants each explicitly specified."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayFixedTimes.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayFixedTimes._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayFixedTimes, [ITimeToolEventArrayFixedTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{EA73AECA-23AB-4DA1-B297-E80E19C55C15}", TimeToolEventArrayFixedTimes)
agcls.AgTypeNameMap["TimeToolEventArrayFixedTimes"] = TimeToolEventArrayFixedTimes

class TimeToolEventArrayMerged(ITimeToolEventArrayMerged, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by merging times from two other arrays by creating a union of bounding intervals from two constituent arrays. If some intervals overlap, then within overlap times from both arrays are merged together."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayMerged.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayMerged._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayMerged, [ITimeToolEventArrayMerged, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{44FBC83E-D466-425F-ADF5-2003D754F935}", TimeToolEventArrayMerged)
agcls.AgTypeNameMap["TimeToolEventArrayMerged"] = TimeToolEventArrayMerged

class TimeToolEventArraySignaled(ITimeToolEventArraySignaled, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Determine what time array is recorded at target clock location by performing signal transmission of original time array between base and target clock locations..."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArraySignaled.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArraySignaled._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArraySignaled, [ITimeToolEventArraySignaled, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{50E37652-E4D1-4B6F-BA12-2D9B17E5F1AA}", TimeToolEventArraySignaled)
agcls.AgTypeNameMap["TimeToolEventArraySignaled"] = TimeToolEventArraySignaled

class TimeToolEventArrayStartStopTimes(ITimeToolEventArrayStartStopTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent):
    """Defined by taking start and/or stop times of every interval in specified reference interval list and adding them to array. The array is then bounded by single interval spanning specified reference interval list..."""

    def __init__(self, sourceObject=None):
        ITimeToolEventArrayStartStopTimes.__init__(self, sourceObject)
        ITimeToolEventArray.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventArrayStartStopTimes._private_init(self, intf)
        ITimeToolEventArray._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventArrayStartStopTimes, [ITimeToolEventArrayStartStopTimes, ITimeToolEventArray, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{1AF5E1AC-97CB-4375-B0AE-AE8B6684432B}", TimeToolEventArrayStartStopTimes)
agcls.AgTypeNameMap["TimeToolEventArrayStartStopTimes"] = TimeToolEventArrayStartStopTimes

class TimeToolEventEpoch(ITimeToolEventEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event set at specified date/time."""

    def __init__(self, sourceObject=None):
        ITimeToolEventEpoch.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventEpoch._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventEpoch, [ITimeToolEventEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{230426D4-438A-4B6E-A9D2-5393F7F87238}", TimeToolEventEpoch)
agcls.AgTypeNameMap["TimeToolEventEpoch"] = TimeToolEventEpoch

class TimeToolEventExtremum(ITimeToolEventExtremum, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Determine time of global minimum or maximum of specified scalar calculation. Determination is performed within interval list using Sampling and Convergence parameters."""

    def __init__(self, sourceObject=None):
        ITimeToolEventExtremum.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventExtremum._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventExtremum, [ITimeToolEventExtremum, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7D4AD095-F1A4-4ACA-8788-50DEF2F4B604}", TimeToolEventExtremum)
agcls.AgTypeNameMap["TimeToolEventExtremum"] = TimeToolEventExtremum

class TimeToolEventFactory(ITimeToolEventFactory):
    """The factory creates events."""

    def __init__(self, sourceObject=None):
        ITimeToolEventFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventFactory, [ITimeToolEventFactory])

agcls.AgClassCatalog.add_catalog_entry("{9DEB7422-F9AA-492A-9269-3BDB7B0AF7E4}", TimeToolEventFactory)
agcls.AgTypeNameMap["TimeToolEventFactory"] = TimeToolEventFactory

class TimeToolEventInterval(ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """A single time interval."""

    def __init__(self, sourceObject=None):
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventInterval, [ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2CDA6DDC-7412-441A-8F94-0671FD57D16A}", TimeToolEventInterval)
agcls.AgTypeNameMap["TimeToolEventInterval"] = TimeToolEventInterval

class TimeToolEventIntervalBetweenTimeInstants(ITimeToolEventIntervalBetweenTimeInstants, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval between specified start and stop time instants. If start instant occurs after stop, then interval is undefined."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalBetweenTimeInstants.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalBetweenTimeInstants._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalBetweenTimeInstants, [ITimeToolEventIntervalBetweenTimeInstants, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{E84D9CAE-E919-4B84-99D7-553CCB97739C}", TimeToolEventIntervalBetweenTimeInstants)
agcls.AgTypeNameMap["TimeToolEventIntervalBetweenTimeInstants"] = TimeToolEventIntervalBetweenTimeInstants

class TimeToolEventIntervalCollection(ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """A collection of related interval lists."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollection, [ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{892BFFEB-D366-49D5-8220-50AC5E4529A1}", TimeToolEventIntervalCollection)
agcls.AgTypeNameMap["TimeToolEventIntervalCollection"] = TimeToolEventIntervalCollection

class TimeToolEventIntervalCollectionCondition(ITimeToolEventIntervalCollectionCondition, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionCondition.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionCondition._private_init(self, intf)
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionCondition, [ITimeToolEventIntervalCollectionCondition, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{05E4AFDD-2917-46BA-84C9-1EE7973F11D7}", TimeToolEventIntervalCollectionCondition)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionCondition"] = TimeToolEventIntervalCollectionCondition

class TimeToolEventIntervalCollectionFactory(ITimeToolEventIntervalCollectionFactory):
    """The factory creates collections of event interval lists."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionFactory, [ITimeToolEventIntervalCollectionFactory])

agcls.AgClassCatalog.add_catalog_entry("{C76F8390-6619-47D5-9D33-DD1FBBF19B63}", TimeToolEventIntervalCollectionFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionFactory"] = TimeToolEventIntervalCollectionFactory

class TimeToolEventIntervalCollectionLighting(ITimeToolEventIntervalCollectionLighting, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Defined by computing sunlight, penumbra and umbra intervals as seen at specified location using specified selection of eclipsing bodies."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionLighting.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionLighting._private_init(self, intf)
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionLighting, [ITimeToolEventIntervalCollectionLighting, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{5457BFBA-3076-4250-B0E0-81FA79D58F19}", TimeToolEventIntervalCollectionLighting)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionLighting"] = TimeToolEventIntervalCollectionLighting

class TimeToolEventIntervalCollectionSignaled(ITimeToolEventIntervalCollectionSignaled, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent):
    """Determine what interval list collection is recorded at target clock location by performing signal transmission of original interval list collection between base and target clock locations..."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalCollectionSignaled.__init__(self, sourceObject)
        ITimeToolEventIntervalCollection.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalCollectionSignaled._private_init(self, intf)
        ITimeToolEventIntervalCollection._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalCollectionSignaled, [ITimeToolEventIntervalCollectionSignaled, ITimeToolEventIntervalCollection, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{D1ED3869-B0E3-40F6-967A-C539C5D5D630}", TimeToolEventIntervalCollectionSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalCollectionSignaled"] = TimeToolEventIntervalCollectionSignaled

class TimeToolEventIntervalFactory(ITimeToolEventIntervalFactory):
    """The factory creates event intervals."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFactory, [ITimeToolEventIntervalFactory])

agcls.AgClassCatalog.add_catalog_entry("{D5D195D8-DE6D-4926-B743-556B08A827C8}", TimeToolEventIntervalFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalFactory"] = TimeToolEventIntervalFactory

class TimeToolEventIntervalFixed(ITimeToolEventIntervalFixed, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined between two explicitly specified start and stop times. Stop date/time is required to be at or after start."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFixed.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalFixed._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFixed, [ITimeToolEventIntervalFixed, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{4408570B-CE46-4B6A-9A50-F8F6D56D76F1}", TimeToolEventIntervalFixed)
agcls.AgTypeNameMap["TimeToolEventIntervalFixed"] = TimeToolEventIntervalFixed

class TimeToolEventIntervalFixedDuration(ITimeToolEventIntervalFixedDuration, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval of fixed duration specified using start and stop offsets relative to specified reference time instant."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFixedDuration.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalFixedDuration._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFixedDuration, [ITimeToolEventIntervalFixedDuration, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{84316F31-A3DB-4DF3-B8E3-352673D4E251}", TimeToolEventIntervalFixedDuration)
agcls.AgTypeNameMap["TimeToolEventIntervalFixedDuration"] = TimeToolEventIntervalFixedDuration

class TimeToolEventIntervalFromIntervalList(ITimeToolEventIntervalFromIntervalList, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval created from specified interval list by using one of several selection methods."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalFromIntervalList.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalFromIntervalList._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalFromIntervalList, [ITimeToolEventIntervalFromIntervalList, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0E3B57D7-B236-4DCA-82DA-6C4835A6D0F1}", TimeToolEventIntervalFromIntervalList)
agcls.AgTypeNameMap["TimeToolEventIntervalFromIntervalList"] = TimeToolEventIntervalFromIntervalList

class TimeToolEventIntervalList(ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """An ordered list of time intervals."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalList, [ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{050E0A6D-9960-4470-9803-AF58B43FD747}", TimeToolEventIntervalList)
agcls.AgTypeNameMap["TimeToolEventIntervalList"] = TimeToolEventIntervalList

class TimeToolEventIntervalListCondition(ITimeToolEventIntervalListCondition, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list containing intervals during which specified condition is satisfied. Determination is performed within interval list using Sampling and Convergence parameters."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListCondition.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListCondition._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListCondition, [ITimeToolEventIntervalListCondition, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{4D1E24FE-BD49-4F09-9C30-523AFD58E02B}", TimeToolEventIntervalListCondition)
agcls.AgTypeNameMap["TimeToolEventIntervalListCondition"] = TimeToolEventIntervalListCondition

class TimeToolEventIntervalListFactory(ITimeToolEventIntervalListFactory):
    """The factory creates event interval lists."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFactory, [ITimeToolEventIntervalListFactory])

agcls.AgClassCatalog.add_catalog_entry("{DC3FA659-172B-4C9D-9DCA-EF6AD6CC4A8A}", TimeToolEventIntervalListFactory)
agcls.AgTypeNameMap["TimeToolEventIntervalListFactory"] = TimeToolEventIntervalListFactory

class TimeToolEventIntervalListFile(ITimeToolEventIntervalListFile, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list loaded from specified interval file - ASCII file with .int extension. See STK help."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFile.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListFile._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFile, [ITimeToolEventIntervalListFile, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{5A3BC6C1-559F-448D-946E-3D608C0C59B4}", TimeToolEventIntervalListFile)
agcls.AgTypeNameMap["TimeToolEventIntervalListFile"] = TimeToolEventIntervalListFile

class TimeToolEventIntervalListFiltered(ITimeToolEventIntervalListFiltered, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Defined by filtering intervals from original interval list using specified filtering method."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFiltered.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListFiltered._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFiltered, [ITimeToolEventIntervalListFiltered, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7123DA29-BECE-4032-9A81-77CDA69C5B13}", TimeToolEventIntervalListFiltered)
agcls.AgTypeNameMap["TimeToolEventIntervalListFiltered"] = TimeToolEventIntervalListFiltered

class TimeToolEventIntervalListFixed(ITimeToolEventIntervalListFixed, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list defined by time ordered non-overlapping intervals each explicitly specified by its start and stop times. Stop date/time is required to be at or after start for each interval."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListFixed.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListFixed._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListFixed, [ITimeToolEventIntervalListFixed, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{60EF79E3-069B-45E3-A5A6-B49F9F9D618E}", TimeToolEventIntervalListFixed)
agcls.AgTypeNameMap["TimeToolEventIntervalListFixed"] = TimeToolEventIntervalListFixed

class TimeToolEventIntervalListMerged(ITimeToolEventIntervalListMerged, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval list created by merging two constituent interval lists using specified logical operation. It is possible to select either interval list or interval types for either or both constituents."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListMerged.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListMerged._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListMerged, [ITimeToolEventIntervalListMerged, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{115C7064-1624-4928-B401-2C2B8DA2A2DC}", TimeToolEventIntervalListMerged)
agcls.AgTypeNameMap["TimeToolEventIntervalListMerged"] = TimeToolEventIntervalListMerged

class TimeToolEventIntervalListScaled(ITimeToolEventIntervalListScaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval List defined by scaling every interval in original interval list using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval is removed from scaled list..."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListScaled.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListScaled._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListScaled, [ITimeToolEventIntervalListScaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{3A5FDAFA-95C5-4743-A675-B9598AAAA1B9}", TimeToolEventIntervalListScaled)
agcls.AgTypeNameMap["TimeToolEventIntervalListScaled"] = TimeToolEventIntervalListScaled

class TimeToolEventIntervalListSignaled(ITimeToolEventIntervalListSignaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Determine what interval list is recorded at target clock location by performing signal transmission of original interval list between base and target clock locations..."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListSignaled.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListSignaled._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListSignaled, [ITimeToolEventIntervalListSignaled, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0C2159AF-FCE5-46AA-A06B-30E49A5B6704}", TimeToolEventIntervalListSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalListSignaled"] = TimeToolEventIntervalListSignaled

class TimeToolEventIntervalListTimeOffset(ITimeToolEventIntervalListTimeOffset, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent):
    """Interval List defined by shifting the specified reference interval list by a fixed time offset."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalListTimeOffset.__init__(self, sourceObject)
        ITimeToolEventIntervalList.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalListTimeOffset._private_init(self, intf)
        ITimeToolEventIntervalList._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalListTimeOffset, [ITimeToolEventIntervalListTimeOffset, ITimeToolEventIntervalList, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{BA2C1495-B20E-477A-A995-8B5B879DE84C}", TimeToolEventIntervalListTimeOffset)
agcls.AgTypeNameMap["TimeToolEventIntervalListTimeOffset"] = TimeToolEventIntervalListTimeOffset

class TimeToolEventIntervalScaled(ITimeToolEventIntervalScaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined by scaling original interval using either absolute or relative scale. If resulting interval's start becomes after its stop, the interval becomes undefined."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalScaled.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalScaled._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalScaled, [ITimeToolEventIntervalScaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{8BCF947C-8E52-4B0C-9416-520C7CCEAB3E}", TimeToolEventIntervalScaled)
agcls.AgTypeNameMap["TimeToolEventIntervalScaled"] = TimeToolEventIntervalScaled

class TimeToolEventIntervalSignaled(ITimeToolEventIntervalSignaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Determine what interval is recorded at target clock location by performing signal transmission of original interval between base and target clock locations."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalSignaled.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalSignaled._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalSignaled, [ITimeToolEventIntervalSignaled, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0E2D6BF4-81D9-476D-A4F2-F1882E24B56E}", TimeToolEventIntervalSignaled)
agcls.AgTypeNameMap["TimeToolEventIntervalSignaled"] = TimeToolEventIntervalSignaled

class TimeToolEventIntervalSmartInterval(ITimeToolEventIntervalSmartInterval, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """A smart interval."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalSmartInterval.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalSmartInterval._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalSmartInterval, [ITimeToolEventIntervalSmartInterval, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F3D4E2AC-3845-4719-AD57-EE0C715A584D}", TimeToolEventIntervalSmartInterval)
agcls.AgTypeNameMap["TimeToolEventIntervalSmartInterval"] = TimeToolEventIntervalSmartInterval

class TimeToolEventIntervalTimeOffset(ITimeToolEventIntervalTimeOffset, ITimeToolEventInterval, IAnalysisWorkbenchComponent):
    """Interval defined by shifting specified reference interval by fixed time offset."""

    def __init__(self, sourceObject=None):
        ITimeToolEventIntervalTimeOffset.__init__(self, sourceObject)
        ITimeToolEventInterval.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventIntervalTimeOffset._private_init(self, intf)
        ITimeToolEventInterval._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventIntervalTimeOffset, [ITimeToolEventIntervalTimeOffset, ITimeToolEventInterval, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{DE89BB00-5A89-4DA4-8730-CA2C3495A867}", TimeToolEventIntervalTimeOffset)
agcls.AgTypeNameMap["TimeToolEventIntervalTimeOffset"] = TimeToolEventIntervalTimeOffset

class TimeToolEventSignaled(ITimeToolEventSignaled, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event recorded on specified clock via signal transmission from original time instant recorded on different clock."""

    def __init__(self, sourceObject=None):
        ITimeToolEventSignaled.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventSignaled._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventSignaled, [ITimeToolEventSignaled, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{3951EF3D-DAEA-4F04-B78C-22537BD84A2D}", TimeToolEventSignaled)
agcls.AgTypeNameMap["TimeToolEventSignaled"] = TimeToolEventSignaled

class TimeToolEventSmartEpoch(ITimeToolEventSmartEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """A smart epoch."""

    def __init__(self, sourceObject=None):
        ITimeToolEventSmartEpoch.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventSmartEpoch._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventSmartEpoch, [ITimeToolEventSmartEpoch, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F722C253-92DA-4956-983B-B80AB469F192}", TimeToolEventSmartEpoch)
agcls.AgTypeNameMap["TimeToolEventSmartEpoch"] = TimeToolEventSmartEpoch

class TimeToolEventStartStopTime(ITimeToolEventStartStopTime, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event is either start or stop time selected from a reference interval."""

    def __init__(self, sourceObject=None):
        ITimeToolEventStartStopTime.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventStartStopTime._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventStartStopTime, [ITimeToolEventStartStopTime, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F0429607-A51C-495C-9902-585429D40D10}", TimeToolEventStartStopTime)
agcls.AgTypeNameMap["TimeToolEventStartStopTime"] = TimeToolEventStartStopTime

class TimeToolEventTimeOffset(ITimeToolEventTimeOffset, ITimeToolEvent, IAnalysisWorkbenchComponent):
    """Event at fixed offset from specified reference event."""

    def __init__(self, sourceObject=None):
        ITimeToolEventTimeOffset.__init__(self, sourceObject)
        ITimeToolEvent.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolEventTimeOffset._private_init(self, intf)
        ITimeToolEvent._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolEventTimeOffset, [ITimeToolEventTimeOffset, ITimeToolEvent, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{EE2C89C8-C148-4044-B0BE-BF137D4B876B}", TimeToolEventTimeOffset)
agcls.AgTypeNameMap["TimeToolEventTimeOffset"] = TimeToolEventTimeOffset

class TimeToolFirstIntervalsFilter(ITimeToolFirstIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects a portion of first intervals."""

    def __init__(self, sourceObject=None):
        ITimeToolFirstIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolFirstIntervalsFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolFirstIntervalsFilter, [ITimeToolFirstIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{9A044590-5063-4331-9FC2-621221CF7EA9}", TimeToolFirstIntervalsFilter)
agcls.AgTypeNameMap["TimeToolFirstIntervalsFilter"] = TimeToolFirstIntervalsFilter

class TimeToolGapsFilter(ITimeToolGapsFilter, ITimeToolPruneFilter):
    """The filter merges intervals unless they are separated by gaps of at least/most certain duration."""

    def __init__(self, sourceObject=None):
        ITimeToolGapsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolGapsFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolGapsFilter, [ITimeToolGapsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{C54D3817-6B48-4436-8E1D-323A38DC2BC0}", TimeToolGapsFilter)
agcls.AgTypeNameMap["TimeToolGapsFilter"] = TimeToolGapsFilter

class AnalysisWorkbenchIntegral(IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent):
    """Represents a base class for integral definitions."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchIntegral._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchIntegral, [IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{9C6B1D39-FC48-475A-A888-DA9D459C1906}", AnalysisWorkbenchIntegral)
agcls.AgTypeNameMap["AnalysisWorkbenchIntegral"] = AnalysisWorkbenchIntegral

class CalculationToolIntegralBasic(ICalculationToolIntegralBasic, IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent):
    """Integral definition determines how scalar calculation is numerically integrated."""

    def __init__(self, sourceObject=None):
        ICalculationToolIntegralBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchIntegral.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolIntegralBasic._private_init(self, intf)
        IAnalysisWorkbenchIntegral._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolIntegralBasic, [ICalculationToolIntegralBasic, IAnalysisWorkbenchIntegral, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7FCEE0EE-218C-419E-B5DB-8381B18FAE8A}", CalculationToolIntegralBasic)
agcls.AgTypeNameMap["CalculationToolIntegralBasic"] = CalculationToolIntegralBasic

class AnalysisWorkbenchInterp(IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent):
    """Represents a base class for interpolation definitions."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchInterp._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchInterp, [IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F73B3675-6FD4-4050-9566-797DCD695107}", AnalysisWorkbenchInterp)
agcls.AgTypeNameMap["AnalysisWorkbenchInterp"] = AnalysisWorkbenchInterp

class CalculationToolInterpBasic(ICalculationToolInterpBasic, IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent):
    """Interpolation definition determines how to obtain values in between tabulated samples. See STK help on interpolation for further details."""

    def __init__(self, sourceObject=None):
        ICalculationToolInterpBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchInterp.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolInterpBasic._private_init(self, intf)
        IAnalysisWorkbenchInterp._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolInterpBasic, [ICalculationToolInterpBasic, IAnalysisWorkbenchInterp, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{AB05143F-6997-4F40-BE86-DCF4D723F31E}", CalculationToolInterpBasic)
agcls.AgTypeNameMap["CalculationToolInterpBasic"] = CalculationToolInterpBasic

class TimeToolIntervalsFilter(ITimeToolIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects intervals of at least/most certain duration."""

    def __init__(self, sourceObject=None):
        ITimeToolIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolIntervalsFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolIntervalsFilter, [ITimeToolIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{DA31C4A7-B07C-4DEC-B479-BBEB07234B44}", TimeToolIntervalsFilter)
agcls.AgTypeNameMap["TimeToolIntervalsFilter"] = TimeToolIntervalsFilter

class TimeToolLastIntervalsFilter(ITimeToolLastIntervalsFilter, ITimeToolPruneFilter):
    """The filter selects a portion of last intervals."""

    def __init__(self, sourceObject=None):
        ITimeToolLastIntervalsFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolLastIntervalsFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolLastIntervalsFilter, [ITimeToolLastIntervalsFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{1FAF4A1D-B0BA-4A86-A0AC-049670C66302}", TimeToolLastIntervalsFilter)
agcls.AgTypeNameMap["TimeToolLastIntervalsFilter"] = TimeToolLastIntervalsFilter

class CalculationToolParameterSet(ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Parameter set contains various sets of scalar computations."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSet, [ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CD1D82FC-08BF-4854-9295-F90AC87FAE68}", CalculationToolParameterSet)
agcls.AgTypeNameMap["CalculationToolParameterSet"] = CalculationToolParameterSet

class CalculationToolParameterSetAttitude(ICalculationToolParameterSetAttitude, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Attitude parameter set contains various representations of attitude of one set of axes relative to another."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetAttitude.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetAttitude._private_init(self, intf)
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetAttitude, [ICalculationToolParameterSetAttitude, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7082CB04-052B-46A2-A051-4FF52D0260B0}", CalculationToolParameterSetAttitude)
agcls.AgTypeNameMap["CalculationToolParameterSetAttitude"] = CalculationToolParameterSetAttitude

class CalculationToolParameterSetFactory(ICalculationToolParameterSetFactory):
    """The factory is used to create instances of available parameter set types."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetFactory, [ICalculationToolParameterSetFactory])

agcls.AgClassCatalog.add_catalog_entry("{FF399336-197C-480B-98AC-3F07E76FF3BC}", CalculationToolParameterSetFactory)
agcls.AgTypeNameMap["CalculationToolParameterSetFactory"] = CalculationToolParameterSetFactory

class CalculationToolParameterSetGroundTrajectory(ICalculationToolParameterSetGroundTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Ground trajectory parameter set contains various representations of trajectory of a point relative to central body reference shape."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetGroundTrajectory.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetGroundTrajectory._private_init(self, intf)
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetGroundTrajectory, [ICalculationToolParameterSetGroundTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B1972E17-F000-4BFF-80A3-216A91D0E2B1}", CalculationToolParameterSetGroundTrajectory)
agcls.AgTypeNameMap["CalculationToolParameterSetGroundTrajectory"] = CalculationToolParameterSetGroundTrajectory

class CalculationToolParameterSetOrbit(ICalculationToolParameterSetOrbit, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Orbit parameter set contains various trajectory representations of an orbiting point."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetOrbit.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetOrbit._private_init(self, intf)
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetOrbit, [ICalculationToolParameterSetOrbit, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{BF4A60A0-68E5-4000-8843-DD7FD76813A9}", CalculationToolParameterSetOrbit)
agcls.AgTypeNameMap["CalculationToolParameterSetOrbit"] = CalculationToolParameterSetOrbit

class CalculationToolParameterSetTrajectory(ICalculationToolParameterSetTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Trajectory parameter set contains various representations of trajectory of a point relative to a reference coordinate system."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetTrajectory.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetTrajectory._private_init(self, intf)
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetTrajectory, [ICalculationToolParameterSetTrajectory, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{542072ED-4073-4F91-8EC8-45F7CC401ED7}", CalculationToolParameterSetTrajectory)
agcls.AgTypeNameMap["CalculationToolParameterSetTrajectory"] = CalculationToolParameterSetTrajectory

class CalculationToolParameterSetVector(ICalculationToolParameterSetVector, ICalculationToolParameterSet, IAnalysisWorkbenchComponent):
    """Vector parameter set contains various representations of a vector in a reference set of axes."""

    def __init__(self, sourceObject=None):
        ICalculationToolParameterSetVector.__init__(self, sourceObject)
        ICalculationToolParameterSet.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolParameterSetVector._private_init(self, intf)
        ICalculationToolParameterSet._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolParameterSetVector, [ICalculationToolParameterSetVector, ICalculationToolParameterSet, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{DC7B40D5-7091-4A24-A698-436D2A274DC8}", CalculationToolParameterSetVector)
agcls.AgTypeNameMap["CalculationToolParameterSetVector"] = CalculationToolParameterSetVector

class TimeToolPruneFilter(ITimeToolPruneFilter):
    """A filter used with event interval list pruned class to prune interval lists..."""

    def __init__(self, sourceObject=None):
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolPruneFilter, [ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{E08D63E9-CC8E-41F8-B3C5-0D062425C025}", TimeToolPruneFilter)
agcls.AgTypeNameMap["TimeToolPruneFilter"] = TimeToolPruneFilter

class TimeToolPruneFilterFactory(ITimeToolPruneFilterFactory):
    """The factory creates pruning filters."""

    def __init__(self, sourceObject=None):
        ITimeToolPruneFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolPruneFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolPruneFilterFactory, [ITimeToolPruneFilterFactory])

agcls.AgClassCatalog.add_catalog_entry("{954284C2-3544-4888-9A56-759AA8C7E1F7}", TimeToolPruneFilterFactory)
agcls.AgTypeNameMap["TimeToolPruneFilterFactory"] = TimeToolPruneFilterFactory

class TimeToolRelativeSatisfactionConditionFilter(ITimeToolRelativeSatisfactionConditionFilter, ITimeToolPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain percentage of time."""

    def __init__(self, sourceObject=None):
        ITimeToolRelativeSatisfactionConditionFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolRelativeSatisfactionConditionFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolRelativeSatisfactionConditionFilter, [ITimeToolRelativeSatisfactionConditionFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{93A5C2C0-AABA-4DB3-9359-100604D0BA02}", TimeToolRelativeSatisfactionConditionFilter)
agcls.AgTypeNameMap["TimeToolRelativeSatisfactionConditionFilter"] = TimeToolRelativeSatisfactionConditionFilter

class AnalysisWorkbenchSampling(IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent):
    """Base sampling interface."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSampling._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchSampling, [IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{17FC40E9-EF68-4FFD-8A16-071054486F6A}", AnalysisWorkbenchSampling)
agcls.AgTypeNameMap["AnalysisWorkbenchSampling"] = AnalysisWorkbenchSampling

class CalculationToolSamplingBasic(ICalculationToolSamplingBasic, IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent):
    """Sampling definition determines how scalar data should be sampled in order to adequately capture trends in that data."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchSampling.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingBasic._private_init(self, intf)
        IAnalysisWorkbenchSampling._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingBasic, [ICalculationToolSamplingBasic, IAnalysisWorkbenchSampling, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CB786C50-8D9C-4333-A985-FFD2ADD20206}", CalculationToolSamplingBasic)
agcls.AgTypeNameMap["CalculationToolSamplingBasic"] = CalculationToolSamplingBasic

class CalculationToolSamplingCurvatureTolerance(ICalculationToolSamplingCurvatureTolerance, ICalculationToolSamplingMethod):
    """Curvature tolerance definition includes parameters that determine how scalar data should be sampled based on limits on slope changes between samples."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingCurvatureTolerance.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingCurvatureTolerance._private_init(self, intf)
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingCurvatureTolerance, [ICalculationToolSamplingCurvatureTolerance, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry("{EF49B404-27D2-4AC5-BB5E-EA223A237922}", CalculationToolSamplingCurvatureTolerance)
agcls.AgTypeNameMap["CalculationToolSamplingCurvatureTolerance"] = CalculationToolSamplingCurvatureTolerance

class CalculationToolSamplingFixedStep(ICalculationToolSamplingFixedStep, ICalculationToolSamplingMethod):
    """Fixed step definition includes parameters that determine how scalar data should be sampled based on fixed steps between samples."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingFixedStep.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingFixedStep._private_init(self, intf)
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingFixedStep, [ICalculationToolSamplingFixedStep, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry("{9B7D520F-7835-4E84-BCA4-D748C73CB609}", CalculationToolSamplingFixedStep)
agcls.AgTypeNameMap["CalculationToolSamplingFixedStep"] = CalculationToolSamplingFixedStep

class CalculationToolSamplingMethod(ICalculationToolSamplingMethod):
    """A sampling method."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingMethod, [ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry("{D77F1444-C9BC-4C9C-91A2-A5F9DE172AB8}", CalculationToolSamplingMethod)
agcls.AgTypeNameMap["CalculationToolSamplingMethod"] = CalculationToolSamplingMethod

class CalculationToolSamplingMethodFactory(ICalculationToolSamplingMethodFactory):
    """The factory creates sampling method components."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingMethodFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingMethodFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingMethodFactory, [ICalculationToolSamplingMethodFactory])

agcls.AgClassCatalog.add_catalog_entry("{E55B6BC9-25B5-46E6-A29A-4E32F9EF3080}", CalculationToolSamplingMethodFactory)
agcls.AgTypeNameMap["CalculationToolSamplingMethodFactory"] = CalculationToolSamplingMethodFactory

class CalculationToolSamplingRelativeTolerance(ICalculationToolSamplingRelativeTolerance, ICalculationToolSamplingMethod):
    """Relative tolerance definition includes parameters that determine how scalar data should be sampled based on limits on difference between actual changes between samples and changes predicted by dead reckoning."""

    def __init__(self, sourceObject=None):
        ICalculationToolSamplingRelativeTolerance.__init__(self, sourceObject)
        ICalculationToolSamplingMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ICalculationToolSamplingRelativeTolerance._private_init(self, intf)
        ICalculationToolSamplingMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, CalculationToolSamplingRelativeTolerance, [ICalculationToolSamplingRelativeTolerance, ICalculationToolSamplingMethod])

agcls.AgClassCatalog.add_catalog_entry("{5FBC3E6B-8097-4482-A1BA-DAA0083FE904}", CalculationToolSamplingRelativeTolerance)
agcls.AgTypeNameMap["CalculationToolSamplingRelativeTolerance"] = CalculationToolSamplingRelativeTolerance

class TimeToolSatisfactionConditionFilter(ITimeToolSatisfactionConditionFilter, ITimeToolPruneFilter):
    """The filter selects intervals if certain side condition is satisfied at least/most certain duration."""

    def __init__(self, sourceObject=None):
        ITimeToolSatisfactionConditionFilter.__init__(self, sourceObject)
        ITimeToolPruneFilter.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolSatisfactionConditionFilter._private_init(self, intf)
        ITimeToolPruneFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolSatisfactionConditionFilter, [ITimeToolSatisfactionConditionFilter, ITimeToolPruneFilter])

agcls.AgClassCatalog.add_catalog_entry("{3DD67B2F-2C0A-4355-A154-08E47A93AFCF}", TimeToolSatisfactionConditionFilter)
agcls.AgTypeNameMap["TimeToolSatisfactionConditionFilter"] = TimeToolSatisfactionConditionFilter

class AnalysisWorkbenchSignalDelay(IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchSignalDelay._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchSignalDelay, [IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{71744841-D938-44BE-8336-2B54F06CF443}", AnalysisWorkbenchSignalDelay)
agcls.AgTypeNameMap["AnalysisWorkbenchSignalDelay"] = AnalysisWorkbenchSignalDelay

class TimeToolSignalDelayBasic(ITimeToolSignalDelayBasic, IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent):
    """Signal delay definition determines how long it takes for a signal to propagate from one location to another."""

    def __init__(self, sourceObject=None):
        ITimeToolSignalDelayBasic.__init__(self, sourceObject)
        IAnalysisWorkbenchSignalDelay.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolSignalDelayBasic._private_init(self, intf)
        IAnalysisWorkbenchSignalDelay._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolSignalDelayBasic, [ITimeToolSignalDelayBasic, IAnalysisWorkbenchSignalDelay, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0763A330-475A-4E4E-AB26-8943A8CC1C92}", TimeToolSignalDelayBasic)
agcls.AgTypeNameMap["TimeToolSignalDelayBasic"] = TimeToolSignalDelayBasic

class SpatialAnalysisToolVolumeCalcFactory(ISpatialAnalysisToolVolumeCalcFactory):
    """The factory is used to create instances of volume calcs."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFactory, [ISpatialAnalysisToolVolumeCalcFactory])

agcls.AgClassCatalog.add_catalog_entry("{80956ae5-fb8c-4ce4-930f-56b362d07cec}", SpatialAnalysisToolVolumeCalcFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFactory"] = SpatialAnalysisToolVolumeCalcFactory

class SpatialAnalysisToolVolumeFactory(ISpatialAnalysisToolVolumeFactory):
    """The factory is used to create instances of volumes."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFactory, [ISpatialAnalysisToolVolumeFactory])

agcls.AgClassCatalog.add_catalog_entry("{F9497BD8-A985-4054-8ADE-9042DE66125F}", SpatialAnalysisToolVolumeFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFactory"] = SpatialAnalysisToolVolumeFactory

class SpatialAnalysisToolVolumeGridFactory(ISpatialAnalysisToolVolumeGridFactory):
    """The factory is used to create instances of volume grids."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridFactory, [ISpatialAnalysisToolVolumeGridFactory])

agcls.AgClassCatalog.add_catalog_entry("{F6359611-FB48-4B00-9017-01A4BE2B76E5}", SpatialAnalysisToolVolumeGridFactory)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridFactory"] = SpatialAnalysisToolVolumeGridFactory

class SpatialAnalysisToolGridCoordinateDefinition(ISpatialAnalysisToolGridCoordinateDefinition):
    """Define a set of coordinate values."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridCoordinateDefinition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridCoordinateDefinition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridCoordinateDefinition, [ISpatialAnalysisToolGridCoordinateDefinition])

agcls.AgClassCatalog.add_catalog_entry("{CCE5BC10-615F-441F-95AE-CB4CC0A7C62A}", SpatialAnalysisToolGridCoordinateDefinition)
agcls.AgTypeNameMap["SpatialAnalysisToolGridCoordinateDefinition"] = SpatialAnalysisToolGridCoordinateDefinition

class SpatialAnalysisToolGridValuesCustom(ISpatialAnalysisToolGridValuesCustom, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesCustom.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesCustom._private_init(self, intf)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesCustom, [ISpatialAnalysisToolGridValuesCustom, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry("{B50CCBA5-A969-40E1-86B3-96DAE5D2A3E3}", SpatialAnalysisToolGridValuesCustom)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesCustom"] = SpatialAnalysisToolGridValuesCustom

class SpatialAnalysisToolGridValuesFixedNumberOfSteps(ISpatialAnalysisToolGridValuesFixedNumberOfSteps, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesFixedNumberOfSteps.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesFixedNumberOfSteps._private_init(self, intf)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesFixedNumberOfSteps, [ISpatialAnalysisToolGridValuesFixedNumberOfSteps, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry("{DDD7F78E-13DC-4417-8AE5-B43BB1511AFC}", SpatialAnalysisToolGridValuesFixedNumberOfSteps)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesFixedNumberOfSteps"] = SpatialAnalysisToolGridValuesFixedNumberOfSteps

class SpatialAnalysisToolGridValuesFixedStep(ISpatialAnalysisToolGridValuesFixedStep, ISpatialAnalysisToolGridValuesMethod):
    """Fixed step grid values."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesFixedStep.__init__(self, sourceObject)
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesFixedStep._private_init(self, intf)
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesFixedStep, [ISpatialAnalysisToolGridValuesFixedStep, ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry("{0942EA2D-33DE-41B5-98BE-E53E659EC81D}", SpatialAnalysisToolGridValuesFixedStep)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesFixedStep"] = SpatialAnalysisToolGridValuesFixedStep

class SpatialAnalysisToolGridValuesMethod(ISpatialAnalysisToolGridValuesMethod):
    """A grid values method."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolGridValuesMethod.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolGridValuesMethod._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolGridValuesMethod, [ISpatialAnalysisToolGridValuesMethod])

agcls.AgClassCatalog.add_catalog_entry("{D1D242BF-73F3-443A-AB46-64EAA02C5F37}", SpatialAnalysisToolGridValuesMethod)
agcls.AgTypeNameMap["SpatialAnalysisToolGridValuesMethod"] = SpatialAnalysisToolGridValuesMethod

class TimeToolLightTimeDelay(ITimeToolLightTimeDelay):
    """Manage Light Time Delay options.."""

    def __init__(self, sourceObject=None):
        ITimeToolLightTimeDelay.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolLightTimeDelay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolLightTimeDelay, [ITimeToolLightTimeDelay])

agcls.AgClassCatalog.add_catalog_entry("{085E2242-4392-4F35-857E-A46A72EADE70}", TimeToolLightTimeDelay)
agcls.AgTypeNameMap["TimeToolLightTimeDelay"] = TimeToolLightTimeDelay

class SpatialAnalysisToolVolume(ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A volume interface. The methods and properties of the interface provide Volume functions."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolume, [ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{299D5D3F-7E12-4747-BFD3-2B5CADBAD8EE}", SpatialAnalysisToolVolume)
agcls.AgTypeNameMap["SpatialAnalysisToolVolume"] = SpatialAnalysisToolVolume

class SpatialAnalysisToolVolumeCalc(ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc interface. The methods and properties of the interface provide Volumetric calc functions."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalc, [ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{d014bfd1-130d-4dc4-a841-76c75bc08f9c}", SpatialAnalysisToolVolumeCalc)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalc"] = SpatialAnalysisToolVolumeCalc

class SpatialAnalysisToolVolumeCalcAltitude(ISpatialAnalysisToolVolumeCalcAltitude, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc altitude interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcAltitude.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcAltitude._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcAltitude, [ISpatialAnalysisToolVolumeCalcAltitude, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{4e3c369c-c189-48ce-8e93-f0c6478f0abe}", SpatialAnalysisToolVolumeCalcAltitude)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcAltitude"] = SpatialAnalysisToolVolumeCalcAltitude

class SpatialAnalysisToolVolumeCalcAngleOffVector(ISpatialAnalysisToolVolumeCalcAngleOffVector, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc angle off vector interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcAngleOffVector.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcAngleOffVector._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcAngleOffVector, [ISpatialAnalysisToolVolumeCalcAngleOffVector, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{e37c954b-d3d5-4d2e-91b6-0ae4f8380620}", SpatialAnalysisToolVolumeCalcAngleOffVector)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcAngleOffVector"] = SpatialAnalysisToolVolumeCalcAngleOffVector

class SpatialAnalysisToolVolumeCalcConditionSatMetric(ISpatialAnalysisToolVolumeCalcConditionSatMetric, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc condition satisfaction interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcConditionSatMetric.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcConditionSatMetric._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcConditionSatMetric, [ISpatialAnalysisToolVolumeCalcConditionSatMetric, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{589b39d3-7b75-4fe8-8fb2-1c7e5e247fea}", SpatialAnalysisToolVolumeCalcConditionSatMetric)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcConditionSatMetric"] = SpatialAnalysisToolVolumeCalcConditionSatMetric

class SpatialAnalysisToolVolumeCalcDelayRange(ISpatialAnalysisToolVolumeCalcDelayRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc propagation delay to location interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcDelayRange.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcDelayRange._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcDelayRange, [ISpatialAnalysisToolVolumeCalcDelayRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{bd9388e8-e5f8-4ba9-9371-4ff8fc1ed33c}", SpatialAnalysisToolVolumeCalcDelayRange)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcDelayRange"] = SpatialAnalysisToolVolumeCalcDelayRange

class SpatialAnalysisToolVolumeCalcFile(ISpatialAnalysisToolVolumeCalcFile, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """Volumetric data loaded from a specified file - A file with .h5 extension. See STK help."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFile.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcFile._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFile, [ISpatialAnalysisToolVolumeCalcFile, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{188f96c6-9568-4609-9944-dfc5fb7247c5}", SpatialAnalysisToolVolumeCalcFile)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFile"] = SpatialAnalysisToolVolumeCalcFile

class SpatialAnalysisToolVolumeCalcFromScalar(ISpatialAnalysisToolVolumeCalcFromScalar, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc scalar to location interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcFromScalar.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcFromScalar._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcFromScalar, [ISpatialAnalysisToolVolumeCalcFromScalar, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{73219623-93c0-4c6e-961a-7fae5dfe9234}", SpatialAnalysisToolVolumeCalcFromScalar)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcFromScalar"] = SpatialAnalysisToolVolumeCalcFromScalar

class SpatialAnalysisToolVolumeCalcRange(ISpatialAnalysisToolVolumeCalcRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc distance to location interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcRange.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcRange._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcRange, [ISpatialAnalysisToolVolumeCalcRange, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7f1aa95f-e8d6-4faf-925b-98785243ba67}", SpatialAnalysisToolVolumeCalcRange)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcRange"] = SpatialAnalysisToolVolumeCalcRange

class SpatialAnalysisToolVolumeCalcSolarIntensity(ISpatialAnalysisToolVolumeCalcSolarIntensity, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent):
    """A volume calc solar intensityn interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCalcSolarIntensity.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeCalc.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCalcSolarIntensity._private_init(self, intf)
        ISpatialAnalysisToolVolumeCalc._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCalcSolarIntensity, [ISpatialAnalysisToolVolumeCalcSolarIntensity, ISpatialAnalysisToolVolumeCalc, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7796e871-d645-4f65-a3dc-de687b6fbcd5}", SpatialAnalysisToolVolumeCalcSolarIntensity)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCalcSolarIntensity"] = SpatialAnalysisToolVolumeCalcSolarIntensity

class SpatialAnalysisToolVolumeCombined(ISpatialAnalysisToolVolumeCombined, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A combined volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeCombined.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeCombined._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeCombined, [ISpatialAnalysisToolVolumeCombined, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7ECD2E89-B432-47C3-A80F-AF6429E66746}", SpatialAnalysisToolVolumeCombined)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeCombined"] = SpatialAnalysisToolVolumeCombined

class SpatialAnalysisToolVolumeFromCalc(ISpatialAnalysisToolVolumeFromCalc, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An volume from calc volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromCalc.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeFromCalc._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromCalc, [ISpatialAnalysisToolVolumeFromCalc, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0F2AC0BF-4645-4C7F-9660-A894E267FD59}", SpatialAnalysisToolVolumeFromCalc)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromCalc"] = SpatialAnalysisToolVolumeFromCalc

class SpatialAnalysisToolVolumeFromCondition(ISpatialAnalysisToolVolumeFromCondition, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A volume from conditioninterface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromCondition.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeFromCondition._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromCondition, [ISpatialAnalysisToolVolumeFromCondition, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{A2546B12-78BF-4F8F-87C2-31BC73DA265B}", SpatialAnalysisToolVolumeFromCondition)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromCondition"] = SpatialAnalysisToolVolumeFromCondition

class SpatialAnalysisToolVolumeFromGrid(ISpatialAnalysisToolVolumeFromGrid, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An over time volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromGrid.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeFromGrid._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromGrid, [ISpatialAnalysisToolVolumeFromGrid, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{D49FE282-4C05-4097-970C-1282997378E9}", SpatialAnalysisToolVolumeFromGrid)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromGrid"] = SpatialAnalysisToolVolumeFromGrid

class SpatialAnalysisToolVolumeFromTimeSatisfaction(ISpatialAnalysisToolVolumeFromTimeSatisfaction, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An volume from time satisfaction volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeFromTimeSatisfaction.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeFromTimeSatisfaction._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeFromTimeSatisfaction, [ISpatialAnalysisToolVolumeFromTimeSatisfaction, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{29ECFCF5-9E5E-4E17-99AA-0B312227CFBF}", SpatialAnalysisToolVolumeFromTimeSatisfaction)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeFromTimeSatisfaction"] = SpatialAnalysisToolVolumeFromTimeSatisfaction

class SpatialAnalysisToolVolumeGrid(ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid interface. The methods and properties of the interface provide Volumetric Grid functions."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGrid, [ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B7068C38-74D7-4F22-B0C4-A0DBA06DF373}", SpatialAnalysisToolVolumeGrid)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGrid"] = SpatialAnalysisToolVolumeGrid

class SpatialAnalysisToolVolumeGridBearingAlt(ISpatialAnalysisToolVolumeGridBearingAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid bearing alt (Surface Bearing) interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridBearingAlt.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridBearingAlt._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridBearingAlt, [ISpatialAnalysisToolVolumeGridBearingAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{ED60A16E-82F8-4E0A-9F07-CF8DF05C985A}", SpatialAnalysisToolVolumeGridBearingAlt)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridBearingAlt"] = SpatialAnalysisToolVolumeGridBearingAlt

class SpatialAnalysisToolVolumeGridCartesian(ISpatialAnalysisToolVolumeGridCartesian, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid Cartesian interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridCartesian.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridCartesian._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridCartesian, [ISpatialAnalysisToolVolumeGridCartesian, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{AF15D0A4-BB42-4762-A761-9BD11DC948D0}", SpatialAnalysisToolVolumeGridCartesian)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridCartesian"] = SpatialAnalysisToolVolumeGridCartesian

class SpatialAnalysisToolVolumeGridConstrained(ISpatialAnalysisToolVolumeGridConstrained, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid constrained interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridConstrained.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridConstrained._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridConstrained, [ISpatialAnalysisToolVolumeGridConstrained, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{253FC52C-5554-4A53-AE3D-624316ECFFFD}", SpatialAnalysisToolVolumeGridConstrained)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridConstrained"] = SpatialAnalysisToolVolumeGridConstrained

class SpatialAnalysisToolVolumeGridCylindrical(ISpatialAnalysisToolVolumeGridCylindrical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid cylindrical interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridCylindrical.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridCylindrical._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridCylindrical, [ISpatialAnalysisToolVolumeGridCylindrical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{55C6A7AA-5354-4DF1-9A0E-F62CB01115C8}", SpatialAnalysisToolVolumeGridCylindrical)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridCylindrical"] = SpatialAnalysisToolVolumeGridCylindrical

class SpatialAnalysisToolVolumeGridLatLonAlt(ISpatialAnalysisToolVolumeGridLatLonAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid lat lon alt (Cartogrographic) interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridLatLonAlt.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridLatLonAlt._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridLatLonAlt, [ISpatialAnalysisToolVolumeGridLatLonAlt, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{89C10FC4-4031-4B63-9C55-E092DDF3839D}", SpatialAnalysisToolVolumeGridLatLonAlt)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridLatLonAlt"] = SpatialAnalysisToolVolumeGridLatLonAlt

class SpatialAnalysisToolVolumeGridResult(ISpatialAnalysisToolVolumeGridResult):
    """An interface that generates Volume Grid results."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridResult, [ISpatialAnalysisToolVolumeGridResult])

agcls.AgClassCatalog.add_catalog_entry("{43B95CA7-5CCA-4477-9F37-63A86CD9DEBB}", SpatialAnalysisToolVolumeGridResult)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridResult"] = SpatialAnalysisToolVolumeGridResult

class SpatialAnalysisToolVolumeGridSpherical(ISpatialAnalysisToolVolumeGridSpherical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent):
    """A volume grid spherical interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeGridSpherical.__init__(self, sourceObject)
        ISpatialAnalysisToolVolumeGrid.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeGridSpherical._private_init(self, intf)
        ISpatialAnalysisToolVolumeGrid._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeGridSpherical, [ISpatialAnalysisToolVolumeGridSpherical, ISpatialAnalysisToolVolumeGrid, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0DFD2937-3181-4895-AB05-A45FFD744964}", SpatialAnalysisToolVolumeGridSpherical)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeGridSpherical"] = SpatialAnalysisToolVolumeGridSpherical

class SpatialAnalysisToolVolumeInview(ISpatialAnalysisToolVolumeInview, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An Inview volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeInview.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeInview._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeInview, [ISpatialAnalysisToolVolumeInview, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{DC8CB747-2714-4F73-8BD6-ED974F0B03AB}", SpatialAnalysisToolVolumeInview)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeInview"] = SpatialAnalysisToolVolumeInview

class SpatialAnalysisToolVolumeLighting(ISpatialAnalysisToolVolumeLighting, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """A lighting volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeLighting.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeLighting._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeLighting, [ISpatialAnalysisToolVolumeLighting, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B9ACC019-A8DD-4342-ADE9-1335215F0FAF}", SpatialAnalysisToolVolumeLighting)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeLighting"] = SpatialAnalysisToolVolumeLighting

class SpatialAnalysisToolVolumeOverTime(ISpatialAnalysisToolVolumeOverTime, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent):
    """An over time volume interface."""

    def __init__(self, sourceObject=None):
        ISpatialAnalysisToolVolumeOverTime.__init__(self, sourceObject)
        ISpatialAnalysisToolVolume.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ISpatialAnalysisToolVolumeOverTime._private_init(self, intf)
        ISpatialAnalysisToolVolume._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, SpatialAnalysisToolVolumeOverTime, [ISpatialAnalysisToolVolumeOverTime, ISpatialAnalysisToolVolume, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{F5AB68EE-DCC1-435F-A0C3-133095B01D2D}", SpatialAnalysisToolVolumeOverTime)
agcls.AgTypeNameMap["SpatialAnalysisToolVolumeOverTime"] = SpatialAnalysisToolVolumeOverTime

class AnalysisWorkbenchGeneric(IAnalysisWorkbenchComponent):
    """Generic VGT component."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchGeneric, [IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2909EDFB-9BE2-4BD2-A678-186C9D136937}", AnalysisWorkbenchGeneric)
agcls.AgTypeNameMap["AnalysisWorkbenchGeneric"] = AnalysisWorkbenchGeneric

class AnalysisWorkbenchTypeInfo(IAnalysisWorkbenchTypeInfo):
    """VGT component info."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchTypeInfo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchTypeInfo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchTypeInfo, [IAnalysisWorkbenchTypeInfo])

agcls.AgClassCatalog.add_catalog_entry("{BA26887C-6DFE-4F18-96D8-5694296568D2}", AnalysisWorkbenchTypeInfo)
agcls.AgTypeNameMap["AnalysisWorkbenchTypeInfo"] = AnalysisWorkbenchTypeInfo

class AnalysisWorkbenchInstance(IAnalysisWorkbenchContext, IAnalysisWorkbenchInstance):
    """Enable to obtain information about the parent object that owns the VGT component."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
        IAnalysisWorkbenchInstance.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchContext._private_init(self, intf)
        IAnalysisWorkbenchInstance._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchInstance, [IAnalysisWorkbenchContext, IAnalysisWorkbenchInstance])

agcls.AgClassCatalog.add_catalog_entry("{28241775-2044-4AD1-BC1D-D5B345437415}", AnalysisWorkbenchInstance)
agcls.AgTypeNameMap["AnalysisWorkbenchInstance"] = AnalysisWorkbenchInstance

class AnalysisWorkbenchTemplate(IAnalysisWorkbenchContext, IAnalysisWorkbenchTemplate):
    """Enable to obtain information about the STK class that owns the VGT component."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchContext.__init__(self, sourceObject)
        IAnalysisWorkbenchTemplate.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchContext._private_init(self, intf)
        IAnalysisWorkbenchTemplate._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchTemplate, [IAnalysisWorkbenchContext, IAnalysisWorkbenchTemplate])

agcls.AgClassCatalog.add_catalog_entry("{DB2ABC0D-53EC-43C9-AB85-3ADBDC10CFE3}", AnalysisWorkbenchTemplate)
agcls.AgTypeNameMap["AnalysisWorkbenchTemplate"] = AnalysisWorkbenchTemplate

class VectorGeometryToolPointRefTo(IVectorGeometryToolPointRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointRefTo, [IVectorGeometryToolPointRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{33A043CD-6D36-414A-B73C-9DA3ABDE4C6F}", VectorGeometryToolPointRefTo)
agcls.AgTypeNameMap["VectorGeometryToolPointRefTo"] = VectorGeometryToolPointRefTo

class VectorGeometryToolVectorRefTo(IVectorGeometryToolVectorRefTo, IAnalysisWorkbenchRefTo):
    """Represents a vector reference."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorRefTo, [IVectorGeometryToolVectorRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{76ABF2B5-C60E-4B80-84BA-3F2345E357A6}", VectorGeometryToolVectorRefTo)
agcls.AgTypeNameMap["VectorGeometryToolVectorRefTo"] = VectorGeometryToolVectorRefTo

class VectorGeometryToolAxesRefTo(IVectorGeometryToolAxesRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesRefTo, [IVectorGeometryToolAxesRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{ABAD0C95-5570-461A-9DA0-FD800B10DB20}", VectorGeometryToolAxesRefTo)
agcls.AgTypeNameMap["VectorGeometryToolAxesRefTo"] = VectorGeometryToolAxesRefTo

class VectorGeometryToolAngleRefTo(IVectorGeometryToolAngleRefTo, IAnalysisWorkbenchRefTo):
    """Represents a reference to a VGT angle."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleRefTo, [IVectorGeometryToolAngleRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{E1C8DFF6-65AA-4A6B-B160-7315BD795133}", VectorGeometryToolAngleRefTo)
agcls.AgTypeNameMap["VectorGeometryToolAngleRefTo"] = VectorGeometryToolAngleRefTo

class VectorGeometryToolSystemRefTo(IVectorGeometryToolSystemRefTo, IAnalysisWorkbenchRefTo):
    """Represents a System reference."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemRefTo, [IVectorGeometryToolSystemRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{4C6DEAA3-3DD0-439F-A58F-A2BC329384A8}", VectorGeometryToolSystemRefTo)
agcls.AgTypeNameMap["VectorGeometryToolSystemRefTo"] = VectorGeometryToolSystemRefTo

class VectorGeometryToolPlaneRefTo(IVectorGeometryToolPlaneRefTo, IAnalysisWorkbenchRefTo):
    """Represents a Plane reference."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneRefTo, [IVectorGeometryToolPlaneRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{C24A1C1D-EEF3-43DB-83BF-04F12E85B155}", VectorGeometryToolPlaneRefTo)
agcls.AgTypeNameMap["VectorGeometryToolPlaneRefTo"] = VectorGeometryToolPlaneRefTo

class VectorGeometryToolVector(IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic vector class."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVector, [IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{64392436-52D5-4274-9483-E10C56BBD037}", VectorGeometryToolVector)
agcls.AgTypeNameMap["VectorGeometryToolVector"] = VectorGeometryToolVector

class VectorGeometryToolAxesLabels(IVectorGeometryToolAxesLabels):
    """Allow configuring the VGT axes labels."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesLabels.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesLabels._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesLabels, [IVectorGeometryToolAxesLabels])

agcls.AgClassCatalog.add_catalog_entry("{AC9F13AD-1E42-4695-AC74-6259D2013E4F}", VectorGeometryToolAxesLabels)
agcls.AgTypeNameMap["VectorGeometryToolAxesLabels"] = VectorGeometryToolAxesLabels

class VectorGeometryToolAxes(IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic axes class."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxes, [IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{50F5DD10-4D83-4603-94ED-BF7514C26282}", VectorGeometryToolAxes)
agcls.AgTypeNameMap["VectorGeometryToolAxes"] = VectorGeometryToolAxes

class VectorGeometryToolPoint(IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A generic VGT point class."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPoint, [IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0092C129-467E-4B36-B971-C53F65481DA9}", VectorGeometryToolPoint)
agcls.AgTypeNameMap["VectorGeometryToolPoint"] = VectorGeometryToolPoint

class VectorGeometryToolSystem(IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystem, [IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{20F29E1B-F72A-4B9C-B13B-04E8F1CCAEA6}", VectorGeometryToolSystem)
agcls.AgTypeNameMap["VectorGeometryToolSystem"] = VectorGeometryToolSystem

class VectorGeometryToolAngle(IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngle, [IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C3F96DA3-00EC-4E20-A66C-B3506100496B}", VectorGeometryToolAngle)
agcls.AgTypeNameMap["VectorGeometryToolAngle"] = VectorGeometryToolAngle

class VectorGeometryToolPlaneLabels(IVectorGeometryToolPlaneLabels):
    """Allow configuring the X and Y axes labels."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneLabels.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneLabels._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneLabels, [IVectorGeometryToolPlaneLabels])

agcls.AgClassCatalog.add_catalog_entry("{E40312E9-2D04-4F38-8E35-0C1F5CC66B79}", VectorGeometryToolPlaneLabels)
agcls.AgTypeNameMap["VectorGeometryToolPlaneLabels"] = VectorGeometryToolPlaneLabels

class VectorGeometryToolPlane(IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Base class for VGT axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlane, [IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2E6EAA85-8440-4C4E-97FE-76491E05098A}", VectorGeometryToolPlane)
agcls.AgTypeNameMap["VectorGeometryToolPlane"] = VectorGeometryToolPlane

class VectorGeometryToolAxesAlignedAndConstrained(IVectorGeometryToolAxesAlignedAndConstrained, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes aligned using two pairs of vectors. One vector in each pair is fixed in these axes and the other vector serves as an independent reference."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAlignedAndConstrained.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesAlignedAndConstrained._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAlignedAndConstrained, [IVectorGeometryToolAxesAlignedAndConstrained, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{46BB7D5B-6593-434F-B288-BF1445920A2C}", VectorGeometryToolAxesAlignedAndConstrained)
agcls.AgTypeNameMap["VectorGeometryToolAxesAlignedAndConstrained"] = VectorGeometryToolAxesAlignedAndConstrained

class VectorGeometryToolAxesAngularOffset(IVectorGeometryToolAxesAngularOffset, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes created by rotating the Reference axes about the Spin vector through the specified rotation angle plus the additional rotational offset."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAngularOffset.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesAngularOffset._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAngularOffset, [IVectorGeometryToolAxesAngularOffset, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{64503F8B-96E7-455B-B589-2578ADE1214B}", VectorGeometryToolAxesAngularOffset)
agcls.AgTypeNameMap["VectorGeometryToolAxesAngularOffset"] = VectorGeometryToolAxesAngularOffset

class VectorGeometryToolAxesFixedAtEpoch(IVectorGeometryToolAxesFixedAtEpoch, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes based on another set fixed at a specified epoch."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFixedAtEpoch.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesFixedAtEpoch._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFixedAtEpoch, [IVectorGeometryToolAxesFixedAtEpoch, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{BEEE1271-F9F7-4C9E-A6C9-4337AA4F86AC}", VectorGeometryToolAxesFixedAtEpoch)
agcls.AgTypeNameMap["VectorGeometryToolAxesFixedAtEpoch"] = VectorGeometryToolAxesFixedAtEpoch

class VectorGeometryToolAxesBPlane(IVectorGeometryToolAxesBPlane, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """B-Plane axes using the selected target body and reference vector."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesBPlane.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesBPlane._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesBPlane, [IVectorGeometryToolAxesBPlane, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{E0F714EA-31E4-4F92-876F-BDD3183C29B5}", VectorGeometryToolAxesBPlane)
agcls.AgTypeNameMap["VectorGeometryToolAxesBPlane"] = VectorGeometryToolAxesBPlane

class VectorGeometryToolAxesCustomScript(IVectorGeometryToolAxesCustomScript, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Customized axes offset with respect to a set of reference Axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesCustomScript.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesCustomScript._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesCustomScript, [IVectorGeometryToolAxesCustomScript, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{BC7A87DC-118E-46ED-8657-90DF42B7B101}", VectorGeometryToolAxesCustomScript)
agcls.AgTypeNameMap["VectorGeometryToolAxesCustomScript"] = VectorGeometryToolAxesCustomScript

class VectorGeometryToolAxesAttitudeFile(IVectorGeometryToolAxesAttitudeFile, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes specified by data from a file."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAttitudeFile.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesAttitudeFile._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAttitudeFile, [IVectorGeometryToolAxesAttitudeFile, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{3505D063-9E1B-4964-9865-FFE41F64C8CF}", VectorGeometryToolAxesAttitudeFile)
agcls.AgTypeNameMap["VectorGeometryToolAxesAttitudeFile"] = VectorGeometryToolAxesAttitudeFile

class VectorGeometryToolAxesFixed(IVectorGeometryToolAxesFixed, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes fixed in reference axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFixed.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesFixed._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFixed, [IVectorGeometryToolAxesFixed, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{4AE41C73-3C82-405B-B7D2-A6D1BE7EE2EE}", VectorGeometryToolAxesFixed)
agcls.AgTypeNameMap["VectorGeometryToolAxesFixed"] = VectorGeometryToolAxesFixed

class VectorGeometryToolAxesModelAttach(IVectorGeometryToolAxesModelAttach, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes aligned with the specified pointable element of the object's 3D model. The axes follow the model as well as any articulations that affect the specified pointable element."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesModelAttach._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesModelAttach, [IVectorGeometryToolAxesModelAttach, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{816C612A-13DD-4812-BFDE-E3861F8C39FD}", VectorGeometryToolAxesModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolAxesModelAttach"] = VectorGeometryToolAxesModelAttach

class VectorGeometryToolAxesSpinning(IVectorGeometryToolAxesSpinning, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes created by spinning the Reference axes about the Spin vector with the specified rate. The axes are aligned with the Reference axes at the specified epoch plus the additional rotational offset."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesSpinning.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesSpinning._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesSpinning, [IVectorGeometryToolAxesSpinning, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C0FB8B6D-84CC-4553-ADA9-2F7D91A83AB6}", VectorGeometryToolAxesSpinning)
agcls.AgTypeNameMap["VectorGeometryToolAxesSpinning"] = VectorGeometryToolAxesSpinning

class VectorGeometryToolAxesOnSurface(IVectorGeometryToolAxesOnSurface, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Topocentric axes located at the reference point's projection on the central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesOnSurface._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesOnSurface, [IVectorGeometryToolAxesOnSurface, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CE8C301A-A846-44FD-8871-5AB4CAACEF11}", VectorGeometryToolAxesOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolAxesOnSurface"] = VectorGeometryToolAxesOnSurface

class VectorGeometryToolAxesTrajectory(IVectorGeometryToolAxesTrajectory, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Axes based on trajectory of the point relative to the reference coordinate system."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesTrajectory.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesTrajectory._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesTrajectory, [IVectorGeometryToolAxesTrajectory, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{4038771E-73C1-4989-A9AB-4DC37025FACC}", VectorGeometryToolAxesTrajectory)
agcls.AgTypeNameMap["VectorGeometryToolAxesTrajectory"] = VectorGeometryToolAxesTrajectory

class VectorGeometryToolAxesLagrangeLibration(IVectorGeometryToolAxesLagrangeLibration, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Libration point axes using one primary and multiple secondary central bodies. Set primary and secondary bodies, and point type."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesLagrangeLibration.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesLagrangeLibration._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesLagrangeLibration, [IVectorGeometryToolAxesLagrangeLibration, IVectorGeometryToolAxes, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{16315085-7C87-4A20-865C-0F419A5CDA2F}", VectorGeometryToolAxesLagrangeLibration)
agcls.AgTypeNameMap["VectorGeometryToolAxesLagrangeLibration"] = VectorGeometryToolAxesLagrangeLibration

class VectorGeometryToolAxesCommonTasks(IVectorGeometryToolAxesCommonTasks):
    """Provide methods to create non-persistent VGT axes components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesCommonTasks, [IVectorGeometryToolAxesCommonTasks])

agcls.AgClassCatalog.add_catalog_entry("{07D4865C-78F1-4B3A-9756-D70050613D4A}", VectorGeometryToolAxesCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolAxesCommonTasks"] = VectorGeometryToolAxesCommonTasks

class VectorGeometryToolAxesAtTimeInstant(IVectorGeometryToolAxesAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes):
    """Axes orientation fixed relative to reference axes based on orientation of another set of axes evaluated at specified time instant."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesAtTimeInstant._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesAtTimeInstant, [IVectorGeometryToolAxesAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes])

agcls.AgClassCatalog.add_catalog_entry("{3845C20A-A6E2-45A0-A748-10E9B565C48D}", VectorGeometryToolAxesAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolAxesAtTimeInstant"] = VectorGeometryToolAxesAtTimeInstant

class VectorGeometryToolAxesPlugin(IVectorGeometryToolAxesPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes):
    """A VGT axes plugin."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesPlugin._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesPlugin, [IVectorGeometryToolAxesPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolAxes])

agcls.AgClassCatalog.add_catalog_entry("{C494C46D-EBC6-45B9-B2E7-C9FF7E75467D}", VectorGeometryToolAxesPlugin)
agcls.AgTypeNameMap["VectorGeometryToolAxesPlugin"] = VectorGeometryToolAxesPlugin

class VectorGeometryToolAngleBetweenVectors(IVectorGeometryToolAngleBetweenVectors, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two vectors."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleBetweenVectors.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleBetweenVectors._private_init(self, intf)
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleBetweenVectors, [IVectorGeometryToolAngleBetweenVectors, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2F0AA430-85D0-4479-9540-B1B64EB3B530}", VectorGeometryToolAngleBetweenVectors)
agcls.AgTypeNameMap["VectorGeometryToolAngleBetweenVectors"] = VectorGeometryToolAngleBetweenVectors

class VectorGeometryToolAngleBetweenPlanes(IVectorGeometryToolAngleBetweenPlanes, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two planes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleBetweenPlanes.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleBetweenPlanes._private_init(self, intf)
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleBetweenPlanes, [IVectorGeometryToolAngleBetweenPlanes, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{30C2886F-8792-475D-9E42-975308B1B94E}", VectorGeometryToolAngleBetweenPlanes)
agcls.AgTypeNameMap["VectorGeometryToolAngleBetweenPlanes"] = VectorGeometryToolAngleBetweenPlanes

class VectorGeometryToolAngleDihedral(IVectorGeometryToolAngleDihedral, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between two vectors about an axis."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleDihedral.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleDihedral._private_init(self, intf)
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleDihedral, [IVectorGeometryToolAngleDihedral, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{550855BB-E8F1-440B-BA5C-024ACE2E2A17}", VectorGeometryToolAngleDihedral)
agcls.AgTypeNameMap["VectorGeometryToolAngleDihedral"] = VectorGeometryToolAngleDihedral

class VectorGeometryToolAngleRotation(IVectorGeometryToolAngleRotation, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angle of the shortest rotation between the specified FromAxes and ToAxes axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleRotation.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleRotation._private_init(self, intf)
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleRotation, [IVectorGeometryToolAngleRotation, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{AD8B87A3-8407-42AB-B6CA-8E83450C32C1}", VectorGeometryToolAngleRotation)
agcls.AgTypeNameMap["VectorGeometryToolAngleRotation"] = VectorGeometryToolAngleRotation

class VectorGeometryToolAngleToPlane(IVectorGeometryToolAngleToPlane, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """An angle between a vector and a plane."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleToPlane.__init__(self, sourceObject)
        IVectorGeometryToolAngle.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleToPlane._private_init(self, intf)
        IVectorGeometryToolAngle._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleToPlane, [IVectorGeometryToolAngleToPlane, IVectorGeometryToolAngle, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{8CE8877B-1078-41CD-AEE6-B9DDD92F8201}", VectorGeometryToolAngleToPlane)
agcls.AgTypeNameMap["VectorGeometryToolAngleToPlane"] = VectorGeometryToolAngleToPlane

class VectorGeometryToolPlaneNormal(IVectorGeometryToolPlaneNormal, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane normal to a vector at a given point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneNormal.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneNormal._private_init(self, intf)
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneNormal, [IVectorGeometryToolPlaneNormal, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0AED319D-7B6C-462B-882B-D363F7A2A86C}", VectorGeometryToolPlaneNormal)
agcls.AgTypeNameMap["VectorGeometryToolPlaneNormal"] = VectorGeometryToolPlaneNormal

class VectorGeometryToolPlaneQuadrant(IVectorGeometryToolPlaneQuadrant, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane based on a selected Quadrant of a reference system."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneQuadrant.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneQuadrant._private_init(self, intf)
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneQuadrant, [IVectorGeometryToolPlaneQuadrant, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{8330CE61-25F6-4F92-AE2E-BDB566BA42F3}", VectorGeometryToolPlaneQuadrant)
agcls.AgTypeNameMap["VectorGeometryToolPlaneQuadrant"] = VectorGeometryToolPlaneQuadrant

class VectorGeometryToolPlaneTrajectory(IVectorGeometryToolPlaneTrajectory, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The plane is defined on the basis of a trajectory of a Point with respect to a ReferenceSystem."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTrajectory.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneTrajectory._private_init(self, intf)
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTrajectory, [IVectorGeometryToolPlaneTrajectory, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7BD18F79-6788-48B1-AFB5-243D62C01177}", VectorGeometryToolPlaneTrajectory)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTrajectory"] = VectorGeometryToolPlaneTrajectory

class VectorGeometryToolPlaneTriad(IVectorGeometryToolPlaneTriad, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A Plane containing points PointA, PointB and ReferencePont with the first axis aligned with the direction from the ReferencePoint to PointA and the second axis toward the direction from the ReferencePoint to PointB."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTriad.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneTriad._private_init(self, intf)
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTriad, [IVectorGeometryToolPlaneTriad, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{8A4D3940-BD08-4D5C-A171-E0AC90DEB5F4}", VectorGeometryToolPlaneTriad)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTriad"] = VectorGeometryToolPlaneTriad

class VectorGeometryToolPlaneTwoVector(IVectorGeometryToolPlaneTwoVector, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A plane normal to a vector at a given point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneTwoVector.__init__(self, sourceObject)
        IVectorGeometryToolPlane.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneTwoVector._private_init(self, intf)
        IVectorGeometryToolPlane._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneTwoVector, [IVectorGeometryToolPlaneTwoVector, IVectorGeometryToolPlane, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{49a61e7a-baba-48fd-9d9d-61f91c520291}", VectorGeometryToolPlaneTwoVector)
agcls.AgTypeNameMap["VectorGeometryToolPlaneTwoVector"] = VectorGeometryToolPlaneTwoVector

class VectorGeometryToolPointBPlane(IVectorGeometryToolPointBPlane, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """B-Plane point using the selected target body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointBPlane.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointBPlane._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointBPlane, [IVectorGeometryToolPointBPlane, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{E62329EB-83D1-47CE-8B5B-B795995A2270}", VectorGeometryToolPointBPlane)
agcls.AgTypeNameMap["VectorGeometryToolPointBPlane"] = VectorGeometryToolPointBPlane

class VectorGeometryToolPointFile(IVectorGeometryToolPointFile, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point specified by data from a file."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFile.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointFile._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFile, [IVectorGeometryToolPointFile, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{0E71C927-09CA-4A90-95F0-CB87E244CE72}", VectorGeometryToolPointFile)
agcls.AgTypeNameMap["VectorGeometryToolPointFile"] = VectorGeometryToolPointFile

class VectorGeometryToolPointFixedInSystem(IVectorGeometryToolPointFixedInSystem, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point fixed in a reference coordinate system using the selected coordinate type."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFixedInSystem.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointFixedInSystem._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFixedInSystem, [IVectorGeometryToolPointFixedInSystem, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{9FA10E06-094A-446C-BE9A-5BA397776778}", VectorGeometryToolPointFixedInSystem)
agcls.AgTypeNameMap["VectorGeometryToolPointFixedInSystem"] = VectorGeometryToolPointFixedInSystem

class VectorGeometryToolPointGrazing(IVectorGeometryToolPointGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The grazing point is the point of closest approach to the surface of the selected central body along a defined direction."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGrazing.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointGrazing._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGrazing, [IVectorGeometryToolPointGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C7D8A954-B6ED-43A0-8B2C-C58B06DCDFF7}", VectorGeometryToolPointGrazing)
agcls.AgTypeNameMap["VectorGeometryToolPointGrazing"] = VectorGeometryToolPointGrazing

class VectorGeometryToolPointGlint(IVectorGeometryToolPointGlint, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point on central body surface that reflects from source to observer."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGlint.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointGlint._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGlint, [IVectorGeometryToolPointGlint, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{68F85553-0FA2-459D-93AC-BD4D68A01F6F}", VectorGeometryToolPointGlint)
agcls.AgTypeNameMap["VectorGeometryToolPointGlint"] = VectorGeometryToolPointGlint

class VectorGeometryToolPointCovarianceGrazing(IVectorGeometryToolPointCovarianceGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The point of closest approach to the surface of the specified position covariance ellipsoid surface along a defined direction. Position covariance must be available for a vehicle object to be considered a possible target for this option."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCovarianceGrazing.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointCovarianceGrazing._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCovarianceGrazing, [IVectorGeometryToolPointCovarianceGrazing, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{84D91807-716E-46F4-AB70-53C73FA21C20}", VectorGeometryToolPointCovarianceGrazing)
agcls.AgTypeNameMap["VectorGeometryToolPointCovarianceGrazing"] = VectorGeometryToolPointCovarianceGrazing

class VectorGeometryToolPointPlaneIntersection(IVectorGeometryToolPointPlaneIntersection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Point on a plane located along a given direction looking from a given origin."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlaneIntersection.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointPlaneIntersection._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlaneIntersection, [IVectorGeometryToolPointPlaneIntersection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{63F785C4-EC8E-4BCA-AF05-D57BD357D06C}", VectorGeometryToolPointPlaneIntersection)
agcls.AgTypeNameMap["VectorGeometryToolPointPlaneIntersection"] = VectorGeometryToolPointPlaneIntersection

class VectorGeometryToolPointOnSurface(IVectorGeometryToolPointOnSurface, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The detic subpoint of the reference point as projected onto the central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointOnSurface._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointOnSurface, [IVectorGeometryToolPointOnSurface, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{03ECCFD1-B058-4817-826F-EDE2A6880757}", VectorGeometryToolPointOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolPointOnSurface"] = VectorGeometryToolPointOnSurface

class VectorGeometryToolPointModelAttach(IVectorGeometryToolPointModelAttach, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A point placed at the specified attachment point of the object's 3D model. The point follows the model as well as any articulations that affect the specified attachment point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointModelAttach._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointModelAttach, [IVectorGeometryToolPointModelAttach, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{15958616-F779-4772-9E54-9B134B69BE89}", VectorGeometryToolPointModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolPointModelAttach"] = VectorGeometryToolPointModelAttach

class VectorGeometryToolPointSatelliteCollectionEntry(IVectorGeometryToolPointSatelliteCollectionEntry, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A point placed at the center of mass of a specified satellite of the satellite collection."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointSatelliteCollectionEntry.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointSatelliteCollectionEntry._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointSatelliteCollectionEntry, [IVectorGeometryToolPointSatelliteCollectionEntry, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{d0dacbed-0c16-4de5-b32a-9c7624297014}", VectorGeometryToolPointSatelliteCollectionEntry)
agcls.AgTypeNameMap["VectorGeometryToolPointSatelliteCollectionEntry"] = VectorGeometryToolPointSatelliteCollectionEntry

class VectorGeometryToolPointPlaneProjection(IVectorGeometryToolPointPlaneProjection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The projection of a point onto a reference plane. Specify the Source Point and Reference Plane."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlaneProjection.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointPlaneProjection._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlaneProjection, [IVectorGeometryToolPointPlaneProjection, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C750AD99-2498-42F6-BBBD-CEB1835E8F3A}", VectorGeometryToolPointPlaneProjection)
agcls.AgTypeNameMap["VectorGeometryToolPointPlaneProjection"] = VectorGeometryToolPointPlaneProjection

class VectorGeometryToolPointLagrangeLibration(IVectorGeometryToolPointLagrangeLibration, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Libration point using one primary and multiple secondary central bodies. Set the central body, secondary central bodies, and point type."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointLagrangeLibration.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointLagrangeLibration._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointLagrangeLibration, [IVectorGeometryToolPointLagrangeLibration, IVectorGeometryToolPoint, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{6BF6D976-775A-445D-AD2B-899892F3127E}", VectorGeometryToolPointLagrangeLibration)
agcls.AgTypeNameMap["VectorGeometryToolPointLagrangeLibration"] = VectorGeometryToolPointLagrangeLibration

class VectorGeometryToolPointCommonTasks(IVectorGeometryToolPointCommonTasks):
    """Provide methods to create non-persistent VGT point components. Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCommonTasks, [IVectorGeometryToolPointCommonTasks])

agcls.AgClassCatalog.add_catalog_entry("{9866644C-E731-465E-A7AA-3F4667C1729E}", VectorGeometryToolPointCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolPointCommonTasks"] = VectorGeometryToolPointCommonTasks

class VectorGeometryToolPointCentBodyIntersect(IVectorGeometryToolPointCentBodyIntersect, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point on central body surface along direction vector originating at source point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCentBodyIntersect.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointCentBodyIntersect._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCentBodyIntersect, [IVectorGeometryToolPointCentBodyIntersect, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry("{882047E8-7CB3-489B-B029-33163CBBA583}", VectorGeometryToolPointCentBodyIntersect)
agcls.AgTypeNameMap["VectorGeometryToolPointCentBodyIntersect"] = VectorGeometryToolPointCentBodyIntersect

class VectorGeometryToolPointAtTimeInstant(IVectorGeometryToolPointAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point fixed relative to reference system based on another point evaluated at specified time instant."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointAtTimeInstant._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointAtTimeInstant, [IVectorGeometryToolPointAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry("{8BFB46DF-C6BC-45DA-BAA7-9C996710CFDA}", VectorGeometryToolPointAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolPointAtTimeInstant"] = VectorGeometryToolPointAtTimeInstant

class VectorGeometryToolPointPlugin(IVectorGeometryToolPointPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """A VGT point plugin."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointPlugin._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointPlugin, [IVectorGeometryToolPointPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry("{8297DC34-1755-4FE7-BA23-2D9CDE487EF1}", VectorGeometryToolPointPlugin)
agcls.AgTypeNameMap["VectorGeometryToolPointPlugin"] = VectorGeometryToolPointPlugin

class VectorGeometryToolPointCBFixedOffset(IVectorGeometryToolPointCBFixedOffset, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint):
    """Point specified by fixed components with respect to central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointCBFixedOffset.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolPoint.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointCBFixedOffset._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointCBFixedOffset, [IVectorGeometryToolPointCBFixedOffset, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolPoint])

agcls.AgClassCatalog.add_catalog_entry("{0C76BDAE-992E-4D61-8D09-E6B2B6923A5B}", VectorGeometryToolPointCBFixedOffset)
agcls.AgTypeNameMap["VectorGeometryToolPointCBFixedOffset"] = VectorGeometryToolPointCBFixedOffset

class VectorGeometryToolSystemAssembled(IVectorGeometryToolSystemAssembled, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A system assembled from an origin point and a set of reference axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemAssembled.__init__(self, sourceObject)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemAssembled._private_init(self, intf)
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemAssembled, [IVectorGeometryToolSystemAssembled, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{CE4E84B1-8CCF-467A-A3ED-274D0943407F}", VectorGeometryToolSystemAssembled)
agcls.AgTypeNameMap["VectorGeometryToolSystemAssembled"] = VectorGeometryToolSystemAssembled

class VectorGeometryToolSystemOnSurface(IVectorGeometryToolSystemOnSurface, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A system with an origin on the surface of the central body with topocentric axes rotated on a clock angle. Specify the central body, angle, and the latitude, longitude, and altitude of the origin."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemOnSurface.__init__(self, sourceObject)
        IVectorGeometryToolSystem.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemOnSurface._private_init(self, intf)
        IVectorGeometryToolSystem._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemOnSurface, [IVectorGeometryToolSystemOnSurface, IVectorGeometryToolSystem, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{073423F9-A59D-4313-B499-C86A45C63513}", VectorGeometryToolSystemOnSurface)
agcls.AgTypeNameMap["VectorGeometryToolSystemOnSurface"] = VectorGeometryToolSystemOnSurface

class AnalysisWorkbenchLLAPosition(IAnalysisWorkbenchLLAPosition):
    """A position represented by the Latitude, longtitude and Latitude."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchLLAPosition.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchLLAPosition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchLLAPosition, [IAnalysisWorkbenchLLAPosition])

agcls.AgClassCatalog.add_catalog_entry("{CB962F51-978A-43F9-A88B-AAB62117F93C}", AnalysisWorkbenchLLAPosition)
agcls.AgTypeNameMap["AnalysisWorkbenchLLAPosition"] = AnalysisWorkbenchLLAPosition

class VectorGeometryToolSystemCommonTasks(IVectorGeometryToolSystemCommonTasks):
    """Provide methods to create non-persistent VGT coordinate reference frames (systems). Non-persistent components do not have names, do not get saved/loaded and are not shown in the VGT browser."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemCommonTasks.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemCommonTasks._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemCommonTasks, [IVectorGeometryToolSystemCommonTasks])

agcls.AgClassCatalog.add_catalog_entry("{EBE7AF41-FC7E-4D82-B522-72B4AA551B41}", VectorGeometryToolSystemCommonTasks)
agcls.AgTypeNameMap["VectorGeometryToolSystemCommonTasks"] = VectorGeometryToolSystemCommonTasks

class VectorGeometryToolVectorAngleRate(IVectorGeometryToolVectorAngleRate, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angle rate vector perpendicular to the plane in which the angle is defined."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorAngleRate.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorAngleRate._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorAngleRate, [IVectorGeometryToolVectorAngleRate, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{5769E079-8E9B-40B2-B2EF-14F202AF5666}", VectorGeometryToolVectorAngleRate)
agcls.AgTypeNameMap["VectorGeometryToolVectorAngleRate"] = VectorGeometryToolVectorAngleRate

class VectorGeometryToolVectorApoapsis(IVectorGeometryToolVectorApoapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector from the center of the specified central body to the farthest point of an elliptical orbit created from the motion of the specified point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorApoapsis.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorApoapsis._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorApoapsis, [IVectorGeometryToolVectorApoapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{22E4138C-29C6-4401-91E0-DF0C00422302}", VectorGeometryToolVectorApoapsis)
agcls.AgTypeNameMap["VectorGeometryToolVectorApoapsis"] = VectorGeometryToolVectorApoapsis

class VectorGeometryToolVectorFixedAtEpoch(IVectorGeometryToolVectorFixedAtEpoch, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Based on another vector fixed at a specified epoch."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedAtEpoch.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorFixedAtEpoch._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedAtEpoch, [IVectorGeometryToolVectorFixedAtEpoch, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{FA8DB5F5-1F28-40E6-9B86-489E06D61523}", VectorGeometryToolVectorFixedAtEpoch)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedAtEpoch"] = VectorGeometryToolVectorFixedAtEpoch

class VectorGeometryToolVectorAngularVelocity(IVectorGeometryToolVectorAngularVelocity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Angular velocity vector of one set of axes computed with respect to the reference set."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorAngularVelocity.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorAngularVelocity._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorAngularVelocity, [IVectorGeometryToolVectorAngularVelocity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2ABC83DB-6F6C-4A91-8597-21BD2715D411}", VectorGeometryToolVectorAngularVelocity)
agcls.AgTypeNameMap["VectorGeometryToolVectorAngularVelocity"] = VectorGeometryToolVectorAngularVelocity

class VectorGeometryToolVectorConing(IVectorGeometryToolVectorConing, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector created by revolving the Reference vector around the About vector with the specified rate."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorConing.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorConing._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorConing, [IVectorGeometryToolVectorConing, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{74E6F986-E292-4115-84E4-9E9953C163B8}", VectorGeometryToolVectorConing)
agcls.AgTypeNameMap["VectorGeometryToolVectorConing"] = VectorGeometryToolVectorConing

class VectorGeometryToolVectorCross(IVectorGeometryToolVectorCross, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """The vector cross product of two vectors."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorCross.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorCross._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorCross, [IVectorGeometryToolVectorCross, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{88B6E3B7-51CD-45DE-97C0-DCFE834C0111}", VectorGeometryToolVectorCross)
agcls.AgTypeNameMap["VectorGeometryToolVectorCross"] = VectorGeometryToolVectorCross

class VectorGeometryToolVectorCustomScript(IVectorGeometryToolVectorCustomScript, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Customized vector components defined with respect to reference axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorCustomScript.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorCustomScript._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorCustomScript, [IVectorGeometryToolVectorCustomScript, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{D65CDDC6-21DA-419F-BF72-79C2376648E8}", VectorGeometryToolVectorCustomScript)
agcls.AgTypeNameMap["VectorGeometryToolVectorCustomScript"] = VectorGeometryToolVectorCustomScript

class VectorGeometryToolVectorDerivative(IVectorGeometryToolVectorDerivative, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A vector derivative of a vector computed with respect to specified axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDerivative.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorDerivative._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDerivative, [IVectorGeometryToolVectorDerivative, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B81ECB39-CF3E-49AE-8622-F454CD0EA7B2}", VectorGeometryToolVectorDerivative)
agcls.AgTypeNameMap["VectorGeometryToolVectorDerivative"] = VectorGeometryToolVectorDerivative

class VectorGeometryToolVectorDisplacement(IVectorGeometryToolVectorDisplacement, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector defined by its start and end points."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDisplacement.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorDisplacement._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDisplacement, [IVectorGeometryToolVectorDisplacement, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{6CAADA67-7238-4705-9F74-95596344DED0}", VectorGeometryToolVectorDisplacement)
agcls.AgTypeNameMap["VectorGeometryToolVectorDisplacement"] = VectorGeometryToolVectorDisplacement

class VectorGeometryToolVectorTwoPlanesIntersection(IVectorGeometryToolVectorTwoPlanesIntersection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Defined along the intersection of two planes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorTwoPlanesIntersection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorTwoPlanesIntersection._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorTwoPlanesIntersection, [IVectorGeometryToolVectorTwoPlanesIntersection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{B1145553-76CD-4C1E-AE08-E63E29CF4E46}", VectorGeometryToolVectorTwoPlanesIntersection)
agcls.AgTypeNameMap["VectorGeometryToolVectorTwoPlanesIntersection"] = VectorGeometryToolVectorTwoPlanesIntersection

class VectorGeometryToolVectorModelAttach(IVectorGeometryToolVectorModelAttach, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector along the specified pointable element of the object's 3D model. The vector's direction follows the model as well as any articulations that affect the specified pointable element."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorModelAttach.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorModelAttach._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorModelAttach, [IVectorGeometryToolVectorModelAttach, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{E95BEEB8-C544-4852-9C82-20080343E585}", VectorGeometryToolVectorModelAttach)
agcls.AgTypeNameMap["VectorGeometryToolVectorModelAttach"] = VectorGeometryToolVectorModelAttach

class VectorGeometryToolVectorProjection(IVectorGeometryToolVectorProjection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A projection of a vector computed with respect to a reference plane."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorProjection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorProjection._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorProjection, [IVectorGeometryToolVectorProjection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{7306544A-A8B0-477B-B89D-BA711C9ED600}", VectorGeometryToolVectorProjection)
agcls.AgTypeNameMap["VectorGeometryToolVectorProjection"] = VectorGeometryToolVectorProjection

class VectorGeometryToolVectorScaled(IVectorGeometryToolVectorScaled, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Scaled version of the input vector. Set IsNormalized to convert the input vector to a unit vector before scaling it."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScaled.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorScaled._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScaled, [IVectorGeometryToolVectorScaled, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{92D80C29-251B-436B-9DA0-D5BA4B262185}", VectorGeometryToolVectorScaled)
agcls.AgTypeNameMap["VectorGeometryToolVectorScaled"] = VectorGeometryToolVectorScaled

class VectorGeometryToolVectorEccentricity(IVectorGeometryToolVectorEccentricity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """A vector directed from the center of the specified central body toward the nearest point of an elliptical orbit created from the motion of the specified point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorEccentricity.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorEccentricity._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorEccentricity, [IVectorGeometryToolVectorEccentricity, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C7F157D7-11EB-4779-955F-98530B9C2608}", VectorGeometryToolVectorEccentricity)
agcls.AgTypeNameMap["VectorGeometryToolVectorEccentricity"] = VectorGeometryToolVectorEccentricity

class VectorGeometryToolVectorFixedInAxes(IVectorGeometryToolVectorFixedInAxes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector fixed in reference axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedInAxes.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorFixedInAxes._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedInAxes, [IVectorGeometryToolVectorFixedInAxes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{61E9F963-8CFC-4B24-B583-716A64BAE54C}", VectorGeometryToolVectorFixedInAxes)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedInAxes"] = VectorGeometryToolVectorFixedInAxes

class VectorGeometryToolVectorLineOfNodes(IVectorGeometryToolVectorLineOfNodes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector along the line of nodes - the line of intersection of the osculating orbit plane and the inertial equator of the specified central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorLineOfNodes.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorLineOfNodes._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorLineOfNodes, [IVectorGeometryToolVectorLineOfNodes, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{3D6B3FD1-93C2-4F11-AB10-B749DF633C29}", VectorGeometryToolVectorLineOfNodes)
agcls.AgTypeNameMap["VectorGeometryToolVectorLineOfNodes"] = VectorGeometryToolVectorLineOfNodes

class VectorGeometryToolVectorOrbitAngularMomentum(IVectorGeometryToolVectorOrbitAngularMomentum, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorOrbitAngularMomentum.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorOrbitAngularMomentum._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorOrbitAngularMomentum, [IVectorGeometryToolVectorOrbitAngularMomentum, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{2B38A283-7EDA-43E2-9C04-E9964FCA7D91}", VectorGeometryToolVectorOrbitAngularMomentum)
agcls.AgTypeNameMap["VectorGeometryToolVectorOrbitAngularMomentum"] = VectorGeometryToolVectorOrbitAngularMomentum

class VectorGeometryToolVectorOrbitNormal(IVectorGeometryToolVectorOrbitNormal, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Unit vector perpendicular to the plane of an elliptical orbit created from the motion of the specified point with respect to the center of the specified central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorOrbitNormal.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorOrbitNormal._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorOrbitNormal, [IVectorGeometryToolVectorOrbitNormal, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{AFBAED88-891B-4EF7-98BD-DEBAF630C0E1}", VectorGeometryToolVectorOrbitNormal)
agcls.AgTypeNameMap["VectorGeometryToolVectorOrbitNormal"] = VectorGeometryToolVectorOrbitNormal

class VectorGeometryToolVectorPeriapsis(IVectorGeometryToolVectorPeriapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Vector from the center of the specified central body to the nearest point of an elliptical orbit created from the motion of the specified point."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorPeriapsis.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorPeriapsis._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorPeriapsis, [IVectorGeometryToolVectorPeriapsis, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{DA81B380-6D7C-48F4-8E7F-472035958B44}", VectorGeometryToolVectorPeriapsis)
agcls.AgTypeNameMap["VectorGeometryToolVectorPeriapsis"] = VectorGeometryToolVectorPeriapsis

class VectorGeometryToolVectorReflection(IVectorGeometryToolVectorReflection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Incident vector reflected using a plane whose normal is the normal vector, scaled by a factor. The selected vector or its opposite can be reflected on just one or on both sides of the plane."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorReflection.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorReflection._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorReflection, [IVectorGeometryToolVectorReflection, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{C35F8BF0-ED12-48BF-8770-EE63DAF4A9B1}", VectorGeometryToolVectorReflection)
agcls.AgTypeNameMap["VectorGeometryToolVectorReflection"] = VectorGeometryToolVectorReflection

class VectorGeometryToolVectorRotationVector(IVectorGeometryToolVectorRotationVector, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Rotation vector representing the rotation of one axes relative to reference axes, expressed as angle*rotationAxis."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorRotationVector.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorRotationVector._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorRotationVector, [IVectorGeometryToolVectorRotationVector, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{c599beae-b6c1-495e-8957-a4b9ffc5cb8e}", VectorGeometryToolVectorRotationVector)
agcls.AgTypeNameMap["VectorGeometryToolVectorRotationVector"] = VectorGeometryToolVectorRotationVector

class VectorGeometryToolVectorDirectionToStar(IVectorGeometryToolVectorDirectionToStar, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent):
    """Defined with respect to a star object. For a star object to be available, you must first create one."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDirectionToStar.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorDirectionToStar._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDirectionToStar, [IVectorGeometryToolVectorDirectionToStar, IVectorGeometryToolVector, ITimeToolTimeProperties, IAnalysisWorkbenchComponent])

agcls.AgClassCatalog.add_catalog_entry("{147FDFCC-767A-460C-9833-02A582AFCA9C}", VectorGeometryToolVectorDirectionToStar)
agcls.AgTypeNameMap["VectorGeometryToolVectorDirectionToStar"] = VectorGeometryToolVectorDirectionToStar

class VectorGeometryToolVectorFixedAtTimeInstant(IVectorGeometryToolVectorFixedAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Vector fixed relative to reference axes based on another vector evaluated at specified time instant."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFixedAtTimeInstant.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorFixedAtTimeInstant._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFixedAtTimeInstant, [IVectorGeometryToolVectorFixedAtTimeInstant, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{BC8737B3-A94E-4B68-857F-81E780C874FD}", VectorGeometryToolVectorFixedAtTimeInstant)
agcls.AgTypeNameMap["VectorGeometryToolVectorFixedAtTimeInstant"] = VectorGeometryToolVectorFixedAtTimeInstant

class VectorGeometryToolVectorLinearCombination(IVectorGeometryToolVectorLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Linear combination of two input vectors."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorLinearCombination.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorLinearCombination._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorLinearCombination, [IVectorGeometryToolVectorLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{59E2764C-7920-4CDC-B5FF-2590154E1ABE}", VectorGeometryToolVectorLinearCombination)
agcls.AgTypeNameMap["VectorGeometryToolVectorLinearCombination"] = VectorGeometryToolVectorLinearCombination

class VectorGeometryToolVectorProjectAlongVector(IVectorGeometryToolVectorProjectAlongVector, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """A projection of a source vector in the direction of another vector."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorProjectAlongVector.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorProjectAlongVector._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorProjectAlongVector, [IVectorGeometryToolVectorProjectAlongVector, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{7B76B999-135B-4AAF-ADEA-444FD759417D}", VectorGeometryToolVectorProjectAlongVector)
agcls.AgTypeNameMap["VectorGeometryToolVectorProjectAlongVector"] = VectorGeometryToolVectorProjectAlongVector

class VectorGeometryToolVectorScalarLinearCombination(IVectorGeometryToolVectorScalarLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Linear combination of two input vectors using scalars."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScalarLinearCombination.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorScalarLinearCombination._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScalarLinearCombination, [IVectorGeometryToolVectorScalarLinearCombination, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{0FB78FA5-9E5F-4A0F-AD73-FB89A0E523F8}", VectorGeometryToolVectorScalarLinearCombination)
agcls.AgTypeNameMap["VectorGeometryToolVectorScalarLinearCombination"] = VectorGeometryToolVectorScalarLinearCombination

class VectorGeometryToolVectorScalarScaled(IVectorGeometryToolVectorScalarScaled, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Scaled version of the input vector using scalar."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorScalarScaled.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorScalarScaled._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorScalarScaled, [IVectorGeometryToolVectorScalarScaled, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{9C93B992-687F-4311-B339-DE0DA38409AE}", VectorGeometryToolVectorScalarScaled)
agcls.AgTypeNameMap["VectorGeometryToolVectorScalarScaled"] = VectorGeometryToolVectorScalarScaled

class VectorGeometryToolVectorVelocityAcceleration(IVectorGeometryToolVectorVelocityAcceleration, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Velocity vector of a point in a coordinate system."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorVelocityAcceleration.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorVelocityAcceleration._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorVelocityAcceleration, [IVectorGeometryToolVectorVelocityAcceleration, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{75A62225-C09F-4F08-B7FE-9216B02DECF2}", VectorGeometryToolVectorVelocityAcceleration)
agcls.AgTypeNameMap["VectorGeometryToolVectorVelocityAcceleration"] = VectorGeometryToolVectorVelocityAcceleration

class VectorGeometryToolVectorPlugin(IVectorGeometryToolVectorPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """A VGT vector plugin."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorPlugin.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorPlugin._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorPlugin, [IVectorGeometryToolVectorPlugin, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{E105429A-489E-47F6-B827-8E5819FCE917}", VectorGeometryToolVectorPlugin)
agcls.AgTypeNameMap["VectorGeometryToolVectorPlugin"] = VectorGeometryToolVectorPlugin

class VectorGeometryToolVectorDispSurface(IVectorGeometryToolVectorDispSurface, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector):
    """Displacement between origin and destination points using surface distance and altitude difference."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorDispSurface.__init__(self, sourceObject)
        IAnalysisWorkbenchComponent.__init__(self, sourceObject)
        ITimeToolTimeProperties.__init__(self, sourceObject)
        IVectorGeometryToolVector.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorDispSurface._private_init(self, intf)
        IAnalysisWorkbenchComponent._private_init(self, intf)
        ITimeToolTimeProperties._private_init(self, intf)
        IVectorGeometryToolVector._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorDispSurface, [IVectorGeometryToolVectorDispSurface, IAnalysisWorkbenchComponent, ITimeToolTimeProperties, IVectorGeometryToolVector])

agcls.AgClassCatalog.add_catalog_entry("{ccd4af03-78af-47ae-902a-90860a17daa4}", VectorGeometryToolVectorDispSurface)
agcls.AgTypeNameMap["VectorGeometryToolVectorDispSurface"] = VectorGeometryToolVectorDispSurface

class VectorGeometryToolVectorFactory(IVectorGeometryToolVectorFactory):
    """A Factory object to create vectors."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorFactory, [IVectorGeometryToolVectorFactory])

agcls.AgClassCatalog.add_catalog_entry("{084C11E1-D35D-4F42-83D6-3EF43FEC1E23}", VectorGeometryToolVectorFactory)
agcls.AgTypeNameMap["VectorGeometryToolVectorFactory"] = VectorGeometryToolVectorFactory

class VectorGeometryToolAxesFactory(IVectorGeometryToolAxesFactory):
    """A Factory object to create axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesFactory, [IVectorGeometryToolAxesFactory])

agcls.AgClassCatalog.add_catalog_entry("{7B3E2402-1E15-43DC-BB48-6E98D377B107}", VectorGeometryToolAxesFactory)
agcls.AgTypeNameMap["VectorGeometryToolAxesFactory"] = VectorGeometryToolAxesFactory

class VectorGeometryToolSystemFactory(IVectorGeometryToolSystemFactory):
    """A Factory class to create VGT systems."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemFactory, [IVectorGeometryToolSystemFactory])

agcls.AgClassCatalog.add_catalog_entry("{01A37414-BA74-4DF3-A007-6A3395C8A859}", VectorGeometryToolSystemFactory)
agcls.AgTypeNameMap["VectorGeometryToolSystemFactory"] = VectorGeometryToolSystemFactory

class VectorGeometryToolPointFactory(IVectorGeometryToolPointFactory):
    """A Factory object to create points."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointFactory, [IVectorGeometryToolPointFactory])

agcls.AgClassCatalog.add_catalog_entry("{6C79F3B2-8AE5-468A-940F-F0988752B309}", VectorGeometryToolPointFactory)
agcls.AgTypeNameMap["VectorGeometryToolPointFactory"] = VectorGeometryToolPointFactory

class VectorGeometryToolPlaneFactory(IVectorGeometryToolPlaneFactory):
    """A Factory object to create VGT planes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneFactory, [IVectorGeometryToolPlaneFactory])

agcls.AgClassCatalog.add_catalog_entry("{6F83DB0C-0AFB-4831-BED0-63AE2F8FEFFB}", VectorGeometryToolPlaneFactory)
agcls.AgTypeNameMap["VectorGeometryToolPlaneFactory"] = VectorGeometryToolPlaneFactory

class VectorGeometryToolAngleFactory(IVectorGeometryToolAngleFactory):
    """A Factory object to create angles."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleFactory.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleFactory, [IVectorGeometryToolAngleFactory])

agcls.AgClassCatalog.add_catalog_entry("{0888F89F-9D77-4FCE-9A08-67FCBE870187}", VectorGeometryToolAngleFactory)
agcls.AgTypeNameMap["VectorGeometryToolAngleFactory"] = VectorGeometryToolAngleFactory

class VectorGeometryToolVectorGroup(IVectorGeometryToolVectorGroup):
    """Access or create VGT vectors associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolVectorGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolVectorGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolVectorGroup, [IVectorGeometryToolVectorGroup])

agcls.AgClassCatalog.add_catalog_entry("{69ABE9EE-BAA4-40A7-8097-06DBE70D71D5}", VectorGeometryToolVectorGroup)
agcls.AgTypeNameMap["VectorGeometryToolVectorGroup"] = VectorGeometryToolVectorGroup

class VectorGeometryToolPointGroup(IVectorGeometryToolPointGroup):
    """Access or create VGT points associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPointGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPointGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPointGroup, [IVectorGeometryToolPointGroup])

agcls.AgClassCatalog.add_catalog_entry("{0793BE73-C894-4AF7-BFDB-5D61F5C3B6FD}", VectorGeometryToolPointGroup)
agcls.AgTypeNameMap["VectorGeometryToolPointGroup"] = VectorGeometryToolPointGroup

class VectorGeometryToolAngleGroup(IVectorGeometryToolAngleGroup):
    """Access or create VGT angles associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAngleGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAngleGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAngleGroup, [IVectorGeometryToolAngleGroup])

agcls.AgClassCatalog.add_catalog_entry("{CF6C41CC-A02E-424C-8E7E-B5BA05F1FAF3}", VectorGeometryToolAngleGroup)
agcls.AgTypeNameMap["VectorGeometryToolAngleGroup"] = VectorGeometryToolAngleGroup

class VectorGeometryToolAxesGroup(IVectorGeometryToolAxesGroup):
    """Access or create VGT axes associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolAxesGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolAxesGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolAxesGroup, [IVectorGeometryToolAxesGroup])

agcls.AgClassCatalog.add_catalog_entry("{2D792657-9D6E-4B1E-AEAB-B964839C6F94}", VectorGeometryToolAxesGroup)
agcls.AgTypeNameMap["VectorGeometryToolAxesGroup"] = VectorGeometryToolAxesGroup

class VectorGeometryToolPlaneGroup(IVectorGeometryToolPlaneGroup):
    """Represents a VGT Plane component."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolPlaneGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolPlaneGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolPlaneGroup, [IVectorGeometryToolPlaneGroup])

agcls.AgClassCatalog.add_catalog_entry("{15117A82-3EE6-483E-A65E-2A44F60DB355}", VectorGeometryToolPlaneGroup)
agcls.AgTypeNameMap["VectorGeometryToolPlaneGroup"] = VectorGeometryToolPlaneGroup

class VectorGeometryToolSystemGroup(IVectorGeometryToolSystemGroup):
    """Access or create VGT systems associated with an object or a central body."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolSystemGroup.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolSystemGroup._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolSystemGroup, [IVectorGeometryToolSystemGroup])

agcls.AgClassCatalog.add_catalog_entry("{65E8F1CC-E68C-4EF6-9A68-443DD01C55E2}", VectorGeometryToolSystemGroup)
agcls.AgTypeNameMap["VectorGeometryToolSystemGroup"] = VectorGeometryToolSystemGroup

class AnalysisWorkbenchProvider(IAnalysisWorkbenchProvider):
    """Allow accessing existing Vector Geometry Tool components."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchProvider.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchProvider._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchProvider, [IAnalysisWorkbenchProvider])

agcls.AgClassCatalog.add_catalog_entry("{D9031FE1-81E1-4818-944D-5F00FC3EC97D}", AnalysisWorkbenchProvider)
agcls.AgTypeNameMap["AnalysisWorkbenchProvider"] = AnalysisWorkbenchProvider

class AnalysisWorkbenchRoot(IAnalysisWorkbenchRoot):
    """Represents a VGT root."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchRoot.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchRoot._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchRoot, [IAnalysisWorkbenchRoot])

agcls.AgClassCatalog.add_catalog_entry("{26E18B6F-19CA-4537-B6B3-D307DAADCDBB}", AnalysisWorkbenchRoot)
agcls.AgTypeNameMap["AnalysisWorkbenchRoot"] = AnalysisWorkbenchRoot

class VectorGeometryToolWellKnownEarthSystems(IVectorGeometryToolWellKnownEarthSystems):
    """Well-known Earth's coordinate systems."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownEarthSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownEarthSystems._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownEarthSystems, [IVectorGeometryToolWellKnownEarthSystems])

agcls.AgClassCatalog.add_catalog_entry("{9CE3EA8C-78D7-4C9E-9D35-4E34DBA9FD19}", VectorGeometryToolWellKnownEarthSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownEarthSystems"] = VectorGeometryToolWellKnownEarthSystems

class VectorGeometryToolWellKnownEarthAxes(IVectorGeometryToolWellKnownEarthAxes):
    """Well-known Earth's axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownEarthAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownEarthAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownEarthAxes, [IVectorGeometryToolWellKnownEarthAxes])

agcls.AgClassCatalog.add_catalog_entry("{B79CA8BC-D4BA-4F76-9278-AB7C9C537859}", VectorGeometryToolWellKnownEarthAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownEarthAxes"] = VectorGeometryToolWellKnownEarthAxes

class VectorGeometryToolWellKnownSunSystems(IVectorGeometryToolWellKnownSunSystems):
    """The Sun's well-known coordinate reference systems."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSunSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownSunSystems._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSunSystems, [IVectorGeometryToolWellKnownSunSystems])

agcls.AgClassCatalog.add_catalog_entry("{855EB036-E71F-47F9-B27B-57247345282A}", VectorGeometryToolWellKnownSunSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSunSystems"] = VectorGeometryToolWellKnownSunSystems

class VectorGeometryToolWellKnownSunAxes(IVectorGeometryToolWellKnownSunAxes):
    """Well-known Sun's axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSunAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownSunAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSunAxes, [IVectorGeometryToolWellKnownSunAxes])

agcls.AgClassCatalog.add_catalog_entry("{7F786A33-8851-4FA4-A0CA-DC353170143E}", VectorGeometryToolWellKnownSunAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSunAxes"] = VectorGeometryToolWellKnownSunAxes

class VectorGeometryToolWellKnownSystems(IVectorGeometryToolWellKnownSystems):
    """Well-known coordinate reference systems."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownSystems.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownSystems._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownSystems, [IVectorGeometryToolWellKnownSystems])

agcls.AgClassCatalog.add_catalog_entry("{8C5101B3-3FDD-443D-A59F-B1E801873E0A}", VectorGeometryToolWellKnownSystems)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownSystems"] = VectorGeometryToolWellKnownSystems

class VectorGeometryToolWellKnownAxes(IVectorGeometryToolWellKnownAxes):
    """Represents well-known VGT Axes."""

    def __init__(self, sourceObject=None):
        IVectorGeometryToolWellKnownAxes.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IVectorGeometryToolWellKnownAxes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, VectorGeometryToolWellKnownAxes, [IVectorGeometryToolWellKnownAxes])

agcls.AgClassCatalog.add_catalog_entry("{5E24B44A-B46D-4B9B-A22C-615EFAA73A6C}", VectorGeometryToolWellKnownAxes)
agcls.AgTypeNameMap["VectorGeometryToolWellKnownAxes"] = VectorGeometryToolWellKnownAxes

class AnalysisWorkbenchMethodCallAngleFindResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindResult):
    """Represents result returned with IVectorGeometryToolAngle.FindCoordinates method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindResult])

agcls.AgClassCatalog.add_catalog_entry("{10a2d878-07e8-4a17-86d9-f91267332b29}", AnalysisWorkbenchMethodCallAngleFindResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindResult"] = AnalysisWorkbenchMethodCallAngleFindResult

class AnalysisWorkbenchMethodCallAngleFindWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindWithRateResult):
    """Contains the results returned with IVectorGeometryToolAngle.FindCoordinatesWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{b6e274e3-92c4-4ee1-80ee-f5d80cd2bdc6}", AnalysisWorkbenchMethodCallAngleFindWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindWithRateResult"] = AnalysisWorkbenchMethodCallAngleFindWithRateResult

class AnalysisWorkbenchMethodCallAxesTransformResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformResult):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFrom method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesTransformResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformResult])

agcls.AgClassCatalog.add_catalog_entry("{d5e580c7-4a27-4249-8424-c74b7552d60c}", AnalysisWorkbenchMethodCallAxesTransformResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesTransformResult"] = AnalysisWorkbenchMethodCallAxesTransformResult

class AnalysisWorkbenchMethodCallAxesTransformWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformWithRateResult):
    """Contains the results returned with IVectorGeometryToolAxes.TransformFromWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesTransformWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesTransformWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{30590e9a-ff5f-4d09-9282-32617361277f}", AnalysisWorkbenchMethodCallAxesTransformWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesTransformWithRateResult"] = AnalysisWorkbenchMethodCallAxesTransformWithRateResult

class AnalysisWorkbenchMethodCallAxesFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesResult):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxes method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry("{a03bd5b7-7178-47cf-bad3-a490b325b12e}", AnalysisWorkbenchMethodCallAxesFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesFindInAxesResult"] = AnalysisWorkbenchMethodCallAxesFindInAxesResult

class AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesWithRateResult):
    """Contains the results returned with IVectorGeometryToolAxes.FindInAxesWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAxesFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAxesFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAxesFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{aa8fab1e-798b-4fa0-97de-c772db073b01}", AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallAxesFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallPlaneFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesResult):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxes method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry("{3ad1d6cb-62bb-4d58-bbfb-42370c82041e}", AnalysisWorkbenchMethodCallPlaneFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInAxesResult"] = AnalysisWorkbenchMethodCallPlaneFindInAxesResult

class AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesWithRateResult):
    """Contains the results returned with IVectorGeometryToolPlane.FindInAxesWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{385659fa-76a0-4fd8-ac65-45b9fc375d21}", AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallPlaneFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallPlaneFindInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemResult):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystem method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemResult])

agcls.AgClassCatalog.add_catalog_entry("{95a12be5-069b-450e-bec2-acb2dee9e956}", AnalysisWorkbenchMethodCallPlaneFindInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInSystemResult"] = AnalysisWorkbenchMethodCallPlaneFindInSystemResult

class AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemWithRateResult):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPlaneFindInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPlaneFindInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPlaneFindInSystemWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{57eea690-8b67-4a20-a56a-386b59693b6f}", AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult"] = AnalysisWorkbenchMethodCallPlaneFindInSystemWithRateResult

class AnalysisWorkbenchMethodCallPointLocateInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemResult):
    """Contains the results returned with IVectorGeometryToolPlane.FindInSystemWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPointLocateInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPointLocateInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemResult])

agcls.AgClassCatalog.add_catalog_entry("{d1c86686-9f3c-40e1-bad0-f4d7fc4e4b38}", AnalysisWorkbenchMethodCallPointLocateInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPointLocateInSystemResult"] = AnalysisWorkbenchMethodCallPointLocateInSystemResult

class AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemWithRateResult):
    """Contains the results returned with IVectorGeometryToolPoint.LocateInSystemWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolPointLocateInSystemWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolPointLocateInSystemWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolPointLocateInSystemWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{7fb55c98-4c9b-4236-a8dc-8b645c43efe7}", AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult"] = AnalysisWorkbenchMethodCallPointLocateInSystemWithRateResult

class AnalysisWorkbenchMethodCallSystemTransformResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformResult):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFrom and IVectorGeometryToolSystem.TransformTo methods."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemTransformResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemTransformResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformResult])

agcls.AgClassCatalog.add_catalog_entry("{69867a9e-52f7-41ac-9305-1dd6d718dd9f}", AnalysisWorkbenchMethodCallSystemTransformResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemTransformResult"] = AnalysisWorkbenchMethodCallSystemTransformResult

class AnalysisWorkbenchMethodCallSystemTransformWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformWithRateResult):
    """Contains the results returned with IVectorGeometryToolSystem.TransformFromWithRate and IVectorGeometryToolSystem.TransformToWithRate methods."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemTransformWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemTransformWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemTransformWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemTransformWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{29682212-7424-423f-8abb-09e337d5a3c5}", AnalysisWorkbenchMethodCallSystemTransformWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemTransformWithRateResult"] = AnalysisWorkbenchMethodCallSystemTransformWithRateResult

class AnalysisWorkbenchMethodCallSystemFindInSystemResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemFindInSystemResult):
    """Contains the results returned with IVectorGeometryToolSystem.FindInSystem method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolSystemFindInSystemResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolSystemFindInSystemResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallSystemFindInSystemResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolSystemFindInSystemResult])

agcls.AgClassCatalog.add_catalog_entry("{a58affee-d2b4-4406-bdb4-1644ac88ff2d}", AnalysisWorkbenchMethodCallSystemFindInSystemResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallSystemFindInSystemResult"] = AnalysisWorkbenchMethodCallSystemFindInSystemResult

class AnalysisWorkbenchMethodCallVectorFindInAxesResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesResult):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxes method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolVectorFindInAxesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallVectorFindInAxesResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesResult])

agcls.AgClassCatalog.add_catalog_entry("{d1e45a85-ed27-499f-a507-9bda219f9c2e}", AnalysisWorkbenchMethodCallVectorFindInAxesResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallVectorFindInAxesResult"] = AnalysisWorkbenchMethodCallVectorFindInAxesResult

class AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesWithRateResult):
    """Contains the results returned with IVectorGeometryToolVector.FindInAxesWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolVectorFindInAxesWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolVectorFindInAxesWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolVectorFindInAxesWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{a2999b36-fde8-4cb2-aef1-fa1928a1b5d4}", AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult"] = AnalysisWorkbenchMethodCallVectorFindInAxesWithRateResult

class AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleWithRateResult):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngleWithRate method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleWithRateResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindAngleWithRateResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleWithRateResult])

agcls.AgClassCatalog.add_catalog_entry("{93ce2539-4115-4086-9076-e006c49881da}", AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult"] = AnalysisWorkbenchMethodCallAngleFindAngleWithRateResult

class AnalysisWorkbenchMethodCallAngleFindAngleResult(IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleResult):
    """Contains the results returned with IVectorGeometryToolAngle.FindAngle method."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchMethodCallResult.__init__(self, sourceObject)
        IVectorGeometryToolAngleFindAngleResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchMethodCallResult._private_init(self, intf)
        IVectorGeometryToolAngleFindAngleResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchMethodCallAngleFindAngleResult, [IAnalysisWorkbenchMethodCallResult, IVectorGeometryToolAngleFindAngleResult])

agcls.AgClassCatalog.add_catalog_entry("{15dab968-8385-4f28-b60f-9567af54380e}", AnalysisWorkbenchMethodCallAngleFindAngleResult)
agcls.AgTypeNameMap["AnalysisWorkbenchMethodCallAngleFindAngleResult"] = AnalysisWorkbenchMethodCallAngleFindAngleResult

class TimeToolInterval(ITimeToolInterval):
    """Represents an interval."""

    def __init__(self, sourceObject=None):
        ITimeToolInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolInterval._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolInterval, [ITimeToolInterval])

agcls.AgClassCatalog.add_catalog_entry("{7825007C-4D30-46EC-A047-EAF6683C4187}", TimeToolInterval)
agcls.AgTypeNameMap["TimeToolInterval"] = TimeToolInterval

class TimeToolIntervalCollection(ITimeToolIntervalCollection):
    """Represents a collection of intervals."""

    def __init__(self, sourceObject=None):
        ITimeToolIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolIntervalCollection, [ITimeToolIntervalCollection])

agcls.AgClassCatalog.add_catalog_entry("{908714CE-1D69-4F68-875A-9B584CF8F2A7}", TimeToolIntervalCollection)
agcls.AgTypeNameMap["TimeToolIntervalCollection"] = TimeToolIntervalCollection

class AnalysisWorkbenchCentralBody(IAnalysisWorkbenchCentralBody):
    """Represents an central body."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBody.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchCentralBody._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBody, [IAnalysisWorkbenchCentralBody])

agcls.AgClassCatalog.add_catalog_entry("{9A0248DF-B126-4448-A653-CD5C28DC9229}", AnalysisWorkbenchCentralBody)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBody"] = AnalysisWorkbenchCentralBody

class AnalysisWorkbenchCentralBodyRefTo(IAnalysisWorkbenchCentralBodyRefTo, IAnalysisWorkbenchRefTo):
    """Represents a central body reference."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBodyRefTo.__init__(self, sourceObject)
        IAnalysisWorkbenchRefTo.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchCentralBodyRefTo._private_init(self, intf)
        IAnalysisWorkbenchRefTo._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBodyRefTo, [IAnalysisWorkbenchCentralBodyRefTo, IAnalysisWorkbenchRefTo])

agcls.AgClassCatalog.add_catalog_entry("{AFB22A58-DB60-4A1B-B0D4-44916CACC759}", AnalysisWorkbenchCentralBodyRefTo)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBodyRefTo"] = AnalysisWorkbenchCentralBodyRefTo

class AnalysisWorkbenchCentralBodyCollection(IAnalysisWorkbenchCentralBodyCollection):
    """A collection of central body names."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchCentralBodyCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCentralBodyCollection, [IAnalysisWorkbenchCentralBodyCollection])

agcls.AgClassCatalog.add_catalog_entry("{E8951B8F-E457-4289-9125-5381515552C4}", AnalysisWorkbenchCentralBodyCollection)
agcls.AgTypeNameMap["AnalysisWorkbenchCentralBodyCollection"] = AnalysisWorkbenchCentralBodyCollection

class AnalysisWorkbenchCollection(IAnalysisWorkbenchCollection):
    """A collection of VGT objects."""

    def __init__(self, sourceObject=None):
        IAnalysisWorkbenchCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        IAnalysisWorkbenchCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, AnalysisWorkbenchCollection, [IAnalysisWorkbenchCollection])

agcls.AgClassCatalog.add_catalog_entry("{24B18D3A-675E-467D-A97C-5CD42EB6DC8D}", AnalysisWorkbenchCollection)
agcls.AgTypeNameMap["AnalysisWorkbenchCollection"] = AnalysisWorkbenchCollection

class TimeToolPointSamplingResult(ITimeToolPointSamplingResult):
    """Contains tabulated positions and velocities of a point created by Sample method."""

    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolPointSamplingResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolPointSamplingResult, [ITimeToolPointSamplingResult])

agcls.AgClassCatalog.add_catalog_entry("{A3132149-15ED-4D7E-85A6-FD1B2BB80B1E}", TimeToolPointSamplingResult)
agcls.AgTypeNameMap["TimeToolPointSamplingResult"] = TimeToolPointSamplingResult

class TimeToolPointSamplingInterval(ITimeToolPointSamplingInterval):
    """The interface represents an interval with the time, position and velocity arrays."""

    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolPointSamplingInterval._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolPointSamplingInterval, [ITimeToolPointSamplingInterval])

agcls.AgClassCatalog.add_catalog_entry("{8B7546E8-0228-4269-92D1-B3C186AF18EF}", TimeToolPointSamplingInterval)
agcls.AgTypeNameMap["TimeToolPointSamplingInterval"] = TimeToolPointSamplingInterval

class TimeToolPointSamplingIntervalCollection(ITimeToolPointSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, position and velocity arrays."""

    def __init__(self, sourceObject=None):
        ITimeToolPointSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolPointSamplingIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolPointSamplingIntervalCollection, [ITimeToolPointSamplingIntervalCollection])

agcls.AgClassCatalog.add_catalog_entry("{3F6CF6B1-7192-4960-927D-1FC328122E59}", TimeToolPointSamplingIntervalCollection)
agcls.AgTypeNameMap["TimeToolPointSamplingIntervalCollection"] = TimeToolPointSamplingIntervalCollection

class TimeToolAxesSamplingResult(ITimeToolAxesSamplingResult):
    """Contains tabulated orientations and angular velocities of axes created by Sample method."""

    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingResult.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolAxesSamplingResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingResult, [ITimeToolAxesSamplingResult])

agcls.AgClassCatalog.add_catalog_entry("{54622168-5440-4C86-9539-A0CA336E554B}", TimeToolAxesSamplingResult)
agcls.AgTypeNameMap["TimeToolAxesSamplingResult"] = TimeToolAxesSamplingResult

class TimeToolAxesSamplingInterval(ITimeToolAxesSamplingInterval):
    """The interface represents an interval with the time, orientation and velocity arrays."""

    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingInterval.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolAxesSamplingInterval._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingInterval, [ITimeToolAxesSamplingInterval])

agcls.AgClassCatalog.add_catalog_entry("{069BCA07-B5AB-4A46-A508-AFE218E21B2F}", TimeToolAxesSamplingInterval)
agcls.AgTypeNameMap["TimeToolAxesSamplingInterval"] = TimeToolAxesSamplingInterval

class TimeToolAxesSamplingIntervalCollection(ITimeToolAxesSamplingIntervalCollection):
    """A collection of intervals where each interval contains the time, orientation and velocity arrays."""

    def __init__(self, sourceObject=None):
        ITimeToolAxesSamplingIntervalCollection.__init__(self, sourceObject)
    def _private_init(self, intf:interface_proxy):
        self.__dict__["_intf"] = intf
        ITimeToolAxesSamplingIntervalCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        set_class_attribute(self, attrname, value, TimeToolAxesSamplingIntervalCollection, [ITimeToolAxesSamplingIntervalCollection])

agcls.AgClassCatalog.add_catalog_entry("{4AD4C296-E643-4CB6-A34A-D33748117EEF}", TimeToolAxesSamplingIntervalCollection)
agcls.AgTypeNameMap["TimeToolAxesSamplingIntervalCollection"] = TimeToolAxesSamplingIntervalCollection


################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
